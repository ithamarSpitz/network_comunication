 Communication Networks Course
Page | 1
Assignment 3 â€“ Transport Layer
Assignment Notes and Instructions
This assignment is to be done in pairs only. You must upload all the necessary files in a ZIP
file named after both of the studentâ€™s ID. For example: ğŸğŸğŸ‘ğŸ’ğŸ“ğŸ”ğŸ•ğŸ–ğŸ—_ğŸ—ğŸ–ğŸ•ğŸ”ğŸ“ğŸ’ğŸ‘ğŸğŸ. ğ’›ğ’Šğ’‘.
1) The assignment must be submitted by the date specified in the submission box.
2) All the assignment files (Code, Wireshark pcap files, PDF) must be submitted in a ZIP file. The
PDF must contain all the necessary screenshots with a description for each one of them.
3) The assignment must be done in pairs only. In exceptional cases, you should send an email to
the course coordinator.
4) You can use any reference material available through the course Moodle website or any
material passed during the exercises.
5) You can use any reference from the web, but copying codes from websites is forbidden; this
includes codes from other GitHub repositories. A student who gets caught in the act will
automatically fail this assignment (score 0). Any website youâ€™ve used to solve the
assignment, every website you used to solve the assignment must be noted in the PDF.
6) No delays in submission without special permission. Lateness without approval will result in
failure of the assignment (score 0).
7) All submissions will be submitted via the course's Moodle website. Email submissions will not
be accepted, resulting in a failure in the assignment.
8) The order and design of the code must be carefully considered. Make sure that the program
output is as clear as possible, comments in the code, and meaningful variable names. You
must also submit a makefile that compiles all the programs.
9) The assignment code must be written in C only.
10) The assignment is personal for each pair, and you should not accept help from other people,
whether outside the university or inside it. You can contact the course staff during reception
hours for help or raise a question in the course forum. Do not transfer code sections
between students, upload solutions or parts of solutions to websites on the Internet or in
various communication groups.
11) Students who copy a solution will receive a 0 in all assignments in the course and a report will
be made to the institutional disciplinary committee.
12) All code files of the assignment are required to both compile and run properly on the Ubuntu
22.04 LTS operating system. This is the operating system where the submissions will be
tested. You mustnâ€™t code it in Windows, as it uses different API for sockets. WSL wonâ€™t work,
as the task needs a tool that works only in a fully Linux environment.
Good Luck!
 Communication Networks Course
Page | 2
Part A â€“ Transmission Control Protocol (TCP) â€“ 30 points
In this part, youâ€™ll write two program files: ğ‘»ğ‘ªğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and ğ‘»ğ‘ªğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
The Sender will send a randomly generated file and the Receiver will receive it and measure
the time it took for his program to receive the file. The file size should be at least 2MB.
When running the Sender and Receiver, they both should support two standard congestion
control algorithms: TCP Reno and TCP Cubic.
Notes:
â€¢ The main goal of this part is to get familiar with the TCP concept of sending
messages between two endpoints.
â€¢ For approaching this part of the assignment, please be sure that you are familiar
with the congestion control algorithms and how to change them using the correct
method in C (see Appendix B for more information).
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). You've
learned that TCP is reliable by design, so you can assume that all the data have been
passed correctly, and thus, no need to recheck.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
Usage:
â€¢ Receiver:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
â€¢ Sender:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port of the Receiver.
â€¢ ğ‘¨ğ‘³ğ‘®ğ‘¶ â€“ The TCP congestion control algorithm that will be used by the party
member (either ğ’“ğ’†ğ’ğ’ for TCP Reno or ğ’„ğ’–ğ’ƒğ’Šğ’„ for TCP Cubic).
 Communication Networks Course
Page | 3
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a TCP socket between the Sender and the
Receiver.
3) Send the file.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a TCP connection between the Receiver and
the Sender.
2) Get a connection from the sender.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./TCP_Receiver -p 1234 -algo reno
Starting Receiver...
Waiting for TCP connection...
Sender connected, beginning to receive file...
File transfer completed.
Waiting for Sender response...
Sender sent exit message.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 4
Part B â€“ Reliable User Datagram Protocol (Reliable UDP or RUDP) â€“ 40 points
Youâ€™ve learned that while TCP is reliable, it lacks speed and has an overhead data of 20 bytes,
compering to UDP that needs only 8 bytes of overhead data.
Reliable UDP or RUDP, is a protocol that uses the UDP protocol for a faster transmission of
data, while adding a reliability layer to it, but without adding too much overhead data like
TCP.
A simple sketch for a RUDP connection would look something like this:
Your task in this part is to implement a Reliable protocol using UDP only. For simplicity, your
implementation should only support a handshake, closing scheme, error checking,
acknowledgment of received packets, and retransmission of lost packets.
Guidance:
â€¢ You can use ğ‘ ğ‘’ğ‘¡ğ‘ ğ‘œğ‘ğ‘˜ğ‘œğ‘ğ‘¡(2) for detecting a timeout.
â€¢ You need to build your own protocol, as Reliable UDP isnâ€™t a standard protocol (see a
draft of RUDP in this link), and no official header is provided. You can use this sketch
for a header, but you can come up with your own protocol, as long as it works.
Where:
o ğ‘³ğ’†ğ’ğ’ˆğ’•ğ’‰ is the length of the data itself, without the RUDP header.
o ğ‘ªğ’‰ğ’†ğ’„ğ’Œğ’”ğ’–ğ’ is a 16bit number that validates the correctness of the data.
o ğ‘­ğ’ğ’‚ğ’ˆğ’” is a special byte where we classify the packet itself (SYN, ACK, etc.).
â€¢ In your PDF, you must explain how your implementation of RUDP works â€“ How does
it detect a timeout to do retransmissions, how does the handshake work, what is the
header overhead, etc.
â€¢ For this part, youâ€™ll write three files: ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¨ğ‘·ğ‘°. ğ’„, ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and
ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
Reliable UDP Header proposed sketch
Byte 0 Byte 1 Byte 2 Byte 3
Length (2 Bytes) Checksum (2 Bytes)
Flags (1 Byte)
Figure 1 - RUDP Protocol Architecture, Geeksforgeeks
 Communication Networks Course
Page | 5
Notes:
â€¢ The Sender will send a random generated file and the Receiver will receive it and
measure the time it took for his program to receive the file. The file size should be at
least 2MB.
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). But, as the
RUDP is based on UDP, itâ€™s not reliable. You must use some form of error checking
(like checksum) to ensure that the packet wasnâ€™t alerted during the transfer.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
â€¢ The RUDP needs support only 1 sender and 1 receiver, for simplicity purposes.
Usage:
â€¢ Receiver:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
â€¢ Sender:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port that both the Sender and the Receiver will use.
The ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„ file will contain all the implementations of the RUDP API functions (That is, to
prevent reusing the same chuck of code both in the Sender and the Receiver.).
The API should support at the bare minimum the following functions (you decide what
parameters to implement, and what are the names of the functions, as long as the API is
explained in the PDF):
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘œğ‘ğ‘˜ğ‘’ğ‘¡() â€“ Creating a RUDP socket and creating a handshake between two
peers.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘’ğ‘›ğ‘‘() â€“ Sending data to the peer. The function should wait for an
acknowledgment packet, and if it didnâ€™t receive any, retransmits the data.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘Ÿğ‘’ğ‘ğ‘£() â€“ Receive data from a peer.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ğ‘™ğ‘œğ‘ ğ‘’() â€“ Closes a connection between peers.
 Communication Networks Course
Page | 6
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a UDP socket between the Sender and the
Receiver.
3) Send the file via the RUDP protocol.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a UDP connection between the Receiver and
the Sender.
2) Get a connection from the sender, by the custom
RUDP protocol youâ€™ve built.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./RUDP_Receiver -p 1234
Starting Receiver...
Waiting for RUDP connection...
Connection request received, sending ACK.
Sender connected, beginning to receive file...
File transfer completed.
ACK sent.
Waiting for Sender response...
Sender sent exit message.
ACK sent.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 7
Part C â€“ Research â€“ 30 points
In this part, youâ€™ll conduct research about your implementations of part A and part B.
In the research itself, each one of the versions (TCP version and UDP version) will be run at
least 5 times (meaning that the file transfer will occur at least 5 times) by the following
conditions:
â€¢ For TCP, youâ€™ll run it in TCP Reno and TCP Cubic, alternating each time, for each
scenario, meaning that you run 5 times with TCP Reno in both Sender and Receiver,
and 5 times with TCP Cubic in both Sender and Receiver.
Bonus (5 points): Create a very large data set â€“ 5 times with TCP Reno in both Sender
and Receiver, 5 times with TCP Reno in Sender and TCP Cubic in Receiver, 5 times
with TCP Cubic in Sender and TCP Reno in Receiver, and 5 times with TCP Cubic in
both Sender and Receiver. This will give you a data set large enough, which allows
you to work with, compare with and to reach a definite conclusion.
â€¢ For RUDP, you will run it 5 times for each scenario.
â€¢ For both TCP and RUDP, you will run them on those scenarios of packet loss:
o 0% packet loss â€“ Control group, simulating perfect connection.
o 2% packet loss â€“ Simulating unstable connection that commonly occur.
o 5% packet loss â€“ Simulating bad connection.
o 10% packet loss â€“ Simulating extremely poor connection.
For each scenario, you must provide a filtered PCAP file and relevant screenshots that
explain each one of the steps in the process. (10 points)
After youâ€™ve gathered the data set for both TCP and Reliable UDP, answer the following
questions:
1) In TCP, which congestion control algorithm gave better results overall? TCP Reno or
TCP Cubic? Which one gave better results on high packet loss? Explain how you came
to this conclusion based on the data set youâ€™ve gathered. (5 points)
2) How did your implementation of Reliable UDP perform overall compared to regular
TCP? Which one is better for high packet loss? (5 points)
3) According to the data youâ€™ve gathered, in which scenarios and applications would we
prefer to use TCP and in which situations would we prefer to use reliable UDP?
Explain your answer. (5 points)
 Communication Networks Course
Page | 8
×¢× ×• ×¢×œ ×”×©××œ×•×ª ×”×‘××•×ª )5 × ×§×•×“×•×ª(:
â— ×‘"×¨×©×ª ×××™× ×”" ×”×›×•×•× ×” ×”×™× ×œ×¨×©×ª ×©×‘×” ××¢×˜ ×××•×“ ×—×‘×™×œ×•×ª ×”×•×œ×›×•×ª ×œ××™×‘×•×“. ×‘"×§×©×¨ ××¨×•×š" ×”×›×•×•× ×” ×”×™×
×œ×§×©×¨ TCP ×©×™×© ×‘×• ×”×¨×‘×” ×××•×“ ××™×“×¢ ×œ×©×œ×•×—. ××•×¦×¢ ×œ×”×’×“×™×œ ×‘ -TCP ××ª SSThreshold ×‘×ª×—×™×œ×ª ×”×§×©×¨.
×‘××™×–×” ××”××§×¨×™× ×”×‘××™× ×”×©×™× ×•×™ ×”×–×” ×¢×©×•×™ ×œ×”×•×¢×™×œ ×‘××™×“×” ×”××™×¨×‘×™×ª? × ××§.
.1 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
.2 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.3 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.4 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.5 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.6 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.7 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.8 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
â— A ×©×•×œ×— ×œ -B ×—×‘×™×œ×•×ª ××™×“×¢ ×‘×××¦×¢×•×ª ×§×©×¨ TCP. × ×ª×•×Ÿ ×›×™ ×”×§×©×¨ ××ª×—×™×œ ×¢× ×—×œ×•×Ÿ ×‘×’×•×“×œ 1MSS. ×”×§×©×¨
××¡×ª×™×™× ×‘×¤×¢× ×”×¨××©×•× ×” ×©×”×•× ××’×™×¢ ×œ -SSthresh. ×‘××”×œ×š ×”×§×©×¨ ×œ× ××•×‘×“×•×ª ×—×‘×™×œ×•×ª. × ×¡××Ÿ ×‘×§×™×¦×•×¨:
.SSthresh=S*MSS
× ×ª×•×Ÿ ×›×™ ×œ××•×¨×š ×›×œ ×”×§×©×¨ rwnd < MSS*S.
××”×™ ×”×ª×¤×•×§×” ×©×œ ×”×§×©×¨ ×-A ×œ-B( ×‘ -sec / Bytes )×‘×–××Ÿ ×”× "×œ? × ××§×™.
]S*MSS / [lg (S) * RTT*2 ×‘×¢×¨×š .1
]S*MSS / [S^0.5 * RTT*2 ×‘×¢×¨×š .2
S*MSS / RTT ×‘×¢×¨×š .3
S^2)*MSS / RTT( ×‘×¢×¨×š .4
â— ×©×ª×™ ×ª×—× ×•×ª ××ª×§×©×¨×•×ª ×‘××•×¤×Ÿ ××œ×—×•×˜×™ ×‘×©×™×˜×ª N Back Go.
× ×¡××Ÿ ×‘-X ××ª ×¡×¤×¨×ª ×”×‘×™×§×•×¨×ª ×©×œ ×”×ª.×–. ×©×œ×š. ×× ×©× ×™ ×©×•×ª×¤×™× ××’×™×©×™× ××ª ×”×ª×¨×’×™×œ ×™×—×“, X ×”×•× ×¡×¤×¨×ª
×”×‘×™×§×•×¨×ª ×‘×¢×œ×ª ×”×¢×¨×š ×”× ××•×š ×™×•×ª×¨ ××‘×™×Ÿ ×”×©×ª×™×™×.
×§×¦×‘ ×”×ª×§×©×•×¨×ª ×”×•× 8Gbps, ×•×’×•×“×œ ×›×œ ×—×‘×™×œ×” ×”×•× KByte*X. ×’×“×œ×™ ×”-headers ×•×” -Acks ×–× ×™×—×™×.
ï¿½ğ‘’ğ‘ ï¿½/ï¿½ï¿½ 8 , ×•×”××¨×—×§ ×‘×™×Ÿ ×”×ª×—× ×•×ª ×”×•× 1Km. ×§×¦×‘ ×”×”×ª×¤×©×˜×•×ª ×”×•× 10 â‹… 2
×–××Ÿ ×¢×™×‘×•×“ ×”× ×ª×•× ×™× ×‘×ª×—× ×•×ª ×–× ×™×—.
××£ ×—×‘×™×œ×” ×•××£ Ack ×œ× ×”×•×œ×›×™× ×œ××™×‘×•×“.
â— ××”×• X ×©×œ×š?
â— ××” ×¦×¨×™×š ×œ×”×™×•×ª ×’×•×“×œ ×—×œ×•×Ÿ ×”××©×œ×•×— ×›×“×™ ×œ×”×‘×˜×™×— ×ª×¤×•×§×” ××§×¡×™××œ×™×ª?
 Communication Networks Course
Page | 9
Bonus â€“ Improving the Reliable UDP â€“ 15 points
Note: This part isnâ€™t mandatory and is a bonus only!
In this part, youâ€™ll improve your RUDP implementation by adding the concepts of flow
control and congestion control from TCP. Youâ€™re free to choose which algorithms to
implement, as long as you explain in your PDF which algorithms youâ€™ve used. Youâ€™ll probably
need to make changes in the original design of the RUDP. Changes only need to be to the API
itself, ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„.
Points distribution:
â€¢ Flow control improvement â€“ 7 Points
â€¢ Congestion control improvement â€“ 8 points.
Guidance:
â€¢ For flow control, you must use one of the Sliding window techniques: stop-and-wait
ARQ, Go-Back-N or Selective repeat.
â€¢ List of known TCP congestion control algorithms, which you can use any one of them
for this bonus task, or makeup your own:
Figure 2 â€“ List of known TCP congestion control algorithms, Wikipedia
 Communication Networks Course
Page | 10
Appendix A â€“ Linux local packet loss tool
To simulate a packet loss in a local network, we'll use a Linux tool that's called Linux Traffic
Control (ğ‘¡ğ‘). This requires a full Linux installation, so working with WSL won't work.
If the tool isn't installed in your machine, you can install it by using the following commands:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’
If the installation didn't work, you can use the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’2
To create a packet loss scenario, type the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘ğ‘‘ğ‘‘ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
After creating a packet loss scenario, you can change the percentage by typing the following
command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘â„ğ‘ğ‘›ğ‘”ğ‘’ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
To remove the packet loss scenario, write the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘‘ğ‘’ğ‘™ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š
 Communication Networks Course
Page | 11
Appendix B â€“ ğ’ğ’‚ğ’(ğŸ) system calls
This appendixâ€™s purpose is to give you a better understanding of socket handling in C.
A recommended reference is Beejâ€™s Guide to Network Programming, by Brian â€œBeej
Jorgensenâ€ Hall, which gives a lot of information about sockets in C and functions.
Functions and documentation links:
â€¢ ğ’”ğ’ğ’„ğ’Œğ’†ğ’•(ğŸ) â€“ A Factory method system call that creates a socket with the given
parameters.
â€¢ ğ’ƒğ’Šğ’ğ’…(ğŸ) â€“ Whenever we create a new socket, we need to bind it to a specific port in
our machine, â€œto catch a portâ€. The port number is managed and used by the kernel
to link incoming packets to the corresponding application socket. The port numbers
are usually fixed. The ğ‘ğ‘‘ğ‘‘ğ‘Ÿ parameter must match the current socket that is used.
â€¢ ğ’ğ’Šğ’”ğ’•ğ’†ğ’(ğŸ) â€“ The ğ‘™ğ‘–ğ‘ ğ‘¡ğ‘’ğ‘›(2) system call doesn't do anything in the mean of
communication but only memory allocation (malloc) for stream sockets only. If we
won't allocate memory, any incoming connection will fail.
â€¢ ğ’„ğ’ğ’ğ’ğ’†ğ’„ğ’•(ğŸ) â€“ The ğ‘ğ‘œğ‘›ğ‘›ğ‘’ğ‘ğ‘¡(2) system call starts the link between a client and a
specific IP address and port number. The connection would complete when the
other side will call the ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call.
â€¢ ğ’‚ğ’„ğ’„ğ’†ğ’‘ğ’•(ğŸ) â€“ The ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call accepts the incoming stream connection
request from the other side, by the listening socket. This system call completes the
three-way handshake of stream socket (like TCP) and opens a new socket that has a
direct communication channel only with the other party in the handshake.
â€¢ ğ’”ğ’†ğ’ğ’…(ğŸ) and ğ’”ğ’†ğ’ğ’…ğ’•ğ’(ğŸ) â€“ The ğ‘ ğ‘’ğ‘›ğ‘‘(2) and ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system calls are an analogy
for the ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’(2) system call, specifcly for sockets, with flags set to 0. Those system
calls return the number of bytes that were sent through the socket itself, as the
number of bytes can vary. The ğ‘ ğ‘’ğ‘›ğ‘‘(2)system call designed for stream sockets (like
TCP), while the ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system call designed for datagram connection-less
sockets (like UDP). When the ğ‘ ğ‘’ğ‘›ğ‘‘(2) system call returns 0, it means that the other
party closed the connection.
â€¢ ğ’“ğ’†ğ’„ğ’—(ğŸ) and ğ’“ğ’†ğ’„ğ’—ğ’‡ğ’“ğ’ğ’(ğŸ) â€“ The ğ‘Ÿğ‘’ğ‘ğ‘£(2) and ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system calls are an
analogy for the ğ‘Ÿğ‘’ğ‘ğ‘‘(2) system call, specifically for sockets, with flags set to 0.
Those system calls return the number of bytes that were received through the socket
itself, as the number of bytes can vary. The ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call designed for stream
sockets (like TCP), while the ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system call designed for datagram
connection-less sockets (like UDP). When the ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call returns 0, it means
that the other party closed the connection.
â€¢ ğ’„ğ’ğ’ğ’”ğ’†(ğŸ) and ğ’”ğ’‰ğ’–ğ’•ğ’…ğ’ğ’˜ğ’(ğŸ) â€“ The ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) and ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2) system calls close
the socket. While ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) system call closes the whole socket, the ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2)
system call partially closes the socket for read/write.
 Communication Networks Course
Page | 12
Appendix C â€“ Random data generator
The data that you are going to send in this assignment is randomly generated. You can use
your own file with appropriate size or use the following function (or a function of your own)
to generate the data:
/*
* @brief A random data generator function based on srand() and rand().
* @param size The size of the data to generate (up to 2^32 bytes).
* @return A pointer to the buffer.
*/
char *util_generate_random_data(unsigned int size) {
 char *buffer = NULL;
 // Argument check.
 if (size == 0)
 return NULL;
 buffer = (char *)calloc(size, sizeof(char));
 // Error checking.
 if (buffer == NULL)
 return NULL;
 // Randomize the seed of the random number generator.
 srand(time(NULL));
 for (unsigned int i = 0; i < size; i++)
 *(buffer + i) = ((unsigned int)rand() % 256);
 return buffer;
}
 Communication Networks Course
Page | 13
Appendix D â€“ Checksum function
A checksum is a small-sized block of data derived from another block of digital data for the
purpose of detecting errors that may have been introduced during its transmission or
storage. By themselves, checksums are often used to verify data integrity but are not relied
upon to verify data authenticity.
Below is a simple yet efficient implementation of the checksum function, you can use it for
the assignment, but you can implement your own checksum function.
/*
* @brief A checksum function that returns 16 bit checksum for data.
* @param data The data to do the checksum for.
* @param bytes The length of the data in bytes.
* @return The checksum itself as 16 bit unsigned number.
* @note This function is taken from RFC1071, can be found here:
* @note https://tools.ietf.org/html/rfc1071
* @note It is the simplest way to calculate a checksum and is not very strong.
* However, it is good enough for this assignment.
* @note You are free to use any other checksum function as well.
* You can also use this function as such without any change.
*/
unsigned short int calculate_checksum(void *data, unsigned int bytes) {
 unsigned short int *data_pointer = (unsigned short int *)data;
 unsigned int total_sum = 0;
 // Main summing loop
 while (bytes > 1) {
 total_sum += *data_pointer++;
 bytes -= 2;
 }
 // Add left-over byte, if any
 if (bytes > 0)
 total_sum += *((unsigned char *)data_pointer);
 // Fold 32-bit sum to 16 bits
 while (total_sum >> 16)
 total_sum = (total_sum & 0xFFFF) + (total_sum >> 16);
 return (~((unsigned short int)total_sum));
} Communication Networks Course
Page | 1
Assignment 3 â€“ Transport Layer
Assignment Notes and Instructions
This assignment is to be done in pairs only. You must upload all the necessary files in a ZIP
file named after both of the studentâ€™s ID. For example: ğŸğŸğŸ‘ğŸ’ğŸ“ğŸ”ğŸ•ğŸ–ğŸ—_ğŸ—ğŸ–ğŸ•ğŸ”ğŸ“ğŸ’ğŸ‘ğŸğŸ. ğ’›ğ’Šğ’‘.
1) The assignment must be submitted by the date specified in the submission box.
2) All the assignment files (Code, Wireshark pcap files, PDF) must be submitted in a ZIP file. The
PDF must contain all the necessary screenshots with a description for each one of them.
3) The assignment must be done in pairs only. In exceptional cases, you should send an email to
the course coordinator.
4) You can use any reference material available through the course Moodle website or any
material passed during the exercises.
5) You can use any reference from the web, but copying codes from websites is forbidden; this
includes codes from other GitHub repositories. A student who gets caught in the act will
automatically fail this assignment (score 0). Any website youâ€™ve used to solve the
assignment, every website you used to solve the assignment must be noted in the PDF.
6) No delays in submission without special permission. Lateness without approval will result in
failure of the assignment (score 0).
7) All submissions will be submitted via the course's Moodle website. Email submissions will not
be accepted, resulting in a failure in the assignment.
8) The order and design of the code must be carefully considered. Make sure that the program
output is as clear as possible, comments in the code, and meaningful variable names. You
must also submit a makefile that compiles all the programs.
9) The assignment code must be written in C only.
10) The assignment is personal for each pair, and you should not accept help from other people,
whether outside the university or inside it. You can contact the course staff during reception
hours for help or raise a question in the course forum. Do not transfer code sections
between students, upload solutions or parts of solutions to websites on the Internet or in
various communication groups.
11) Students who copy a solution will receive a 0 in all assignments in the course and a report will
be made to the institutional disciplinary committee.
12) All code files of the assignment are required to both compile and run properly on the Ubuntu
22.04 LTS operating system. This is the operating system where the submissions will be
tested. You mustnâ€™t code it in Windows, as it uses different API for sockets. WSL wonâ€™t work,
as the task needs a tool that works only in a fully Linux environment.
Good Luck!
 Communication Networks Course
Page | 2
Part A â€“ Transmission Control Protocol (TCP) â€“ 30 points
In this part, youâ€™ll write two program files: ğ‘»ğ‘ªğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and ğ‘»ğ‘ªğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
The Sender will send a randomly generated file and the Receiver will receive it and measure
the time it took for his program to receive the file. The file size should be at least 2MB.
When running the Sender and Receiver, they both should support two standard congestion
control algorithms: TCP Reno and TCP Cubic.
Notes:
â€¢ The main goal of this part is to get familiar with the TCP concept of sending
messages between two endpoints.
â€¢ For approaching this part of the assignment, please be sure that you are familiar
with the congestion control algorithms and how to change them using the correct
method in C (see Appendix B for more information).
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). You've
learned that TCP is reliable by design, so you can assume that all the data have been
passed correctly, and thus, no need to recheck.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
Usage:
â€¢ Receiver:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
â€¢ Sender:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port of the Receiver.
â€¢ ğ‘¨ğ‘³ğ‘®ğ‘¶ â€“ The TCP congestion control algorithm that will be used by the party
member (either ğ’“ğ’†ğ’ğ’ for TCP Reno or ğ’„ğ’–ğ’ƒğ’Šğ’„ for TCP Cubic).
 Communication Networks Course
Page | 3
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a TCP socket between the Sender and the
Receiver.
3) Send the file.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a TCP connection between the Receiver and
the Sender.
2) Get a connection from the sender.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./TCP_Receiver -p 1234 -algo reno
Starting Receiver...
Waiting for TCP connection...
Sender connected, beginning to receive file...
File transfer completed.
Waiting for Sender response...
Sender sent exit message.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 4
Part B â€“ Reliable User Datagram Protocol (Reliable UDP or RUDP) â€“ 40 points
Youâ€™ve learned that while TCP is reliable, it lacks speed and has an overhead data of 20 bytes,
compering to UDP that needs only 8 bytes of overhead data.
Reliable UDP or RUDP, is a protocol that uses the UDP protocol for a faster transmission of
data, while adding a reliability layer to it, but without adding too much overhead data like
TCP.
A simple sketch for a RUDP connection would look something like this:
Your task in this part is to implement a Reliable protocol using UDP only. For simplicity, your
implementation should only support a handshake, closing scheme, error checking,
acknowledgment of received packets, and retransmission of lost packets.
Guidance:
â€¢ You can use ğ‘ ğ‘’ğ‘¡ğ‘ ğ‘œğ‘ğ‘˜ğ‘œğ‘ğ‘¡(2) for detecting a timeout.
â€¢ You need to build your own protocol, as Reliable UDP isnâ€™t a standard protocol (see a
draft of RUDP in this link), and no official header is provided. You can use this sketch
for a header, but you can come up with your own protocol, as long as it works.
Where:
o ğ‘³ğ’†ğ’ğ’ˆğ’•ğ’‰ is the length of the data itself, without the RUDP header.
o ğ‘ªğ’‰ğ’†ğ’„ğ’Œğ’”ğ’–ğ’ is a 16bit number that validates the correctness of the data.
o ğ‘­ğ’ğ’‚ğ’ˆğ’” is a special byte where we classify the packet itself (SYN, ACK, etc.).
â€¢ In your PDF, you must explain how your implementation of RUDP works â€“ How does
it detect a timeout to do retransmissions, how does the handshake work, what is the
header overhead, etc.
â€¢ For this part, youâ€™ll write three files: ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¨ğ‘·ğ‘°. ğ’„, ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and
ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
Reliable UDP Header proposed sketch
Byte 0 Byte 1 Byte 2 Byte 3
Length (2 Bytes) Checksum (2 Bytes)
Flags (1 Byte)
Figure 1 - RUDP Protocol Architecture, Geeksforgeeks
 Communication Networks Course
Page | 5
Notes:
â€¢ The Sender will send a random generated file and the Receiver will receive it and
measure the time it took for his program to receive the file. The file size should be at
least 2MB.
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). But, as the
RUDP is based on UDP, itâ€™s not reliable. You must use some form of error checking
(like checksum) to ensure that the packet wasnâ€™t alerted during the transfer.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
â€¢ The RUDP needs support only 1 sender and 1 receiver, for simplicity purposes.
Usage:
â€¢ Receiver:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
â€¢ Sender:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port that both the Sender and the Receiver will use.
The ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„ file will contain all the implementations of the RUDP API functions (That is, to
prevent reusing the same chuck of code both in the Sender and the Receiver.).
The API should support at the bare minimum the following functions (you decide what
parameters to implement, and what are the names of the functions, as long as the API is
explained in the PDF):
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘œğ‘ğ‘˜ğ‘’ğ‘¡() â€“ Creating a RUDP socket and creating a handshake between two
peers.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘’ğ‘›ğ‘‘() â€“ Sending data to the peer. The function should wait for an
acknowledgment packet, and if it didnâ€™t receive any, retransmits the data.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘Ÿğ‘’ğ‘ğ‘£() â€“ Receive data from a peer.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ğ‘™ğ‘œğ‘ ğ‘’() â€“ Closes a connection between peers.
 Communication Networks Course
Page | 6
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a UDP socket between the Sender and the
Receiver.
3) Send the file via the RUDP protocol.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a UDP connection between the Receiver and
the Sender.
2) Get a connection from the sender, by the custom
RUDP protocol youâ€™ve built.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./RUDP_Receiver -p 1234
Starting Receiver...
Waiting for RUDP connection...
Connection request received, sending ACK.
Sender connected, beginning to receive file...
File transfer completed.
ACK sent.
Waiting for Sender response...
Sender sent exit message.
ACK sent.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 7
Part C â€“ Research â€“ 30 points
In this part, youâ€™ll conduct research about your implementations of part A and part B.
In the research itself, each one of the versions (TCP version and UDP version) will be run at
least 5 times (meaning that the file transfer will occur at least 5 times) by the following
conditions:
â€¢ For TCP, youâ€™ll run it in TCP Reno and TCP Cubic, alternating each time, for each
scenario, meaning that you run 5 times with TCP Reno in both Sender and Receiver,
and 5 times with TCP Cubic in both Sender and Receiver.
Bonus (5 points): Create a very large data set â€“ 5 times with TCP Reno in both Sender
and Receiver, 5 times with TCP Reno in Sender and TCP Cubic in Receiver, 5 times
with TCP Cubic in Sender and TCP Reno in Receiver, and 5 times with TCP Cubic in
both Sender and Receiver. This will give you a data set large enough, which allows
you to work with, compare with and to reach a definite conclusion.
â€¢ For RUDP, you will run it 5 times for each scenario.
â€¢ For both TCP and RUDP, you will run them on those scenarios of packet loss:
o 0% packet loss â€“ Control group, simulating perfect connection.
o 2% packet loss â€“ Simulating unstable connection that commonly occur.
o 5% packet loss â€“ Simulating bad connection.
o 10% packet loss â€“ Simulating extremely poor connection.
For each scenario, you must provide a filtered PCAP file and relevant screenshots that
explain each one of the steps in the process. (10 points)
After youâ€™ve gathered the data set for both TCP and Reliable UDP, answer the following
questions:
1) In TCP, which congestion control algorithm gave better results overall? TCP Reno or
TCP Cubic? Which one gave better results on high packet loss? Explain how you came
to this conclusion based on the data set youâ€™ve gathered. (5 points)
2) How did your implementation of Reliable UDP perform overall compared to regular
TCP? Which one is better for high packet loss? (5 points)
3) According to the data youâ€™ve gathered, in which scenarios and applications would we
prefer to use TCP and in which situations would we prefer to use reliable UDP?
Explain your answer. (5 points)
 Communication Networks Course
Page | 8
×¢× ×• ×¢×œ ×”×©××œ×•×ª ×”×‘××•×ª )5 × ×§×•×“×•×ª(:
â— ×‘"×¨×©×ª ×××™× ×”" ×”×›×•×•× ×” ×”×™× ×œ×¨×©×ª ×©×‘×” ××¢×˜ ×××•×“ ×—×‘×™×œ×•×ª ×”×•×œ×›×•×ª ×œ××™×‘×•×“. ×‘"×§×©×¨ ××¨×•×š" ×”×›×•×•× ×” ×”×™×
×œ×§×©×¨ TCP ×©×™×© ×‘×• ×”×¨×‘×” ×××•×“ ××™×“×¢ ×œ×©×œ×•×—. ××•×¦×¢ ×œ×”×’×“×™×œ ×‘ -TCP ××ª SSThreshold ×‘×ª×—×™×œ×ª ×”×§×©×¨.
×‘××™×–×” ××”××§×¨×™× ×”×‘××™× ×”×©×™× ×•×™ ×”×–×” ×¢×©×•×™ ×œ×”×•×¢×™×œ ×‘××™×“×” ×”××™×¨×‘×™×ª? × ××§.
.1 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
.2 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.3 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.4 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.5 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.6 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.7 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.8 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
â— A ×©×•×œ×— ×œ -B ×—×‘×™×œ×•×ª ××™×“×¢ ×‘×××¦×¢×•×ª ×§×©×¨ TCP. × ×ª×•×Ÿ ×›×™ ×”×§×©×¨ ××ª×—×™×œ ×¢× ×—×œ×•×Ÿ ×‘×’×•×“×œ 1MSS. ×”×§×©×¨
××¡×ª×™×™× ×‘×¤×¢× ×”×¨××©×•× ×” ×©×”×•× ××’×™×¢ ×œ -SSthresh. ×‘××”×œ×š ×”×§×©×¨ ×œ× ××•×‘×“×•×ª ×—×‘×™×œ×•×ª. × ×¡××Ÿ ×‘×§×™×¦×•×¨:
.SSthresh=S*MSS
× ×ª×•×Ÿ ×›×™ ×œ××•×¨×š ×›×œ ×”×§×©×¨ rwnd < MSS*S.
××”×™ ×”×ª×¤×•×§×” ×©×œ ×”×§×©×¨ ×-A ×œ-B( ×‘ -sec / Bytes )×‘×–××Ÿ ×”× "×œ? × ××§×™.
]S*MSS / [lg (S) * RTT*2 ×‘×¢×¨×š .1
]S*MSS / [S^0.5 * RTT*2 ×‘×¢×¨×š .2
S*MSS / RTT ×‘×¢×¨×š .3
S^2)*MSS / RTT( ×‘×¢×¨×š .4
â— ×©×ª×™ ×ª×—× ×•×ª ××ª×§×©×¨×•×ª ×‘××•×¤×Ÿ ××œ×—×•×˜×™ ×‘×©×™×˜×ª N Back Go.
× ×¡××Ÿ ×‘-X ××ª ×¡×¤×¨×ª ×”×‘×™×§×•×¨×ª ×©×œ ×”×ª.×–. ×©×œ×š. ×× ×©× ×™ ×©×•×ª×¤×™× ××’×™×©×™× ××ª ×”×ª×¨×’×™×œ ×™×—×“, X ×”×•× ×¡×¤×¨×ª
×”×‘×™×§×•×¨×ª ×‘×¢×œ×ª ×”×¢×¨×š ×”× ××•×š ×™×•×ª×¨ ××‘×™×Ÿ ×”×©×ª×™×™×.
×§×¦×‘ ×”×ª×§×©×•×¨×ª ×”×•× 8Gbps, ×•×’×•×“×œ ×›×œ ×—×‘×™×œ×” ×”×•× KByte*X. ×’×“×œ×™ ×”-headers ×•×” -Acks ×–× ×™×—×™×.
ï¿½ğ‘’ğ‘ ï¿½/ï¿½ï¿½ 8 , ×•×”××¨×—×§ ×‘×™×Ÿ ×”×ª×—× ×•×ª ×”×•× 1Km. ×§×¦×‘ ×”×”×ª×¤×©×˜×•×ª ×”×•× 10 â‹… 2
×–××Ÿ ×¢×™×‘×•×“ ×”× ×ª×•× ×™× ×‘×ª×—× ×•×ª ×–× ×™×—.
××£ ×—×‘×™×œ×” ×•××£ Ack ×œ× ×”×•×œ×›×™× ×œ××™×‘×•×“.
â— ××”×• X ×©×œ×š?
â— ××” ×¦×¨×™×š ×œ×”×™×•×ª ×’×•×“×œ ×—×œ×•×Ÿ ×”××©×œ×•×— ×›×“×™ ×œ×”×‘×˜×™×— ×ª×¤×•×§×” ××§×¡×™××œ×™×ª?
 Communication Networks Course
Page | 9
Bonus â€“ Improving the Reliable UDP â€“ 15 points
Note: This part isnâ€™t mandatory and is a bonus only!
In this part, youâ€™ll improve your RUDP implementation by adding the concepts of flow
control and congestion control from TCP. Youâ€™re free to choose which algorithms to
implement, as long as you explain in your PDF which algorithms youâ€™ve used. Youâ€™ll probably
need to make changes in the original design of the RUDP. Changes only need to be to the API
itself, ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„.
Points distribution:
â€¢ Flow control improvement â€“ 7 Points
â€¢ Congestion control improvement â€“ 8 points.
Guidance:
â€¢ For flow control, you must use one of the Sliding window techniques: stop-and-wait
ARQ, Go-Back-N or Selective repeat.
â€¢ List of known TCP congestion control algorithms, which you can use any one of them
for this bonus task, or makeup your own:
Figure 2 â€“ List of known TCP congestion control algorithms, Wikipedia
 Communication Networks Course
Page | 10
Appendix A â€“ Linux local packet loss tool
To simulate a packet loss in a local network, we'll use a Linux tool that's called Linux Traffic
Control (ğ‘¡ğ‘). This requires a full Linux installation, so working with WSL won't work.
If the tool isn't installed in your machine, you can install it by using the following commands:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’
If the installation didn't work, you can use the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’2
To create a packet loss scenario, type the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘ğ‘‘ğ‘‘ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
After creating a packet loss scenario, you can change the percentage by typing the following
command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘â„ğ‘ğ‘›ğ‘”ğ‘’ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
To remove the packet loss scenario, write the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘‘ğ‘’ğ‘™ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š
 Communication Networks Course
Page | 11
Appendix B â€“ ğ’ğ’‚ğ’(ğŸ) system calls
This appendixâ€™s purpose is to give you a better understanding of socket handling in C.
A recommended reference is Beejâ€™s Guide to Network Programming, by Brian â€œBeej
Jorgensenâ€ Hall, which gives a lot of information about sockets in C and functions.
Functions and documentation links:
â€¢ ğ’”ğ’ğ’„ğ’Œğ’†ğ’•(ğŸ) â€“ A Factory method system call that creates a socket with the given
parameters.
â€¢ ğ’ƒğ’Šğ’ğ’…(ğŸ) â€“ Whenever we create a new socket, we need to bind it to a specific port in
our machine, â€œto catch a portâ€. The port number is managed and used by the kernel
to link incoming packets to the corresponding application socket. The port numbers
are usually fixed. The ğ‘ğ‘‘ğ‘‘ğ‘Ÿ parameter must match the current socket that is used.
â€¢ ğ’ğ’Šğ’”ğ’•ğ’†ğ’(ğŸ) â€“ The ğ‘™ğ‘–ğ‘ ğ‘¡ğ‘’ğ‘›(2) system call doesn't do anything in the mean of
communication but only memory allocation (malloc) for stream sockets only. If we
won't allocate memory, any incoming connection will fail.
â€¢ ğ’„ğ’ğ’ğ’ğ’†ğ’„ğ’•(ğŸ) â€“ The ğ‘ğ‘œğ‘›ğ‘›ğ‘’ğ‘ğ‘¡(2) system call starts the link between a client and a
specific IP address and port number. The connection would complete when the
other side will call the ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call.
â€¢ ğ’‚ğ’„ğ’„ğ’†ğ’‘ğ’•(ğŸ) â€“ The ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call accepts the incoming stream connection
request from the other side, by the listening socket. This system call completes the
three-way handshake of stream socket (like TCP) and opens a new socket that has a
direct communication channel only with the other party in the handshake.
â€¢ ğ’”ğ’†ğ’ğ’…(ğŸ) and ğ’”ğ’†ğ’ğ’…ğ’•ğ’(ğŸ) â€“ The ğ‘ ğ‘’ğ‘›ğ‘‘(2) and ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system calls are an analogy
for the ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’(2) system call, specifcly for sockets, with flags set to 0. Those system
calls return the number of bytes that were sent through the socket itself, as the
number of bytes can vary. The ğ‘ ğ‘’ğ‘›ğ‘‘(2)system call designed for stream sockets (like
TCP), while the ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system call designed for datagram connection-less
sockets (like UDP). When the ğ‘ ğ‘’ğ‘›ğ‘‘(2) system call returns 0, it means that the other
party closed the connection.
â€¢ ğ’“ğ’†ğ’„ğ’—(ğŸ) and ğ’“ğ’†ğ’„ğ’—ğ’‡ğ’“ğ’ğ’(ğŸ) â€“ The ğ‘Ÿğ‘’ğ‘ğ‘£(2) and ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system calls are an
analogy for the ğ‘Ÿğ‘’ğ‘ğ‘‘(2) system call, specifically for sockets, with flags set to 0.
Those system calls return the number of bytes that were received through the socket
itself, as the number of bytes can vary. The ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call designed for stream
sockets (like TCP), while the ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system call designed for datagram
connection-less sockets (like UDP). When the ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call returns 0, it means
that the other party closed the connection.
â€¢ ğ’„ğ’ğ’ğ’”ğ’†(ğŸ) and ğ’”ğ’‰ğ’–ğ’•ğ’…ğ’ğ’˜ğ’(ğŸ) â€“ The ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) and ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2) system calls close
the socket. While ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) system call closes the whole socket, the ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2)
system call partially closes the socket for read/write.
 Communication Networks Course
Page | 12
Appendix C â€“ Random data generator
The data that you are going to send in this assignment is randomly generated. You can use
your own file with appropriate size or use the following function (or a function of your own)
to generate the data:
/*
* @brief A random data generator function based on srand() and rand().
* @param size The size of the data to generate (up to 2^32 bytes).
* @return A pointer to the buffer.
*/
char *util_generate_random_data(unsigned int size) {
 char *buffer = NULL;
 // Argument check.
 if (size == 0)
 return NULL;
 buffer = (char *)calloc(size, sizeof(char));
 // Error checking.
 if (buffer == NULL)
 return NULL;
 // Randomize the seed of the random number generator.
 srand(time(NULL));
 for (unsigned int i = 0; i < size; i++)
 *(buffer + i) = ((unsigned int)rand() % 256);
 return buffer;
}
 Communication Networks Course
Page | 13
Appendix D â€“ Checksum function
A checksum is a small-sized block of data derived from another block of digital data for the
purpose of detecting errors that may have been introduced during its transmission or
storage. By themselves, checksums are often used to verify data integrity but are not relied
upon to verify data authenticity.
Below is a simple yet efficient implementation of the checksum function, you can use it for
the assignment, but you can implement your own checksum function.
/*
* @brief A checksum function that returns 16 bit checksum for data.
* @param data The data to do the checksum for.
* @param bytes The length of the data in bytes.
* @return The checksum itself as 16 bit unsigned number.
* @note This function is taken from RFC1071, can be found here:
* @note https://tools.ietf.org/html/rfc1071
* @note It is the simplest way to calculate a checksum and is not very strong.
* However, it is good enough for this assignment.
* @note You are free to use any other checksum function as well.
* You can also use this function as such without any change.
*/
unsigned short int calculate_checksum(void *data, unsigned int bytes) {
 unsigned short int *data_pointer = (unsigned short int *)data;
 unsigned int total_sum = 0;
 // Main summing loop
 while (bytes > 1) {
 total_sum += *data_pointer++;
 bytes -= 2;
 }
 // Add left-over byte, if any
 if (bytes > 0)
 total_sum += *((unsigned char *)data_pointer);
 // Fold 32-bit sum to 16 bits
 while (total_sum >> 16)
 total_sum = (total_sum & 0xFFFF) + (total_sum >> 16);
 return (~((unsigned short int)total_sum));
} Communication Networks Course
Page | 1
Assignment 3 â€“ Transport Layer
Assignment Notes and Instructions
This assignment is to be done in pairs only. You must upload all the necessary files in a ZIP
file named after both of the studentâ€™s ID. For example: ğŸğŸğŸ‘ğŸ’ğŸ“ğŸ”ğŸ•ğŸ–ğŸ—_ğŸ—ğŸ–ğŸ•ğŸ”ğŸ“ğŸ’ğŸ‘ğŸğŸ. ğ’›ğ’Šğ’‘.
1) The assignment must be submitted by the date specified in the submission box.
2) All the assignment files (Code, Wireshark pcap files, PDF) must be submitted in a ZIP file. The
PDF must contain all the necessary screenshots with a description for each one of them.
3) The assignment must be done in pairs only. In exceptional cases, you should send an email to
the course coordinator.
4) You can use any reference material available through the course Moodle website or any
material passed during the exercises.
5) You can use any reference from the web, but copying codes from websites is forbidden; this
includes codes from other GitHub repositories. A student who gets caught in the act will
automatically fail this assignment (score 0). Any website youâ€™ve used to solve the
assignment, every website you used to solve the assignment must be noted in the PDF.
6) No delays in submission without special permission. Lateness without approval will result in
failure of the assignment (score 0).
7) All submissions will be submitted via the course's Moodle website. Email submissions will not
be accepted, resulting in a failure in the assignment.
8) The order and design of the code must be carefully considered. Make sure that the program
output is as clear as possible, comments in the code, and meaningful variable names. You
must also submit a makefile that compiles all the programs.
9) The assignment code must be written in C only.
10) The assignment is personal for each pair, and you should not accept help from other people,
whether outside the university or inside it. You can contact the course staff during reception
hours for help or raise a question in the course forum. Do not transfer code sections
between students, upload solutions or parts of solutions to websites on the Internet or in
various communication groups.
11) Students who copy a solution will receive a 0 in all assignments in the course and a report will
be made to the institutional disciplinary committee.
12) All code files of the assignment are required to both compile and run properly on the Ubuntu
22.04 LTS operating system. This is the operating system where the submissions will be
tested. You mustnâ€™t code it in Windows, as it uses different API for sockets. WSL wonâ€™t work,
as the task needs a tool that works only in a fully Linux environment.
Good Luck!
 Communication Networks Course
Page | 2
Part A â€“ Transmission Control Protocol (TCP) â€“ 30 points
In this part, youâ€™ll write two program files: ğ‘»ğ‘ªğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and ğ‘»ğ‘ªğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
The Sender will send a randomly generated file and the Receiver will receive it and measure
the time it took for his program to receive the file. The file size should be at least 2MB.
When running the Sender and Receiver, they both should support two standard congestion
control algorithms: TCP Reno and TCP Cubic.
Notes:
â€¢ The main goal of this part is to get familiar with the TCP concept of sending
messages between two endpoints.
â€¢ For approaching this part of the assignment, please be sure that you are familiar
with the congestion control algorithms and how to change them using the correct
method in C (see Appendix B for more information).
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). You've
learned that TCP is reliable by design, so you can assume that all the data have been
passed correctly, and thus, no need to recheck.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
Usage:
â€¢ Receiver:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
â€¢ Sender:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port of the Receiver.
â€¢ ğ‘¨ğ‘³ğ‘®ğ‘¶ â€“ The TCP congestion control algorithm that will be used by the party
member (either ğ’“ğ’†ğ’ğ’ for TCP Reno or ğ’„ğ’–ğ’ƒğ’Šğ’„ for TCP Cubic).
 Communication Networks Course
Page | 3
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a TCP socket between the Sender and the
Receiver.
3) Send the file.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a TCP connection between the Receiver and
the Sender.
2) Get a connection from the sender.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./TCP_Receiver -p 1234 -algo reno
Starting Receiver...
Waiting for TCP connection...
Sender connected, beginning to receive file...
File transfer completed.
Waiting for Sender response...
Sender sent exit message.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 4
Part B â€“ Reliable User Datagram Protocol (Reliable UDP or RUDP) â€“ 40 points
Youâ€™ve learned that while TCP is reliable, it lacks speed and has an overhead data of 20 bytes,
compering to UDP that needs only 8 bytes of overhead data.
Reliable UDP or RUDP, is a protocol that uses the UDP protocol for a faster transmission of
data, while adding a reliability layer to it, but without adding too much overhead data like
TCP.
A simple sketch for a RUDP connection would look something like this:
Your task in this part is to implement a Reliable protocol using UDP only. For simplicity, your
implementation should only support a handshake, closing scheme, error checking,
acknowledgment of received packets, and retransmission of lost packets.
Guidance:
â€¢ You can use ğ‘ ğ‘’ğ‘¡ğ‘ ğ‘œğ‘ğ‘˜ğ‘œğ‘ğ‘¡(2) for detecting a timeout.
â€¢ You need to build your own protocol, as Reliable UDP isnâ€™t a standard protocol (see a
draft of RUDP in this link), and no official header is provided. You can use this sketch
for a header, but you can come up with your own protocol, as long as it works.
Where:
o ğ‘³ğ’†ğ’ğ’ˆğ’•ğ’‰ is the length of the data itself, without the RUDP header.
o ğ‘ªğ’‰ğ’†ğ’„ğ’Œğ’”ğ’–ğ’ is a 16bit number that validates the correctness of the data.
o ğ‘­ğ’ğ’‚ğ’ˆğ’” is a special byte where we classify the packet itself (SYN, ACK, etc.).
â€¢ In your PDF, you must explain how your implementation of RUDP works â€“ How does
it detect a timeout to do retransmissions, how does the handshake work, what is the
header overhead, etc.
â€¢ For this part, youâ€™ll write three files: ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¨ğ‘·ğ‘°. ğ’„, ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and
ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
Reliable UDP Header proposed sketch
Byte 0 Byte 1 Byte 2 Byte 3
Length (2 Bytes) Checksum (2 Bytes)
Flags (1 Byte)
Figure 1 - RUDP Protocol Architecture, Geeksforgeeks
 Communication Networks Course
Page | 5
Notes:
â€¢ The Sender will send a random generated file and the Receiver will receive it and
measure the time it took for his program to receive the file. The file size should be at
least 2MB.
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). But, as the
RUDP is based on UDP, itâ€™s not reliable. You must use some form of error checking
(like checksum) to ensure that the packet wasnâ€™t alerted during the transfer.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
â€¢ The RUDP needs support only 1 sender and 1 receiver, for simplicity purposes.
Usage:
â€¢ Receiver:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
â€¢ Sender:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port that both the Sender and the Receiver will use.
The ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„ file will contain all the implementations of the RUDP API functions (That is, to
prevent reusing the same chuck of code both in the Sender and the Receiver.).
The API should support at the bare minimum the following functions (you decide what
parameters to implement, and what are the names of the functions, as long as the API is
explained in the PDF):
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘œğ‘ğ‘˜ğ‘’ğ‘¡() â€“ Creating a RUDP socket and creating a handshake between two
peers.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘’ğ‘›ğ‘‘() â€“ Sending data to the peer. The function should wait for an
acknowledgment packet, and if it didnâ€™t receive any, retransmits the data.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘Ÿğ‘’ğ‘ğ‘£() â€“ Receive data from a peer.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ğ‘™ğ‘œğ‘ ğ‘’() â€“ Closes a connection between peers.
 Communication Networks Course
Page | 6
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a UDP socket between the Sender and the
Receiver.
3) Send the file via the RUDP protocol.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a UDP connection between the Receiver and
the Sender.
2) Get a connection from the sender, by the custom
RUDP protocol youâ€™ve built.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./RUDP_Receiver -p 1234
Starting Receiver...
Waiting for RUDP connection...
Connection request received, sending ACK.
Sender connected, beginning to receive file...
File transfer completed.
ACK sent.
Waiting for Sender response...
Sender sent exit message.
ACK sent.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 7
Part C â€“ Research â€“ 30 points
In this part, youâ€™ll conduct research about your implementations of part A and part B.
In the research itself, each one of the versions (TCP version and UDP version) will be run at
least 5 times (meaning that the file transfer will occur at least 5 times) by the following
conditions:
â€¢ For TCP, youâ€™ll run it in TCP Reno and TCP Cubic, alternating each time, for each
scenario, meaning that you run 5 times with TCP Reno in both Sender and Receiver,
and 5 times with TCP Cubic in both Sender and Receiver.
Bonus (5 points): Create a very large data set â€“ 5 times with TCP Reno in both Sender
and Receiver, 5 times with TCP Reno in Sender and TCP Cubic in Receiver, 5 times
with TCP Cubic in Sender and TCP Reno in Receiver, and 5 times with TCP Cubic in
both Sender and Receiver. This will give you a data set large enough, which allows
you to work with, compare with and to reach a definite conclusion.
â€¢ For RUDP, you will run it 5 times for each scenario.
â€¢ For both TCP and RUDP, you will run them on those scenarios of packet loss:
o 0% packet loss â€“ Control group, simulating perfect connection.
o 2% packet loss â€“ Simulating unstable connection that commonly occur.
o 5% packet loss â€“ Simulating bad connection.
o 10% packet loss â€“ Simulating extremely poor connection.
For each scenario, you must provide a filtered PCAP file and relevant screenshots that
explain each one of the steps in the process. (10 points)
After youâ€™ve gathered the data set for both TCP and Reliable UDP, answer the following
questions:
1) In TCP, which congestion control algorithm gave better results overall? TCP Reno or
TCP Cubic? Which one gave better results on high packet loss? Explain how you came
to this conclusion based on the data set youâ€™ve gathered. (5 points)
2) How did your implementation of Reliable UDP perform overall compared to regular
TCP? Which one is better for high packet loss? (5 points)
3) According to the data youâ€™ve gathered, in which scenarios and applications would we
prefer to use TCP and in which situations would we prefer to use reliable UDP?
Explain your answer. (5 points)
 Communication Networks Course
Page | 8
×¢× ×• ×¢×œ ×”×©××œ×•×ª ×”×‘××•×ª )5 × ×§×•×“×•×ª(:
â— ×‘"×¨×©×ª ×××™× ×”" ×”×›×•×•× ×” ×”×™× ×œ×¨×©×ª ×©×‘×” ××¢×˜ ×××•×“ ×—×‘×™×œ×•×ª ×”×•×œ×›×•×ª ×œ××™×‘×•×“. ×‘"×§×©×¨ ××¨×•×š" ×”×›×•×•× ×” ×”×™×
×œ×§×©×¨ TCP ×©×™×© ×‘×• ×”×¨×‘×” ×××•×“ ××™×“×¢ ×œ×©×œ×•×—. ××•×¦×¢ ×œ×”×’×“×™×œ ×‘ -TCP ××ª SSThreshold ×‘×ª×—×™×œ×ª ×”×§×©×¨.
×‘××™×–×” ××”××§×¨×™× ×”×‘××™× ×”×©×™× ×•×™ ×”×–×” ×¢×©×•×™ ×œ×”×•×¢×™×œ ×‘××™×“×” ×”××™×¨×‘×™×ª? × ××§.
.1 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
.2 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.3 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.4 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.5 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.6 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.7 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.8 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
â— A ×©×•×œ×— ×œ -B ×—×‘×™×œ×•×ª ××™×“×¢ ×‘×××¦×¢×•×ª ×§×©×¨ TCP. × ×ª×•×Ÿ ×›×™ ×”×§×©×¨ ××ª×—×™×œ ×¢× ×—×œ×•×Ÿ ×‘×’×•×“×œ 1MSS. ×”×§×©×¨
××¡×ª×™×™× ×‘×¤×¢× ×”×¨××©×•× ×” ×©×”×•× ××’×™×¢ ×œ -SSthresh. ×‘××”×œ×š ×”×§×©×¨ ×œ× ××•×‘×“×•×ª ×—×‘×™×œ×•×ª. × ×¡××Ÿ ×‘×§×™×¦×•×¨:
.SSthresh=S*MSS
× ×ª×•×Ÿ ×›×™ ×œ××•×¨×š ×›×œ ×”×§×©×¨ rwnd < MSS*S.
××”×™ ×”×ª×¤×•×§×” ×©×œ ×”×§×©×¨ ×-A ×œ-B( ×‘ -sec / Bytes )×‘×–××Ÿ ×”× "×œ? × ××§×™.
]S*MSS / [lg (S) * RTT*2 ×‘×¢×¨×š .1
]S*MSS / [S^0.5 * RTT*2 ×‘×¢×¨×š .2
S*MSS / RTT ×‘×¢×¨×š .3
S^2)*MSS / RTT( ×‘×¢×¨×š .4
â— ×©×ª×™ ×ª×—× ×•×ª ××ª×§×©×¨×•×ª ×‘××•×¤×Ÿ ××œ×—×•×˜×™ ×‘×©×™×˜×ª N Back Go.
× ×¡××Ÿ ×‘-X ××ª ×¡×¤×¨×ª ×”×‘×™×§×•×¨×ª ×©×œ ×”×ª.×–. ×©×œ×š. ×× ×©× ×™ ×©×•×ª×¤×™× ××’×™×©×™× ××ª ×”×ª×¨×’×™×œ ×™×—×“, X ×”×•× ×¡×¤×¨×ª
×”×‘×™×§×•×¨×ª ×‘×¢×œ×ª ×”×¢×¨×š ×”× ××•×š ×™×•×ª×¨ ××‘×™×Ÿ ×”×©×ª×™×™×.
×§×¦×‘ ×”×ª×§×©×•×¨×ª ×”×•× 8Gbps, ×•×’×•×“×œ ×›×œ ×—×‘×™×œ×” ×”×•× KByte*X. ×’×“×œ×™ ×”-headers ×•×” -Acks ×–× ×™×—×™×.
ï¿½ğ‘’ğ‘ ï¿½/ï¿½ï¿½ 8 , ×•×”××¨×—×§ ×‘×™×Ÿ ×”×ª×—× ×•×ª ×”×•× 1Km. ×§×¦×‘ ×”×”×ª×¤×©×˜×•×ª ×”×•× 10 â‹… 2
×–××Ÿ ×¢×™×‘×•×“ ×”× ×ª×•× ×™× ×‘×ª×—× ×•×ª ×–× ×™×—.
××£ ×—×‘×™×œ×” ×•××£ Ack ×œ× ×”×•×œ×›×™× ×œ××™×‘×•×“.
â— ××”×• X ×©×œ×š?
â— ××” ×¦×¨×™×š ×œ×”×™×•×ª ×’×•×“×œ ×—×œ×•×Ÿ ×”××©×œ×•×— ×›×“×™ ×œ×”×‘×˜×™×— ×ª×¤×•×§×” ××§×¡×™××œ×™×ª?
 Communication Networks Course
Page | 9
Bonus â€“ Improving the Reliable UDP â€“ 15 points
Note: This part isnâ€™t mandatory and is a bonus only!
In this part, youâ€™ll improve your RUDP implementation by adding the concepts of flow
control and congestion control from TCP. Youâ€™re free to choose which algorithms to
implement, as long as you explain in your PDF which algorithms youâ€™ve used. Youâ€™ll probably
need to make changes in the original design of the RUDP. Changes only need to be to the API
itself, ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„.
Points distribution:
â€¢ Flow control improvement â€“ 7 Points
â€¢ Congestion control improvement â€“ 8 points.
Guidance:
â€¢ For flow control, you must use one of the Sliding window techniques: stop-and-wait
ARQ, Go-Back-N or Selective repeat.
â€¢ List of known TCP congestion control algorithms, which you can use any one of them
for this bonus task, or makeup your own:
Figure 2 â€“ List of known TCP congestion control algorithms, Wikipedia
 Communication Networks Course
Page | 10
Appendix A â€“ Linux local packet loss tool
To simulate a packet loss in a local network, we'll use a Linux tool that's called Linux Traffic
Control (ğ‘¡ğ‘). This requires a full Linux installation, so working with WSL won't work.
If the tool isn't installed in your machine, you can install it by using the following commands:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’
If the installation didn't work, you can use the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’2
To create a packet loss scenario, type the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘ğ‘‘ğ‘‘ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
After creating a packet loss scenario, you can change the percentage by typing the following
command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘â„ğ‘ğ‘›ğ‘”ğ‘’ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
To remove the packet loss scenario, write the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘‘ğ‘’ğ‘™ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š
 Communication Networks Course
Page | 11
Appendix B â€“ ğ’ğ’‚ğ’(ğŸ) system calls
This appendixâ€™s purpose is to give you a better understanding of socket handling in C.
A recommended reference is Beejâ€™s Guide to Network Programming, by Brian â€œBeej
Jorgensenâ€ Hall, which gives a lot of information about sockets in C and functions.
Functions and documentation links:
â€¢ ğ’”ğ’ğ’„ğ’Œğ’†ğ’•(ğŸ) â€“ A Factory method system call that creates a socket with the given
parameters.
â€¢ ğ’ƒğ’Šğ’ğ’…(ğŸ) â€“ Whenever we create a new socket, we need to bind it to a specific port in
our machine, â€œto catch a portâ€. The port number is managed and used by the kernel
to link incoming packets to the corresponding application socket. The port numbers
are usually fixed. The ğ‘ğ‘‘ğ‘‘ğ‘Ÿ parameter must match the current socket that is used.
â€¢ ğ’ğ’Šğ’”ğ’•ğ’†ğ’(ğŸ) â€“ The ğ‘™ğ‘–ğ‘ ğ‘¡ğ‘’ğ‘›(2) system call doesn't do anything in the mean of
communication but only memory allocation (malloc) for stream sockets only. If we
won't allocate memory, any incoming connection will fail.
â€¢ ğ’„ğ’ğ’ğ’ğ’†ğ’„ğ’•(ğŸ) â€“ The ğ‘ğ‘œğ‘›ğ‘›ğ‘’ğ‘ğ‘¡(2) system call starts the link between a client and a
specific IP address and port number. The connection would complete when the
other side will call the ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call.
â€¢ ğ’‚ğ’„ğ’„ğ’†ğ’‘ğ’•(ğŸ) â€“ The ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call accepts the incoming stream connection
request from the other side, by the listening socket. This system call completes the
three-way handshake of stream socket (like TCP) and opens a new socket that has a
direct communication channel only with the other party in the handshake.
â€¢ ğ’”ğ’†ğ’ğ’…(ğŸ) and ğ’”ğ’†ğ’ğ’…ğ’•ğ’(ğŸ) â€“ The ğ‘ ğ‘’ğ‘›ğ‘‘(2) and ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system calls are an analogy
for the ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’(2) system call, specifcly for sockets, with flags set to 0. Those system
calls return the number of bytes that were sent through the socket itself, as the
number of bytes can vary. The ğ‘ ğ‘’ğ‘›ğ‘‘(2)system call designed for stream sockets (like
TCP), while the ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system call designed for datagram connection-less
sockets (like UDP). When the ğ‘ ğ‘’ğ‘›ğ‘‘(2) system call returns 0, it means that the other
party closed the connection.
â€¢ ğ’“ğ’†ğ’„ğ’—(ğŸ) and ğ’“ğ’†ğ’„ğ’—ğ’‡ğ’“ğ’ğ’(ğŸ) â€“ The ğ‘Ÿğ‘’ğ‘ğ‘£(2) and ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system calls are an
analogy for the ğ‘Ÿğ‘’ğ‘ğ‘‘(2) system call, specifically for sockets, with flags set to 0.
Those system calls return the number of bytes that were received through the socket
itself, as the number of bytes can vary. The ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call designed for stream
sockets (like TCP), while the ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system call designed for datagram
connection-less sockets (like UDP). When the ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call returns 0, it means
that the other party closed the connection.
â€¢ ğ’„ğ’ğ’ğ’”ğ’†(ğŸ) and ğ’”ğ’‰ğ’–ğ’•ğ’…ğ’ğ’˜ğ’(ğŸ) â€“ The ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) and ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2) system calls close
the socket. While ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) system call closes the whole socket, the ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2)
system call partially closes the socket for read/write.
 Communication Networks Course
Page | 12
Appendix C â€“ Random data generator
The data that you are going to send in this assignment is randomly generated. You can use
your own file with appropriate size or use the following function (or a function of your own)
to generate the data:
/*
* @brief A random data generator function based on srand() and rand().
* @param size The size of the data to generate (up to 2^32 bytes).
* @return A pointer to the buffer.
*/
char *util_generate_random_data(unsigned int size) {
 char *buffer = NULL;
 // Argument check.
 if (size == 0)
 return NULL;
 buffer = (char *)calloc(size, sizeof(char));
 // Error checking.
 if (buffer == NULL)
 return NULL;
 // Randomize the seed of the random number generator.
 srand(time(NULL));
 for (unsigned int i = 0; i < size; i++)
 *(buffer + i) = ((unsigned int)rand() % 256);
 return buffer;
}
 Communication Networks Course
Page | 13
Appendix D â€“ Checksum function
A checksum is a small-sized block of data derived from another block of digital data for the
purpose of detecting errors that may have been introduced during its transmission or
storage. By themselves, checksums are often used to verify data integrity but are not relied
upon to verify data authenticity.
Below is a simple yet efficient implementation of the checksum function, you can use it for
the assignment, but you can implement your own checksum function.
/*
* @brief A checksum function that returns 16 bit checksum for data.
* @param data The data to do the checksum for.
* @param bytes The length of the data in bytes.
* @return The checksum itself as 16 bit unsigned number.
* @note This function is taken from RFC1071, can be found here:
* @note https://tools.ietf.org/html/rfc1071
* @note It is the simplest way to calculate a checksum and is not very strong.
* However, it is good enough for this assignment.
* @note You are free to use any other checksum function as well.
* You can also use this function as such without any change.
*/
unsigned short int calculate_checksum(void *data, unsigned int bytes) {
 unsigned short int *data_pointer = (unsigned short int *)data;
 unsigned int total_sum = 0;
 // Main summing loop
 while (bytes > 1) {
 total_sum += *data_pointer++;
 bytes -= 2;
 }
 // Add left-over byte, if any
 if (bytes > 0)
 total_sum += *((unsigned char *)data_pointer);
 // Fold 32-bit sum to 16 bits
 while (total_sum >> 16)
 total_sum = (total_sum & 0xFFFF) + (total_sum >> 16);
 return (~((unsigned short int)total_sum));
} Communication Networks Course
Page | 1
Assignment 3 â€“ Transport Layer
Assignment Notes and Instructions
This assignment is to be done in pairs only. You must upload all the necessary files in a ZIP
file named after both of the studentâ€™s ID. For example: ğŸğŸğŸ‘ğŸ’ğŸ“ğŸ”ğŸ•ğŸ–ğŸ—_ğŸ—ğŸ–ğŸ•ğŸ”ğŸ“ğŸ’ğŸ‘ğŸğŸ. ğ’›ğ’Šğ’‘.
1) The assignment must be submitted by the date specified in the submission box.
2) All the assignment files (Code, Wireshark pcap files, PDF) must be submitted in a ZIP file. The
PDF must contain all the necessary screenshots with a description for each one of them.
3) The assignment must be done in pairs only. In exceptional cases, you should send an email to
the course coordinator.
4) You can use any reference material available through the course Moodle website or any
material passed during the exercises.
5) You can use any reference from the web, but copying codes from websites is forbidden; this
includes codes from other GitHub repositories. A student who gets caught in the act will
automatically fail this assignment (score 0). Any website youâ€™ve used to solve the
assignment, every website you used to solve the assignment must be noted in the PDF.
6) No delays in submission without special permission. Lateness without approval will result in
failure of the assignment (score 0).
7) All submissions will be submitted via the course's Moodle website. Email submissions will not
be accepted, resulting in a failure in the assignment.
8) The order and design of the code must be carefully considered. Make sure that the program
output is as clear as possible, comments in the code, and meaningful variable names. You
must also submit a makefile that compiles all the programs.
9) The assignment code must be written in C only.
10) The assignment is personal for each pair, and you should not accept help from other people,
whether outside the university or inside it. You can contact the course staff during reception
hours for help or raise a question in the course forum. Do not transfer code sections
between students, upload solutions or parts of solutions to websites on the Internet or in
various communication groups.
11) Students who copy a solution will receive a 0 in all assignments in the course and a report will
be made to the institutional disciplinary committee.
12) All code files of the assignment are required to both compile and run properly on the Ubuntu
22.04 LTS operating system. This is the operating system where the submissions will be
tested. You mustnâ€™t code it in Windows, as it uses different API for sockets. WSL wonâ€™t work,
as the task needs a tool that works only in a fully Linux environment.
Good Luck!
 Communication Networks Course
Page | 2
Part A â€“ Transmission Control Protocol (TCP) â€“ 30 points
In this part, youâ€™ll write two program files: ğ‘»ğ‘ªğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and ğ‘»ğ‘ªğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
The Sender will send a randomly generated file and the Receiver will receive it and measure
the time it took for his program to receive the file. The file size should be at least 2MB.
When running the Sender and Receiver, they both should support two standard congestion
control algorithms: TCP Reno and TCP Cubic.
Notes:
â€¢ The main goal of this part is to get familiar with the TCP concept of sending
messages between two endpoints.
â€¢ For approaching this part of the assignment, please be sure that you are familiar
with the congestion control algorithms and how to change them using the correct
method in C (see Appendix B for more information).
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). You've
learned that TCP is reliable by design, so you can assume that all the data have been
passed correctly, and thus, no need to recheck.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
Usage:
â€¢ Receiver:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
â€¢ Sender:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port of the Receiver.
â€¢ ğ‘¨ğ‘³ğ‘®ğ‘¶ â€“ The TCP congestion control algorithm that will be used by the party
member (either ğ’“ğ’†ğ’ğ’ for TCP Reno or ğ’„ğ’–ğ’ƒğ’Šğ’„ for TCP Cubic).
 Communication Networks Course
Page | 3
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a TCP socket between the Sender and the
Receiver.
3) Send the file.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a TCP connection between the Receiver and
the Sender.
2) Get a connection from the sender.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./TCP_Receiver -p 1234 -algo reno
Starting Receiver...
Waiting for TCP connection...
Sender connected, beginning to receive file...
File transfer completed.
Waiting for Sender response...
Sender sent exit message.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 4
Part B â€“ Reliable User Datagram Protocol (Reliable UDP or RUDP) â€“ 40 points
Youâ€™ve learned that while TCP is reliable, it lacks speed and has an overhead data of 20 bytes,
compering to UDP that needs only 8 bytes of overhead data.
Reliable UDP or RUDP, is a protocol that uses the UDP protocol for a faster transmission of
data, while adding a reliability layer to it, but without adding too much overhead data like
TCP.
A simple sketch for a RUDP connection would look something like this:
Your task in this part is to implement a Reliable protocol using UDP only. For simplicity, your
implementation should only support a handshake, closing scheme, error checking,
acknowledgment of received packets, and retransmission of lost packets.
Guidance:
â€¢ You can use ğ‘ ğ‘’ğ‘¡ğ‘ ğ‘œğ‘ğ‘˜ğ‘œğ‘ğ‘¡(2) for detecting a timeout.
â€¢ You need to build your own protocol, as Reliable UDP isnâ€™t a standard protocol (see a
draft of RUDP in this link), and no official header is provided. You can use this sketch
for a header, but you can come up with your own protocol, as long as it works.
Where:
o ğ‘³ğ’†ğ’ğ’ˆğ’•ğ’‰ is the length of the data itself, without the RUDP header.
o ğ‘ªğ’‰ğ’†ğ’„ğ’Œğ’”ğ’–ğ’ is a 16bit number that validates the correctness of the data.
o ğ‘­ğ’ğ’‚ğ’ˆğ’” is a special byte where we classify the packet itself (SYN, ACK, etc.).
â€¢ In your PDF, you must explain how your implementation of RUDP works â€“ How does
it detect a timeout to do retransmissions, how does the handshake work, what is the
header overhead, etc.
â€¢ For this part, youâ€™ll write three files: ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¨ğ‘·ğ‘°. ğ’„, ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and
ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
Reliable UDP Header proposed sketch
Byte 0 Byte 1 Byte 2 Byte 3
Length (2 Bytes) Checksum (2 Bytes)
Flags (1 Byte)
Figure 1 - RUDP Protocol Architecture, Geeksforgeeks
 Communication Networks Course
Page | 5
Notes:
â€¢ The Sender will send a random generated file and the Receiver will receive it and
measure the time it took for his program to receive the file. The file size should be at
least 2MB.
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). But, as the
RUDP is based on UDP, itâ€™s not reliable. You must use some form of error checking
(like checksum) to ensure that the packet wasnâ€™t alerted during the transfer.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
â€¢ The RUDP needs support only 1 sender and 1 receiver, for simplicity purposes.
Usage:
â€¢ Receiver:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
â€¢ Sender:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port that both the Sender and the Receiver will use.
The ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„ file will contain all the implementations of the RUDP API functions (That is, to
prevent reusing the same chuck of code both in the Sender and the Receiver.).
The API should support at the bare minimum the following functions (you decide what
parameters to implement, and what are the names of the functions, as long as the API is
explained in the PDF):
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘œğ‘ğ‘˜ğ‘’ğ‘¡() â€“ Creating a RUDP socket and creating a handshake between two
peers.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘’ğ‘›ğ‘‘() â€“ Sending data to the peer. The function should wait for an
acknowledgment packet, and if it didnâ€™t receive any, retransmits the data.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘Ÿğ‘’ğ‘ğ‘£() â€“ Receive data from a peer.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ğ‘™ğ‘œğ‘ ğ‘’() â€“ Closes a connection between peers.
 Communication Networks Course
Page | 6
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a UDP socket between the Sender and the
Receiver.
3) Send the file via the RUDP protocol.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a UDP connection between the Receiver and
the Sender.
2) Get a connection from the sender, by the custom
RUDP protocol youâ€™ve built.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./RUDP_Receiver -p 1234
Starting Receiver...
Waiting for RUDP connection...
Connection request received, sending ACK.
Sender connected, beginning to receive file...
File transfer completed.
ACK sent.
Waiting for Sender response...
Sender sent exit message.
ACK sent.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 7
Part C â€“ Research â€“ 30 points
In this part, youâ€™ll conduct research about your implementations of part A and part B.
In the research itself, each one of the versions (TCP version and UDP version) will be run at
least 5 times (meaning that the file transfer will occur at least 5 times) by the following
conditions:
â€¢ For TCP, youâ€™ll run it in TCP Reno and TCP Cubic, alternating each time, for each
scenario, meaning that you run 5 times with TCP Reno in both Sender and Receiver,
and 5 times with TCP Cubic in both Sender and Receiver.
Bonus (5 points): Create a very large data set â€“ 5 times with TCP Reno in both Sender
and Receiver, 5 times with TCP Reno in Sender and TCP Cubic in Receiver, 5 times
with TCP Cubic in Sender and TCP Reno in Receiver, and 5 times with TCP Cubic in
both Sender and Receiver. This will give you a data set large enough, which allows
you to work with, compare with and to reach a definite conclusion.
â€¢ For RUDP, you will run it 5 times for each scenario.
â€¢ For both TCP and RUDP, you will run them on those scenarios of packet loss:
o 0% packet loss â€“ Control group, simulating perfect connection.
o 2% packet loss â€“ Simulating unstable connection that commonly occur.
o 5% packet loss â€“ Simulating bad connection.
o 10% packet loss â€“ Simulating extremely poor connection.
For each scenario, you must provide a filtered PCAP file and relevant screenshots that
explain each one of the steps in the process. (10 points)
After youâ€™ve gathered the data set for both TCP and Reliable UDP, answer the following
questions:
1) In TCP, which congestion control algorithm gave better results overall? TCP Reno or
TCP Cubic? Which one gave better results on high packet loss? Explain how you came
to this conclusion based on the data set youâ€™ve gathered. (5 points)
2) How did your implementation of Reliable UDP perform overall compared to regular
TCP? Which one is better for high packet loss? (5 points)
3) According to the data youâ€™ve gathered, in which scenarios and applications would we
prefer to use TCP and in which situations would we prefer to use reliable UDP?
Explain your answer. (5 points)
 Communication Networks Course
Page | 8
×¢× ×• ×¢×œ ×”×©××œ×•×ª ×”×‘××•×ª )5 × ×§×•×“×•×ª(:
â— ×‘"×¨×©×ª ×××™× ×”" ×”×›×•×•× ×” ×”×™× ×œ×¨×©×ª ×©×‘×” ××¢×˜ ×××•×“ ×—×‘×™×œ×•×ª ×”×•×œ×›×•×ª ×œ××™×‘×•×“. ×‘"×§×©×¨ ××¨×•×š" ×”×›×•×•× ×” ×”×™×
×œ×§×©×¨ TCP ×©×™×© ×‘×• ×”×¨×‘×” ×××•×“ ××™×“×¢ ×œ×©×œ×•×—. ××•×¦×¢ ×œ×”×’×“×™×œ ×‘ -TCP ××ª SSThreshold ×‘×ª×—×™×œ×ª ×”×§×©×¨.
×‘××™×–×” ××”××§×¨×™× ×”×‘××™× ×”×©×™× ×•×™ ×”×–×” ×¢×©×•×™ ×œ×”×•×¢×™×œ ×‘××™×“×” ×”××™×¨×‘×™×ª? × ××§.
.1 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
.2 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.3 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.4 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.5 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.6 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.7 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.8 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
â— A ×©×•×œ×— ×œ -B ×—×‘×™×œ×•×ª ××™×“×¢ ×‘×××¦×¢×•×ª ×§×©×¨ TCP. × ×ª×•×Ÿ ×›×™ ×”×§×©×¨ ××ª×—×™×œ ×¢× ×—×œ×•×Ÿ ×‘×’×•×“×œ 1MSS. ×”×§×©×¨
××¡×ª×™×™× ×‘×¤×¢× ×”×¨××©×•× ×” ×©×”×•× ××’×™×¢ ×œ -SSthresh. ×‘××”×œ×š ×”×§×©×¨ ×œ× ××•×‘×“×•×ª ×—×‘×™×œ×•×ª. × ×¡××Ÿ ×‘×§×™×¦×•×¨:
.SSthresh=S*MSS
× ×ª×•×Ÿ ×›×™ ×œ××•×¨×š ×›×œ ×”×§×©×¨ rwnd < MSS*S.
××”×™ ×”×ª×¤×•×§×” ×©×œ ×”×§×©×¨ ×-A ×œ-B( ×‘ -sec / Bytes )×‘×–××Ÿ ×”× "×œ? × ××§×™.
]S*MSS / [lg (S) * RTT*2 ×‘×¢×¨×š .1
]S*MSS / [S^0.5 * RTT*2 ×‘×¢×¨×š .2
S*MSS / RTT ×‘×¢×¨×š .3
S^2)*MSS / RTT( ×‘×¢×¨×š .4
â— ×©×ª×™ ×ª×—× ×•×ª ××ª×§×©×¨×•×ª ×‘××•×¤×Ÿ ××œ×—×•×˜×™ ×‘×©×™×˜×ª N Back Go.
× ×¡××Ÿ ×‘-X ××ª ×¡×¤×¨×ª ×”×‘×™×§×•×¨×ª ×©×œ ×”×ª.×–. ×©×œ×š. ×× ×©× ×™ ×©×•×ª×¤×™× ××’×™×©×™× ××ª ×”×ª×¨×’×™×œ ×™×—×“, X ×”×•× ×¡×¤×¨×ª
×”×‘×™×§×•×¨×ª ×‘×¢×œ×ª ×”×¢×¨×š ×”× ××•×š ×™×•×ª×¨ ××‘×™×Ÿ ×”×©×ª×™×™×.
×§×¦×‘ ×”×ª×§×©×•×¨×ª ×”×•× 8Gbps, ×•×’×•×“×œ ×›×œ ×—×‘×™×œ×” ×”×•× KByte*X. ×’×“×œ×™ ×”-headers ×•×” -Acks ×–× ×™×—×™×.
ï¿½ğ‘’ğ‘ ï¿½/ï¿½ï¿½ 8 , ×•×”××¨×—×§ ×‘×™×Ÿ ×”×ª×—× ×•×ª ×”×•× 1Km. ×§×¦×‘ ×”×”×ª×¤×©×˜×•×ª ×”×•× 10 â‹… 2
×–××Ÿ ×¢×™×‘×•×“ ×”× ×ª×•× ×™× ×‘×ª×—× ×•×ª ×–× ×™×—.
××£ ×—×‘×™×œ×” ×•××£ Ack ×œ× ×”×•×œ×›×™× ×œ××™×‘×•×“.
â— ××”×• X ×©×œ×š?
â— ××” ×¦×¨×™×š ×œ×”×™×•×ª ×’×•×“×œ ×—×œ×•×Ÿ ×”××©×œ×•×— ×›×“×™ ×œ×”×‘×˜×™×— ×ª×¤×•×§×” ××§×¡×™××œ×™×ª?
 Communication Networks Course
Page | 9
Bonus â€“ Improving the Reliable UDP â€“ 15 points
Note: This part isnâ€™t mandatory and is a bonus only!
In this part, youâ€™ll improve your RUDP implementation by adding the concepts of flow
control and congestion control from TCP. Youâ€™re free to choose which algorithms to
implement, as long as you explain in your PDF which algorithms youâ€™ve used. Youâ€™ll probably
need to make changes in the original design of the RUDP. Changes only need to be to the API
itself, ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„.
Points distribution:
â€¢ Flow control improvement â€“ 7 Points
â€¢ Congestion control improvement â€“ 8 points.
Guidance:
â€¢ For flow control, you must use one of the Sliding window techniques: stop-and-wait
ARQ, Go-Back-N or Selective repeat.
â€¢ List of known TCP congestion control algorithms, which you can use any one of them
for this bonus task, or makeup your own:
Figure 2 â€“ List of known TCP congestion control algorithms, Wikipedia
 Communication Networks Course
Page | 10
Appendix A â€“ Linux local packet loss tool
To simulate a packet loss in a local network, we'll use a Linux tool that's called Linux Traffic
Control (ğ‘¡ğ‘). This requires a full Linux installation, so working with WSL won't work.
If the tool isn't installed in your machine, you can install it by using the following commands:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’
If the installation didn't work, you can use the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’2
To create a packet loss scenario, type the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘ğ‘‘ğ‘‘ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
After creating a packet loss scenario, you can change the percentage by typing the following
command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘â„ğ‘ğ‘›ğ‘”ğ‘’ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
To remove the packet loss scenario, write the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘‘ğ‘’ğ‘™ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š
 Communication Networks Course
Page | 11
Appendix B â€“ ğ’ğ’‚ğ’(ğŸ) system calls
This appendixâ€™s purpose is to give you a better understanding of socket handling in C.
A recommended reference is Beejâ€™s Guide to Network Programming, by Brian â€œBeej
Jorgensenâ€ Hall, which gives a lot of information about sockets in C and functions.
Functions and documentation links:
â€¢ ğ’”ğ’ğ’„ğ’Œğ’†ğ’•(ğŸ) â€“ A Factory method system call that creates a socket with the given
parameters.
â€¢ ğ’ƒğ’Šğ’ğ’…(ğŸ) â€“ Whenever we create a new socket, we need to bind it to a specific port in
our machine, â€œto catch a portâ€. The port number is managed and used by the kernel
to link incoming packets to the corresponding application socket. The port numbers
are usually fixed. The ğ‘ğ‘‘ğ‘‘ğ‘Ÿ parameter must match the current socket that is used.
â€¢ ğ’ğ’Šğ’”ğ’•ğ’†ğ’(ğŸ) â€“ The ğ‘™ğ‘–ğ‘ ğ‘¡ğ‘’ğ‘›(2) system call doesn't do anything in the mean of
communication but only memory allocation (malloc) for stream sockets only. If we
won't allocate memory, any incoming connection will fail.
â€¢ ğ’„ğ’ğ’ğ’ğ’†ğ’„ğ’•(ğŸ) â€“ The ğ‘ğ‘œğ‘›ğ‘›ğ‘’ğ‘ğ‘¡(2) system call starts the link between a client and a
specific IP address and port number. The connection would complete when the
other side will call the ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call.
â€¢ ğ’‚ğ’„ğ’„ğ’†ğ’‘ğ’•(ğŸ) â€“ The ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call accepts the incoming stream connection
request from the other side, by the listening socket. This system call completes the
three-way handshake of stream socket (like TCP) and opens a new socket that has a
direct communication channel only with the other party in the handshake.
â€¢ ğ’”ğ’†ğ’ğ’…(ğŸ) and ğ’”ğ’†ğ’ğ’…ğ’•ğ’(ğŸ) â€“ The ğ‘ ğ‘’ğ‘›ğ‘‘(2) and ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system calls are an analogy
for the ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’(2) system call, specifcly for sockets, with flags set to 0. Those system
calls return the number of bytes that were sent through the socket itself, as the
number of bytes can vary. The ğ‘ ğ‘’ğ‘›ğ‘‘(2)system call designed for stream sockets (like
TCP), while the ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system call designed for datagram connection-less
sockets (like UDP). When the ğ‘ ğ‘’ğ‘›ğ‘‘(2) system call returns 0, it means that the other
party closed the connection.
â€¢ ğ’“ğ’†ğ’„ğ’—(ğŸ) and ğ’“ğ’†ğ’„ğ’—ğ’‡ğ’“ğ’ğ’(ğŸ) â€“ The ğ‘Ÿğ‘’ğ‘ğ‘£(2) and ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system calls are an
analogy for the ğ‘Ÿğ‘’ğ‘ğ‘‘(2) system call, specifically for sockets, with flags set to 0.
Those system calls return the number of bytes that were received through the socket
itself, as the number of bytes can vary. The ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call designed for stream
sockets (like TCP), while the ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system call designed for datagram
connection-less sockets (like UDP). When the ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call returns 0, it means
that the other party closed the connection.
â€¢ ğ’„ğ’ğ’ğ’”ğ’†(ğŸ) and ğ’”ğ’‰ğ’–ğ’•ğ’…ğ’ğ’˜ğ’(ğŸ) â€“ The ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) and ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2) system calls close
the socket. While ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) system call closes the whole socket, the ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2)
system call partially closes the socket for read/write.
 Communication Networks Course
Page | 12
Appendix C â€“ Random data generator
The data that you are going to send in this assignment is randomly generated. You can use
your own file with appropriate size or use the following function (or a function of your own)
to generate the data:
/*
* @brief A random data generator function based on srand() and rand().
* @param size The size of the data to generate (up to 2^32 bytes).
* @return A pointer to the buffer.
*/
char *util_generate_random_data(unsigned int size) {
 char *buffer = NULL;
 // Argument check.
 if (size == 0)
 return NULL;
 buffer = (char *)calloc(size, sizeof(char));
 // Error checking.
 if (buffer == NULL)
 return NULL;
 // Randomize the seed of the random number generator.
 srand(time(NULL));
 for (unsigned int i = 0; i < size; i++)
 *(buffer + i) = ((unsigned int)rand() % 256);
 return buffer;
}
 Communication Networks Course
Page | 13
Appendix D â€“ Checksum function
A checksum is a small-sized block of data derived from another block of digital data for the
purpose of detecting errors that may have been introduced during its transmission or
storage. By themselves, checksums are often used to verify data integrity but are not relied
upon to verify data authenticity.
Below is a simple yet efficient implementation of the checksum function, you can use it for
the assignment, but you can implement your own checksum function.
/*
* @brief A checksum function that returns 16 bit checksum for data.
* @param data The data to do the checksum for.
* @param bytes The length of the data in bytes.
* @return The checksum itself as 16 bit unsigned number.
* @note This function is taken from RFC1071, can be found here:
* @note https://tools.ietf.org/html/rfc1071
* @note It is the simplest way to calculate a checksum and is not very strong.
* However, it is good enough for this assignment.
* @note You are free to use any other checksum function as well.
* You can also use this function as such without any change.
*/
unsigned short int calculate_checksum(void *data, unsigned int bytes) {
 unsigned short int *data_pointer = (unsigned short int *)data;
 unsigned int total_sum = 0;
 // Main summing loop
 while (bytes > 1) {
 total_sum += *data_pointer++;
 bytes -= 2;
 }
 // Add left-over byte, if any
 if (bytes > 0)
 total_sum += *((unsigned char *)data_pointer);
 // Fold 32-bit sum to 16 bits
 while (total_sum >> 16)
 total_sum = (total_sum & 0xFFFF) + (total_sum >> 16);
 return (~((unsigned short int)total_sum));
} Communication Networks Course
Page | 1
Assignment 3 â€“ Transport Layer
Assignment Notes and Instructions
This assignment is to be done in pairs only. You must upload all the necessary files in a ZIP
file named after both of the studentâ€™s ID. For example: ğŸğŸğŸ‘ğŸ’ğŸ“ğŸ”ğŸ•ğŸ–ğŸ—_ğŸ—ğŸ–ğŸ•ğŸ”ğŸ“ğŸ’ğŸ‘ğŸğŸ. ğ’›ğ’Šğ’‘.
1) The assignment must be submitted by the date specified in the submission box.
2) All the assignment files (Code, Wireshark pcap files, PDF) must be submitted in a ZIP file. The
PDF must contain all the necessary screenshots with a description for each one of them.
3) The assignment must be done in pairs only. In exceptional cases, you should send an email to
the course coordinator.
4) You can use any reference material available through the course Moodle website or any
material passed during the exercises.
5) You can use any reference from the web, but copying codes from websites is forbidden; this
includes codes from other GitHub repositories. A student who gets caught in the act will
automatically fail this assignment (score 0). Any website youâ€™ve used to solve the
assignment, every website you used to solve the assignment must be noted in the PDF.
6) No delays in submission without special permission. Lateness without approval will result in
failure of the assignment (score 0).
7) All submissions will be submitted via the course's Moodle website. Email submissions will not
be accepted, resulting in a failure in the assignment.
8) The order and design of the code must be carefully considered. Make sure that the program
output is as clear as possible, comments in the code, and meaningful variable names. You
must also submit a makefile that compiles all the programs.
9) The assignment code must be written in C only.
10) The assignment is personal for each pair, and you should not accept help from other people,
whether outside the university or inside it. You can contact the course staff during reception
hours for help or raise a question in the course forum. Do not transfer code sections
between students, upload solutions or parts of solutions to websites on the Internet or in
various communication groups.
11) Students who copy a solution will receive a 0 in all assignments in the course and a report will
be made to the institutional disciplinary committee.
12) All code files of the assignment are required to both compile and run properly on the Ubuntu
22.04 LTS operating system. This is the operating system where the submissions will be
tested. You mustnâ€™t code it in Windows, as it uses different API for sockets. WSL wonâ€™t work,
as the task needs a tool that works only in a fully Linux environment.
Good Luck!
 Communication Networks Course
Page | 2
Part A â€“ Transmission Control Protocol (TCP) â€“ 30 points
In this part, youâ€™ll write two program files: ğ‘»ğ‘ªğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and ğ‘»ğ‘ªğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
The Sender will send a randomly generated file and the Receiver will receive it and measure
the time it took for his program to receive the file. The file size should be at least 2MB.
When running the Sender and Receiver, they both should support two standard congestion
control algorithms: TCP Reno and TCP Cubic.
Notes:
â€¢ The main goal of this part is to get familiar with the TCP concept of sending
messages between two endpoints.
â€¢ For approaching this part of the assignment, please be sure that you are familiar
with the congestion control algorithms and how to change them using the correct
method in C (see Appendix B for more information).
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). You've
learned that TCP is reliable by design, so you can assume that all the data have been
passed correctly, and thus, no need to recheck.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
Usage:
â€¢ Receiver:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
â€¢ Sender:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port of the Receiver.
â€¢ ğ‘¨ğ‘³ğ‘®ğ‘¶ â€“ The TCP congestion control algorithm that will be used by the party
member (either ğ’“ğ’†ğ’ğ’ for TCP Reno or ğ’„ğ’–ğ’ƒğ’Šğ’„ for TCP Cubic).
 Communication Networks Course
Page | 3
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a TCP socket between the Sender and the
Receiver.
3) Send the file.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a TCP connection between the Receiver and
the Sender.
2) Get a connection from the sender.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./TCP_Receiver -p 1234 -algo reno
Starting Receiver...
Waiting for TCP connection...
Sender connected, beginning to receive file...
File transfer completed.
Waiting for Sender response...
Sender sent exit message.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 4
Part B â€“ Reliable User Datagram Protocol (Reliable UDP or RUDP) â€“ 40 points
Youâ€™ve learned that while TCP is reliable, it lacks speed and has an overhead data of 20 bytes,
compering to UDP that needs only 8 bytes of overhead data.
Reliable UDP or RUDP, is a protocol that uses the UDP protocol for a faster transmission of
data, while adding a reliability layer to it, but without adding too much overhead data like
TCP.
A simple sketch for a RUDP connection would look something like this:
Your task in this part is to implement a Reliable protocol using UDP only. For simplicity, your
implementation should only support a handshake, closing scheme, error checking,
acknowledgment of received packets, and retransmission of lost packets.
Guidance:
â€¢ You can use ğ‘ ğ‘’ğ‘¡ğ‘ ğ‘œğ‘ğ‘˜ğ‘œğ‘ğ‘¡(2) for detecting a timeout.
â€¢ You need to build your own protocol, as Reliable UDP isnâ€™t a standard protocol (see a
draft of RUDP in this link), and no official header is provided. You can use this sketch
for a header, but you can come up with your own protocol, as long as it works.
Where:
o ğ‘³ğ’†ğ’ğ’ˆğ’•ğ’‰ is the length of the data itself, without the RUDP header.
o ğ‘ªğ’‰ğ’†ğ’„ğ’Œğ’”ğ’–ğ’ is a 16bit number that validates the correctness of the data.
o ğ‘­ğ’ğ’‚ğ’ˆğ’” is a special byte where we classify the packet itself (SYN, ACK, etc.).
â€¢ In your PDF, you must explain how your implementation of RUDP works â€“ How does
it detect a timeout to do retransmissions, how does the handshake work, what is the
header overhead, etc.
â€¢ For this part, youâ€™ll write three files: ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¨ğ‘·ğ‘°. ğ’„, ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and
ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
Reliable UDP Header proposed sketch
Byte 0 Byte 1 Byte 2 Byte 3
Length (2 Bytes) Checksum (2 Bytes)
Flags (1 Byte)
Figure 1 - RUDP Protocol Architecture, Geeksforgeeks
 Communication Networks Course
Page | 5
Notes:
â€¢ The Sender will send a random generated file and the Receiver will receive it and
measure the time it took for his program to receive the file. The file size should be at
least 2MB.
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). But, as the
RUDP is based on UDP, itâ€™s not reliable. You must use some form of error checking
(like checksum) to ensure that the packet wasnâ€™t alerted during the transfer.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
â€¢ The RUDP needs support only 1 sender and 1 receiver, for simplicity purposes.
Usage:
â€¢ Receiver:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
â€¢ Sender:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port that both the Sender and the Receiver will use.
The ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„ file will contain all the implementations of the RUDP API functions (That is, to
prevent reusing the same chuck of code both in the Sender and the Receiver.).
The API should support at the bare minimum the following functions (you decide what
parameters to implement, and what are the names of the functions, as long as the API is
explained in the PDF):
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘œğ‘ğ‘˜ğ‘’ğ‘¡() â€“ Creating a RUDP socket and creating a handshake between two
peers.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘’ğ‘›ğ‘‘() â€“ Sending data to the peer. The function should wait for an
acknowledgment packet, and if it didnâ€™t receive any, retransmits the data.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘Ÿğ‘’ğ‘ğ‘£() â€“ Receive data from a peer.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ğ‘™ğ‘œğ‘ ğ‘’() â€“ Closes a connection between peers.
 Communication Networks Course
Page | 6
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a UDP socket between the Sender and the
Receiver.
3) Send the file via the RUDP protocol.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a UDP connection between the Receiver and
the Sender.
2) Get a connection from the sender, by the custom
RUDP protocol youâ€™ve built.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./RUDP_Receiver -p 1234
Starting Receiver...
Waiting for RUDP connection...
Connection request received, sending ACK.
Sender connected, beginning to receive file...
File transfer completed.
ACK sent.
Waiting for Sender response...
Sender sent exit message.
ACK sent.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 7
Part C â€“ Research â€“ 30 points
In this part, youâ€™ll conduct research about your implementations of part A and part B.
In the research itself, each one of the versions (TCP version and UDP version) will be run at
least 5 times (meaning that the file transfer will occur at least 5 times) by the following
conditions:
â€¢ For TCP, youâ€™ll run it in TCP Reno and TCP Cubic, alternating each time, for each
scenario, meaning that you run 5 times with TCP Reno in both Sender and Receiver,
and 5 times with TCP Cubic in both Sender and Receiver.
Bonus (5 points): Create a very large data set â€“ 5 times with TCP Reno in both Sender
and Receiver, 5 times with TCP Reno in Sender and TCP Cubic in Receiver, 5 times
with TCP Cubic in Sender and TCP Reno in Receiver, and 5 times with TCP Cubic in
both Sender and Receiver. This will give you a data set large enough, which allows
you to work with, compare with and to reach a definite conclusion.
â€¢ For RUDP, you will run it 5 times for each scenario.
â€¢ For both TCP and RUDP, you will run them on those scenarios of packet loss:
o 0% packet loss â€“ Control group, simulating perfect connection.
o 2% packet loss â€“ Simulating unstable connection that commonly occur.
o 5% packet loss â€“ Simulating bad connection.
o 10% packet loss â€“ Simulating extremely poor connection.
For each scenario, you must provide a filtered PCAP file and relevant screenshots that
explain each one of the steps in the process. (10 points)
After youâ€™ve gathered the data set for both TCP and Reliable UDP, answer the following
questions:
1) In TCP, which congestion control algorithm gave better results overall? TCP Reno or
TCP Cubic? Which one gave better results on high packet loss? Explain how you came
to this conclusion based on the data set youâ€™ve gathered. (5 points)
2) How did your implementation of Reliable UDP perform overall compared to regular
TCP? Which one is better for high packet loss? (5 points)
3) According to the data youâ€™ve gathered, in which scenarios and applications would we
prefer to use TCP and in which situations would we prefer to use reliable UDP?
Explain your answer. (5 points)
 Communication Networks Course
Page | 8
×¢× ×• ×¢×œ ×”×©××œ×•×ª ×”×‘××•×ª )5 × ×§×•×“×•×ª(:
â— ×‘"×¨×©×ª ×××™× ×”" ×”×›×•×•× ×” ×”×™× ×œ×¨×©×ª ×©×‘×” ××¢×˜ ×××•×“ ×—×‘×™×œ×•×ª ×”×•×œ×›×•×ª ×œ××™×‘×•×“. ×‘"×§×©×¨ ××¨×•×š" ×”×›×•×•× ×” ×”×™×
×œ×§×©×¨ TCP ×©×™×© ×‘×• ×”×¨×‘×” ×××•×“ ××™×“×¢ ×œ×©×œ×•×—. ××•×¦×¢ ×œ×”×’×“×™×œ ×‘ -TCP ××ª SSThreshold ×‘×ª×—×™×œ×ª ×”×§×©×¨.
×‘××™×–×” ××”××§×¨×™× ×”×‘××™× ×”×©×™× ×•×™ ×”×–×” ×¢×©×•×™ ×œ×”×•×¢×™×œ ×‘××™×“×” ×”××™×¨×‘×™×ª? × ××§.
.1 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
.2 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.3 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.4 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.5 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.6 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.7 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.8 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
â— A ×©×•×œ×— ×œ -B ×—×‘×™×œ×•×ª ××™×“×¢ ×‘×××¦×¢×•×ª ×§×©×¨ TCP. × ×ª×•×Ÿ ×›×™ ×”×§×©×¨ ××ª×—×™×œ ×¢× ×—×œ×•×Ÿ ×‘×’×•×“×œ 1MSS. ×”×§×©×¨
××¡×ª×™×™× ×‘×¤×¢× ×”×¨××©×•× ×” ×©×”×•× ××’×™×¢ ×œ -SSthresh. ×‘××”×œ×š ×”×§×©×¨ ×œ× ××•×‘×“×•×ª ×—×‘×™×œ×•×ª. × ×¡××Ÿ ×‘×§×™×¦×•×¨:
.SSthresh=S*MSS
× ×ª×•×Ÿ ×›×™ ×œ××•×¨×š ×›×œ ×”×§×©×¨ rwnd < MSS*S.
××”×™ ×”×ª×¤×•×§×” ×©×œ ×”×§×©×¨ ×-A ×œ-B( ×‘ -sec / Bytes )×‘×–××Ÿ ×”× "×œ? × ××§×™.
]S*MSS / [lg (S) * RTT*2 ×‘×¢×¨×š .1
]S*MSS / [S^0.5 * RTT*2 ×‘×¢×¨×š .2
S*MSS / RTT ×‘×¢×¨×š .3
S^2)*MSS / RTT( ×‘×¢×¨×š .4
â— ×©×ª×™ ×ª×—× ×•×ª ××ª×§×©×¨×•×ª ×‘××•×¤×Ÿ ××œ×—×•×˜×™ ×‘×©×™×˜×ª N Back Go.
× ×¡××Ÿ ×‘-X ××ª ×¡×¤×¨×ª ×”×‘×™×§×•×¨×ª ×©×œ ×”×ª.×–. ×©×œ×š. ×× ×©× ×™ ×©×•×ª×¤×™× ××’×™×©×™× ××ª ×”×ª×¨×’×™×œ ×™×—×“, X ×”×•× ×¡×¤×¨×ª
×”×‘×™×§×•×¨×ª ×‘×¢×œ×ª ×”×¢×¨×š ×”× ××•×š ×™×•×ª×¨ ××‘×™×Ÿ ×”×©×ª×™×™×.
×§×¦×‘ ×”×ª×§×©×•×¨×ª ×”×•× 8Gbps, ×•×’×•×“×œ ×›×œ ×—×‘×™×œ×” ×”×•× KByte*X. ×’×“×œ×™ ×”-headers ×•×” -Acks ×–× ×™×—×™×.
ï¿½ğ‘’ğ‘ ï¿½/ï¿½ï¿½ 8 , ×•×”××¨×—×§ ×‘×™×Ÿ ×”×ª×—× ×•×ª ×”×•× 1Km. ×§×¦×‘ ×”×”×ª×¤×©×˜×•×ª ×”×•× 10 â‹… 2
×–××Ÿ ×¢×™×‘×•×“ ×”× ×ª×•× ×™× ×‘×ª×—× ×•×ª ×–× ×™×—.
××£ ×—×‘×™×œ×” ×•××£ Ack ×œ× ×”×•×œ×›×™× ×œ××™×‘×•×“.
â— ××”×• X ×©×œ×š?
â— ××” ×¦×¨×™×š ×œ×”×™×•×ª ×’×•×“×œ ×—×œ×•×Ÿ ×”××©×œ×•×— ×›×“×™ ×œ×”×‘×˜×™×— ×ª×¤×•×§×” ××§×¡×™××œ×™×ª?
 Communication Networks Course
Page | 9
Bonus â€“ Improving the Reliable UDP â€“ 15 points
Note: This part isnâ€™t mandatory and is a bonus only!
In this part, youâ€™ll improve your RUDP implementation by adding the concepts of flow
control and congestion control from TCP. Youâ€™re free to choose which algorithms to
implement, as long as you explain in your PDF which algorithms youâ€™ve used. Youâ€™ll probably
need to make changes in the original design of the RUDP. Changes only need to be to the API
itself, ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„.
Points distribution:
â€¢ Flow control improvement â€“ 7 Points
â€¢ Congestion control improvement â€“ 8 points.
Guidance:
â€¢ For flow control, you must use one of the Sliding window techniques: stop-and-wait
ARQ, Go-Back-N or Selective repeat.
â€¢ List of known TCP congestion control algorithms, which you can use any one of them
for this bonus task, or makeup your own:
Figure 2 â€“ List of known TCP congestion control algorithms, Wikipedia
 Communication Networks Course
Page | 10
Appendix A â€“ Linux local packet loss tool
To simulate a packet loss in a local network, we'll use a Linux tool that's called Linux Traffic
Control (ğ‘¡ğ‘). This requires a full Linux installation, so working with WSL won't work.
If the tool isn't installed in your machine, you can install it by using the following commands:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’
If the installation didn't work, you can use the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’2
To create a packet loss scenario, type the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘ğ‘‘ğ‘‘ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
After creating a packet loss scenario, you can change the percentage by typing the following
command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘â„ğ‘ğ‘›ğ‘”ğ‘’ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
To remove the packet loss scenario, write the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘‘ğ‘’ğ‘™ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š
 Communication Networks Course
Page | 11
Appendix B â€“ ğ’ğ’‚ğ’(ğŸ) system calls
This appendixâ€™s purpose is to give you a better understanding of socket handling in C.
A recommended reference is Beejâ€™s Guide to Network Programming, by Brian â€œBeej
Jorgensenâ€ Hall, which gives a lot of information about sockets in C and functions.
Functions and documentation links:
â€¢ ğ’”ğ’ğ’„ğ’Œğ’†ğ’•(ğŸ) â€“ A Factory method system call that creates a socket with the given
parameters.
â€¢ ğ’ƒğ’Šğ’ğ’…(ğŸ) â€“ Whenever we create a new socket, we need to bind it to a specific port in
our machine, â€œto catch a portâ€. The port number is managed and used by the kernel
to link incoming packets to the corresponding application socket. The port numbers
are usually fixed. The ğ‘ğ‘‘ğ‘‘ğ‘Ÿ parameter must match the current socket that is used.
â€¢ ğ’ğ’Šğ’”ğ’•ğ’†ğ’(ğŸ) â€“ The ğ‘™ğ‘–ğ‘ ğ‘¡ğ‘’ğ‘›(2) system call doesn't do anything in the mean of
communication but only memory allocation (malloc) for stream sockets only. If we
won't allocate memory, any incoming connection will fail.
â€¢ ğ’„ğ’ğ’ğ’ğ’†ğ’„ğ’•(ğŸ) â€“ The ğ‘ğ‘œğ‘›ğ‘›ğ‘’ğ‘ğ‘¡(2) system call starts the link between a client and a
specific IP address and port number. The connection would complete when the
other side will call the ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call.
â€¢ ğ’‚ğ’„ğ’„ğ’†ğ’‘ğ’•(ğŸ) â€“ The ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call accepts the incoming stream connection
request from the other side, by the listening socket. This system call completes the
three-way handshake of stream socket (like TCP) and opens a new socket that has a
direct communication channel only with the other party in the handshake.
â€¢ ğ’”ğ’†ğ’ğ’…(ğŸ) and ğ’”ğ’†ğ’ğ’…ğ’•ğ’(ğŸ) â€“ The ğ‘ ğ‘’ğ‘›ğ‘‘(2) and ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system calls are an analogy
for the ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’(2) system call, specifcly for sockets, with flags set to 0. Those system
calls return the number of bytes that were sent through the socket itself, as the
number of bytes can vary. The ğ‘ ğ‘’ğ‘›ğ‘‘(2)system call designed for stream sockets (like
TCP), while the ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system call designed for datagram connection-less
sockets (like UDP). When the ğ‘ ğ‘’ğ‘›ğ‘‘(2) system call returns 0, it means that the other
party closed the connection.
â€¢ ğ’“ğ’†ğ’„ğ’—(ğŸ) and ğ’“ğ’†ğ’„ğ’—ğ’‡ğ’“ğ’ğ’(ğŸ) â€“ The ğ‘Ÿğ‘’ğ‘ğ‘£(2) and ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system calls are an
analogy for the ğ‘Ÿğ‘’ğ‘ğ‘‘(2) system call, specifically for sockets, with flags set to 0.
Those system calls return the number of bytes that were received through the socket
itself, as the number of bytes can vary. The ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call designed for stream
sockets (like TCP), while the ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system call designed for datagram
connection-less sockets (like UDP). When the ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call returns 0, it means
that the other party closed the connection.
â€¢ ğ’„ğ’ğ’ğ’”ğ’†(ğŸ) and ğ’”ğ’‰ğ’–ğ’•ğ’…ğ’ğ’˜ğ’(ğŸ) â€“ The ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) and ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2) system calls close
the socket. While ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) system call closes the whole socket, the ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2)
system call partially closes the socket for read/write.
 Communication Networks Course
Page | 12
Appendix C â€“ Random data generator
The data that you are going to send in this assignment is randomly generated. You can use
your own file with appropriate size or use the following function (or a function of your own)
to generate the data:
/*
* @brief A random data generator function based on srand() and rand().
* @param size The size of the data to generate (up to 2^32 bytes).
* @return A pointer to the buffer.
*/
char *util_generate_random_data(unsigned int size) {
 char *buffer = NULL;
 // Argument check.
 if (size == 0)
 return NULL;
 buffer = (char *)calloc(size, sizeof(char));
 // Error checking.
 if (buffer == NULL)
 return NULL;
 // Randomize the seed of the random number generator.
 srand(time(NULL));
 for (unsigned int i = 0; i < size; i++)
 *(buffer + i) = ((unsigned int)rand() % 256);
 return buffer;
}
 Communication Networks Course
Page | 13
Appendix D â€“ Checksum function
A checksum is a small-sized block of data derived from another block of digital data for the
purpose of detecting errors that may have been introduced during its transmission or
storage. By themselves, checksums are often used to verify data integrity but are not relied
upon to verify data authenticity.
Below is a simple yet efficient implementation of the checksum function, you can use it for
the assignment, but you can implement your own checksum function.
/*
* @brief A checksum function that returns 16 bit checksum for data.
* @param data The data to do the checksum for.
* @param bytes The length of the data in bytes.
* @return The checksum itself as 16 bit unsigned number.
* @note This function is taken from RFC1071, can be found here:
* @note https://tools.ietf.org/html/rfc1071
* @note It is the simplest way to calculate a checksum and is not very strong.
* However, it is good enough for this assignment.
* @note You are free to use any other checksum function as well.
* You can also use this function as such without any change.
*/
unsigned short int calculate_checksum(void *data, unsigned int bytes) {
 unsigned short int *data_pointer = (unsigned short int *)data;
 unsigned int total_sum = 0;
 // Main summing loop
 while (bytes > 1) {
 total_sum += *data_pointer++;
 bytes -= 2;
 }
 // Add left-over byte, if any
 if (bytes > 0)
 total_sum += *((unsigned char *)data_pointer);
 // Fold 32-bit sum to 16 bits
 while (total_sum >> 16)
 total_sum = (total_sum & 0xFFFF) + (total_sum >> 16);
 return (~((unsigned short int)total_sum));
} Communication Networks Course
Page | 1
Assignment 3 â€“ Transport Layer
Assignment Notes and Instructions
This assignment is to be done in pairs only. You must upload all the necessary files in a ZIP
file named after both of the studentâ€™s ID. For example: ğŸğŸğŸ‘ğŸ’ğŸ“ğŸ”ğŸ•ğŸ–ğŸ—_ğŸ—ğŸ–ğŸ•ğŸ”ğŸ“ğŸ’ğŸ‘ğŸğŸ. ğ’›ğ’Šğ’‘.
1) The assignment must be submitted by the date specified in the submission box.
2) All the assignment files (Code, Wireshark pcap files, PDF) must be submitted in a ZIP file. The
PDF must contain all the necessary screenshots with a description for each one of them.
3) The assignment must be done in pairs only. In exceptional cases, you should send an email to
the course coordinator.
4) You can use any reference material available through the course Moodle website or any
material passed during the exercises.
5) You can use any reference from the web, but copying codes from websites is forbidden; this
includes codes from other GitHub repositories. A student who gets caught in the act will
automatically fail this assignment (score 0). Any website youâ€™ve used to solve the
assignment, every website you used to solve the assignment must be noted in the PDF.
6) No delays in submission without special permission. Lateness without approval will result in
failure of the assignment (score 0).
7) All submissions will be submitted via the course's Moodle website. Email submissions will not
be accepted, resulting in a failure in the assignment.
8) The order and design of the code must be carefully considered. Make sure that the program
output is as clear as possible, comments in the code, and meaningful variable names. You
must also submit a makefile that compiles all the programs.
9) The assignment code must be written in C only.
10) The assignment is personal for each pair, and you should not accept help from other people,
whether outside the university or inside it. You can contact the course staff during reception
hours for help or raise a question in the course forum. Do not transfer code sections
between students, upload solutions or parts of solutions to websites on the Internet or in
various communication groups.
11) Students who copy a solution will receive a 0 in all assignments in the course and a report will
be made to the institutional disciplinary committee.
12) All code files of the assignment are required to both compile and run properly on the Ubuntu
22.04 LTS operating system. This is the operating system where the submissions will be
tested. You mustnâ€™t code it in Windows, as it uses different API for sockets. WSL wonâ€™t work,
as the task needs a tool that works only in a fully Linux environment.
Good Luck!
 Communication Networks Course
Page | 2
Part A â€“ Transmission Control Protocol (TCP) â€“ 30 points
In this part, youâ€™ll write two program files: ğ‘»ğ‘ªğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and ğ‘»ğ‘ªğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
The Sender will send a randomly generated file and the Receiver will receive it and measure
the time it took for his program to receive the file. The file size should be at least 2MB.
When running the Sender and Receiver, they both should support two standard congestion
control algorithms: TCP Reno and TCP Cubic.
Notes:
â€¢ The main goal of this part is to get familiar with the TCP concept of sending
messages between two endpoints.
â€¢ For approaching this part of the assignment, please be sure that you are familiar
with the congestion control algorithms and how to change them using the correct
method in C (see Appendix B for more information).
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). You've
learned that TCP is reliable by design, so you can assume that all the data have been
passed correctly, and thus, no need to recheck.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
Usage:
â€¢ Receiver:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
â€¢ Sender:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port of the Receiver.
â€¢ ğ‘¨ğ‘³ğ‘®ğ‘¶ â€“ The TCP congestion control algorithm that will be used by the party
member (either ğ’“ğ’†ğ’ğ’ for TCP Reno or ğ’„ğ’–ğ’ƒğ’Šğ’„ for TCP Cubic).
 Communication Networks Course
Page | 3
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a TCP socket between the Sender and the
Receiver.
3) Send the file.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a TCP connection between the Receiver and
the Sender.
2) Get a connection from the sender.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./TCP_Receiver -p 1234 -algo reno
Starting Receiver...
Waiting for TCP connection...
Sender connected, beginning to receive file...
File transfer completed.
Waiting for Sender response...
Sender sent exit message.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 4
Part B â€“ Reliable User Datagram Protocol (Reliable UDP or RUDP) â€“ 40 points
Youâ€™ve learned that while TCP is reliable, it lacks speed and has an overhead data of 20 bytes,
compering to UDP that needs only 8 bytes of overhead data.
Reliable UDP or RUDP, is a protocol that uses the UDP protocol for a faster transmission of
data, while adding a reliability layer to it, but without adding too much overhead data like
TCP.
A simple sketch for a RUDP connection would look something like this:
Your task in this part is to implement a Reliable protocol using UDP only. For simplicity, your
implementation should only support a handshake, closing scheme, error checking,
acknowledgment of received packets, and retransmission of lost packets.
Guidance:
â€¢ You can use ğ‘ ğ‘’ğ‘¡ğ‘ ğ‘œğ‘ğ‘˜ğ‘œğ‘ğ‘¡(2) for detecting a timeout.
â€¢ You need to build your own protocol, as Reliable UDP isnâ€™t a standard protocol (see a
draft of RUDP in this link), and no official header is provided. You can use this sketch
for a header, but you can come up with your own protocol, as long as it works.
Where:
o ğ‘³ğ’†ğ’ğ’ˆğ’•ğ’‰ is the length of the data itself, without the RUDP header.
o ğ‘ªğ’‰ğ’†ğ’„ğ’Œğ’”ğ’–ğ’ is a 16bit number that validates the correctness of the data.
o ğ‘­ğ’ğ’‚ğ’ˆğ’” is a special byte where we classify the packet itself (SYN, ACK, etc.).
â€¢ In your PDF, you must explain how your implementation of RUDP works â€“ How does
it detect a timeout to do retransmissions, how does the handshake work, what is the
header overhead, etc.
â€¢ For this part, youâ€™ll write three files: ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¨ğ‘·ğ‘°. ğ’„, ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and
ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
Reliable UDP Header proposed sketch
Byte 0 Byte 1 Byte 2 Byte 3
Length (2 Bytes) Checksum (2 Bytes)
Flags (1 Byte)
Figure 1 - RUDP Protocol Architecture, Geeksforgeeks
 Communication Networks Course
Page | 5
Notes:
â€¢ The Sender will send a random generated file and the Receiver will receive it and
measure the time it took for his program to receive the file. The file size should be at
least 2MB.
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). But, as the
RUDP is based on UDP, itâ€™s not reliable. You must use some form of error checking
(like checksum) to ensure that the packet wasnâ€™t alerted during the transfer.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
â€¢ The RUDP needs support only 1 sender and 1 receiver, for simplicity purposes.
Usage:
â€¢ Receiver:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
â€¢ Sender:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port that both the Sender and the Receiver will use.
The ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„ file will contain all the implementations of the RUDP API functions (That is, to
prevent reusing the same chuck of code both in the Sender and the Receiver.).
The API should support at the bare minimum the following functions (you decide what
parameters to implement, and what are the names of the functions, as long as the API is
explained in the PDF):
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘œğ‘ğ‘˜ğ‘’ğ‘¡() â€“ Creating a RUDP socket and creating a handshake between two
peers.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘’ğ‘›ğ‘‘() â€“ Sending data to the peer. The function should wait for an
acknowledgment packet, and if it didnâ€™t receive any, retransmits the data.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘Ÿğ‘’ğ‘ğ‘£() â€“ Receive data from a peer.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ğ‘™ğ‘œğ‘ ğ‘’() â€“ Closes a connection between peers.
 Communication Networks Course
Page | 6
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a UDP socket between the Sender and the
Receiver.
3) Send the file via the RUDP protocol.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a UDP connection between the Receiver and
the Sender.
2) Get a connection from the sender, by the custom
RUDP protocol youâ€™ve built.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./RUDP_Receiver -p 1234
Starting Receiver...
Waiting for RUDP connection...
Connection request received, sending ACK.
Sender connected, beginning to receive file...
File transfer completed.
ACK sent.
Waiting for Sender response...
Sender sent exit message.
ACK sent.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 7
Part C â€“ Research â€“ 30 points
In this part, youâ€™ll conduct research about your implementations of part A and part B.
In the research itself, each one of the versions (TCP version and UDP version) will be run at
least 5 times (meaning that the file transfer will occur at least 5 times) by the following
conditions:
â€¢ For TCP, youâ€™ll run it in TCP Reno and TCP Cubic, alternating each time, for each
scenario, meaning that you run 5 times with TCP Reno in both Sender and Receiver,
and 5 times with TCP Cubic in both Sender and Receiver.
Bonus (5 points): Create a very large data set â€“ 5 times with TCP Reno in both Sender
and Receiver, 5 times with TCP Reno in Sender and TCP Cubic in Receiver, 5 times
with TCP Cubic in Sender and TCP Reno in Receiver, and 5 times with TCP Cubic in
both Sender and Receiver. This will give you a data set large enough, which allows
you to work with, compare with and to reach a definite conclusion.
â€¢ For RUDP, you will run it 5 times for each scenario.
â€¢ For both TCP and RUDP, you will run them on those scenarios of packet loss:
o 0% packet loss â€“ Control group, simulating perfect connection.
o 2% packet loss â€“ Simulating unstable connection that commonly occur.
o 5% packet loss â€“ Simulating bad connection.
o 10% packet loss â€“ Simulating extremely poor connection.
For each scenario, you must provide a filtered PCAP file and relevant screenshots that
explain each one of the steps in the process. (10 points)
After youâ€™ve gathered the data set for both TCP and Reliable UDP, answer the following
questions:
1) In TCP, which congestion control algorithm gave better results overall? TCP Reno or
TCP Cubic? Which one gave better results on high packet loss? Explain how you came
to this conclusion based on the data set youâ€™ve gathered. (5 points)
2) How did your implementation of Reliable UDP perform overall compared to regular
TCP? Which one is better for high packet loss? (5 points)
3) According to the data youâ€™ve gathered, in which scenarios and applications would we
prefer to use TCP and in which situations would we prefer to use reliable UDP?
Explain your answer. (5 points)
 Communication Networks Course
Page | 8
×¢× ×• ×¢×œ ×”×©××œ×•×ª ×”×‘××•×ª )5 × ×§×•×“×•×ª(:
â— ×‘"×¨×©×ª ×××™× ×”" ×”×›×•×•× ×” ×”×™× ×œ×¨×©×ª ×©×‘×” ××¢×˜ ×××•×“ ×—×‘×™×œ×•×ª ×”×•×œ×›×•×ª ×œ××™×‘×•×“. ×‘"×§×©×¨ ××¨×•×š" ×”×›×•×•× ×” ×”×™×
×œ×§×©×¨ TCP ×©×™×© ×‘×• ×”×¨×‘×” ×××•×“ ××™×“×¢ ×œ×©×œ×•×—. ××•×¦×¢ ×œ×”×’×“×™×œ ×‘ -TCP ××ª SSThreshold ×‘×ª×—×™×œ×ª ×”×§×©×¨.
×‘××™×–×” ××”××§×¨×™× ×”×‘××™× ×”×©×™× ×•×™ ×”×–×” ×¢×©×•×™ ×œ×”×•×¢×™×œ ×‘××™×“×” ×”××™×¨×‘×™×ª? × ××§.
.1 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
.2 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.3 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.4 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.5 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.6 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.7 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.8 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
â— A ×©×•×œ×— ×œ -B ×—×‘×™×œ×•×ª ××™×“×¢ ×‘×××¦×¢×•×ª ×§×©×¨ TCP. × ×ª×•×Ÿ ×›×™ ×”×§×©×¨ ××ª×—×™×œ ×¢× ×—×œ×•×Ÿ ×‘×’×•×“×œ 1MSS. ×”×§×©×¨
××¡×ª×™×™× ×‘×¤×¢× ×”×¨××©×•× ×” ×©×”×•× ××’×™×¢ ×œ -SSthresh. ×‘××”×œ×š ×”×§×©×¨ ×œ× ××•×‘×“×•×ª ×—×‘×™×œ×•×ª. × ×¡××Ÿ ×‘×§×™×¦×•×¨:
.SSthresh=S*MSS
× ×ª×•×Ÿ ×›×™ ×œ××•×¨×š ×›×œ ×”×§×©×¨ rwnd < MSS*S.
××”×™ ×”×ª×¤×•×§×” ×©×œ ×”×§×©×¨ ×-A ×œ-B( ×‘ -sec / Bytes )×‘×–××Ÿ ×”× "×œ? × ××§×™.
]S*MSS / [lg (S) * RTT*2 ×‘×¢×¨×š .1
]S*MSS / [S^0.5 * RTT*2 ×‘×¢×¨×š .2
S*MSS / RTT ×‘×¢×¨×š .3
S^2)*MSS / RTT( ×‘×¢×¨×š .4
â— ×©×ª×™ ×ª×—× ×•×ª ××ª×§×©×¨×•×ª ×‘××•×¤×Ÿ ××œ×—×•×˜×™ ×‘×©×™×˜×ª N Back Go.
× ×¡××Ÿ ×‘-X ××ª ×¡×¤×¨×ª ×”×‘×™×§×•×¨×ª ×©×œ ×”×ª.×–. ×©×œ×š. ×× ×©× ×™ ×©×•×ª×¤×™× ××’×™×©×™× ××ª ×”×ª×¨×’×™×œ ×™×—×“, X ×”×•× ×¡×¤×¨×ª
×”×‘×™×§×•×¨×ª ×‘×¢×œ×ª ×”×¢×¨×š ×”× ××•×š ×™×•×ª×¨ ××‘×™×Ÿ ×”×©×ª×™×™×.
×§×¦×‘ ×”×ª×§×©×•×¨×ª ×”×•× 8Gbps, ×•×’×•×“×œ ×›×œ ×—×‘×™×œ×” ×”×•× KByte*X. ×’×“×œ×™ ×”-headers ×•×” -Acks ×–× ×™×—×™×.
ï¿½ğ‘’ğ‘ ï¿½/ï¿½ï¿½ 8 , ×•×”××¨×—×§ ×‘×™×Ÿ ×”×ª×—× ×•×ª ×”×•× 1Km. ×§×¦×‘ ×”×”×ª×¤×©×˜×•×ª ×”×•× 10 â‹… 2
×–××Ÿ ×¢×™×‘×•×“ ×”× ×ª×•× ×™× ×‘×ª×—× ×•×ª ×–× ×™×—.
××£ ×—×‘×™×œ×” ×•××£ Ack ×œ× ×”×•×œ×›×™× ×œ××™×‘×•×“.
â— ××”×• X ×©×œ×š?
â— ××” ×¦×¨×™×š ×œ×”×™×•×ª ×’×•×“×œ ×—×œ×•×Ÿ ×”××©×œ×•×— ×›×“×™ ×œ×”×‘×˜×™×— ×ª×¤×•×§×” ××§×¡×™××œ×™×ª?
 Communication Networks Course
Page | 9
Bonus â€“ Improving the Reliable UDP â€“ 15 points
Note: This part isnâ€™t mandatory and is a bonus only!
In this part, youâ€™ll improve your RUDP implementation by adding the concepts of flow
control and congestion control from TCP. Youâ€™re free to choose which algorithms to
implement, as long as you explain in your PDF which algorithms youâ€™ve used. Youâ€™ll probably
need to make changes in the original design of the RUDP. Changes only need to be to the API
itself, ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„.
Points distribution:
â€¢ Flow control improvement â€“ 7 Points
â€¢ Congestion control improvement â€“ 8 points.
Guidance:
â€¢ For flow control, you must use one of the Sliding window techniques: stop-and-wait
ARQ, Go-Back-N or Selective repeat.
â€¢ List of known TCP congestion control algorithms, which you can use any one of them
for this bonus task, or makeup your own:
Figure 2 â€“ List of known TCP congestion control algorithms, Wikipedia
 Communication Networks Course
Page | 10
Appendix A â€“ Linux local packet loss tool
To simulate a packet loss in a local network, we'll use a Linux tool that's called Linux Traffic
Control (ğ‘¡ğ‘). This requires a full Linux installation, so working with WSL won't work.
If the tool isn't installed in your machine, you can install it by using the following commands:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’
If the installation didn't work, you can use the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’2
To create a packet loss scenario, type the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘ğ‘‘ğ‘‘ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
After creating a packet loss scenario, you can change the percentage by typing the following
command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘â„ğ‘ğ‘›ğ‘”ğ‘’ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
To remove the packet loss scenario, write the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘‘ğ‘’ğ‘™ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š
 Communication Networks Course
Page | 11
Appendix B â€“ ğ’ğ’‚ğ’(ğŸ) system calls
This appendixâ€™s purpose is to give you a better understanding of socket handling in C.
A recommended reference is Beejâ€™s Guide to Network Programming, by Brian â€œBeej
Jorgensenâ€ Hall, which gives a lot of information about sockets in C and functions.
Functions and documentation links:
â€¢ ğ’”ğ’ğ’„ğ’Œğ’†ğ’•(ğŸ) â€“ A Factory method system call that creates a socket with the given
parameters.
â€¢ ğ’ƒğ’Šğ’ğ’…(ğŸ) â€“ Whenever we create a new socket, we need to bind it to a specific port in
our machine, â€œto catch a portâ€. The port number is managed and used by the kernel
to link incoming packets to the corresponding application socket. The port numbers
are usually fixed. The ğ‘ğ‘‘ğ‘‘ğ‘Ÿ parameter must match the current socket that is used.
â€¢ ğ’ğ’Šğ’”ğ’•ğ’†ğ’(ğŸ) â€“ The ğ‘™ğ‘–ğ‘ ğ‘¡ğ‘’ğ‘›(2) system call doesn't do anything in the mean of
communication but only memory allocation (malloc) for stream sockets only. If we
won't allocate memory, any incoming connection will fail.
â€¢ ğ’„ğ’ğ’ğ’ğ’†ğ’„ğ’•(ğŸ) â€“ The ğ‘ğ‘œğ‘›ğ‘›ğ‘’ğ‘ğ‘¡(2) system call starts the link between a client and a
specific IP address and port number. The connection would complete when the
other side will call the ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call.
â€¢ ğ’‚ğ’„ğ’„ğ’†ğ’‘ğ’•(ğŸ) â€“ The ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call accepts the incoming stream connection
request from the other side, by the listening socket. This system call completes the
three-way handshake of stream socket (like TCP) and opens a new socket that has a
direct communication channel only with the other party in the handshake.
â€¢ ğ’”ğ’†ğ’ğ’…(ğŸ) and ğ’”ğ’†ğ’ğ’…ğ’•ğ’(ğŸ) â€“ The ğ‘ ğ‘’ğ‘›ğ‘‘(2) and ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system calls are an analogy
for the ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’(2) system call, specifcly for sockets, with flags set to 0. Those system
calls return the number of bytes that were sent through the socket itself, as the
number of bytes can vary. The ğ‘ ğ‘’ğ‘›ğ‘‘(2)system call designed for stream sockets (like
TCP), while the ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system call designed for datagram connection-less
sockets (like UDP). When the ğ‘ ğ‘’ğ‘›ğ‘‘(2) system call returns 0, it means that the other
party closed the connection.
â€¢ ğ’“ğ’†ğ’„ğ’—(ğŸ) and ğ’“ğ’†ğ’„ğ’—ğ’‡ğ’“ğ’ğ’(ğŸ) â€“ The ğ‘Ÿğ‘’ğ‘ğ‘£(2) and ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system calls are an
analogy for the ğ‘Ÿğ‘’ğ‘ğ‘‘(2) system call, specifically for sockets, with flags set to 0.
Those system calls return the number of bytes that were received through the socket
itself, as the number of bytes can vary. The ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call designed for stream
sockets (like TCP), while the ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system call designed for datagram
connection-less sockets (like UDP). When the ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call returns 0, it means
that the other party closed the connection.
â€¢ ğ’„ğ’ğ’ğ’”ğ’†(ğŸ) and ğ’”ğ’‰ğ’–ğ’•ğ’…ğ’ğ’˜ğ’(ğŸ) â€“ The ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) and ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2) system calls close
the socket. While ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) system call closes the whole socket, the ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2)
system call partially closes the socket for read/write.
 Communication Networks Course
Page | 12
Appendix C â€“ Random data generator
The data that you are going to send in this assignment is randomly generated. You can use
your own file with appropriate size or use the following function (or a function of your own)
to generate the data:
/*
* @brief A random data generator function based on srand() and rand().
* @param size The size of the data to generate (up to 2^32 bytes).
* @return A pointer to the buffer.
*/
char *util_generate_random_data(unsigned int size) {
 char *buffer = NULL;
 // Argument check.
 if (size == 0)
 return NULL;
 buffer = (char *)calloc(size, sizeof(char));
 // Error checking.
 if (buffer == NULL)
 return NULL;
 // Randomize the seed of the random number generator.
 srand(time(NULL));
 for (unsigned int i = 0; i < size; i++)
 *(buffer + i) = ((unsigned int)rand() % 256);
 return buffer;
}
 Communication Networks Course
Page | 13
Appendix D â€“ Checksum function
A checksum is a small-sized block of data derived from another block of digital data for the
purpose of detecting errors that may have been introduced during its transmission or
storage. By themselves, checksums are often used to verify data integrity but are not relied
upon to verify data authenticity.
Below is a simple yet efficient implementation of the checksum function, you can use it for
the assignment, but you can implement your own checksum function.
/*
* @brief A checksum function that returns 16 bit checksum for data.
* @param data The data to do the checksum for.
* @param bytes The length of the data in bytes.
* @return The checksum itself as 16 bit unsigned number.
* @note This function is taken from RFC1071, can be found here:
* @note https://tools.ietf.org/html/rfc1071
* @note It is the simplest way to calculate a checksum and is not very strong.
* However, it is good enough for this assignment.
* @note You are free to use any other checksum function as well.
* You can also use this function as such without any change.
*/
unsigned short int calculate_checksum(void *data, unsigned int bytes) {
 unsigned short int *data_pointer = (unsigned short int *)data;
 unsigned int total_sum = 0;
 // Main summing loop
 while (bytes > 1) {
 total_sum += *data_pointer++;
 bytes -= 2;
 }
 // Add left-over byte, if any
 if (bytes > 0)
 total_sum += *((unsigned char *)data_pointer);
 // Fold 32-bit sum to 16 bits
 while (total_sum >> 16)
 total_sum = (total_sum & 0xFFFF) + (total_sum >> 16);
 return (~((unsigned short int)total_sum));
} Communication Networks Course
Page | 1
Assignment 3 â€“ Transport Layer
Assignment Notes and Instructions
This assignment is to be done in pairs only. You must upload all the necessary files in a ZIP
file named after both of the studentâ€™s ID. For example: ğŸğŸğŸ‘ğŸ’ğŸ“ğŸ”ğŸ•ğŸ–ğŸ—_ğŸ—ğŸ–ğŸ•ğŸ”ğŸ“ğŸ’ğŸ‘ğŸğŸ. ğ’›ğ’Šğ’‘.
1) The assignment must be submitted by the date specified in the submission box.
2) All the assignment files (Code, Wireshark pcap files, PDF) must be submitted in a ZIP file. The
PDF must contain all the necessary screenshots with a description for each one of them.
3) The assignment must be done in pairs only. In exceptional cases, you should send an email to
the course coordinator.
4) You can use any reference material available through the course Moodle website or any
material passed during the exercises.
5) You can use any reference from the web, but copying codes from websites is forbidden; this
includes codes from other GitHub repositories. A student who gets caught in the act will
automatically fail this assignment (score 0). Any website youâ€™ve used to solve the
assignment, every website you used to solve the assignment must be noted in the PDF.
6) No delays in submission without special permission. Lateness without approval will result in
failure of the assignment (score 0).
7) All submissions will be submitted via the course's Moodle website. Email submissions will not
be accepted, resulting in a failure in the assignment.
8) The order and design of the code must be carefully considered. Make sure that the program
output is as clear as possible, comments in the code, and meaningful variable names. You
must also submit a makefile that compiles all the programs.
9) The assignment code must be written in C only.
10) The assignment is personal for each pair, and you should not accept help from other people,
whether outside the university or inside it. You can contact the course staff during reception
hours for help or raise a question in the course forum. Do not transfer code sections
between students, upload solutions or parts of solutions to websites on the Internet or in
various communication groups.
11) Students who copy a solution will receive a 0 in all assignments in the course and a report will
be made to the institutional disciplinary committee.
12) All code files of the assignment are required to both compile and run properly on the Ubuntu
22.04 LTS operating system. This is the operating system where the submissions will be
tested. You mustnâ€™t code it in Windows, as it uses different API for sockets. WSL wonâ€™t work,
as the task needs a tool that works only in a fully Linux environment.
Good Luck!
 Communication Networks Course
Page | 2
Part A â€“ Transmission Control Protocol (TCP) â€“ 30 points
In this part, youâ€™ll write two program files: ğ‘»ğ‘ªğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and ğ‘»ğ‘ªğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
The Sender will send a randomly generated file and the Receiver will receive it and measure
the time it took for his program to receive the file. The file size should be at least 2MB.
When running the Sender and Receiver, they both should support two standard congestion
control algorithms: TCP Reno and TCP Cubic.
Notes:
â€¢ The main goal of this part is to get familiar with the TCP concept of sending
messages between two endpoints.
â€¢ For approaching this part of the assignment, please be sure that you are familiar
with the congestion control algorithms and how to change them using the correct
method in C (see Appendix B for more information).
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). You've
learned that TCP is reliable by design, so you can assume that all the data have been
passed correctly, and thus, no need to recheck.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
Usage:
â€¢ Receiver:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
â€¢ Sender:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port of the Receiver.
â€¢ ğ‘¨ğ‘³ğ‘®ğ‘¶ â€“ The TCP congestion control algorithm that will be used by the party
member (either ğ’“ğ’†ğ’ğ’ for TCP Reno or ğ’„ğ’–ğ’ƒğ’Šğ’„ for TCP Cubic).
 Communication Networks Course
Page | 3
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a TCP socket between the Sender and the
Receiver.
3) Send the file.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a TCP connection between the Receiver and
the Sender.
2) Get a connection from the sender.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./TCP_Receiver -p 1234 -algo reno
Starting Receiver...
Waiting for TCP connection...
Sender connected, beginning to receive file...
File transfer completed.
Waiting for Sender response...
Sender sent exit message.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 4
Part B â€“ Reliable User Datagram Protocol (Reliable UDP or RUDP) â€“ 40 points
Youâ€™ve learned that while TCP is reliable, it lacks speed and has an overhead data of 20 bytes,
compering to UDP that needs only 8 bytes of overhead data.
Reliable UDP or RUDP, is a protocol that uses the UDP protocol for a faster transmission of
data, while adding a reliability layer to it, but without adding too much overhead data like
TCP.
A simple sketch for a RUDP connection would look something like this:
Your task in this part is to implement a Reliable protocol using UDP only. For simplicity, your
implementation should only support a handshake, closing scheme, error checking,
acknowledgment of received packets, and retransmission of lost packets.
Guidance:
â€¢ You can use ğ‘ ğ‘’ğ‘¡ğ‘ ğ‘œğ‘ğ‘˜ğ‘œğ‘ğ‘¡(2) for detecting a timeout.
â€¢ You need to build your own protocol, as Reliable UDP isnâ€™t a standard protocol (see a
draft of RUDP in this link), and no official header is provided. You can use this sketch
for a header, but you can come up with your own protocol, as long as it works.
Where:
o ğ‘³ğ’†ğ’ğ’ˆğ’•ğ’‰ is the length of the data itself, without the RUDP header.
o ğ‘ªğ’‰ğ’†ğ’„ğ’Œğ’”ğ’–ğ’ is a 16bit number that validates the correctness of the data.
o ğ‘­ğ’ğ’‚ğ’ˆğ’” is a special byte where we classify the packet itself (SYN, ACK, etc.).
â€¢ In your PDF, you must explain how your implementation of RUDP works â€“ How does
it detect a timeout to do retransmissions, how does the handshake work, what is the
header overhead, etc.
â€¢ For this part, youâ€™ll write three files: ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¨ğ‘·ğ‘°. ğ’„, ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and
ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
Reliable UDP Header proposed sketch
Byte 0 Byte 1 Byte 2 Byte 3
Length (2 Bytes) Checksum (2 Bytes)
Flags (1 Byte)
Figure 1 - RUDP Protocol Architecture, Geeksforgeeks
 Communication Networks Course
Page | 5
Notes:
â€¢ The Sender will send a random generated file and the Receiver will receive it and
measure the time it took for his program to receive the file. The file size should be at
least 2MB.
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). But, as the
RUDP is based on UDP, itâ€™s not reliable. You must use some form of error checking
(like checksum) to ensure that the packet wasnâ€™t alerted during the transfer.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
â€¢ The RUDP needs support only 1 sender and 1 receiver, for simplicity purposes.
Usage:
â€¢ Receiver:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
â€¢ Sender:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port that both the Sender and the Receiver will use.
The ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„ file will contain all the implementations of the RUDP API functions (That is, to
prevent reusing the same chuck of code both in the Sender and the Receiver.).
The API should support at the bare minimum the following functions (you decide what
parameters to implement, and what are the names of the functions, as long as the API is
explained in the PDF):
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘œğ‘ğ‘˜ğ‘’ğ‘¡() â€“ Creating a RUDP socket and creating a handshake between two
peers.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘’ğ‘›ğ‘‘() â€“ Sending data to the peer. The function should wait for an
acknowledgment packet, and if it didnâ€™t receive any, retransmits the data.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘Ÿğ‘’ğ‘ğ‘£() â€“ Receive data from a peer.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ğ‘™ğ‘œğ‘ ğ‘’() â€“ Closes a connection between peers.
 Communication Networks Course
Page | 6
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a UDP socket between the Sender and the
Receiver.
3) Send the file via the RUDP protocol.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a UDP connection between the Receiver and
the Sender.
2) Get a connection from the sender, by the custom
RUDP protocol youâ€™ve built.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./RUDP_Receiver -p 1234
Starting Receiver...
Waiting for RUDP connection...
Connection request received, sending ACK.
Sender connected, beginning to receive file...
File transfer completed.
ACK sent.
Waiting for Sender response...
Sender sent exit message.
ACK sent.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 7
Part C â€“ Research â€“ 30 points
In this part, youâ€™ll conduct research about your implementations of part A and part B.
In the research itself, each one of the versions (TCP version and UDP version) will be run at
least 5 times (meaning that the file transfer will occur at least 5 times) by the following
conditions:
â€¢ For TCP, youâ€™ll run it in TCP Reno and TCP Cubic, alternating each time, for each
scenario, meaning that you run 5 times with TCP Reno in both Sender and Receiver,
and 5 times with TCP Cubic in both Sender and Receiver.
Bonus (5 points): Create a very large data set â€“ 5 times with TCP Reno in both Sender
and Receiver, 5 times with TCP Reno in Sender and TCP Cubic in Receiver, 5 times
with TCP Cubic in Sender and TCP Reno in Receiver, and 5 times with TCP Cubic in
both Sender and Receiver. This will give you a data set large enough, which allows
you to work with, compare with and to reach a definite conclusion.
â€¢ For RUDP, you will run it 5 times for each scenario.
â€¢ For both TCP and RUDP, you will run them on those scenarios of packet loss:
o 0% packet loss â€“ Control group, simulating perfect connection.
o 2% packet loss â€“ Simulating unstable connection that commonly occur.
o 5% packet loss â€“ Simulating bad connection.
o 10% packet loss â€“ Simulating extremely poor connection.
For each scenario, you must provide a filtered PCAP file and relevant screenshots that
explain each one of the steps in the process. (10 points)
After youâ€™ve gathered the data set for both TCP and Reliable UDP, answer the following
questions:
1) In TCP, which congestion control algorithm gave better results overall? TCP Reno or
TCP Cubic? Which one gave better results on high packet loss? Explain how you came
to this conclusion based on the data set youâ€™ve gathered. (5 points)
2) How did your implementation of Reliable UDP perform overall compared to regular
TCP? Which one is better for high packet loss? (5 points)
3) According to the data youâ€™ve gathered, in which scenarios and applications would we
prefer to use TCP and in which situations would we prefer to use reliable UDP?
Explain your answer. (5 points)
 Communication Networks Course
Page | 8
×¢× ×• ×¢×œ ×”×©××œ×•×ª ×”×‘××•×ª )5 × ×§×•×“×•×ª(:
â— ×‘"×¨×©×ª ×××™× ×”" ×”×›×•×•× ×” ×”×™× ×œ×¨×©×ª ×©×‘×” ××¢×˜ ×××•×“ ×—×‘×™×œ×•×ª ×”×•×œ×›×•×ª ×œ××™×‘×•×“. ×‘"×§×©×¨ ××¨×•×š" ×”×›×•×•× ×” ×”×™×
×œ×§×©×¨ TCP ×©×™×© ×‘×• ×”×¨×‘×” ×××•×“ ××™×“×¢ ×œ×©×œ×•×—. ××•×¦×¢ ×œ×”×’×“×™×œ ×‘ -TCP ××ª SSThreshold ×‘×ª×—×™×œ×ª ×”×§×©×¨.
×‘××™×–×” ××”××§×¨×™× ×”×‘××™× ×”×©×™× ×•×™ ×”×–×” ×¢×©×•×™ ×œ×”×•×¢×™×œ ×‘××™×“×” ×”××™×¨×‘×™×ª? × ××§.
.1 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
.2 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.3 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.4 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.5 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.6 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.7 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.8 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
â— A ×©×•×œ×— ×œ -B ×—×‘×™×œ×•×ª ××™×“×¢ ×‘×××¦×¢×•×ª ×§×©×¨ TCP. × ×ª×•×Ÿ ×›×™ ×”×§×©×¨ ××ª×—×™×œ ×¢× ×—×œ×•×Ÿ ×‘×’×•×“×œ 1MSS. ×”×§×©×¨
××¡×ª×™×™× ×‘×¤×¢× ×”×¨××©×•× ×” ×©×”×•× ××’×™×¢ ×œ -SSthresh. ×‘××”×œ×š ×”×§×©×¨ ×œ× ××•×‘×“×•×ª ×—×‘×™×œ×•×ª. × ×¡××Ÿ ×‘×§×™×¦×•×¨:
.SSthresh=S*MSS
× ×ª×•×Ÿ ×›×™ ×œ××•×¨×š ×›×œ ×”×§×©×¨ rwnd < MSS*S.
××”×™ ×”×ª×¤×•×§×” ×©×œ ×”×§×©×¨ ×-A ×œ-B( ×‘ -sec / Bytes )×‘×–××Ÿ ×”× "×œ? × ××§×™.
]S*MSS / [lg (S) * RTT*2 ×‘×¢×¨×š .1
]S*MSS / [S^0.5 * RTT*2 ×‘×¢×¨×š .2
S*MSS / RTT ×‘×¢×¨×š .3
S^2)*MSS / RTT( ×‘×¢×¨×š .4
â— ×©×ª×™ ×ª×—× ×•×ª ××ª×§×©×¨×•×ª ×‘××•×¤×Ÿ ××œ×—×•×˜×™ ×‘×©×™×˜×ª N Back Go.
× ×¡××Ÿ ×‘-X ××ª ×¡×¤×¨×ª ×”×‘×™×§×•×¨×ª ×©×œ ×”×ª.×–. ×©×œ×š. ×× ×©× ×™ ×©×•×ª×¤×™× ××’×™×©×™× ××ª ×”×ª×¨×’×™×œ ×™×—×“, X ×”×•× ×¡×¤×¨×ª
×”×‘×™×§×•×¨×ª ×‘×¢×œ×ª ×”×¢×¨×š ×”× ××•×š ×™×•×ª×¨ ××‘×™×Ÿ ×”×©×ª×™×™×.
×§×¦×‘ ×”×ª×§×©×•×¨×ª ×”×•× 8Gbps, ×•×’×•×“×œ ×›×œ ×—×‘×™×œ×” ×”×•× KByte*X. ×’×“×œ×™ ×”-headers ×•×” -Acks ×–× ×™×—×™×.
ï¿½ğ‘’ğ‘ ï¿½/ï¿½ï¿½ 8 , ×•×”××¨×—×§ ×‘×™×Ÿ ×”×ª×—× ×•×ª ×”×•× 1Km. ×§×¦×‘ ×”×”×ª×¤×©×˜×•×ª ×”×•× 10 â‹… 2
×–××Ÿ ×¢×™×‘×•×“ ×”× ×ª×•× ×™× ×‘×ª×—× ×•×ª ×–× ×™×—.
××£ ×—×‘×™×œ×” ×•××£ Ack ×œ× ×”×•×œ×›×™× ×œ××™×‘×•×“.
â— ××”×• X ×©×œ×š?
â— ××” ×¦×¨×™×š ×œ×”×™×•×ª ×’×•×“×œ ×—×œ×•×Ÿ ×”××©×œ×•×— ×›×“×™ ×œ×”×‘×˜×™×— ×ª×¤×•×§×” ××§×¡×™××œ×™×ª?
 Communication Networks Course
Page | 9
Bonus â€“ Improving the Reliable UDP â€“ 15 points
Note: This part isnâ€™t mandatory and is a bonus only!
In this part, youâ€™ll improve your RUDP implementation by adding the concepts of flow
control and congestion control from TCP. Youâ€™re free to choose which algorithms to
implement, as long as you explain in your PDF which algorithms youâ€™ve used. Youâ€™ll probably
need to make changes in the original design of the RUDP. Changes only need to be to the API
itself, ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„.
Points distribution:
â€¢ Flow control improvement â€“ 7 Points
â€¢ Congestion control improvement â€“ 8 points.
Guidance:
â€¢ For flow control, you must use one of the Sliding window techniques: stop-and-wait
ARQ, Go-Back-N or Selective repeat.
â€¢ List of known TCP congestion control algorithms, which you can use any one of them
for this bonus task, or makeup your own:
Figure 2 â€“ List of known TCP congestion control algorithms, Wikipedia
 Communication Networks Course
Page | 10
Appendix A â€“ Linux local packet loss tool
To simulate a packet loss in a local network, we'll use a Linux tool that's called Linux Traffic
Control (ğ‘¡ğ‘). This requires a full Linux installation, so working with WSL won't work.
If the tool isn't installed in your machine, you can install it by using the following commands:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’
If the installation didn't work, you can use the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’2
To create a packet loss scenario, type the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘ğ‘‘ğ‘‘ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
After creating a packet loss scenario, you can change the percentage by typing the following
command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘â„ğ‘ğ‘›ğ‘”ğ‘’ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
To remove the packet loss scenario, write the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘‘ğ‘’ğ‘™ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š
 Communication Networks Course
Page | 11
Appendix B â€“ ğ’ğ’‚ğ’(ğŸ) system calls
This appendixâ€™s purpose is to give you a better understanding of socket handling in C.
A recommended reference is Beejâ€™s Guide to Network Programming, by Brian â€œBeej
Jorgensenâ€ Hall, which gives a lot of information about sockets in C and functions.
Functions and documentation links:
â€¢ ğ’”ğ’ğ’„ğ’Œğ’†ğ’•(ğŸ) â€“ A Factory method system call that creates a socket with the given
parameters.
â€¢ ğ’ƒğ’Šğ’ğ’…(ğŸ) â€“ Whenever we create a new socket, we need to bind it to a specific port in
our machine, â€œto catch a portâ€. The port number is managed and used by the kernel
to link incoming packets to the corresponding application socket. The port numbers
are usually fixed. The ğ‘ğ‘‘ğ‘‘ğ‘Ÿ parameter must match the current socket that is used.
â€¢ ğ’ğ’Šğ’”ğ’•ğ’†ğ’(ğŸ) â€“ The ğ‘™ğ‘–ğ‘ ğ‘¡ğ‘’ğ‘›(2) system call doesn't do anything in the mean of
communication but only memory allocation (malloc) for stream sockets only. If we
won't allocate memory, any incoming connection will fail.
â€¢ ğ’„ğ’ğ’ğ’ğ’†ğ’„ğ’•(ğŸ) â€“ The ğ‘ğ‘œğ‘›ğ‘›ğ‘’ğ‘ğ‘¡(2) system call starts the link between a client and a
specific IP address and port number. The connection would complete when the
other side will call the ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call.
â€¢ ğ’‚ğ’„ğ’„ğ’†ğ’‘ğ’•(ğŸ) â€“ The ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call accepts the incoming stream connection
request from the other side, by the listening socket. This system call completes the
three-way handshake of stream socket (like TCP) and opens a new socket that has a
direct communication channel only with the other party in the handshake.
â€¢ ğ’”ğ’†ğ’ğ’…(ğŸ) and ğ’”ğ’†ğ’ğ’…ğ’•ğ’(ğŸ) â€“ The ğ‘ ğ‘’ğ‘›ğ‘‘(2) and ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system calls are an analogy
for the ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’(2) system call, specifcly for sockets, with flags set to 0. Those system
calls return the number of bytes that were sent through the socket itself, as the
number of bytes can vary. The ğ‘ ğ‘’ğ‘›ğ‘‘(2)system call designed for stream sockets (like
TCP), while the ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system call designed for datagram connection-less
sockets (like UDP). When the ğ‘ ğ‘’ğ‘›ğ‘‘(2) system call returns 0, it means that the other
party closed the connection.
â€¢ ğ’“ğ’†ğ’„ğ’—(ğŸ) and ğ’“ğ’†ğ’„ğ’—ğ’‡ğ’“ğ’ğ’(ğŸ) â€“ The ğ‘Ÿğ‘’ğ‘ğ‘£(2) and ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system calls are an
analogy for the ğ‘Ÿğ‘’ğ‘ğ‘‘(2) system call, specifically for sockets, with flags set to 0.
Those system calls return the number of bytes that were received through the socket
itself, as the number of bytes can vary. The ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call designed for stream
sockets (like TCP), while the ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system call designed for datagram
connection-less sockets (like UDP). When the ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call returns 0, it means
that the other party closed the connection.
â€¢ ğ’„ğ’ğ’ğ’”ğ’†(ğŸ) and ğ’”ğ’‰ğ’–ğ’•ğ’…ğ’ğ’˜ğ’(ğŸ) â€“ The ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) and ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2) system calls close
the socket. While ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) system call closes the whole socket, the ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2)
system call partially closes the socket for read/write.
 Communication Networks Course
Page | 12
Appendix C â€“ Random data generator
The data that you are going to send in this assignment is randomly generated. You can use
your own file with appropriate size or use the following function (or a function of your own)
to generate the data:
/*
* @brief A random data generator function based on srand() and rand().
* @param size The size of the data to generate (up to 2^32 bytes).
* @return A pointer to the buffer.
*/
char *util_generate_random_data(unsigned int size) {
 char *buffer = NULL;
 // Argument check.
 if (size == 0)
 return NULL;
 buffer = (char *)calloc(size, sizeof(char));
 // Error checking.
 if (buffer == NULL)
 return NULL;
 // Randomize the seed of the random number generator.
 srand(time(NULL));
 for (unsigned int i = 0; i < size; i++)
 *(buffer + i) = ((unsigned int)rand() % 256);
 return buffer;
}
 Communication Networks Course
Page | 13
Appendix D â€“ Checksum function
A checksum is a small-sized block of data derived from another block of digital data for the
purpose of detecting errors that may have been introduced during its transmission or
storage. By themselves, checksums are often used to verify data integrity but are not relied
upon to verify data authenticity.
Below is a simple yet efficient implementation of the checksum function, you can use it for
the assignment, but you can implement your own checksum function.
/*
* @brief A checksum function that returns 16 bit checksum for data.
* @param data The data to do the checksum for.
* @param bytes The length of the data in bytes.
* @return The checksum itself as 16 bit unsigned number.
* @note This function is taken from RFC1071, can be found here:
* @note https://tools.ietf.org/html/rfc1071
* @note It is the simplest way to calculate a checksum and is not very strong.
* However, it is good enough for this assignment.
* @note You are free to use any other checksum function as well.
* You can also use this function as such without any change.
*/
unsigned short int calculate_checksum(void *data, unsigned int bytes) {
 unsigned short int *data_pointer = (unsigned short int *)data;
 unsigned int total_sum = 0;
 // Main summing loop
 while (bytes > 1) {
 total_sum += *data_pointer++;
 bytes -= 2;
 }
 // Add left-over byte, if any
 if (bytes > 0)
 total_sum += *((unsigned char *)data_pointer);
 // Fold 32-bit sum to 16 bits
 while (total_sum >> 16)
 total_sum = (total_sum & 0xFFFF) + (total_sum >> 16);
 return (~((unsigned short int)total_sum));
} Communication Networks Course
Page | 1
Assignment 3 â€“ Transport Layer
Assignment Notes and Instructions
This assignment is to be done in pairs only. You must upload all the necessary files in a ZIP
file named after both of the studentâ€™s ID. For example: ğŸğŸğŸ‘ğŸ’ğŸ“ğŸ”ğŸ•ğŸ–ğŸ—_ğŸ—ğŸ–ğŸ•ğŸ”ğŸ“ğŸ’ğŸ‘ğŸğŸ. ğ’›ğ’Šğ’‘.
1) The assignment must be submitted by the date specified in the submission box.
2) All the assignment files (Code, Wireshark pcap files, PDF) must be submitted in a ZIP file. The
PDF must contain all the necessary screenshots with a description for each one of them.
3) The assignment must be done in pairs only. In exceptional cases, you should send an email to
the course coordinator.
4) You can use any reference material available through the course Moodle website or any
material passed during the exercises.
5) You can use any reference from the web, but copying codes from websites is forbidden; this
includes codes from other GitHub repositories. A student who gets caught in the act will
automatically fail this assignment (score 0). Any website youâ€™ve used to solve the
assignment, every website you used to solve the assignment must be noted in the PDF.
6) No delays in submission without special permission. Lateness without approval will result in
failure of the assignment (score 0).
7) All submissions will be submitted via the course's Moodle website. Email submissions will not
be accepted, resulting in a failure in the assignment.
8) The order and design of the code must be carefully considered. Make sure that the program
output is as clear as possible, comments in the code, and meaningful variable names. You
must also submit a makefile that compiles all the programs.
9) The assignment code must be written in C only.
10) The assignment is personal for each pair, and you should not accept help from other people,
whether outside the university or inside it. You can contact the course staff during reception
hours for help or raise a question in the course forum. Do not transfer code sections
between students, upload solutions or parts of solutions to websites on the Internet or in
various communication groups.
11) Students who copy a solution will receive a 0 in all assignments in the course and a report will
be made to the institutional disciplinary committee.
12) All code files of the assignment are required to both compile and run properly on the Ubuntu
22.04 LTS operating system. This is the operating system where the submissions will be
tested. You mustnâ€™t code it in Windows, as it uses different API for sockets. WSL wonâ€™t work,
as the task needs a tool that works only in a fully Linux environment.
Good Luck!
 Communication Networks Course
Page | 2
Part A â€“ Transmission Control Protocol (TCP) â€“ 30 points
In this part, youâ€™ll write two program files: ğ‘»ğ‘ªğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and ğ‘»ğ‘ªğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
The Sender will send a randomly generated file and the Receiver will receive it and measure
the time it took for his program to receive the file. The file size should be at least 2MB.
When running the Sender and Receiver, they both should support two standard congestion
control algorithms: TCP Reno and TCP Cubic.
Notes:
â€¢ The main goal of this part is to get familiar with the TCP concept of sending
messages between two endpoints.
â€¢ For approaching this part of the assignment, please be sure that you are familiar
with the congestion control algorithms and how to change them using the correct
method in C (see Appendix B for more information).
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). You've
learned that TCP is reliable by design, so you can assume that all the data have been
passed correctly, and thus, no need to recheck.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
Usage:
â€¢ Receiver:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
â€¢ Sender:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port of the Receiver.
â€¢ ğ‘¨ğ‘³ğ‘®ğ‘¶ â€“ The TCP congestion control algorithm that will be used by the party
member (either ğ’“ğ’†ğ’ğ’ for TCP Reno or ğ’„ğ’–ğ’ƒğ’Šğ’„ for TCP Cubic).
 Communication Networks Course
Page | 3
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a TCP socket between the Sender and the
Receiver.
3) Send the file.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a TCP connection between the Receiver and
the Sender.
2) Get a connection from the sender.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./TCP_Receiver -p 1234 -algo reno
Starting Receiver...
Waiting for TCP connection...
Sender connected, beginning to receive file...
File transfer completed.
Waiting for Sender response...
Sender sent exit message.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 4
Part B â€“ Reliable User Datagram Protocol (Reliable UDP or RUDP) â€“ 40 points
Youâ€™ve learned that while TCP is reliable, it lacks speed and has an overhead data of 20 bytes,
compering to UDP that needs only 8 bytes of overhead data.
Reliable UDP or RUDP, is a protocol that uses the UDP protocol for a faster transmission of
data, while adding a reliability layer to it, but without adding too much overhead data like
TCP.
A simple sketch for a RUDP connection would look something like this:
Your task in this part is to implement a Reliable protocol using UDP only. For simplicity, your
implementation should only support a handshake, closing scheme, error checking,
acknowledgment of received packets, and retransmission of lost packets.
Guidance:
â€¢ You can use ğ‘ ğ‘’ğ‘¡ğ‘ ğ‘œğ‘ğ‘˜ğ‘œğ‘ğ‘¡(2) for detecting a timeout.
â€¢ You need to build your own protocol, as Reliable UDP isnâ€™t a standard protocol (see a
draft of RUDP in this link), and no official header is provided. You can use this sketch
for a header, but you can come up with your own protocol, as long as it works.
Where:
o ğ‘³ğ’†ğ’ğ’ˆğ’•ğ’‰ is the length of the data itself, without the RUDP header.
o ğ‘ªğ’‰ğ’†ğ’„ğ’Œğ’”ğ’–ğ’ is a 16bit number that validates the correctness of the data.
o ğ‘­ğ’ğ’‚ğ’ˆğ’” is a special byte where we classify the packet itself (SYN, ACK, etc.).
â€¢ In your PDF, you must explain how your implementation of RUDP works â€“ How does
it detect a timeout to do retransmissions, how does the handshake work, what is the
header overhead, etc.
â€¢ For this part, youâ€™ll write three files: ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¨ğ‘·ğ‘°. ğ’„, ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and
ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
Reliable UDP Header proposed sketch
Byte 0 Byte 1 Byte 2 Byte 3
Length (2 Bytes) Checksum (2 Bytes)
Flags (1 Byte)
Figure 1 - RUDP Protocol Architecture, Geeksforgeeks
 Communication Networks Course
Page | 5
Notes:
â€¢ The Sender will send a random generated file and the Receiver will receive it and
measure the time it took for his program to receive the file. The file size should be at
least 2MB.
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). But, as the
RUDP is based on UDP, itâ€™s not reliable. You must use some form of error checking
(like checksum) to ensure that the packet wasnâ€™t alerted during the transfer.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
â€¢ The RUDP needs support only 1 sender and 1 receiver, for simplicity purposes.
Usage:
â€¢ Receiver:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
â€¢ Sender:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port that both the Sender and the Receiver will use.
The ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„ file will contain all the implementations of the RUDP API functions (That is, to
prevent reusing the same chuck of code both in the Sender and the Receiver.).
The API should support at the bare minimum the following functions (you decide what
parameters to implement, and what are the names of the functions, as long as the API is
explained in the PDF):
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘œğ‘ğ‘˜ğ‘’ğ‘¡() â€“ Creating a RUDP socket and creating a handshake between two
peers.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘’ğ‘›ğ‘‘() â€“ Sending data to the peer. The function should wait for an
acknowledgment packet, and if it didnâ€™t receive any, retransmits the data.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘Ÿğ‘’ğ‘ğ‘£() â€“ Receive data from a peer.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ğ‘™ğ‘œğ‘ ğ‘’() â€“ Closes a connection between peers.
 Communication Networks Course
Page | 6
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a UDP socket between the Sender and the
Receiver.
3) Send the file via the RUDP protocol.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a UDP connection between the Receiver and
the Sender.
2) Get a connection from the sender, by the custom
RUDP protocol youâ€™ve built.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./RUDP_Receiver -p 1234
Starting Receiver...
Waiting for RUDP connection...
Connection request received, sending ACK.
Sender connected, beginning to receive file...
File transfer completed.
ACK sent.
Waiting for Sender response...
Sender sent exit message.
ACK sent.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 7
Part C â€“ Research â€“ 30 points
In this part, youâ€™ll conduct research about your implementations of part A and part B.
In the research itself, each one of the versions (TCP version and UDP version) will be run at
least 5 times (meaning that the file transfer will occur at least 5 times) by the following
conditions:
â€¢ For TCP, youâ€™ll run it in TCP Reno and TCP Cubic, alternating each time, for each
scenario, meaning that you run 5 times with TCP Reno in both Sender and Receiver,
and 5 times with TCP Cubic in both Sender and Receiver.
Bonus (5 points): Create a very large data set â€“ 5 times with TCP Reno in both Sender
and Receiver, 5 times with TCP Reno in Sender and TCP Cubic in Receiver, 5 times
with TCP Cubic in Sender and TCP Reno in Receiver, and 5 times with TCP Cubic in
both Sender and Receiver. This will give you a data set large enough, which allows
you to work with, compare with and to reach a definite conclusion.
â€¢ For RUDP, you will run it 5 times for each scenario.
â€¢ For both TCP and RUDP, you will run them on those scenarios of packet loss:
o 0% packet loss â€“ Control group, simulating perfect connection.
o 2% packet loss â€“ Simulating unstable connection that commonly occur.
o 5% packet loss â€“ Simulating bad connection.
o 10% packet loss â€“ Simulating extremely poor connection.
For each scenario, you must provide a filtered PCAP file and relevant screenshots that
explain each one of the steps in the process. (10 points)
After youâ€™ve gathered the data set for both TCP and Reliable UDP, answer the following
questions:
1) In TCP, which congestion control algorithm gave better results overall? TCP Reno or
TCP Cubic? Which one gave better results on high packet loss? Explain how you came
to this conclusion based on the data set youâ€™ve gathered. (5 points)
2) How did your implementation of Reliable UDP perform overall compared to regular
TCP? Which one is better for high packet loss? (5 points)
3) According to the data youâ€™ve gathered, in which scenarios and applications would we
prefer to use TCP and in which situations would we prefer to use reliable UDP?
Explain your answer. (5 points)
 Communication Networks Course
Page | 8
×¢× ×• ×¢×œ ×”×©××œ×•×ª ×”×‘××•×ª )5 × ×§×•×“×•×ª(:
â— ×‘"×¨×©×ª ×××™× ×”" ×”×›×•×•× ×” ×”×™× ×œ×¨×©×ª ×©×‘×” ××¢×˜ ×××•×“ ×—×‘×™×œ×•×ª ×”×•×œ×›×•×ª ×œ××™×‘×•×“. ×‘"×§×©×¨ ××¨×•×š" ×”×›×•×•× ×” ×”×™×
×œ×§×©×¨ TCP ×©×™×© ×‘×• ×”×¨×‘×” ×××•×“ ××™×“×¢ ×œ×©×œ×•×—. ××•×¦×¢ ×œ×”×’×“×™×œ ×‘ -TCP ××ª SSThreshold ×‘×ª×—×™×œ×ª ×”×§×©×¨.
×‘××™×–×” ××”××§×¨×™× ×”×‘××™× ×”×©×™× ×•×™ ×”×–×” ×¢×©×•×™ ×œ×”×•×¢×™×œ ×‘××™×“×” ×”××™×¨×‘×™×ª? × ××§.
.1 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
.2 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.3 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.4 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.5 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.6 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.7 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.8 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
â— A ×©×•×œ×— ×œ -B ×—×‘×™×œ×•×ª ××™×“×¢ ×‘×××¦×¢×•×ª ×§×©×¨ TCP. × ×ª×•×Ÿ ×›×™ ×”×§×©×¨ ××ª×—×™×œ ×¢× ×—×œ×•×Ÿ ×‘×’×•×“×œ 1MSS. ×”×§×©×¨
××¡×ª×™×™× ×‘×¤×¢× ×”×¨××©×•× ×” ×©×”×•× ××’×™×¢ ×œ -SSthresh. ×‘××”×œ×š ×”×§×©×¨ ×œ× ××•×‘×“×•×ª ×—×‘×™×œ×•×ª. × ×¡××Ÿ ×‘×§×™×¦×•×¨:
.SSthresh=S*MSS
× ×ª×•×Ÿ ×›×™ ×œ××•×¨×š ×›×œ ×”×§×©×¨ rwnd < MSS*S.
××”×™ ×”×ª×¤×•×§×” ×©×œ ×”×§×©×¨ ×-A ×œ-B( ×‘ -sec / Bytes )×‘×–××Ÿ ×”× "×œ? × ××§×™.
]S*MSS / [lg (S) * RTT*2 ×‘×¢×¨×š .1
]S*MSS / [S^0.5 * RTT*2 ×‘×¢×¨×š .2
S*MSS / RTT ×‘×¢×¨×š .3
S^2)*MSS / RTT( ×‘×¢×¨×š .4
â— ×©×ª×™ ×ª×—× ×•×ª ××ª×§×©×¨×•×ª ×‘××•×¤×Ÿ ××œ×—×•×˜×™ ×‘×©×™×˜×ª N Back Go.
× ×¡××Ÿ ×‘-X ××ª ×¡×¤×¨×ª ×”×‘×™×§×•×¨×ª ×©×œ ×”×ª.×–. ×©×œ×š. ×× ×©× ×™ ×©×•×ª×¤×™× ××’×™×©×™× ××ª ×”×ª×¨×’×™×œ ×™×—×“, X ×”×•× ×¡×¤×¨×ª
×”×‘×™×§×•×¨×ª ×‘×¢×œ×ª ×”×¢×¨×š ×”× ××•×š ×™×•×ª×¨ ××‘×™×Ÿ ×”×©×ª×™×™×.
×§×¦×‘ ×”×ª×§×©×•×¨×ª ×”×•× 8Gbps, ×•×’×•×“×œ ×›×œ ×—×‘×™×œ×” ×”×•× KByte*X. ×’×“×œ×™ ×”-headers ×•×” -Acks ×–× ×™×—×™×.
ï¿½ğ‘’ğ‘ ï¿½/ï¿½ï¿½ 8 , ×•×”××¨×—×§ ×‘×™×Ÿ ×”×ª×—× ×•×ª ×”×•× 1Km. ×§×¦×‘ ×”×”×ª×¤×©×˜×•×ª ×”×•× 10 â‹… 2
×–××Ÿ ×¢×™×‘×•×“ ×”× ×ª×•× ×™× ×‘×ª×—× ×•×ª ×–× ×™×—.
××£ ×—×‘×™×œ×” ×•××£ Ack ×œ× ×”×•×œ×›×™× ×œ××™×‘×•×“.
â— ××”×• X ×©×œ×š?
â— ××” ×¦×¨×™×š ×œ×”×™×•×ª ×’×•×“×œ ×—×œ×•×Ÿ ×”××©×œ×•×— ×›×“×™ ×œ×”×‘×˜×™×— ×ª×¤×•×§×” ××§×¡×™××œ×™×ª?
 Communication Networks Course
Page | 9
Bonus â€“ Improving the Reliable UDP â€“ 15 points
Note: This part isnâ€™t mandatory and is a bonus only!
In this part, youâ€™ll improve your RUDP implementation by adding the concepts of flow
control and congestion control from TCP. Youâ€™re free to choose which algorithms to
implement, as long as you explain in your PDF which algorithms youâ€™ve used. Youâ€™ll probably
need to make changes in the original design of the RUDP. Changes only need to be to the API
itself, ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„.
Points distribution:
â€¢ Flow control improvement â€“ 7 Points
â€¢ Congestion control improvement â€“ 8 points.
Guidance:
â€¢ For flow control, you must use one of the Sliding window techniques: stop-and-wait
ARQ, Go-Back-N or Selective repeat.
â€¢ List of known TCP congestion control algorithms, which you can use any one of them
for this bonus task, or makeup your own:
Figure 2 â€“ List of known TCP congestion control algorithms, Wikipedia
 Communication Networks Course
Page | 10
Appendix A â€“ Linux local packet loss tool
To simulate a packet loss in a local network, we'll use a Linux tool that's called Linux Traffic
Control (ğ‘¡ğ‘). This requires a full Linux installation, so working with WSL won't work.
If the tool isn't installed in your machine, you can install it by using the following commands:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’
If the installation didn't work, you can use the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’2
To create a packet loss scenario, type the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘ğ‘‘ğ‘‘ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
After creating a packet loss scenario, you can change the percentage by typing the following
command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘â„ğ‘ğ‘›ğ‘”ğ‘’ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
To remove the packet loss scenario, write the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘‘ğ‘’ğ‘™ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š
 Communication Networks Course
Page | 11
Appendix B â€“ ğ’ğ’‚ğ’(ğŸ) system calls
This appendixâ€™s purpose is to give you a better understanding of socket handling in C.
A recommended reference is Beejâ€™s Guide to Network Programming, by Brian â€œBeej
Jorgensenâ€ Hall, which gives a lot of information about sockets in C and functions.
Functions and documentation links:
â€¢ ğ’”ğ’ğ’„ğ’Œğ’†ğ’•(ğŸ) â€“ A Factory method system call that creates a socket with the given
parameters.
â€¢ ğ’ƒğ’Šğ’ğ’…(ğŸ) â€“ Whenever we create a new socket, we need to bind it to a specific port in
our machine, â€œto catch a portâ€. The port number is managed and used by the kernel
to link incoming packets to the corresponding application socket. The port numbers
are usually fixed. The ğ‘ğ‘‘ğ‘‘ğ‘Ÿ parameter must match the current socket that is used.
â€¢ ğ’ğ’Šğ’”ğ’•ğ’†ğ’(ğŸ) â€“ The ğ‘™ğ‘–ğ‘ ğ‘¡ğ‘’ğ‘›(2) system call doesn't do anything in the mean of
communication but only memory allocation (malloc) for stream sockets only. If we
won't allocate memory, any incoming connection will fail.
â€¢ ğ’„ğ’ğ’ğ’ğ’†ğ’„ğ’•(ğŸ) â€“ The ğ‘ğ‘œğ‘›ğ‘›ğ‘’ğ‘ğ‘¡(2) system call starts the link between a client and a
specific IP address and port number. The connection would complete when the
other side will call the ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call.
â€¢ ğ’‚ğ’„ğ’„ğ’†ğ’‘ğ’•(ğŸ) â€“ The ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call accepts the incoming stream connection
request from the other side, by the listening socket. This system call completes the
three-way handshake of stream socket (like TCP) and opens a new socket that has a
direct communication channel only with the other party in the handshake.
â€¢ ğ’”ğ’†ğ’ğ’…(ğŸ) and ğ’”ğ’†ğ’ğ’…ğ’•ğ’(ğŸ) â€“ The ğ‘ ğ‘’ğ‘›ğ‘‘(2) and ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system calls are an analogy
for the ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’(2) system call, specifcly for sockets, with flags set to 0. Those system
calls return the number of bytes that were sent through the socket itself, as the
number of bytes can vary. The ğ‘ ğ‘’ğ‘›ğ‘‘(2)system call designed for stream sockets (like
TCP), while the ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system call designed for datagram connection-less
sockets (like UDP). When the ğ‘ ğ‘’ğ‘›ğ‘‘(2) system call returns 0, it means that the other
party closed the connection.
â€¢ ğ’“ğ’†ğ’„ğ’—(ğŸ) and ğ’“ğ’†ğ’„ğ’—ğ’‡ğ’“ğ’ğ’(ğŸ) â€“ The ğ‘Ÿğ‘’ğ‘ğ‘£(2) and ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system calls are an
analogy for the ğ‘Ÿğ‘’ğ‘ğ‘‘(2) system call, specifically for sockets, with flags set to 0.
Those system calls return the number of bytes that were received through the socket
itself, as the number of bytes can vary. The ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call designed for stream
sockets (like TCP), while the ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system call designed for datagram
connection-less sockets (like UDP). When the ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call returns 0, it means
that the other party closed the connection.
â€¢ ğ’„ğ’ğ’ğ’”ğ’†(ğŸ) and ğ’”ğ’‰ğ’–ğ’•ğ’…ğ’ğ’˜ğ’(ğŸ) â€“ The ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) and ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2) system calls close
the socket. While ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) system call closes the whole socket, the ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2)
system call partially closes the socket for read/write.
 Communication Networks Course
Page | 12
Appendix C â€“ Random data generator
The data that you are going to send in this assignment is randomly generated. You can use
your own file with appropriate size or use the following function (or a function of your own)
to generate the data:
/*
* @brief A random data generator function based on srand() and rand().
* @param size The size of the data to generate (up to 2^32 bytes).
* @return A pointer to the buffer.
*/
char *util_generate_random_data(unsigned int size) {
 char *buffer = NULL;
 // Argument check.
 if (size == 0)
 return NULL;
 buffer = (char *)calloc(size, sizeof(char));
 // Error checking.
 if (buffer == NULL)
 return NULL;
 // Randomize the seed of the random number generator.
 srand(time(NULL));
 for (unsigned int i = 0; i < size; i++)
 *(buffer + i) = ((unsigned int)rand() % 256);
 return buffer;
}
 Communication Networks Course
Page | 13
Appendix D â€“ Checksum function
A checksum is a small-sized block of data derived from another block of digital data for the
purpose of detecting errors that may have been introduced during its transmission or
storage. By themselves, checksums are often used to verify data integrity but are not relied
upon to verify data authenticity.
Below is a simple yet efficient implementation of the checksum function, you can use it for
the assignment, but you can implement your own checksum function.
/*
* @brief A checksum function that returns 16 bit checksum for data.
* @param data The data to do the checksum for.
* @param bytes The length of the data in bytes.
* @return The checksum itself as 16 bit unsigned number.
* @note This function is taken from RFC1071, can be found here:
* @note https://tools.ietf.org/html/rfc1071
* @note It is the simplest way to calculate a checksum and is not very strong.
* However, it is good enough for this assignment.
* @note You are free to use any other checksum function as well.
* You can also use this function as such without any change.
*/
unsigned short int calculate_checksum(void *data, unsigned int bytes) {
 unsigned short int *data_pointer = (unsigned short int *)data;
 unsigned int total_sum = 0;
 // Main summing loop
 while (bytes > 1) {
 total_sum += *data_pointer++;
 bytes -= 2;
 }
 // Add left-over byte, if any
 if (bytes > 0)
 total_sum += *((unsigned char *)data_pointer);
 // Fold 32-bit sum to 16 bits
 while (total_sum >> 16)
 total_sum = (total_sum & 0xFFFF) + (total_sum >> 16);
 return (~((unsigned short int)total_sum));
} Communication Networks Course
Page | 1
Assignment 3 â€“ Transport Layer
Assignment Notes and Instructions
This assignment is to be done in pairs only. You must upload all the necessary files in a ZIP
file named after both of the studentâ€™s ID. For example: ğŸğŸğŸ‘ğŸ’ğŸ“ğŸ”ğŸ•ğŸ–ğŸ—_ğŸ—ğŸ–ğŸ•ğŸ”ğŸ“ğŸ’ğŸ‘ğŸğŸ. ğ’›ğ’Šğ’‘.
1) The assignment must be submitted by the date specified in the submission box.
2) All the assignment files (Code, Wireshark pcap files, PDF) must be submitted in a ZIP file. The
PDF must contain all the necessary screenshots with a description for each one of them.
3) The assignment must be done in pairs only. In exceptional cases, you should send an email to
the course coordinator.
4) You can use any reference material available through the course Moodle website or any
material passed during the exercises.
5) You can use any reference from the web, but copying codes from websites is forbidden; this
includes codes from other GitHub repositories. A student who gets caught in the act will
automatically fail this assignment (score 0). Any website youâ€™ve used to solve the
assignment, every website you used to solve the assignment must be noted in the PDF.
6) No delays in submission without special permission. Lateness without approval will result in
failure of the assignment (score 0).
7) All submissions will be submitted via the course's Moodle website. Email submissions will not
be accepted, resulting in a failure in the assignment.
8) The order and design of the code must be carefully considered. Make sure that the program
output is as clear as possible, comments in the code, and meaningful variable names. You
must also submit a makefile that compiles all the programs.
9) The assignment code must be written in C only.
10) The assignment is personal for each pair, and you should not accept help from other people,
whether outside the university or inside it. You can contact the course staff during reception
hours for help or raise a question in the course forum. Do not transfer code sections
between students, upload solutions or parts of solutions to websites on the Internet or in
various communication groups.
11) Students who copy a solution will receive a 0 in all assignments in the course and a report will
be made to the institutional disciplinary committee.
12) All code files of the assignment are required to both compile and run properly on the Ubuntu
22.04 LTS operating system. This is the operating system where the submissions will be
tested. You mustnâ€™t code it in Windows, as it uses different API for sockets. WSL wonâ€™t work,
as the task needs a tool that works only in a fully Linux environment.
Good Luck!
 Communication Networks Course
Page | 2
Part A â€“ Transmission Control Protocol (TCP) â€“ 30 points
In this part, youâ€™ll write two program files: ğ‘»ğ‘ªğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and ğ‘»ğ‘ªğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
The Sender will send a randomly generated file and the Receiver will receive it and measure
the time it took for his program to receive the file. The file size should be at least 2MB.
When running the Sender and Receiver, they both should support two standard congestion
control algorithms: TCP Reno and TCP Cubic.
Notes:
â€¢ The main goal of this part is to get familiar with the TCP concept of sending
messages between two endpoints.
â€¢ For approaching this part of the assignment, please be sure that you are familiar
with the congestion control algorithms and how to change them using the correct
method in C (see Appendix B for more information).
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). You've
learned that TCP is reliable by design, so you can assume that all the data have been
passed correctly, and thus, no need to recheck.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
Usage:
â€¢ Receiver:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
â€¢ Sender:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port of the Receiver.
â€¢ ğ‘¨ğ‘³ğ‘®ğ‘¶ â€“ The TCP congestion control algorithm that will be used by the party
member (either ğ’“ğ’†ğ’ğ’ for TCP Reno or ğ’„ğ’–ğ’ƒğ’Šğ’„ for TCP Cubic).
 Communication Networks Course
Page | 3
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a TCP socket between the Sender and the
Receiver.
3) Send the file.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a TCP connection between the Receiver and
the Sender.
2) Get a connection from the sender.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./TCP_Receiver -p 1234 -algo reno
Starting Receiver...
Waiting for TCP connection...
Sender connected, beginning to receive file...
File transfer completed.
Waiting for Sender response...
Sender sent exit message.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 4
Part B â€“ Reliable User Datagram Protocol (Reliable UDP or RUDP) â€“ 40 points
Youâ€™ve learned that while TCP is reliable, it lacks speed and has an overhead data of 20 bytes,
compering to UDP that needs only 8 bytes of overhead data.
Reliable UDP or RUDP, is a protocol that uses the UDP protocol for a faster transmission of
data, while adding a reliability layer to it, but without adding too much overhead data like
TCP.
A simple sketch for a RUDP connection would look something like this:
Your task in this part is to implement a Reliable protocol using UDP only. For simplicity, your
implementation should only support a handshake, closing scheme, error checking,
acknowledgment of received packets, and retransmission of lost packets.
Guidance:
â€¢ You can use ğ‘ ğ‘’ğ‘¡ğ‘ ğ‘œğ‘ğ‘˜ğ‘œğ‘ğ‘¡(2) for detecting a timeout.
â€¢ You need to build your own protocol, as Reliable UDP isnâ€™t a standard protocol (see a
draft of RUDP in this link), and no official header is provided. You can use this sketch
for a header, but you can come up with your own protocol, as long as it works.
Where:
o ğ‘³ğ’†ğ’ğ’ˆğ’•ğ’‰ is the length of the data itself, without the RUDP header.
o ğ‘ªğ’‰ğ’†ğ’„ğ’Œğ’”ğ’–ğ’ is a 16bit number that validates the correctness of the data.
o ğ‘­ğ’ğ’‚ğ’ˆğ’” is a special byte where we classify the packet itself (SYN, ACK, etc.).
â€¢ In your PDF, you must explain how your implementation of RUDP works â€“ How does
it detect a timeout to do retransmissions, how does the handshake work, what is the
header overhead, etc.
â€¢ For this part, youâ€™ll write three files: ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¨ğ‘·ğ‘°. ğ’„, ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and
ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
Reliable UDP Header proposed sketch
Byte 0 Byte 1 Byte 2 Byte 3
Length (2 Bytes) Checksum (2 Bytes)
Flags (1 Byte)
Figure 1 - RUDP Protocol Architecture, Geeksforgeeks
 Communication Networks Course
Page | 5
Notes:
â€¢ The Sender will send a random generated file and the Receiver will receive it and
measure the time it took for his program to receive the file. The file size should be at
least 2MB.
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). But, as the
RUDP is based on UDP, itâ€™s not reliable. You must use some form of error checking
(like checksum) to ensure that the packet wasnâ€™t alerted during the transfer.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
â€¢ The RUDP needs support only 1 sender and 1 receiver, for simplicity purposes.
Usage:
â€¢ Receiver:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
â€¢ Sender:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port that both the Sender and the Receiver will use.
The ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„ file will contain all the implementations of the RUDP API functions (That is, to
prevent reusing the same chuck of code both in the Sender and the Receiver.).
The API should support at the bare minimum the following functions (you decide what
parameters to implement, and what are the names of the functions, as long as the API is
explained in the PDF):
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘œğ‘ğ‘˜ğ‘’ğ‘¡() â€“ Creating a RUDP socket and creating a handshake between two
peers.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘’ğ‘›ğ‘‘() â€“ Sending data to the peer. The function should wait for an
acknowledgment packet, and if it didnâ€™t receive any, retransmits the data.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘Ÿğ‘’ğ‘ğ‘£() â€“ Receive data from a peer.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ğ‘™ğ‘œğ‘ ğ‘’() â€“ Closes a connection between peers.
 Communication Networks Course
Page | 6
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a UDP socket between the Sender and the
Receiver.
3) Send the file via the RUDP protocol.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a UDP connection between the Receiver and
the Sender.
2) Get a connection from the sender, by the custom
RUDP protocol youâ€™ve built.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./RUDP_Receiver -p 1234
Starting Receiver...
Waiting for RUDP connection...
Connection request received, sending ACK.
Sender connected, beginning to receive file...
File transfer completed.
ACK sent.
Waiting for Sender response...
Sender sent exit message.
ACK sent.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 7
Part C â€“ Research â€“ 30 points
In this part, youâ€™ll conduct research about your implementations of part A and part B.
In the research itself, each one of the versions (TCP version and UDP version) will be run at
least 5 times (meaning that the file transfer will occur at least 5 times) by the following
conditions:
â€¢ For TCP, youâ€™ll run it in TCP Reno and TCP Cubic, alternating each time, for each
scenario, meaning that you run 5 times with TCP Reno in both Sender and Receiver,
and 5 times with TCP Cubic in both Sender and Receiver.
Bonus (5 points): Create a very large data set â€“ 5 times with TCP Reno in both Sender
and Receiver, 5 times with TCP Reno in Sender and TCP Cubic in Receiver, 5 times
with TCP Cubic in Sender and TCP Reno in Receiver, and 5 times with TCP Cubic in
both Sender and Receiver. This will give you a data set large enough, which allows
you to work with, compare with and to reach a definite conclusion.
â€¢ For RUDP, you will run it 5 times for each scenario.
â€¢ For both TCP and RUDP, you will run them on those scenarios of packet loss:
o 0% packet loss â€“ Control group, simulating perfect connection.
o 2% packet loss â€“ Simulating unstable connection that commonly occur.
o 5% packet loss â€“ Simulating bad connection.
o 10% packet loss â€“ Simulating extremely poor connection.
For each scenario, you must provide a filtered PCAP file and relevant screenshots that
explain each one of the steps in the process. (10 points)
After youâ€™ve gathered the data set for both TCP and Reliable UDP, answer the following
questions:
1) In TCP, which congestion control algorithm gave better results overall? TCP Reno or
TCP Cubic? Which one gave better results on high packet loss? Explain how you came
to this conclusion based on the data set youâ€™ve gathered. (5 points)
2) How did your implementation of Reliable UDP perform overall compared to regular
TCP? Which one is better for high packet loss? (5 points)
3) According to the data youâ€™ve gathered, in which scenarios and applications would we
prefer to use TCP and in which situations would we prefer to use reliable UDP?
Explain your answer. (5 points)
 Communication Networks Course
Page | 8
×¢× ×• ×¢×œ ×”×©××œ×•×ª ×”×‘××•×ª )5 × ×§×•×“×•×ª(:
â— ×‘"×¨×©×ª ×××™× ×”" ×”×›×•×•× ×” ×”×™× ×œ×¨×©×ª ×©×‘×” ××¢×˜ ×××•×“ ×—×‘×™×œ×•×ª ×”×•×œ×›×•×ª ×œ××™×‘×•×“. ×‘"×§×©×¨ ××¨×•×š" ×”×›×•×•× ×” ×”×™×
×œ×§×©×¨ TCP ×©×™×© ×‘×• ×”×¨×‘×” ×××•×“ ××™×“×¢ ×œ×©×œ×•×—. ××•×¦×¢ ×œ×”×’×“×™×œ ×‘ -TCP ××ª SSThreshold ×‘×ª×—×™×œ×ª ×”×§×©×¨.
×‘××™×–×” ××”××§×¨×™× ×”×‘××™× ×”×©×™× ×•×™ ×”×–×” ×¢×©×•×™ ×œ×”×•×¢×™×œ ×‘××™×“×” ×”××™×¨×‘×™×ª? × ××§.
.1 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
.2 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.3 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.4 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.5 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.6 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.7 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.8 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
â— A ×©×•×œ×— ×œ -B ×—×‘×™×œ×•×ª ××™×“×¢ ×‘×××¦×¢×•×ª ×§×©×¨ TCP. × ×ª×•×Ÿ ×›×™ ×”×§×©×¨ ××ª×—×™×œ ×¢× ×—×œ×•×Ÿ ×‘×’×•×“×œ 1MSS. ×”×§×©×¨
××¡×ª×™×™× ×‘×¤×¢× ×”×¨××©×•× ×” ×©×”×•× ××’×™×¢ ×œ -SSthresh. ×‘××”×œ×š ×”×§×©×¨ ×œ× ××•×‘×“×•×ª ×—×‘×™×œ×•×ª. × ×¡××Ÿ ×‘×§×™×¦×•×¨:
.SSthresh=S*MSS
× ×ª×•×Ÿ ×›×™ ×œ××•×¨×š ×›×œ ×”×§×©×¨ rwnd < MSS*S.
××”×™ ×”×ª×¤×•×§×” ×©×œ ×”×§×©×¨ ×-A ×œ-B( ×‘ -sec / Bytes )×‘×–××Ÿ ×”× "×œ? × ××§×™.
]S*MSS / [lg (S) * RTT*2 ×‘×¢×¨×š .1
]S*MSS / [S^0.5 * RTT*2 ×‘×¢×¨×š .2
S*MSS / RTT ×‘×¢×¨×š .3
S^2)*MSS / RTT( ×‘×¢×¨×š .4
â— ×©×ª×™ ×ª×—× ×•×ª ××ª×§×©×¨×•×ª ×‘××•×¤×Ÿ ××œ×—×•×˜×™ ×‘×©×™×˜×ª N Back Go.
× ×¡××Ÿ ×‘-X ××ª ×¡×¤×¨×ª ×”×‘×™×§×•×¨×ª ×©×œ ×”×ª.×–. ×©×œ×š. ×× ×©× ×™ ×©×•×ª×¤×™× ××’×™×©×™× ××ª ×”×ª×¨×’×™×œ ×™×—×“, X ×”×•× ×¡×¤×¨×ª
×”×‘×™×§×•×¨×ª ×‘×¢×œ×ª ×”×¢×¨×š ×”× ××•×š ×™×•×ª×¨ ××‘×™×Ÿ ×”×©×ª×™×™×.
×§×¦×‘ ×”×ª×§×©×•×¨×ª ×”×•× 8Gbps, ×•×’×•×“×œ ×›×œ ×—×‘×™×œ×” ×”×•× KByte*X. ×’×“×œ×™ ×”-headers ×•×” -Acks ×–× ×™×—×™×.
ï¿½ğ‘’ğ‘ ï¿½/ï¿½ï¿½ 8 , ×•×”××¨×—×§ ×‘×™×Ÿ ×”×ª×—× ×•×ª ×”×•× 1Km. ×§×¦×‘ ×”×”×ª×¤×©×˜×•×ª ×”×•× 10 â‹… 2
×–××Ÿ ×¢×™×‘×•×“ ×”× ×ª×•× ×™× ×‘×ª×—× ×•×ª ×–× ×™×—.
××£ ×—×‘×™×œ×” ×•××£ Ack ×œ× ×”×•×œ×›×™× ×œ××™×‘×•×“.
â— ××”×• X ×©×œ×š?
â— ××” ×¦×¨×™×š ×œ×”×™×•×ª ×’×•×“×œ ×—×œ×•×Ÿ ×”××©×œ×•×— ×›×“×™ ×œ×”×‘×˜×™×— ×ª×¤×•×§×” ××§×¡×™××œ×™×ª?
 Communication Networks Course
Page | 9
Bonus â€“ Improving the Reliable UDP â€“ 15 points
Note: This part isnâ€™t mandatory and is a bonus only!
In this part, youâ€™ll improve your RUDP implementation by adding the concepts of flow
control and congestion control from TCP. Youâ€™re free to choose which algorithms to
implement, as long as you explain in your PDF which algorithms youâ€™ve used. Youâ€™ll probably
need to make changes in the original design of the RUDP. Changes only need to be to the API
itself, ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„.
Points distribution:
â€¢ Flow control improvement â€“ 7 Points
â€¢ Congestion control improvement â€“ 8 points.
Guidance:
â€¢ For flow control, you must use one of the Sliding window techniques: stop-and-wait
ARQ, Go-Back-N or Selective repeat.
â€¢ List of known TCP congestion control algorithms, which you can use any one of them
for this bonus task, or makeup your own:
Figure 2 â€“ List of known TCP congestion control algorithms, Wikipedia
 Communication Networks Course
Page | 10
Appendix A â€“ Linux local packet loss tool
To simulate a packet loss in a local network, we'll use a Linux tool that's called Linux Traffic
Control (ğ‘¡ğ‘). This requires a full Linux installation, so working with WSL won't work.
If the tool isn't installed in your machine, you can install it by using the following commands:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’
If the installation didn't work, you can use the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’2
To create a packet loss scenario, type the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘ğ‘‘ğ‘‘ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
After creating a packet loss scenario, you can change the percentage by typing the following
command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘â„ğ‘ğ‘›ğ‘”ğ‘’ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
To remove the packet loss scenario, write the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘‘ğ‘’ğ‘™ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š
 Communication Networks Course
Page | 11
Appendix B â€“ ğ’ğ’‚ğ’(ğŸ) system calls
This appendixâ€™s purpose is to give you a better understanding of socket handling in C.
A recommended reference is Beejâ€™s Guide to Network Programming, by Brian â€œBeej
Jorgensenâ€ Hall, which gives a lot of information about sockets in C and functions.
Functions and documentation links:
â€¢ ğ’”ğ’ğ’„ğ’Œğ’†ğ’•(ğŸ) â€“ A Factory method system call that creates a socket with the given
parameters.
â€¢ ğ’ƒğ’Šğ’ğ’…(ğŸ) â€“ Whenever we create a new socket, we need to bind it to a specific port in
our machine, â€œto catch a portâ€. The port number is managed and used by the kernel
to link incoming packets to the corresponding application socket. The port numbers
are usually fixed. The ğ‘ğ‘‘ğ‘‘ğ‘Ÿ parameter must match the current socket that is used.
â€¢ ğ’ğ’Šğ’”ğ’•ğ’†ğ’(ğŸ) â€“ The ğ‘™ğ‘–ğ‘ ğ‘¡ğ‘’ğ‘›(2) system call doesn't do anything in the mean of
communication but only memory allocation (malloc) for stream sockets only. If we
won't allocate memory, any incoming connection will fail.
â€¢ ğ’„ğ’ğ’ğ’ğ’†ğ’„ğ’•(ğŸ) â€“ The ğ‘ğ‘œğ‘›ğ‘›ğ‘’ğ‘ğ‘¡(2) system call starts the link between a client and a
specific IP address and port number. The connection would complete when the
other side will call the ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call.
â€¢ ğ’‚ğ’„ğ’„ğ’†ğ’‘ğ’•(ğŸ) â€“ The ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call accepts the incoming stream connection
request from the other side, by the listening socket. This system call completes the
three-way handshake of stream socket (like TCP) and opens a new socket that has a
direct communication channel only with the other party in the handshake.
â€¢ ğ’”ğ’†ğ’ğ’…(ğŸ) and ğ’”ğ’†ğ’ğ’…ğ’•ğ’(ğŸ) â€“ The ğ‘ ğ‘’ğ‘›ğ‘‘(2) and ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system calls are an analogy
for the ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’(2) system call, specifcly for sockets, with flags set to 0. Those system
calls return the number of bytes that were sent through the socket itself, as the
number of bytes can vary. The ğ‘ ğ‘’ğ‘›ğ‘‘(2)system call designed for stream sockets (like
TCP), while the ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system call designed for datagram connection-less
sockets (like UDP). When the ğ‘ ğ‘’ğ‘›ğ‘‘(2) system call returns 0, it means that the other
party closed the connection.
â€¢ ğ’“ğ’†ğ’„ğ’—(ğŸ) and ğ’“ğ’†ğ’„ğ’—ğ’‡ğ’“ğ’ğ’(ğŸ) â€“ The ğ‘Ÿğ‘’ğ‘ğ‘£(2) and ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system calls are an
analogy for the ğ‘Ÿğ‘’ğ‘ğ‘‘(2) system call, specifically for sockets, with flags set to 0.
Those system calls return the number of bytes that were received through the socket
itself, as the number of bytes can vary. The ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call designed for stream
sockets (like TCP), while the ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system call designed for datagram
connection-less sockets (like UDP). When the ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call returns 0, it means
that the other party closed the connection.
â€¢ ğ’„ğ’ğ’ğ’”ğ’†(ğŸ) and ğ’”ğ’‰ğ’–ğ’•ğ’…ğ’ğ’˜ğ’(ğŸ) â€“ The ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) and ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2) system calls close
the socket. While ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) system call closes the whole socket, the ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2)
system call partially closes the socket for read/write.
 Communication Networks Course
Page | 12
Appendix C â€“ Random data generator
The data that you are going to send in this assignment is randomly generated. You can use
your own file with appropriate size or use the following function (or a function of your own)
to generate the data:
/*
* @brief A random data generator function based on srand() and rand().
* @param size The size of the data to generate (up to 2^32 bytes).
* @return A pointer to the buffer.
*/
char *util_generate_random_data(unsigned int size) {
 char *buffer = NULL;
 // Argument check.
 if (size == 0)
 return NULL;
 buffer = (char *)calloc(size, sizeof(char));
 // Error checking.
 if (buffer == NULL)
 return NULL;
 // Randomize the seed of the random number generator.
 srand(time(NULL));
 for (unsigned int i = 0; i < size; i++)
 *(buffer + i) = ((unsigned int)rand() % 256);
 return buffer;
}
 Communication Networks Course
Page | 13
Appendix D â€“ Checksum function
A checksum is a small-sized block of data derived from another block of digital data for the
purpose of detecting errors that may have been introduced during its transmission or
storage. By themselves, checksums are often used to verify data integrity but are not relied
upon to verify data authenticity.
Below is a simple yet efficient implementation of the checksum function, you can use it for
the assignment, but you can implement your own checksum function.
/*
* @brief A checksum function that returns 16 bit checksum for data.
* @param data The data to do the checksum for.
* @param bytes The length of the data in bytes.
* @return The checksum itself as 16 bit unsigned number.
* @note This function is taken from RFC1071, can be found here:
* @note https://tools.ietf.org/html/rfc1071
* @note It is the simplest way to calculate a checksum and is not very strong.
* However, it is good enough for this assignment.
* @note You are free to use any other checksum function as well.
* You can also use this function as such without any change.
*/
unsigned short int calculate_checksum(void *data, unsigned int bytes) {
 unsigned short int *data_pointer = (unsigned short int *)data;
 unsigned int total_sum = 0;
 // Main summing loop
 while (bytes > 1) {
 total_sum += *data_pointer++;
 bytes -= 2;
 }
 // Add left-over byte, if any
 if (bytes > 0)
 total_sum += *((unsigned char *)data_pointer);
 // Fold 32-bit sum to 16 bits
 while (total_sum >> 16)
 total_sum = (total_sum & 0xFFFF) + (total_sum >> 16);
 return (~((unsigned short int)total_sum));
} Communication Networks Course
Page | 1
Assignment 3 â€“ Transport Layer
Assignment Notes and Instructions
This assignment is to be done in pairs only. You must upload all the necessary files in a ZIP
file named after both of the studentâ€™s ID. For example: ğŸğŸğŸ‘ğŸ’ğŸ“ğŸ”ğŸ•ğŸ–ğŸ—_ğŸ—ğŸ–ğŸ•ğŸ”ğŸ“ğŸ’ğŸ‘ğŸğŸ. ğ’›ğ’Šğ’‘.
1) The assignment must be submitted by the date specified in the submission box.
2) All the assignment files (Code, Wireshark pcap files, PDF) must be submitted in a ZIP file. The
PDF must contain all the necessary screenshots with a description for each one of them.
3) The assignment must be done in pairs only. In exceptional cases, you should send an email to
the course coordinator.
4) You can use any reference material available through the course Moodle website or any
material passed during the exercises.
5) You can use any reference from the web, but copying codes from websites is forbidden; this
includes codes from other GitHub repositories. A student who gets caught in the act will
automatically fail this assignment (score 0). Any website youâ€™ve used to solve the
assignment, every website you used to solve the assignment must be noted in the PDF.
6) No delays in submission without special permission. Lateness without approval will result in
failure of the assignment (score 0).
7) All submissions will be submitted via the course's Moodle website. Email submissions will not
be accepted, resulting in a failure in the assignment.
8) The order and design of the code must be carefully considered. Make sure that the program
output is as clear as possible, comments in the code, and meaningful variable names. You
must also submit a makefile that compiles all the programs.
9) The assignment code must be written in C only.
10) The assignment is personal for each pair, and you should not accept help from other people,
whether outside the university or inside it. You can contact the course staff during reception
hours for help or raise a question in the course forum. Do not transfer code sections
between students, upload solutions or parts of solutions to websites on the Internet or in
various communication groups.
11) Students who copy a solution will receive a 0 in all assignments in the course and a report will
be made to the institutional disciplinary committee.
12) All code files of the assignment are required to both compile and run properly on the Ubuntu
22.04 LTS operating system. This is the operating system where the submissions will be
tested. You mustnâ€™t code it in Windows, as it uses different API for sockets. WSL wonâ€™t work,
as the task needs a tool that works only in a fully Linux environment.
Good Luck!
 Communication Networks Course
Page | 2
Part A â€“ Transmission Control Protocol (TCP) â€“ 30 points
In this part, youâ€™ll write two program files: ğ‘»ğ‘ªğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and ğ‘»ğ‘ªğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
The Sender will send a randomly generated file and the Receiver will receive it and measure
the time it took for his program to receive the file. The file size should be at least 2MB.
When running the Sender and Receiver, they both should support two standard congestion
control algorithms: TCP Reno and TCP Cubic.
Notes:
â€¢ The main goal of this part is to get familiar with the TCP concept of sending
messages between two endpoints.
â€¢ For approaching this part of the assignment, please be sure that you are familiar
with the congestion control algorithms and how to change them using the correct
method in C (see Appendix B for more information).
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). You've
learned that TCP is reliable by design, so you can assume that all the data have been
passed correctly, and thus, no need to recheck.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
Usage:
â€¢ Receiver:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
â€¢ Sender:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port of the Receiver.
â€¢ ğ‘¨ğ‘³ğ‘®ğ‘¶ â€“ The TCP congestion control algorithm that will be used by the party
member (either ğ’“ğ’†ğ’ğ’ for TCP Reno or ğ’„ğ’–ğ’ƒğ’Šğ’„ for TCP Cubic).
 Communication Networks Course
Page | 3
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a TCP socket between the Sender and the
Receiver.
3) Send the file.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a TCP connection between the Receiver and
the Sender.
2) Get a connection from the sender.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./TCP_Receiver -p 1234 -algo reno
Starting Receiver...
Waiting for TCP connection...
Sender connected, beginning to receive file...
File transfer completed.
Waiting for Sender response...
Sender sent exit message.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 4
Part B â€“ Reliable User Datagram Protocol (Reliable UDP or RUDP) â€“ 40 points
Youâ€™ve learned that while TCP is reliable, it lacks speed and has an overhead data of 20 bytes,
compering to UDP that needs only 8 bytes of overhead data.
Reliable UDP or RUDP, is a protocol that uses the UDP protocol for a faster transmission of
data, while adding a reliability layer to it, but without adding too much overhead data like
TCP.
A simple sketch for a RUDP connection would look something like this:
Your task in this part is to implement a Reliable protocol using UDP only. For simplicity, your
implementation should only support a handshake, closing scheme, error checking,
acknowledgment of received packets, and retransmission of lost packets.
Guidance:
â€¢ You can use ğ‘ ğ‘’ğ‘¡ğ‘ ğ‘œğ‘ğ‘˜ğ‘œğ‘ğ‘¡(2) for detecting a timeout.
â€¢ You need to build your own protocol, as Reliable UDP isnâ€™t a standard protocol (see a
draft of RUDP in this link), and no official header is provided. You can use this sketch
for a header, but you can come up with your own protocol, as long as it works.
Where:
o ğ‘³ğ’†ğ’ğ’ˆğ’•ğ’‰ is the length of the data itself, without the RUDP header.
o ğ‘ªğ’‰ğ’†ğ’„ğ’Œğ’”ğ’–ğ’ is a 16bit number that validates the correctness of the data.
o ğ‘­ğ’ğ’‚ğ’ˆğ’” is a special byte where we classify the packet itself (SYN, ACK, etc.).
â€¢ In your PDF, you must explain how your implementation of RUDP works â€“ How does
it detect a timeout to do retransmissions, how does the handshake work, what is the
header overhead, etc.
â€¢ For this part, youâ€™ll write three files: ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¨ğ‘·ğ‘°. ğ’„, ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and
ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
Reliable UDP Header proposed sketch
Byte 0 Byte 1 Byte 2 Byte 3
Length (2 Bytes) Checksum (2 Bytes)
Flags (1 Byte)
Figure 1 - RUDP Protocol Architecture, Geeksforgeeks
 Communication Networks Course
Page | 5
Notes:
â€¢ The Sender will send a random generated file and the Receiver will receive it and
measure the time it took for his program to receive the file. The file size should be at
least 2MB.
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). But, as the
RUDP is based on UDP, itâ€™s not reliable. You must use some form of error checking
(like checksum) to ensure that the packet wasnâ€™t alerted during the transfer.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
â€¢ The RUDP needs support only 1 sender and 1 receiver, for simplicity purposes.
Usage:
â€¢ Receiver:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
â€¢ Sender:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port that both the Sender and the Receiver will use.
The ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„ file will contain all the implementations of the RUDP API functions (That is, to
prevent reusing the same chuck of code both in the Sender and the Receiver.).
The API should support at the bare minimum the following functions (you decide what
parameters to implement, and what are the names of the functions, as long as the API is
explained in the PDF):
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘œğ‘ğ‘˜ğ‘’ğ‘¡() â€“ Creating a RUDP socket and creating a handshake between two
peers.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘’ğ‘›ğ‘‘() â€“ Sending data to the peer. The function should wait for an
acknowledgment packet, and if it didnâ€™t receive any, retransmits the data.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘Ÿğ‘’ğ‘ğ‘£() â€“ Receive data from a peer.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ğ‘™ğ‘œğ‘ ğ‘’() â€“ Closes a connection between peers.
 Communication Networks Course
Page | 6
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a UDP socket between the Sender and the
Receiver.
3) Send the file via the RUDP protocol.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a UDP connection between the Receiver and
the Sender.
2) Get a connection from the sender, by the custom
RUDP protocol youâ€™ve built.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./RUDP_Receiver -p 1234
Starting Receiver...
Waiting for RUDP connection...
Connection request received, sending ACK.
Sender connected, beginning to receive file...
File transfer completed.
ACK sent.
Waiting for Sender response...
Sender sent exit message.
ACK sent.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 7
Part C â€“ Research â€“ 30 points
In this part, youâ€™ll conduct research about your implementations of part A and part B.
In the research itself, each one of the versions (TCP version and UDP version) will be run at
least 5 times (meaning that the file transfer will occur at least 5 times) by the following
conditions:
â€¢ For TCP, youâ€™ll run it in TCP Reno and TCP Cubic, alternating each time, for each
scenario, meaning that you run 5 times with TCP Reno in both Sender and Receiver,
and 5 times with TCP Cubic in both Sender and Receiver.
Bonus (5 points): Create a very large data set â€“ 5 times with TCP Reno in both Sender
and Receiver, 5 times with TCP Reno in Sender and TCP Cubic in Receiver, 5 times
with TCP Cubic in Sender and TCP Reno in Receiver, and 5 times with TCP Cubic in
both Sender and Receiver. This will give you a data set large enough, which allows
you to work with, compare with and to reach a definite conclusion.
â€¢ For RUDP, you will run it 5 times for each scenario.
â€¢ For both TCP and RUDP, you will run them on those scenarios of packet loss:
o 0% packet loss â€“ Control group, simulating perfect connection.
o 2% packet loss â€“ Simulating unstable connection that commonly occur.
o 5% packet loss â€“ Simulating bad connection.
o 10% packet loss â€“ Simulating extremely poor connection.
For each scenario, you must provide a filtered PCAP file and relevant screenshots that
explain each one of the steps in the process. (10 points)
After youâ€™ve gathered the data set for both TCP and Reliable UDP, answer the following
questions:
1) In TCP, which congestion control algorithm gave better results overall? TCP Reno or
TCP Cubic? Which one gave better results on high packet loss? Explain how you came
to this conclusion based on the data set youâ€™ve gathered. (5 points)
2) How did your implementation of Reliable UDP perform overall compared to regular
TCP? Which one is better for high packet loss? (5 points)
3) According to the data youâ€™ve gathered, in which scenarios and applications would we
prefer to use TCP and in which situations would we prefer to use reliable UDP?
Explain your answer. (5 points)
 Communication Networks Course
Page | 8
×¢× ×• ×¢×œ ×”×©××œ×•×ª ×”×‘××•×ª )5 × ×§×•×“×•×ª(:
â— ×‘"×¨×©×ª ×××™× ×”" ×”×›×•×•× ×” ×”×™× ×œ×¨×©×ª ×©×‘×” ××¢×˜ ×××•×“ ×—×‘×™×œ×•×ª ×”×•×œ×›×•×ª ×œ××™×‘×•×“. ×‘"×§×©×¨ ××¨×•×š" ×”×›×•×•× ×” ×”×™×
×œ×§×©×¨ TCP ×©×™×© ×‘×• ×”×¨×‘×” ×××•×“ ××™×“×¢ ×œ×©×œ×•×—. ××•×¦×¢ ×œ×”×’×“×™×œ ×‘ -TCP ××ª SSThreshold ×‘×ª×—×™×œ×ª ×”×§×©×¨.
×‘××™×–×” ××”××§×¨×™× ×”×‘××™× ×”×©×™× ×•×™ ×”×–×” ×¢×©×•×™ ×œ×”×•×¢×™×œ ×‘××™×“×” ×”××™×¨×‘×™×ª? × ××§.
.1 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
.2 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.3 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.4 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.5 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.6 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.7 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.8 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
â— A ×©×•×œ×— ×œ -B ×—×‘×™×œ×•×ª ××™×“×¢ ×‘×××¦×¢×•×ª ×§×©×¨ TCP. × ×ª×•×Ÿ ×›×™ ×”×§×©×¨ ××ª×—×™×œ ×¢× ×—×œ×•×Ÿ ×‘×’×•×“×œ 1MSS. ×”×§×©×¨
××¡×ª×™×™× ×‘×¤×¢× ×”×¨××©×•× ×” ×©×”×•× ××’×™×¢ ×œ -SSthresh. ×‘××”×œ×š ×”×§×©×¨ ×œ× ××•×‘×“×•×ª ×—×‘×™×œ×•×ª. × ×¡××Ÿ ×‘×§×™×¦×•×¨:
.SSthresh=S*MSS
× ×ª×•×Ÿ ×›×™ ×œ××•×¨×š ×›×œ ×”×§×©×¨ rwnd < MSS*S.
××”×™ ×”×ª×¤×•×§×” ×©×œ ×”×§×©×¨ ×-A ×œ-B( ×‘ -sec / Bytes )×‘×–××Ÿ ×”× "×œ? × ××§×™.
]S*MSS / [lg (S) * RTT*2 ×‘×¢×¨×š .1
]S*MSS / [S^0.5 * RTT*2 ×‘×¢×¨×š .2
S*MSS / RTT ×‘×¢×¨×š .3
S^2)*MSS / RTT( ×‘×¢×¨×š .4
â— ×©×ª×™ ×ª×—× ×•×ª ××ª×§×©×¨×•×ª ×‘××•×¤×Ÿ ××œ×—×•×˜×™ ×‘×©×™×˜×ª N Back Go.
× ×¡××Ÿ ×‘-X ××ª ×¡×¤×¨×ª ×”×‘×™×§×•×¨×ª ×©×œ ×”×ª.×–. ×©×œ×š. ×× ×©× ×™ ×©×•×ª×¤×™× ××’×™×©×™× ××ª ×”×ª×¨×’×™×œ ×™×—×“, X ×”×•× ×¡×¤×¨×ª
×”×‘×™×§×•×¨×ª ×‘×¢×œ×ª ×”×¢×¨×š ×”× ××•×š ×™×•×ª×¨ ××‘×™×Ÿ ×”×©×ª×™×™×.
×§×¦×‘ ×”×ª×§×©×•×¨×ª ×”×•× 8Gbps, ×•×’×•×“×œ ×›×œ ×—×‘×™×œ×” ×”×•× KByte*X. ×’×“×œ×™ ×”-headers ×•×” -Acks ×–× ×™×—×™×.
ï¿½ğ‘’ğ‘ ï¿½/ï¿½ï¿½ 8 , ×•×”××¨×—×§ ×‘×™×Ÿ ×”×ª×—× ×•×ª ×”×•× 1Km. ×§×¦×‘ ×”×”×ª×¤×©×˜×•×ª ×”×•× 10 â‹… 2
×–××Ÿ ×¢×™×‘×•×“ ×”× ×ª×•× ×™× ×‘×ª×—× ×•×ª ×–× ×™×—.
××£ ×—×‘×™×œ×” ×•××£ Ack ×œ× ×”×•×œ×›×™× ×œ××™×‘×•×“.
â— ××”×• X ×©×œ×š?
â— ××” ×¦×¨×™×š ×œ×”×™×•×ª ×’×•×“×œ ×—×œ×•×Ÿ ×”××©×œ×•×— ×›×“×™ ×œ×”×‘×˜×™×— ×ª×¤×•×§×” ××§×¡×™××œ×™×ª?
 Communication Networks Course
Page | 9
Bonus â€“ Improving the Reliable UDP â€“ 15 points
Note: This part isnâ€™t mandatory and is a bonus only!
In this part, youâ€™ll improve your RUDP implementation by adding the concepts of flow
control and congestion control from TCP. Youâ€™re free to choose which algorithms to
implement, as long as you explain in your PDF which algorithms youâ€™ve used. Youâ€™ll probably
need to make changes in the original design of the RUDP. Changes only need to be to the API
itself, ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„.
Points distribution:
â€¢ Flow control improvement â€“ 7 Points
â€¢ Congestion control improvement â€“ 8 points.
Guidance:
â€¢ For flow control, you must use one of the Sliding window techniques: stop-and-wait
ARQ, Go-Back-N or Selective repeat.
â€¢ List of known TCP congestion control algorithms, which you can use any one of them
for this bonus task, or makeup your own:
Figure 2 â€“ List of known TCP congestion control algorithms, Wikipedia
 Communication Networks Course
Page | 10
Appendix A â€“ Linux local packet loss tool
To simulate a packet loss in a local network, we'll use a Linux tool that's called Linux Traffic
Control (ğ‘¡ğ‘). This requires a full Linux installation, so working with WSL won't work.
If the tool isn't installed in your machine, you can install it by using the following commands:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’
If the installation didn't work, you can use the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’2
To create a packet loss scenario, type the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘ğ‘‘ğ‘‘ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
After creating a packet loss scenario, you can change the percentage by typing the following
command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘â„ğ‘ğ‘›ğ‘”ğ‘’ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
To remove the packet loss scenario, write the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘‘ğ‘’ğ‘™ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š
 Communication Networks Course
Page | 11
Appendix B â€“ ğ’ğ’‚ğ’(ğŸ) system calls
This appendixâ€™s purpose is to give you a better understanding of socket handling in C.
A recommended reference is Beejâ€™s Guide to Network Programming, by Brian â€œBeej
Jorgensenâ€ Hall, which gives a lot of information about sockets in C and functions.
Functions and documentation links:
â€¢ ğ’”ğ’ğ’„ğ’Œğ’†ğ’•(ğŸ) â€“ A Factory method system call that creates a socket with the given
parameters.
â€¢ ğ’ƒğ’Šğ’ğ’…(ğŸ) â€“ Whenever we create a new socket, we need to bind it to a specific port in
our machine, â€œto catch a portâ€. The port number is managed and used by the kernel
to link incoming packets to the corresponding application socket. The port numbers
are usually fixed. The ğ‘ğ‘‘ğ‘‘ğ‘Ÿ parameter must match the current socket that is used.
â€¢ ğ’ğ’Šğ’”ğ’•ğ’†ğ’(ğŸ) â€“ The ğ‘™ğ‘–ğ‘ ğ‘¡ğ‘’ğ‘›(2) system call doesn't do anything in the mean of
communication but only memory allocation (malloc) for stream sockets only. If we
won't allocate memory, any incoming connection will fail.
â€¢ ğ’„ğ’ğ’ğ’ğ’†ğ’„ğ’•(ğŸ) â€“ The ğ‘ğ‘œğ‘›ğ‘›ğ‘’ğ‘ğ‘¡(2) system call starts the link between a client and a
specific IP address and port number. The connection would complete when the
other side will call the ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call.
â€¢ ğ’‚ğ’„ğ’„ğ’†ğ’‘ğ’•(ğŸ) â€“ The ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call accepts the incoming stream connection
request from the other side, by the listening socket. This system call completes the
three-way handshake of stream socket (like TCP) and opens a new socket that has a
direct communication channel only with the other party in the handshake.
â€¢ ğ’”ğ’†ğ’ğ’…(ğŸ) and ğ’”ğ’†ğ’ğ’…ğ’•ğ’(ğŸ) â€“ The ğ‘ ğ‘’ğ‘›ğ‘‘(2) and ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system calls are an analogy
for the ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’(2) system call, specifcly for sockets, with flags set to 0. Those system
calls return the number of bytes that were sent through the socket itself, as the
number of bytes can vary. The ğ‘ ğ‘’ğ‘›ğ‘‘(2)system call designed for stream sockets (like
TCP), while the ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system call designed for datagram connection-less
sockets (like UDP). When the ğ‘ ğ‘’ğ‘›ğ‘‘(2) system call returns 0, it means that the other
party closed the connection.
â€¢ ğ’“ğ’†ğ’„ğ’—(ğŸ) and ğ’“ğ’†ğ’„ğ’—ğ’‡ğ’“ğ’ğ’(ğŸ) â€“ The ğ‘Ÿğ‘’ğ‘ğ‘£(2) and ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system calls are an
analogy for the ğ‘Ÿğ‘’ğ‘ğ‘‘(2) system call, specifically for sockets, with flags set to 0.
Those system calls return the number of bytes that were received through the socket
itself, as the number of bytes can vary. The ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call designed for stream
sockets (like TCP), while the ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system call designed for datagram
connection-less sockets (like UDP). When the ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call returns 0, it means
that the other party closed the connection.
â€¢ ğ’„ğ’ğ’ğ’”ğ’†(ğŸ) and ğ’”ğ’‰ğ’–ğ’•ğ’…ğ’ğ’˜ğ’(ğŸ) â€“ The ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) and ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2) system calls close
the socket. While ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) system call closes the whole socket, the ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2)
system call partially closes the socket for read/write.
 Communication Networks Course
Page | 12
Appendix C â€“ Random data generator
The data that you are going to send in this assignment is randomly generated. You can use
your own file with appropriate size or use the following function (or a function of your own)
to generate the data:
/*
* @brief A random data generator function based on srand() and rand().
* @param size The size of the data to generate (up to 2^32 bytes).
* @return A pointer to the buffer.
*/
char *util_generate_random_data(unsigned int size) {
 char *buffer = NULL;
 // Argument check.
 if (size == 0)
 return NULL;
 buffer = (char *)calloc(size, sizeof(char));
 // Error checking.
 if (buffer == NULL)
 return NULL;
 // Randomize the seed of the random number generator.
 srand(time(NULL));
 for (unsigned int i = 0; i < size; i++)
 *(buffer + i) = ((unsigned int)rand() % 256);
 return buffer;
}
 Communication Networks Course
Page | 13
Appendix D â€“ Checksum function
A checksum is a small-sized block of data derived from another block of digital data for the
purpose of detecting errors that may have been introduced during its transmission or
storage. By themselves, checksums are often used to verify data integrity but are not relied
upon to verify data authenticity.
Below is a simple yet efficient implementation of the checksum function, you can use it for
the assignment, but you can implement your own checksum function.
/*
* @brief A checksum function that returns 16 bit checksum for data.
* @param data The data to do the checksum for.
* @param bytes The length of the data in bytes.
* @return The checksum itself as 16 bit unsigned number.
* @note This function is taken from RFC1071, can be found here:
* @note https://tools.ietf.org/html/rfc1071
* @note It is the simplest way to calculate a checksum and is not very strong.
* However, it is good enough for this assignment.
* @note You are free to use any other checksum function as well.
* You can also use this function as such without any change.
*/
unsigned short int calculate_checksum(void *data, unsigned int bytes) {
 unsigned short int *data_pointer = (unsigned short int *)data;
 unsigned int total_sum = 0;
 // Main summing loop
 while (bytes > 1) {
 total_sum += *data_pointer++;
 bytes -= 2;
 }
 // Add left-over byte, if any
 if (bytes > 0)
 total_sum += *((unsigned char *)data_pointer);
 // Fold 32-bit sum to 16 bits
 while (total_sum >> 16)
 total_sum = (total_sum & 0xFFFF) + (total_sum >> 16);
 return (~((unsigned short int)total_sum));
} Communication Networks Course
Page | 1
Assignment 3 â€“ Transport Layer
Assignment Notes and Instructions
This assignment is to be done in pairs only. You must upload all the necessary files in a ZIP
file named after both of the studentâ€™s ID. For example: ğŸğŸğŸ‘ğŸ’ğŸ“ğŸ”ğŸ•ğŸ–ğŸ—_ğŸ—ğŸ–ğŸ•ğŸ”ğŸ“ğŸ’ğŸ‘ğŸğŸ. ğ’›ğ’Šğ’‘.
1) The assignment must be submitted by the date specified in the submission box.
2) All the assignment files (Code, Wireshark pcap files, PDF) must be submitted in a ZIP file. The
PDF must contain all the necessary screenshots with a description for each one of them.
3) The assignment must be done in pairs only. In exceptional cases, you should send an email to
the course coordinator.
4) You can use any reference material available through the course Moodle website or any
material passed during the exercises.
5) You can use any reference from the web, but copying codes from websites is forbidden; this
includes codes from other GitHub repositories. A student who gets caught in the act will
automatically fail this assignment (score 0). Any website youâ€™ve used to solve the
assignment, every website you used to solve the assignment must be noted in the PDF.
6) No delays in submission without special permission. Lateness without approval will result in
failure of the assignment (score 0).
7) All submissions will be submitted via the course's Moodle website. Email submissions will not
be accepted, resulting in a failure in the assignment.
8) The order and design of the code must be carefully considered. Make sure that the program
output is as clear as possible, comments in the code, and meaningful variable names. You
must also submit a makefile that compiles all the programs.
9) The assignment code must be written in C only.
10) The assignment is personal for each pair, and you should not accept help from other people,
whether outside the university or inside it. You can contact the course staff during reception
hours for help or raise a question in the course forum. Do not transfer code sections
between students, upload solutions or parts of solutions to websites on the Internet or in
various communication groups.
11) Students who copy a solution will receive a 0 in all assignments in the course and a report will
be made to the institutional disciplinary committee.
12) All code files of the assignment are required to both compile and run properly on the Ubuntu
22.04 LTS operating system. This is the operating system where the submissions will be
tested. You mustnâ€™t code it in Windows, as it uses different API for sockets. WSL wonâ€™t work,
as the task needs a tool that works only in a fully Linux environment.
Good Luck!
 Communication Networks Course
Page | 2
Part A â€“ Transmission Control Protocol (TCP) â€“ 30 points
In this part, youâ€™ll write two program files: ğ‘»ğ‘ªğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and ğ‘»ğ‘ªğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
The Sender will send a randomly generated file and the Receiver will receive it and measure
the time it took for his program to receive the file. The file size should be at least 2MB.
When running the Sender and Receiver, they both should support two standard congestion
control algorithms: TCP Reno and TCP Cubic.
Notes:
â€¢ The main goal of this part is to get familiar with the TCP concept of sending
messages between two endpoints.
â€¢ For approaching this part of the assignment, please be sure that you are familiar
with the congestion control algorithms and how to change them using the correct
method in C (see Appendix B for more information).
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). You've
learned that TCP is reliable by design, so you can assume that all the data have been
passed correctly, and thus, no need to recheck.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
Usage:
â€¢ Receiver:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
â€¢ Sender:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port of the Receiver.
â€¢ ğ‘¨ğ‘³ğ‘®ğ‘¶ â€“ The TCP congestion control algorithm that will be used by the party
member (either ğ’“ğ’†ğ’ğ’ for TCP Reno or ğ’„ğ’–ğ’ƒğ’Šğ’„ for TCP Cubic).
 Communication Networks Course
Page | 3
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a TCP socket between the Sender and the
Receiver.
3) Send the file.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a TCP connection between the Receiver and
the Sender.
2) Get a connection from the sender.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./TCP_Receiver -p 1234 -algo reno
Starting Receiver...
Waiting for TCP connection...
Sender connected, beginning to receive file...
File transfer completed.
Waiting for Sender response...
Sender sent exit message.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 4
Part B â€“ Reliable User Datagram Protocol (Reliable UDP or RUDP) â€“ 40 points
Youâ€™ve learned that while TCP is reliable, it lacks speed and has an overhead data of 20 bytes,
compering to UDP that needs only 8 bytes of overhead data.
Reliable UDP or RUDP, is a protocol that uses the UDP protocol for a faster transmission of
data, while adding a reliability layer to it, but without adding too much overhead data like
TCP.
A simple sketch for a RUDP connection would look something like this:
Your task in this part is to implement a Reliable protocol using UDP only. For simplicity, your
implementation should only support a handshake, closing scheme, error checking,
acknowledgment of received packets, and retransmission of lost packets.
Guidance:
â€¢ You can use ğ‘ ğ‘’ğ‘¡ğ‘ ğ‘œğ‘ğ‘˜ğ‘œğ‘ğ‘¡(2) for detecting a timeout.
â€¢ You need to build your own protocol, as Reliable UDP isnâ€™t a standard protocol (see a
draft of RUDP in this link), and no official header is provided. You can use this sketch
for a header, but you can come up with your own protocol, as long as it works.
Where:
o ğ‘³ğ’†ğ’ğ’ˆğ’•ğ’‰ is the length of the data itself, without the RUDP header.
o ğ‘ªğ’‰ğ’†ğ’„ğ’Œğ’”ğ’–ğ’ is a 16bit number that validates the correctness of the data.
o ğ‘­ğ’ğ’‚ğ’ˆğ’” is a special byte where we classify the packet itself (SYN, ACK, etc.).
â€¢ In your PDF, you must explain how your implementation of RUDP works â€“ How does
it detect a timeout to do retransmissions, how does the handshake work, what is the
header overhead, etc.
â€¢ For this part, youâ€™ll write three files: ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¨ğ‘·ğ‘°. ğ’„, ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and
ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
Reliable UDP Header proposed sketch
Byte 0 Byte 1 Byte 2 Byte 3
Length (2 Bytes) Checksum (2 Bytes)
Flags (1 Byte)
Figure 1 - RUDP Protocol Architecture, Geeksforgeeks
 Communication Networks Course
Page | 5
Notes:
â€¢ The Sender will send a random generated file and the Receiver will receive it and
measure the time it took for his program to receive the file. The file size should be at
least 2MB.
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). But, as the
RUDP is based on UDP, itâ€™s not reliable. You must use some form of error checking
(like checksum) to ensure that the packet wasnâ€™t alerted during the transfer.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
â€¢ The RUDP needs support only 1 sender and 1 receiver, for simplicity purposes.
Usage:
â€¢ Receiver:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
â€¢ Sender:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port that both the Sender and the Receiver will use.
The ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„ file will contain all the implementations of the RUDP API functions (That is, to
prevent reusing the same chuck of code both in the Sender and the Receiver.).
The API should support at the bare minimum the following functions (you decide what
parameters to implement, and what are the names of the functions, as long as the API is
explained in the PDF):
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘œğ‘ğ‘˜ğ‘’ğ‘¡() â€“ Creating a RUDP socket and creating a handshake between two
peers.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘’ğ‘›ğ‘‘() â€“ Sending data to the peer. The function should wait for an
acknowledgment packet, and if it didnâ€™t receive any, retransmits the data.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘Ÿğ‘’ğ‘ğ‘£() â€“ Receive data from a peer.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ğ‘™ğ‘œğ‘ ğ‘’() â€“ Closes a connection between peers.
 Communication Networks Course
Page | 6
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a UDP socket between the Sender and the
Receiver.
3) Send the file via the RUDP protocol.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a UDP connection between the Receiver and
the Sender.
2) Get a connection from the sender, by the custom
RUDP protocol youâ€™ve built.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./RUDP_Receiver -p 1234
Starting Receiver...
Waiting for RUDP connection...
Connection request received, sending ACK.
Sender connected, beginning to receive file...
File transfer completed.
ACK sent.
Waiting for Sender response...
Sender sent exit message.
ACK sent.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 7
Part C â€“ Research â€“ 30 points
In this part, youâ€™ll conduct research about your implementations of part A and part B.
In the research itself, each one of the versions (TCP version and UDP version) will be run at
least 5 times (meaning that the file transfer will occur at least 5 times) by the following
conditions:
â€¢ For TCP, youâ€™ll run it in TCP Reno and TCP Cubic, alternating each time, for each
scenario, meaning that you run 5 times with TCP Reno in both Sender and Receiver,
and 5 times with TCP Cubic in both Sender and Receiver.
Bonus (5 points): Create a very large data set â€“ 5 times with TCP Reno in both Sender
and Receiver, 5 times with TCP Reno in Sender and TCP Cubic in Receiver, 5 times
with TCP Cubic in Sender and TCP Reno in Receiver, and 5 times with TCP Cubic in
both Sender and Receiver. This will give you a data set large enough, which allows
you to work with, compare with and to reach a definite conclusion.
â€¢ For RUDP, you will run it 5 times for each scenario.
â€¢ For both TCP and RUDP, you will run them on those scenarios of packet loss:
o 0% packet loss â€“ Control group, simulating perfect connection.
o 2% packet loss â€“ Simulating unstable connection that commonly occur.
o 5% packet loss â€“ Simulating bad connection.
o 10% packet loss â€“ Simulating extremely poor connection.
For each scenario, you must provide a filtered PCAP file and relevant screenshots that
explain each one of the steps in the process. (10 points)
After youâ€™ve gathered the data set for both TCP and Reliable UDP, answer the following
questions:
1) In TCP, which congestion control algorithm gave better results overall? TCP Reno or
TCP Cubic? Which one gave better results on high packet loss? Explain how you came
to this conclusion based on the data set youâ€™ve gathered. (5 points)
2) How did your implementation of Reliable UDP perform overall compared to regular
TCP? Which one is better for high packet loss? (5 points)
3) According to the data youâ€™ve gathered, in which scenarios and applications would we
prefer to use TCP and in which situations would we prefer to use reliable UDP?
Explain your answer. (5 points)
 Communication Networks Course
Page | 8
×¢× ×• ×¢×œ ×”×©××œ×•×ª ×”×‘××•×ª )5 × ×§×•×“×•×ª(:
â— ×‘"×¨×©×ª ×××™× ×”" ×”×›×•×•× ×” ×”×™× ×œ×¨×©×ª ×©×‘×” ××¢×˜ ×××•×“ ×—×‘×™×œ×•×ª ×”×•×œ×›×•×ª ×œ××™×‘×•×“. ×‘"×§×©×¨ ××¨×•×š" ×”×›×•×•× ×” ×”×™×
×œ×§×©×¨ TCP ×©×™×© ×‘×• ×”×¨×‘×” ×××•×“ ××™×“×¢ ×œ×©×œ×•×—. ××•×¦×¢ ×œ×”×’×“×™×œ ×‘ -TCP ××ª SSThreshold ×‘×ª×—×™×œ×ª ×”×§×©×¨.
×‘××™×–×” ××”××§×¨×™× ×”×‘××™× ×”×©×™× ×•×™ ×”×–×” ×¢×©×•×™ ×œ×”×•×¢×™×œ ×‘××™×“×” ×”××™×¨×‘×™×ª? × ××§.
.1 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
.2 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.3 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.4 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.5 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.6 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.7 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.8 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
â— A ×©×•×œ×— ×œ -B ×—×‘×™×œ×•×ª ××™×“×¢ ×‘×××¦×¢×•×ª ×§×©×¨ TCP. × ×ª×•×Ÿ ×›×™ ×”×§×©×¨ ××ª×—×™×œ ×¢× ×—×œ×•×Ÿ ×‘×’×•×“×œ 1MSS. ×”×§×©×¨
××¡×ª×™×™× ×‘×¤×¢× ×”×¨××©×•× ×” ×©×”×•× ××’×™×¢ ×œ -SSthresh. ×‘××”×œ×š ×”×§×©×¨ ×œ× ××•×‘×“×•×ª ×—×‘×™×œ×•×ª. × ×¡××Ÿ ×‘×§×™×¦×•×¨:
.SSthresh=S*MSS
× ×ª×•×Ÿ ×›×™ ×œ××•×¨×š ×›×œ ×”×§×©×¨ rwnd < MSS*S.
××”×™ ×”×ª×¤×•×§×” ×©×œ ×”×§×©×¨ ×-A ×œ-B( ×‘ -sec / Bytes )×‘×–××Ÿ ×”× "×œ? × ××§×™.
]S*MSS / [lg (S) * RTT*2 ×‘×¢×¨×š .1
]S*MSS / [S^0.5 * RTT*2 ×‘×¢×¨×š .2
S*MSS / RTT ×‘×¢×¨×š .3
S^2)*MSS / RTT( ×‘×¢×¨×š .4
â— ×©×ª×™ ×ª×—× ×•×ª ××ª×§×©×¨×•×ª ×‘××•×¤×Ÿ ××œ×—×•×˜×™ ×‘×©×™×˜×ª N Back Go.
× ×¡××Ÿ ×‘-X ××ª ×¡×¤×¨×ª ×”×‘×™×§×•×¨×ª ×©×œ ×”×ª.×–. ×©×œ×š. ×× ×©× ×™ ×©×•×ª×¤×™× ××’×™×©×™× ××ª ×”×ª×¨×’×™×œ ×™×—×“, X ×”×•× ×¡×¤×¨×ª
×”×‘×™×§×•×¨×ª ×‘×¢×œ×ª ×”×¢×¨×š ×”× ××•×š ×™×•×ª×¨ ××‘×™×Ÿ ×”×©×ª×™×™×.
×§×¦×‘ ×”×ª×§×©×•×¨×ª ×”×•× 8Gbps, ×•×’×•×“×œ ×›×œ ×—×‘×™×œ×” ×”×•× KByte*X. ×’×“×œ×™ ×”-headers ×•×” -Acks ×–× ×™×—×™×.
ï¿½ğ‘’ğ‘ ï¿½/ï¿½ï¿½ 8 , ×•×”××¨×—×§ ×‘×™×Ÿ ×”×ª×—× ×•×ª ×”×•× 1Km. ×§×¦×‘ ×”×”×ª×¤×©×˜×•×ª ×”×•× 10 â‹… 2
×–××Ÿ ×¢×™×‘×•×“ ×”× ×ª×•× ×™× ×‘×ª×—× ×•×ª ×–× ×™×—.
××£ ×—×‘×™×œ×” ×•××£ Ack ×œ× ×”×•×œ×›×™× ×œ××™×‘×•×“.
â— ××”×• X ×©×œ×š?
â— ××” ×¦×¨×™×š ×œ×”×™×•×ª ×’×•×“×œ ×—×œ×•×Ÿ ×”××©×œ×•×— ×›×“×™ ×œ×”×‘×˜×™×— ×ª×¤×•×§×” ××§×¡×™××œ×™×ª?
 Communication Networks Course
Page | 9
Bonus â€“ Improving the Reliable UDP â€“ 15 points
Note: This part isnâ€™t mandatory and is a bonus only!
In this part, youâ€™ll improve your RUDP implementation by adding the concepts of flow
control and congestion control from TCP. Youâ€™re free to choose which algorithms to
implement, as long as you explain in your PDF which algorithms youâ€™ve used. Youâ€™ll probably
need to make changes in the original design of the RUDP. Changes only need to be to the API
itself, ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„.
Points distribution:
â€¢ Flow control improvement â€“ 7 Points
â€¢ Congestion control improvement â€“ 8 points.
Guidance:
â€¢ For flow control, you must use one of the Sliding window techniques: stop-and-wait
ARQ, Go-Back-N or Selective repeat.
â€¢ List of known TCP congestion control algorithms, which you can use any one of them
for this bonus task, or makeup your own:
Figure 2 â€“ List of known TCP congestion control algorithms, Wikipedia
 Communication Networks Course
Page | 10
Appendix A â€“ Linux local packet loss tool
To simulate a packet loss in a local network, we'll use a Linux tool that's called Linux Traffic
Control (ğ‘¡ğ‘). This requires a full Linux installation, so working with WSL won't work.
If the tool isn't installed in your machine, you can install it by using the following commands:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’
If the installation didn't work, you can use the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’2
To create a packet loss scenario, type the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘ğ‘‘ğ‘‘ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
After creating a packet loss scenario, you can change the percentage by typing the following
command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘â„ğ‘ğ‘›ğ‘”ğ‘’ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
To remove the packet loss scenario, write the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘‘ğ‘’ğ‘™ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š
 Communication Networks Course
Page | 11
Appendix B â€“ ğ’ğ’‚ğ’(ğŸ) system calls
This appendixâ€™s purpose is to give you a better understanding of socket handling in C.
A recommended reference is Beejâ€™s Guide to Network Programming, by Brian â€œBeej
Jorgensenâ€ Hall, which gives a lot of information about sockets in C and functions.
Functions and documentation links:
â€¢ ğ’”ğ’ğ’„ğ’Œğ’†ğ’•(ğŸ) â€“ A Factory method system call that creates a socket with the given
parameters.
â€¢ ğ’ƒğ’Šğ’ğ’…(ğŸ) â€“ Whenever we create a new socket, we need to bind it to a specific port in
our machine, â€œto catch a portâ€. The port number is managed and used by the kernel
to link incoming packets to the corresponding application socket. The port numbers
are usually fixed. The ğ‘ğ‘‘ğ‘‘ğ‘Ÿ parameter must match the current socket that is used.
â€¢ ğ’ğ’Šğ’”ğ’•ğ’†ğ’(ğŸ) â€“ The ğ‘™ğ‘–ğ‘ ğ‘¡ğ‘’ğ‘›(2) system call doesn't do anything in the mean of
communication but only memory allocation (malloc) for stream sockets only. If we
won't allocate memory, any incoming connection will fail.
â€¢ ğ’„ğ’ğ’ğ’ğ’†ğ’„ğ’•(ğŸ) â€“ The ğ‘ğ‘œğ‘›ğ‘›ğ‘’ğ‘ğ‘¡(2) system call starts the link between a client and a
specific IP address and port number. The connection would complete when the
other side will call the ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call.
â€¢ ğ’‚ğ’„ğ’„ğ’†ğ’‘ğ’•(ğŸ) â€“ The ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call accepts the incoming stream connection
request from the other side, by the listening socket. This system call completes the
three-way handshake of stream socket (like TCP) and opens a new socket that has a
direct communication channel only with the other party in the handshake.
â€¢ ğ’”ğ’†ğ’ğ’…(ğŸ) and ğ’”ğ’†ğ’ğ’…ğ’•ğ’(ğŸ) â€“ The ğ‘ ğ‘’ğ‘›ğ‘‘(2) and ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system calls are an analogy
for the ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’(2) system call, specifcly for sockets, with flags set to 0. Those system
calls return the number of bytes that were sent through the socket itself, as the
number of bytes can vary. The ğ‘ ğ‘’ğ‘›ğ‘‘(2)system call designed for stream sockets (like
TCP), while the ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system call designed for datagram connection-less
sockets (like UDP). When the ğ‘ ğ‘’ğ‘›ğ‘‘(2) system call returns 0, it means that the other
party closed the connection.
â€¢ ğ’“ğ’†ğ’„ğ’—(ğŸ) and ğ’“ğ’†ğ’„ğ’—ğ’‡ğ’“ğ’ğ’(ğŸ) â€“ The ğ‘Ÿğ‘’ğ‘ğ‘£(2) and ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system calls are an
analogy for the ğ‘Ÿğ‘’ğ‘ğ‘‘(2) system call, specifically for sockets, with flags set to 0.
Those system calls return the number of bytes that were received through the socket
itself, as the number of bytes can vary. The ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call designed for stream
sockets (like TCP), while the ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system call designed for datagram
connection-less sockets (like UDP). When the ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call returns 0, it means
that the other party closed the connection.
â€¢ ğ’„ğ’ğ’ğ’”ğ’†(ğŸ) and ğ’”ğ’‰ğ’–ğ’•ğ’…ğ’ğ’˜ğ’(ğŸ) â€“ The ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) and ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2) system calls close
the socket. While ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) system call closes the whole socket, the ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2)
system call partially closes the socket for read/write.
 Communication Networks Course
Page | 12
Appendix C â€“ Random data generator
The data that you are going to send in this assignment is randomly generated. You can use
your own file with appropriate size or use the following function (or a function of your own)
to generate the data:
/*
* @brief A random data generator function based on srand() and rand().
* @param size The size of the data to generate (up to 2^32 bytes).
* @return A pointer to the buffer.
*/
char *util_generate_random_data(unsigned int size) {
 char *buffer = NULL;
 // Argument check.
 if (size == 0)
 return NULL;
 buffer = (char *)calloc(size, sizeof(char));
 // Error checking.
 if (buffer == NULL)
 return NULL;
 // Randomize the seed of the random number generator.
 srand(time(NULL));
 for (unsigned int i = 0; i < size; i++)
 *(buffer + i) = ((unsigned int)rand() % 256);
 return buffer;
}
 Communication Networks Course
Page | 13
Appendix D â€“ Checksum function
A checksum is a small-sized block of data derived from another block of digital data for the
purpose of detecting errors that may have been introduced during its transmission or
storage. By themselves, checksums are often used to verify data integrity but are not relied
upon to verify data authenticity.
Below is a simple yet efficient implementation of the checksum function, you can use it for
the assignment, but you can implement your own checksum function.
/*
* @brief A checksum function that returns 16 bit checksum for data.
* @param data The data to do the checksum for.
* @param bytes The length of the data in bytes.
* @return The checksum itself as 16 bit unsigned number.
* @note This function is taken from RFC1071, can be found here:
* @note https://tools.ietf.org/html/rfc1071
* @note It is the simplest way to calculate a checksum and is not very strong.
* However, it is good enough for this assignment.
* @note You are free to use any other checksum function as well.
* You can also use this function as such without any change.
*/
unsigned short int calculate_checksum(void *data, unsigned int bytes) {
 unsigned short int *data_pointer = (unsigned short int *)data;
 unsigned int total_sum = 0;
 // Main summing loop
 while (bytes > 1) {
 total_sum += *data_pointer++;
 bytes -= 2;
 }
 // Add left-over byte, if any
 if (bytes > 0)
 total_sum += *((unsigned char *)data_pointer);
 // Fold 32-bit sum to 16 bits
 while (total_sum >> 16)
 total_sum = (total_sum & 0xFFFF) + (total_sum >> 16);
 return (~((unsigned short int)total_sum));
} Communication Networks Course
Page | 1
Assignment 3 â€“ Transport Layer
Assignment Notes and Instructions
This assignment is to be done in pairs only. You must upload all the necessary files in a ZIP
file named after both of the studentâ€™s ID. For example: ğŸğŸğŸ‘ğŸ’ğŸ“ğŸ”ğŸ•ğŸ–ğŸ—_ğŸ—ğŸ–ğŸ•ğŸ”ğŸ“ğŸ’ğŸ‘ğŸğŸ. ğ’›ğ’Šğ’‘.
1) The assignment must be submitted by the date specified in the submission box.
2) All the assignment files (Code, Wireshark pcap files, PDF) must be submitted in a ZIP file. The
PDF must contain all the necessary screenshots with a description for each one of them.
3) The assignment must be done in pairs only. In exceptional cases, you should send an email to
the course coordinator.
4) You can use any reference material available through the course Moodle website or any
material passed during the exercises.
5) You can use any reference from the web, but copying codes from websites is forbidden; this
includes codes from other GitHub repositories. A student who gets caught in the act will
automatically fail this assignment (score 0). Any website youâ€™ve used to solve the
assignment, every website you used to solve the assignment must be noted in the PDF.
6) No delays in submission without special permission. Lateness without approval will result in
failure of the assignment (score 0).
7) All submissions will be submitted via the course's Moodle website. Email submissions will not
be accepted, resulting in a failure in the assignment.
8) The order and design of the code must be carefully considered. Make sure that the program
output is as clear as possible, comments in the code, and meaningful variable names. You
must also submit a makefile that compiles all the programs.
9) The assignment code must be written in C only.
10) The assignment is personal for each pair, and you should not accept help from other people,
whether outside the university or inside it. You can contact the course staff during reception
hours for help or raise a question in the course forum. Do not transfer code sections
between students, upload solutions or parts of solutions to websites on the Internet or in
various communication groups.
11) Students who copy a solution will receive a 0 in all assignments in the course and a report will
be made to the institutional disciplinary committee.
12) All code files of the assignment are required to both compile and run properly on the Ubuntu
22.04 LTS operating system. This is the operating system where the submissions will be
tested. You mustnâ€™t code it in Windows, as it uses different API for sockets. WSL wonâ€™t work,
as the task needs a tool that works only in a fully Linux environment.
Good Luck!
 Communication Networks Course
Page | 2
Part A â€“ Transmission Control Protocol (TCP) â€“ 30 points
In this part, youâ€™ll write two program files: ğ‘»ğ‘ªğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and ğ‘»ğ‘ªğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
The Sender will send a randomly generated file and the Receiver will receive it and measure
the time it took for his program to receive the file. The file size should be at least 2MB.
When running the Sender and Receiver, they both should support two standard congestion
control algorithms: TCP Reno and TCP Cubic.
Notes:
â€¢ The main goal of this part is to get familiar with the TCP concept of sending
messages between two endpoints.
â€¢ For approaching this part of the assignment, please be sure that you are familiar
with the congestion control algorithms and how to change them using the correct
method in C (see Appendix B for more information).
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). You've
learned that TCP is reliable by design, so you can assume that all the data have been
passed correctly, and thus, no need to recheck.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
Usage:
â€¢ Receiver:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
â€¢ Sender:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port of the Receiver.
â€¢ ğ‘¨ğ‘³ğ‘®ğ‘¶ â€“ The TCP congestion control algorithm that will be used by the party
member (either ğ’“ğ’†ğ’ğ’ for TCP Reno or ğ’„ğ’–ğ’ƒğ’Šğ’„ for TCP Cubic).
 Communication Networks Course
Page | 3
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a TCP socket between the Sender and the
Receiver.
3) Send the file.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a TCP connection between the Receiver and
the Sender.
2) Get a connection from the sender.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./TCP_Receiver -p 1234 -algo reno
Starting Receiver...
Waiting for TCP connection...
Sender connected, beginning to receive file...
File transfer completed.
Waiting for Sender response...
Sender sent exit message.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 4
Part B â€“ Reliable User Datagram Protocol (Reliable UDP or RUDP) â€“ 40 points
Youâ€™ve learned that while TCP is reliable, it lacks speed and has an overhead data of 20 bytes,
compering to UDP that needs only 8 bytes of overhead data.
Reliable UDP or RUDP, is a protocol that uses the UDP protocol for a faster transmission of
data, while adding a reliability layer to it, but without adding too much overhead data like
TCP.
A simple sketch for a RUDP connection would look something like this:
Your task in this part is to implement a Reliable protocol using UDP only. For simplicity, your
implementation should only support a handshake, closing scheme, error checking,
acknowledgment of received packets, and retransmission of lost packets.
Guidance:
â€¢ You can use ğ‘ ğ‘’ğ‘¡ğ‘ ğ‘œğ‘ğ‘˜ğ‘œğ‘ğ‘¡(2) for detecting a timeout.
â€¢ You need to build your own protocol, as Reliable UDP isnâ€™t a standard protocol (see a
draft of RUDP in this link), and no official header is provided. You can use this sketch
for a header, but you can come up with your own protocol, as long as it works.
Where:
o ğ‘³ğ’†ğ’ğ’ˆğ’•ğ’‰ is the length of the data itself, without the RUDP header.
o ğ‘ªğ’‰ğ’†ğ’„ğ’Œğ’”ğ’–ğ’ is a 16bit number that validates the correctness of the data.
o ğ‘­ğ’ğ’‚ğ’ˆğ’” is a special byte where we classify the packet itself (SYN, ACK, etc.).
â€¢ In your PDF, you must explain how your implementation of RUDP works â€“ How does
it detect a timeout to do retransmissions, how does the handshake work, what is the
header overhead, etc.
â€¢ For this part, youâ€™ll write three files: ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¨ğ‘·ğ‘°. ğ’„, ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and
ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
Reliable UDP Header proposed sketch
Byte 0 Byte 1 Byte 2 Byte 3
Length (2 Bytes) Checksum (2 Bytes)
Flags (1 Byte)
Figure 1 - RUDP Protocol Architecture, Geeksforgeeks
 Communication Networks Course
Page | 5
Notes:
â€¢ The Sender will send a random generated file and the Receiver will receive it and
measure the time it took for his program to receive the file. The file size should be at
least 2MB.
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). But, as the
RUDP is based on UDP, itâ€™s not reliable. You must use some form of error checking
(like checksum) to ensure that the packet wasnâ€™t alerted during the transfer.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
â€¢ The RUDP needs support only 1 sender and 1 receiver, for simplicity purposes.
Usage:
â€¢ Receiver:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
â€¢ Sender:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port that both the Sender and the Receiver will use.
The ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„ file will contain all the implementations of the RUDP API functions (That is, to
prevent reusing the same chuck of code both in the Sender and the Receiver.).
The API should support at the bare minimum the following functions (you decide what
parameters to implement, and what are the names of the functions, as long as the API is
explained in the PDF):
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘œğ‘ğ‘˜ğ‘’ğ‘¡() â€“ Creating a RUDP socket and creating a handshake between two
peers.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘’ğ‘›ğ‘‘() â€“ Sending data to the peer. The function should wait for an
acknowledgment packet, and if it didnâ€™t receive any, retransmits the data.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘Ÿğ‘’ğ‘ğ‘£() â€“ Receive data from a peer.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ğ‘™ğ‘œğ‘ ğ‘’() â€“ Closes a connection between peers.
 Communication Networks Course
Page | 6
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a UDP socket between the Sender and the
Receiver.
3) Send the file via the RUDP protocol.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a UDP connection between the Receiver and
the Sender.
2) Get a connection from the sender, by the custom
RUDP protocol youâ€™ve built.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./RUDP_Receiver -p 1234
Starting Receiver...
Waiting for RUDP connection...
Connection request received, sending ACK.
Sender connected, beginning to receive file...
File transfer completed.
ACK sent.
Waiting for Sender response...
Sender sent exit message.
ACK sent.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 7
Part C â€“ Research â€“ 30 points
In this part, youâ€™ll conduct research about your implementations of part A and part B.
In the research itself, each one of the versions (TCP version and UDP version) will be run at
least 5 times (meaning that the file transfer will occur at least 5 times) by the following
conditions:
â€¢ For TCP, youâ€™ll run it in TCP Reno and TCP Cubic, alternating each time, for each
scenario, meaning that you run 5 times with TCP Reno in both Sender and Receiver,
and 5 times with TCP Cubic in both Sender and Receiver.
Bonus (5 points): Create a very large data set â€“ 5 times with TCP Reno in both Sender
and Receiver, 5 times with TCP Reno in Sender and TCP Cubic in Receiver, 5 times
with TCP Cubic in Sender and TCP Reno in Receiver, and 5 times with TCP Cubic in
both Sender and Receiver. This will give you a data set large enough, which allows
you to work with, compare with and to reach a definite conclusion.
â€¢ For RUDP, you will run it 5 times for each scenario.
â€¢ For both TCP and RUDP, you will run them on those scenarios of packet loss:
o 0% packet loss â€“ Control group, simulating perfect connection.
o 2% packet loss â€“ Simulating unstable connection that commonly occur.
o 5% packet loss â€“ Simulating bad connection.
o 10% packet loss â€“ Simulating extremely poor connection.
For each scenario, you must provide a filtered PCAP file and relevant screenshots that
explain each one of the steps in the process. (10 points)
After youâ€™ve gathered the data set for both TCP and Reliable UDP, answer the following
questions:
1) In TCP, which congestion control algorithm gave better results overall? TCP Reno or
TCP Cubic? Which one gave better results on high packet loss? Explain how you came
to this conclusion based on the data set youâ€™ve gathered. (5 points)
2) How did your implementation of Reliable UDP perform overall compared to regular
TCP? Which one is better for high packet loss? (5 points)
3) According to the data youâ€™ve gathered, in which scenarios and applications would we
prefer to use TCP and in which situations would we prefer to use reliable UDP?
Explain your answer. (5 points)
 Communication Networks Course
Page | 8
×¢× ×• ×¢×œ ×”×©××œ×•×ª ×”×‘××•×ª )5 × ×§×•×“×•×ª(:
â— ×‘"×¨×©×ª ×××™× ×”" ×”×›×•×•× ×” ×”×™× ×œ×¨×©×ª ×©×‘×” ××¢×˜ ×××•×“ ×—×‘×™×œ×•×ª ×”×•×œ×›×•×ª ×œ××™×‘×•×“. ×‘"×§×©×¨ ××¨×•×š" ×”×›×•×•× ×” ×”×™×
×œ×§×©×¨ TCP ×©×™×© ×‘×• ×”×¨×‘×” ×××•×“ ××™×“×¢ ×œ×©×œ×•×—. ××•×¦×¢ ×œ×”×’×“×™×œ ×‘ -TCP ××ª SSThreshold ×‘×ª×—×™×œ×ª ×”×§×©×¨.
×‘××™×–×” ××”××§×¨×™× ×”×‘××™× ×”×©×™× ×•×™ ×”×–×” ×¢×©×•×™ ×œ×”×•×¢×™×œ ×‘××™×“×” ×”××™×¨×‘×™×ª? × ××§.
.1 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
.2 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.3 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.4 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.5 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.6 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.7 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.8 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
â— A ×©×•×œ×— ×œ -B ×—×‘×™×œ×•×ª ××™×“×¢ ×‘×××¦×¢×•×ª ×§×©×¨ TCP. × ×ª×•×Ÿ ×›×™ ×”×§×©×¨ ××ª×—×™×œ ×¢× ×—×œ×•×Ÿ ×‘×’×•×“×œ 1MSS. ×”×§×©×¨
××¡×ª×™×™× ×‘×¤×¢× ×”×¨××©×•× ×” ×©×”×•× ××’×™×¢ ×œ -SSthresh. ×‘××”×œ×š ×”×§×©×¨ ×œ× ××•×‘×“×•×ª ×—×‘×™×œ×•×ª. × ×¡××Ÿ ×‘×§×™×¦×•×¨:
.SSthresh=S*MSS
× ×ª×•×Ÿ ×›×™ ×œ××•×¨×š ×›×œ ×”×§×©×¨ rwnd < MSS*S.
××”×™ ×”×ª×¤×•×§×” ×©×œ ×”×§×©×¨ ×-A ×œ-B( ×‘ -sec / Bytes )×‘×–××Ÿ ×”× "×œ? × ××§×™.
]S*MSS / [lg (S) * RTT*2 ×‘×¢×¨×š .1
]S*MSS / [S^0.5 * RTT*2 ×‘×¢×¨×š .2
S*MSS / RTT ×‘×¢×¨×š .3
S^2)*MSS / RTT( ×‘×¢×¨×š .4
â— ×©×ª×™ ×ª×—× ×•×ª ××ª×§×©×¨×•×ª ×‘××•×¤×Ÿ ××œ×—×•×˜×™ ×‘×©×™×˜×ª N Back Go.
× ×¡××Ÿ ×‘-X ××ª ×¡×¤×¨×ª ×”×‘×™×§×•×¨×ª ×©×œ ×”×ª.×–. ×©×œ×š. ×× ×©× ×™ ×©×•×ª×¤×™× ××’×™×©×™× ××ª ×”×ª×¨×’×™×œ ×™×—×“, X ×”×•× ×¡×¤×¨×ª
×”×‘×™×§×•×¨×ª ×‘×¢×œ×ª ×”×¢×¨×š ×”× ××•×š ×™×•×ª×¨ ××‘×™×Ÿ ×”×©×ª×™×™×.
×§×¦×‘ ×”×ª×§×©×•×¨×ª ×”×•× 8Gbps, ×•×’×•×“×œ ×›×œ ×—×‘×™×œ×” ×”×•× KByte*X. ×’×“×œ×™ ×”-headers ×•×” -Acks ×–× ×™×—×™×.
ï¿½ğ‘’ğ‘ ï¿½/ï¿½ï¿½ 8 , ×•×”××¨×—×§ ×‘×™×Ÿ ×”×ª×—× ×•×ª ×”×•× 1Km. ×§×¦×‘ ×”×”×ª×¤×©×˜×•×ª ×”×•× 10 â‹… 2
×–××Ÿ ×¢×™×‘×•×“ ×”× ×ª×•× ×™× ×‘×ª×—× ×•×ª ×–× ×™×—.
××£ ×—×‘×™×œ×” ×•××£ Ack ×œ× ×”×•×œ×›×™× ×œ××™×‘×•×“.
â— ××”×• X ×©×œ×š?
â— ××” ×¦×¨×™×š ×œ×”×™×•×ª ×’×•×“×œ ×—×œ×•×Ÿ ×”××©×œ×•×— ×›×“×™ ×œ×”×‘×˜×™×— ×ª×¤×•×§×” ××§×¡×™××œ×™×ª?
 Communication Networks Course
Page | 9
Bonus â€“ Improving the Reliable UDP â€“ 15 points
Note: This part isnâ€™t mandatory and is a bonus only!
In this part, youâ€™ll improve your RUDP implementation by adding the concepts of flow
control and congestion control from TCP. Youâ€™re free to choose which algorithms to
implement, as long as you explain in your PDF which algorithms youâ€™ve used. Youâ€™ll probably
need to make changes in the original design of the RUDP. Changes only need to be to the API
itself, ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„.
Points distribution:
â€¢ Flow control improvement â€“ 7 Points
â€¢ Congestion control improvement â€“ 8 points.
Guidance:
â€¢ For flow control, you must use one of the Sliding window techniques: stop-and-wait
ARQ, Go-Back-N or Selective repeat.
â€¢ List of known TCP congestion control algorithms, which you can use any one of them
for this bonus task, or makeup your own:
Figure 2 â€“ List of known TCP congestion control algorithms, Wikipedia
 Communication Networks Course
Page | 10
Appendix A â€“ Linux local packet loss tool
To simulate a packet loss in a local network, we'll use a Linux tool that's called Linux Traffic
Control (ğ‘¡ğ‘). This requires a full Linux installation, so working with WSL won't work.
If the tool isn't installed in your machine, you can install it by using the following commands:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’
If the installation didn't work, you can use the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’2
To create a packet loss scenario, type the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘ğ‘‘ğ‘‘ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
After creating a packet loss scenario, you can change the percentage by typing the following
command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘â„ğ‘ğ‘›ğ‘”ğ‘’ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
To remove the packet loss scenario, write the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘‘ğ‘’ğ‘™ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š
 Communication Networks Course
Page | 11
Appendix B â€“ ğ’ğ’‚ğ’(ğŸ) system calls
This appendixâ€™s purpose is to give you a better understanding of socket handling in C.
A recommended reference is Beejâ€™s Guide to Network Programming, by Brian â€œBeej
Jorgensenâ€ Hall, which gives a lot of information about sockets in C and functions.
Functions and documentation links:
â€¢ ğ’”ğ’ğ’„ğ’Œğ’†ğ’•(ğŸ) â€“ A Factory method system call that creates a socket with the given
parameters.
â€¢ ğ’ƒğ’Šğ’ğ’…(ğŸ) â€“ Whenever we create a new socket, we need to bind it to a specific port in
our machine, â€œto catch a portâ€. The port number is managed and used by the kernel
to link incoming packets to the corresponding application socket. The port numbers
are usually fixed. The ğ‘ğ‘‘ğ‘‘ğ‘Ÿ parameter must match the current socket that is used.
â€¢ ğ’ğ’Šğ’”ğ’•ğ’†ğ’(ğŸ) â€“ The ğ‘™ğ‘–ğ‘ ğ‘¡ğ‘’ğ‘›(2) system call doesn't do anything in the mean of
communication but only memory allocation (malloc) for stream sockets only. If we
won't allocate memory, any incoming connection will fail.
â€¢ ğ’„ğ’ğ’ğ’ğ’†ğ’„ğ’•(ğŸ) â€“ The ğ‘ğ‘œğ‘›ğ‘›ğ‘’ğ‘ğ‘¡(2) system call starts the link between a client and a
specific IP address and port number. The connection would complete when the
other side will call the ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call.
â€¢ ğ’‚ğ’„ğ’„ğ’†ğ’‘ğ’•(ğŸ) â€“ The ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call accepts the incoming stream connection
request from the other side, by the listening socket. This system call completes the
three-way handshake of stream socket (like TCP) and opens a new socket that has a
direct communication channel only with the other party in the handshake.
â€¢ ğ’”ğ’†ğ’ğ’…(ğŸ) and ğ’”ğ’†ğ’ğ’…ğ’•ğ’(ğŸ) â€“ The ğ‘ ğ‘’ğ‘›ğ‘‘(2) and ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system calls are an analogy
for the ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’(2) system call, specifcly for sockets, with flags set to 0. Those system
calls return the number of bytes that were sent through the socket itself, as the
number of bytes can vary. The ğ‘ ğ‘’ğ‘›ğ‘‘(2)system call designed for stream sockets (like
TCP), while the ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system call designed for datagram connection-less
sockets (like UDP). When the ğ‘ ğ‘’ğ‘›ğ‘‘(2) system call returns 0, it means that the other
party closed the connection.
â€¢ ğ’“ğ’†ğ’„ğ’—(ğŸ) and ğ’“ğ’†ğ’„ğ’—ğ’‡ğ’“ğ’ğ’(ğŸ) â€“ The ğ‘Ÿğ‘’ğ‘ğ‘£(2) and ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system calls are an
analogy for the ğ‘Ÿğ‘’ğ‘ğ‘‘(2) system call, specifically for sockets, with flags set to 0.
Those system calls return the number of bytes that were received through the socket
itself, as the number of bytes can vary. The ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call designed for stream
sockets (like TCP), while the ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system call designed for datagram
connection-less sockets (like UDP). When the ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call returns 0, it means
that the other party closed the connection.
â€¢ ğ’„ğ’ğ’ğ’”ğ’†(ğŸ) and ğ’”ğ’‰ğ’–ğ’•ğ’…ğ’ğ’˜ğ’(ğŸ) â€“ The ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) and ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2) system calls close
the socket. While ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) system call closes the whole socket, the ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2)
system call partially closes the socket for read/write.
 Communication Networks Course
Page | 12
Appendix C â€“ Random data generator
The data that you are going to send in this assignment is randomly generated. You can use
your own file with appropriate size or use the following function (or a function of your own)
to generate the data:
/*
* @brief A random data generator function based on srand() and rand().
* @param size The size of the data to generate (up to 2^32 bytes).
* @return A pointer to the buffer.
*/
char *util_generate_random_data(unsigned int size) {
 char *buffer = NULL;
 // Argument check.
 if (size == 0)
 return NULL;
 buffer = (char *)calloc(size, sizeof(char));
 // Error checking.
 if (buffer == NULL)
 return NULL;
 // Randomize the seed of the random number generator.
 srand(time(NULL));
 for (unsigned int i = 0; i < size; i++)
 *(buffer + i) = ((unsigned int)rand() % 256);
 return buffer;
}
 Communication Networks Course
Page | 13
Appendix D â€“ Checksum function
A checksum is a small-sized block of data derived from another block of digital data for the
purpose of detecting errors that may have been introduced during its transmission or
storage. By themselves, checksums are often used to verify data integrity but are not relied
upon to verify data authenticity.
Below is a simple yet efficient implementation of the checksum function, you can use it for
the assignment, but you can implement your own checksum function.
/*
* @brief A checksum function that returns 16 bit checksum for data.
* @param data The data to do the checksum for.
* @param bytes The length of the data in bytes.
* @return The checksum itself as 16 bit unsigned number.
* @note This function is taken from RFC1071, can be found here:
* @note https://tools.ietf.org/html/rfc1071
* @note It is the simplest way to calculate a checksum and is not very strong.
* However, it is good enough for this assignment.
* @note You are free to use any other checksum function as well.
* You can also use this function as such without any change.
*/
unsigned short int calculate_checksum(void *data, unsigned int bytes) {
 unsigned short int *data_pointer = (unsigned short int *)data;
 unsigned int total_sum = 0;
 // Main summing loop
 while (bytes > 1) {
 total_sum += *data_pointer++;
 bytes -= 2;
 }
 // Add left-over byte, if any
 if (bytes > 0)
 total_sum += *((unsigned char *)data_pointer);
 // Fold 32-bit sum to 16 bits
 while (total_sum >> 16)
 total_sum = (total_sum & 0xFFFF) + (total_sum >> 16);
 return (~((unsigned short int)total_sum));
} Communication Networks Course
Page | 1
Assignment 3 â€“ Transport Layer
Assignment Notes and Instructions
This assignment is to be done in pairs only. You must upload all the necessary files in a ZIP
file named after both of the studentâ€™s ID. For example: ğŸğŸğŸ‘ğŸ’ğŸ“ğŸ”ğŸ•ğŸ–ğŸ—_ğŸ—ğŸ–ğŸ•ğŸ”ğŸ“ğŸ’ğŸ‘ğŸğŸ. ğ’›ğ’Šğ’‘.
1) The assignment must be submitted by the date specified in the submission box.
2) All the assignment files (Code, Wireshark pcap files, PDF) must be submitted in a ZIP file. The
PDF must contain all the necessary screenshots with a description for each one of them.
3) The assignment must be done in pairs only. In exceptional cases, you should send an email to
the course coordinator.
4) You can use any reference material available through the course Moodle website or any
material passed during the exercises.
5) You can use any reference from the web, but copying codes from websites is forbidden; this
includes codes from other GitHub repositories. A student who gets caught in the act will
automatically fail this assignment (score 0). Any website youâ€™ve used to solve the
assignment, every website you used to solve the assignment must be noted in the PDF.
6) No delays in submission without special permission. Lateness without approval will result in
failure of the assignment (score 0).
7) All submissions will be submitted via the course's Moodle website. Email submissions will not
be accepted, resulting in a failure in the assignment.
8) The order and design of the code must be carefully considered. Make sure that the program
output is as clear as possible, comments in the code, and meaningful variable names. You
must also submit a makefile that compiles all the programs.
9) The assignment code must be written in C only.
10) The assignment is personal for each pair, and you should not accept help from other people,
whether outside the university or inside it. You can contact the course staff during reception
hours for help or raise a question in the course forum. Do not transfer code sections
between students, upload solutions or parts of solutions to websites on the Internet or in
various communication groups.
11) Students who copy a solution will receive a 0 in all assignments in the course and a report will
be made to the institutional disciplinary committee.
12) All code files of the assignment are required to both compile and run properly on the Ubuntu
22.04 LTS operating system. This is the operating system where the submissions will be
tested. You mustnâ€™t code it in Windows, as it uses different API for sockets. WSL wonâ€™t work,
as the task needs a tool that works only in a fully Linux environment.
Good Luck!
 Communication Networks Course
Page | 2
Part A â€“ Transmission Control Protocol (TCP) â€“ 30 points
In this part, youâ€™ll write two program files: ğ‘»ğ‘ªğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and ğ‘»ğ‘ªğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
The Sender will send a randomly generated file and the Receiver will receive it and measure
the time it took for his program to receive the file. The file size should be at least 2MB.
When running the Sender and Receiver, they both should support two standard congestion
control algorithms: TCP Reno and TCP Cubic.
Notes:
â€¢ The main goal of this part is to get familiar with the TCP concept of sending
messages between two endpoints.
â€¢ For approaching this part of the assignment, please be sure that you are familiar
with the congestion control algorithms and how to change them using the correct
method in C (see Appendix B for more information).
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). You've
learned that TCP is reliable by design, so you can assume that all the data have been
passed correctly, and thus, no need to recheck.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
Usage:
â€¢ Receiver:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
â€¢ Sender:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port of the Receiver.
â€¢ ğ‘¨ğ‘³ğ‘®ğ‘¶ â€“ The TCP congestion control algorithm that will be used by the party
member (either ğ’“ğ’†ğ’ğ’ for TCP Reno or ğ’„ğ’–ğ’ƒğ’Šğ’„ for TCP Cubic).
 Communication Networks Course
Page | 3
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a TCP socket between the Sender and the
Receiver.
3) Send the file.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a TCP connection between the Receiver and
the Sender.
2) Get a connection from the sender.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./TCP_Receiver -p 1234 -algo reno
Starting Receiver...
Waiting for TCP connection...
Sender connected, beginning to receive file...
File transfer completed.
Waiting for Sender response...
Sender sent exit message.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 4
Part B â€“ Reliable User Datagram Protocol (Reliable UDP or RUDP) â€“ 40 points
Youâ€™ve learned that while TCP is reliable, it lacks speed and has an overhead data of 20 bytes,
compering to UDP that needs only 8 bytes of overhead data.
Reliable UDP or RUDP, is a protocol that uses the UDP protocol for a faster transmission of
data, while adding a reliability layer to it, but without adding too much overhead data like
TCP.
A simple sketch for a RUDP connection would look something like this:
Your task in this part is to implement a Reliable protocol using UDP only. For simplicity, your
implementation should only support a handshake, closing scheme, error checking,
acknowledgment of received packets, and retransmission of lost packets.
Guidance:
â€¢ You can use ğ‘ ğ‘’ğ‘¡ğ‘ ğ‘œğ‘ğ‘˜ğ‘œğ‘ğ‘¡(2) for detecting a timeout.
â€¢ You need to build your own protocol, as Reliable UDP isnâ€™t a standard protocol (see a
draft of RUDP in this link), and no official header is provided. You can use this sketch
for a header, but you can come up with your own protocol, as long as it works.
Where:
o ğ‘³ğ’†ğ’ğ’ˆğ’•ğ’‰ is the length of the data itself, without the RUDP header.
o ğ‘ªğ’‰ğ’†ğ’„ğ’Œğ’”ğ’–ğ’ is a 16bit number that validates the correctness of the data.
o ğ‘­ğ’ğ’‚ğ’ˆğ’” is a special byte where we classify the packet itself (SYN, ACK, etc.).
â€¢ In your PDF, you must explain how your implementation of RUDP works â€“ How does
it detect a timeout to do retransmissions, how does the handshake work, what is the
header overhead, etc.
â€¢ For this part, youâ€™ll write three files: ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¨ğ‘·ğ‘°. ğ’„, ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and
ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
Reliable UDP Header proposed sketch
Byte 0 Byte 1 Byte 2 Byte 3
Length (2 Bytes) Checksum (2 Bytes)
Flags (1 Byte)
Figure 1 - RUDP Protocol Architecture, Geeksforgeeks
 Communication Networks Course
Page | 5
Notes:
â€¢ The Sender will send a random generated file and the Receiver will receive it and
measure the time it took for his program to receive the file. The file size should be at
least 2MB.
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). But, as the
RUDP is based on UDP, itâ€™s not reliable. You must use some form of error checking
(like checksum) to ensure that the packet wasnâ€™t alerted during the transfer.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
â€¢ The RUDP needs support only 1 sender and 1 receiver, for simplicity purposes.
Usage:
â€¢ Receiver:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
â€¢ Sender:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port that both the Sender and the Receiver will use.
The ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„ file will contain all the implementations of the RUDP API functions (That is, to
prevent reusing the same chuck of code both in the Sender and the Receiver.).
The API should support at the bare minimum the following functions (you decide what
parameters to implement, and what are the names of the functions, as long as the API is
explained in the PDF):
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘œğ‘ğ‘˜ğ‘’ğ‘¡() â€“ Creating a RUDP socket and creating a handshake between two
peers.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘’ğ‘›ğ‘‘() â€“ Sending data to the peer. The function should wait for an
acknowledgment packet, and if it didnâ€™t receive any, retransmits the data.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘Ÿğ‘’ğ‘ğ‘£() â€“ Receive data from a peer.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ğ‘™ğ‘œğ‘ ğ‘’() â€“ Closes a connection between peers.
 Communication Networks Course
Page | 6
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a UDP socket between the Sender and the
Receiver.
3) Send the file via the RUDP protocol.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a UDP connection between the Receiver and
the Sender.
2) Get a connection from the sender, by the custom
RUDP protocol youâ€™ve built.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./RUDP_Receiver -p 1234
Starting Receiver...
Waiting for RUDP connection...
Connection request received, sending ACK.
Sender connected, beginning to receive file...
File transfer completed.
ACK sent.
Waiting for Sender response...
Sender sent exit message.
ACK sent.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 7
Part C â€“ Research â€“ 30 points
In this part, youâ€™ll conduct research about your implementations of part A and part B.
In the research itself, each one of the versions (TCP version and UDP version) will be run at
least 5 times (meaning that the file transfer will occur at least 5 times) by the following
conditions:
â€¢ For TCP, youâ€™ll run it in TCP Reno and TCP Cubic, alternating each time, for each
scenario, meaning that you run 5 times with TCP Reno in both Sender and Receiver,
and 5 times with TCP Cubic in both Sender and Receiver.
Bonus (5 points): Create a very large data set â€“ 5 times with TCP Reno in both Sender
and Receiver, 5 times with TCP Reno in Sender and TCP Cubic in Receiver, 5 times
with TCP Cubic in Sender and TCP Reno in Receiver, and 5 times with TCP Cubic in
both Sender and Receiver. This will give you a data set large enough, which allows
you to work with, compare with and to reach a definite conclusion.
â€¢ For RUDP, you will run it 5 times for each scenario.
â€¢ For both TCP and RUDP, you will run them on those scenarios of packet loss:
o 0% packet loss â€“ Control group, simulating perfect connection.
o 2% packet loss â€“ Simulating unstable connection that commonly occur.
o 5% packet loss â€“ Simulating bad connection.
o 10% packet loss â€“ Simulating extremely poor connection.
For each scenario, you must provide a filtered PCAP file and relevant screenshots that
explain each one of the steps in the process. (10 points)
After youâ€™ve gathered the data set for both TCP and Reliable UDP, answer the following
questions:
1) In TCP, which congestion control algorithm gave better results overall? TCP Reno or
TCP Cubic? Which one gave better results on high packet loss? Explain how you came
to this conclusion based on the data set youâ€™ve gathered. (5 points)
2) How did your implementation of Reliable UDP perform overall compared to regular
TCP? Which one is better for high packet loss? (5 points)
3) According to the data youâ€™ve gathered, in which scenarios and applications would we
prefer to use TCP and in which situations would we prefer to use reliable UDP?
Explain your answer. (5 points)
 Communication Networks Course
Page | 8
×¢× ×• ×¢×œ ×”×©××œ×•×ª ×”×‘××•×ª )5 × ×§×•×“×•×ª(:
â— ×‘"×¨×©×ª ×××™× ×”" ×”×›×•×•× ×” ×”×™× ×œ×¨×©×ª ×©×‘×” ××¢×˜ ×××•×“ ×—×‘×™×œ×•×ª ×”×•×œ×›×•×ª ×œ××™×‘×•×“. ×‘"×§×©×¨ ××¨×•×š" ×”×›×•×•× ×” ×”×™×
×œ×§×©×¨ TCP ×©×™×© ×‘×• ×”×¨×‘×” ×××•×“ ××™×“×¢ ×œ×©×œ×•×—. ××•×¦×¢ ×œ×”×’×“×™×œ ×‘ -TCP ××ª SSThreshold ×‘×ª×—×™×œ×ª ×”×§×©×¨.
×‘××™×–×” ××”××§×¨×™× ×”×‘××™× ×”×©×™× ×•×™ ×”×–×” ×¢×©×•×™ ×œ×”×•×¢×™×œ ×‘××™×“×” ×”××™×¨×‘×™×ª? × ××§.
.1 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
.2 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.3 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.4 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.5 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.6 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.7 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.8 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
â— A ×©×•×œ×— ×œ -B ×—×‘×™×œ×•×ª ××™×“×¢ ×‘×××¦×¢×•×ª ×§×©×¨ TCP. × ×ª×•×Ÿ ×›×™ ×”×§×©×¨ ××ª×—×™×œ ×¢× ×—×œ×•×Ÿ ×‘×’×•×“×œ 1MSS. ×”×§×©×¨
××¡×ª×™×™× ×‘×¤×¢× ×”×¨××©×•× ×” ×©×”×•× ××’×™×¢ ×œ -SSthresh. ×‘××”×œ×š ×”×§×©×¨ ×œ× ××•×‘×“×•×ª ×—×‘×™×œ×•×ª. × ×¡××Ÿ ×‘×§×™×¦×•×¨:
.SSthresh=S*MSS
× ×ª×•×Ÿ ×›×™ ×œ××•×¨×š ×›×œ ×”×§×©×¨ rwnd < MSS*S.
××”×™ ×”×ª×¤×•×§×” ×©×œ ×”×§×©×¨ ×-A ×œ-B( ×‘ -sec / Bytes )×‘×–××Ÿ ×”× "×œ? × ××§×™.
]S*MSS / [lg (S) * RTT*2 ×‘×¢×¨×š .1
]S*MSS / [S^0.5 * RTT*2 ×‘×¢×¨×š .2
S*MSS / RTT ×‘×¢×¨×š .3
S^2)*MSS / RTT( ×‘×¢×¨×š .4
â— ×©×ª×™ ×ª×—× ×•×ª ××ª×§×©×¨×•×ª ×‘××•×¤×Ÿ ××œ×—×•×˜×™ ×‘×©×™×˜×ª N Back Go.
× ×¡××Ÿ ×‘-X ××ª ×¡×¤×¨×ª ×”×‘×™×§×•×¨×ª ×©×œ ×”×ª.×–. ×©×œ×š. ×× ×©× ×™ ×©×•×ª×¤×™× ××’×™×©×™× ××ª ×”×ª×¨×’×™×œ ×™×—×“, X ×”×•× ×¡×¤×¨×ª
×”×‘×™×§×•×¨×ª ×‘×¢×œ×ª ×”×¢×¨×š ×”× ××•×š ×™×•×ª×¨ ××‘×™×Ÿ ×”×©×ª×™×™×.
×§×¦×‘ ×”×ª×§×©×•×¨×ª ×”×•× 8Gbps, ×•×’×•×“×œ ×›×œ ×—×‘×™×œ×” ×”×•× KByte*X. ×’×“×œ×™ ×”-headers ×•×” -Acks ×–× ×™×—×™×.
ï¿½ğ‘’ğ‘ ï¿½/ï¿½ï¿½ 8 , ×•×”××¨×—×§ ×‘×™×Ÿ ×”×ª×—× ×•×ª ×”×•× 1Km. ×§×¦×‘ ×”×”×ª×¤×©×˜×•×ª ×”×•× 10 â‹… 2
×–××Ÿ ×¢×™×‘×•×“ ×”× ×ª×•× ×™× ×‘×ª×—× ×•×ª ×–× ×™×—.
××£ ×—×‘×™×œ×” ×•××£ Ack ×œ× ×”×•×œ×›×™× ×œ××™×‘×•×“.
â— ××”×• X ×©×œ×š?
â— ××” ×¦×¨×™×š ×œ×”×™×•×ª ×’×•×“×œ ×—×œ×•×Ÿ ×”××©×œ×•×— ×›×“×™ ×œ×”×‘×˜×™×— ×ª×¤×•×§×” ××§×¡×™××œ×™×ª?
 Communication Networks Course
Page | 9
Bonus â€“ Improving the Reliable UDP â€“ 15 points
Note: This part isnâ€™t mandatory and is a bonus only!
In this part, youâ€™ll improve your RUDP implementation by adding the concepts of flow
control and congestion control from TCP. Youâ€™re free to choose which algorithms to
implement, as long as you explain in your PDF which algorithms youâ€™ve used. Youâ€™ll probably
need to make changes in the original design of the RUDP. Changes only need to be to the API
itself, ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„.
Points distribution:
â€¢ Flow control improvement â€“ 7 Points
â€¢ Congestion control improvement â€“ 8 points.
Guidance:
â€¢ For flow control, you must use one of the Sliding window techniques: stop-and-wait
ARQ, Go-Back-N or Selective repeat.
â€¢ List of known TCP congestion control algorithms, which you can use any one of them
for this bonus task, or makeup your own:
Figure 2 â€“ List of known TCP congestion control algorithms, Wikipedia
 Communication Networks Course
Page | 10
Appendix A â€“ Linux local packet loss tool
To simulate a packet loss in a local network, we'll use a Linux tool that's called Linux Traffic
Control (ğ‘¡ğ‘). This requires a full Linux installation, so working with WSL won't work.
If the tool isn't installed in your machine, you can install it by using the following commands:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’
If the installation didn't work, you can use the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’2
To create a packet loss scenario, type the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘ğ‘‘ğ‘‘ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
After creating a packet loss scenario, you can change the percentage by typing the following
command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘â„ğ‘ğ‘›ğ‘”ğ‘’ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
To remove the packet loss scenario, write the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘‘ğ‘’ğ‘™ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š
 Communication Networks Course
Page | 11
Appendix B â€“ ğ’ğ’‚ğ’(ğŸ) system calls
This appendixâ€™s purpose is to give you a better understanding of socket handling in C.
A recommended reference is Beejâ€™s Guide to Network Programming, by Brian â€œBeej
Jorgensenâ€ Hall, which gives a lot of information about sockets in C and functions.
Functions and documentation links:
â€¢ ğ’”ğ’ğ’„ğ’Œğ’†ğ’•(ğŸ) â€“ A Factory method system call that creates a socket with the given
parameters.
â€¢ ğ’ƒğ’Šğ’ğ’…(ğŸ) â€“ Whenever we create a new socket, we need to bind it to a specific port in
our machine, â€œto catch a portâ€. The port number is managed and used by the kernel
to link incoming packets to the corresponding application socket. The port numbers
are usually fixed. The ğ‘ğ‘‘ğ‘‘ğ‘Ÿ parameter must match the current socket that is used.
â€¢ ğ’ğ’Šğ’”ğ’•ğ’†ğ’(ğŸ) â€“ The ğ‘™ğ‘–ğ‘ ğ‘¡ğ‘’ğ‘›(2) system call doesn't do anything in the mean of
communication but only memory allocation (malloc) for stream sockets only. If we
won't allocate memory, any incoming connection will fail.
â€¢ ğ’„ğ’ğ’ğ’ğ’†ğ’„ğ’•(ğŸ) â€“ The ğ‘ğ‘œğ‘›ğ‘›ğ‘’ğ‘ğ‘¡(2) system call starts the link between a client and a
specific IP address and port number. The connection would complete when the
other side will call the ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call.
â€¢ ğ’‚ğ’„ğ’„ğ’†ğ’‘ğ’•(ğŸ) â€“ The ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call accepts the incoming stream connection
request from the other side, by the listening socket. This system call completes the
three-way handshake of stream socket (like TCP) and opens a new socket that has a
direct communication channel only with the other party in the handshake.
â€¢ ğ’”ğ’†ğ’ğ’…(ğŸ) and ğ’”ğ’†ğ’ğ’…ğ’•ğ’(ğŸ) â€“ The ğ‘ ğ‘’ğ‘›ğ‘‘(2) and ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system calls are an analogy
for the ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’(2) system call, specifcly for sockets, with flags set to 0. Those system
calls return the number of bytes that were sent through the socket itself, as the
number of bytes can vary. The ğ‘ ğ‘’ğ‘›ğ‘‘(2)system call designed for stream sockets (like
TCP), while the ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system call designed for datagram connection-less
sockets (like UDP). When the ğ‘ ğ‘’ğ‘›ğ‘‘(2) system call returns 0, it means that the other
party closed the connection.
â€¢ ğ’“ğ’†ğ’„ğ’—(ğŸ) and ğ’“ğ’†ğ’„ğ’—ğ’‡ğ’“ğ’ğ’(ğŸ) â€“ The ğ‘Ÿğ‘’ğ‘ğ‘£(2) and ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system calls are an
analogy for the ğ‘Ÿğ‘’ğ‘ğ‘‘(2) system call, specifically for sockets, with flags set to 0.
Those system calls return the number of bytes that were received through the socket
itself, as the number of bytes can vary. The ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call designed for stream
sockets (like TCP), while the ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system call designed for datagram
connection-less sockets (like UDP). When the ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call returns 0, it means
that the other party closed the connection.
â€¢ ğ’„ğ’ğ’ğ’”ğ’†(ğŸ) and ğ’”ğ’‰ğ’–ğ’•ğ’…ğ’ğ’˜ğ’(ğŸ) â€“ The ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) and ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2) system calls close
the socket. While ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) system call closes the whole socket, the ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2)
system call partially closes the socket for read/write.
 Communication Networks Course
Page | 12
Appendix C â€“ Random data generator
The data that you are going to send in this assignment is randomly generated. You can use
your own file with appropriate size or use the following function (or a function of your own)
to generate the data:
/*
* @brief A random data generator function based on srand() and rand().
* @param size The size of the data to generate (up to 2^32 bytes).
* @return A pointer to the buffer.
*/
char *util_generate_random_data(unsigned int size) {
 char *buffer = NULL;
 // Argument check.
 if (size == 0)
 return NULL;
 buffer = (char *)calloc(size, sizeof(char));
 // Error checking.
 if (buffer == NULL)
 return NULL;
 // Randomize the seed of the random number generator.
 srand(time(NULL));
 for (unsigned int i = 0; i < size; i++)
 *(buffer + i) = ((unsigned int)rand() % 256);
 return buffer;
}
 Communication Networks Course
Page | 13
Appendix D â€“ Checksum function
A checksum is a small-sized block of data derived from another block of digital data for the
purpose of detecting errors that may have been introduced during its transmission or
storage. By themselves, checksums are often used to verify data integrity but are not relied
upon to verify data authenticity.
Below is a simple yet efficient implementation of the checksum function, you can use it for
the assignment, but you can implement your own checksum function.
/*
* @brief A checksum function that returns 16 bit checksum for data.
* @param data The data to do the checksum for.
* @param bytes The length of the data in bytes.
* @return The checksum itself as 16 bit unsigned number.
* @note This function is taken from RFC1071, can be found here:
* @note https://tools.ietf.org/html/rfc1071
* @note It is the simplest way to calculate a checksum and is not very strong.
* However, it is good enough for this assignment.
* @note You are free to use any other checksum function as well.
* You can also use this function as such without any change.
*/
unsigned short int calculate_checksum(void *data, unsigned int bytes) {
 unsigned short int *data_pointer = (unsigned short int *)data;
 unsigned int total_sum = 0;
 // Main summing loop
 while (bytes > 1) {
 total_sum += *data_pointer++;
 bytes -= 2;
 }
 // Add left-over byte, if any
 if (bytes > 0)
 total_sum += *((unsigned char *)data_pointer);
 // Fold 32-bit sum to 16 bits
 while (total_sum >> 16)
 total_sum = (total_sum & 0xFFFF) + (total_sum >> 16);
 return (~((unsigned short int)total_sum));
} Communication Networks Course
Page | 1
Assignment 3 â€“ Transport Layer
Assignment Notes and Instructions
This assignment is to be done in pairs only. You must upload all the necessary files in a ZIP
file named after both of the studentâ€™s ID. For example: ğŸğŸğŸ‘ğŸ’ğŸ“ğŸ”ğŸ•ğŸ–ğŸ—_ğŸ—ğŸ–ğŸ•ğŸ”ğŸ“ğŸ’ğŸ‘ğŸğŸ. ğ’›ğ’Šğ’‘.
1) The assignment must be submitted by the date specified in the submission box.
2) All the assignment files (Code, Wireshark pcap files, PDF) must be submitted in a ZIP file. The
PDF must contain all the necessary screenshots with a description for each one of them.
3) The assignment must be done in pairs only. In exceptional cases, you should send an email to
the course coordinator.
4) You can use any reference material available through the course Moodle website or any
material passed during the exercises.
5) You can use any reference from the web, but copying codes from websites is forbidden; this
includes codes from other GitHub repositories. A student who gets caught in the act will
automatically fail this assignment (score 0). Any website youâ€™ve used to solve the
assignment, every website you used to solve the assignment must be noted in the PDF.
6) No delays in submission without special permission. Lateness without approval will result in
failure of the assignment (score 0).
7) All submissions will be submitted via the course's Moodle website. Email submissions will not
be accepted, resulting in a failure in the assignment.
8) The order and design of the code must be carefully considered. Make sure that the program
output is as clear as possible, comments in the code, and meaningful variable names. You
must also submit a makefile that compiles all the programs.
9) The assignment code must be written in C only.
10) The assignment is personal for each pair, and you should not accept help from other people,
whether outside the university or inside it. You can contact the course staff during reception
hours for help or raise a question in the course forum. Do not transfer code sections
between students, upload solutions or parts of solutions to websites on the Internet or in
various communication groups.
11) Students who copy a solution will receive a 0 in all assignments in the course and a report will
be made to the institutional disciplinary committee.
12) All code files of the assignment are required to both compile and run properly on the Ubuntu
22.04 LTS operating system. This is the operating system where the submissions will be
tested. You mustnâ€™t code it in Windows, as it uses different API for sockets. WSL wonâ€™t work,
as the task needs a tool that works only in a fully Linux environment.
Good Luck!
 Communication Networks Course
Page | 2
Part A â€“ Transmission Control Protocol (TCP) â€“ 30 points
In this part, youâ€™ll write two program files: ğ‘»ğ‘ªğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and ğ‘»ğ‘ªğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
The Sender will send a randomly generated file and the Receiver will receive it and measure
the time it took for his program to receive the file. The file size should be at least 2MB.
When running the Sender and Receiver, they both should support two standard congestion
control algorithms: TCP Reno and TCP Cubic.
Notes:
â€¢ The main goal of this part is to get familiar with the TCP concept of sending
messages between two endpoints.
â€¢ For approaching this part of the assignment, please be sure that you are familiar
with the congestion control algorithms and how to change them using the correct
method in C (see Appendix B for more information).
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). You've
learned that TCP is reliable by design, so you can assume that all the data have been
passed correctly, and thus, no need to recheck.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
Usage:
â€¢ Receiver:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
â€¢ Sender:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port of the Receiver.
â€¢ ğ‘¨ğ‘³ğ‘®ğ‘¶ â€“ The TCP congestion control algorithm that will be used by the party
member (either ğ’“ğ’†ğ’ğ’ for TCP Reno or ğ’„ğ’–ğ’ƒğ’Šğ’„ for TCP Cubic).
 Communication Networks Course
Page | 3
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a TCP socket between the Sender and the
Receiver.
3) Send the file.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a TCP connection between the Receiver and
the Sender.
2) Get a connection from the sender.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./TCP_Receiver -p 1234 -algo reno
Starting Receiver...
Waiting for TCP connection...
Sender connected, beginning to receive file...
File transfer completed.
Waiting for Sender response...
Sender sent exit message.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 4
Part B â€“ Reliable User Datagram Protocol (Reliable UDP or RUDP) â€“ 40 points
Youâ€™ve learned that while TCP is reliable, it lacks speed and has an overhead data of 20 bytes,
compering to UDP that needs only 8 bytes of overhead data.
Reliable UDP or RUDP, is a protocol that uses the UDP protocol for a faster transmission of
data, while adding a reliability layer to it, but without adding too much overhead data like
TCP.
A simple sketch for a RUDP connection would look something like this:
Your task in this part is to implement a Reliable protocol using UDP only. For simplicity, your
implementation should only support a handshake, closing scheme, error checking,
acknowledgment of received packets, and retransmission of lost packets.
Guidance:
â€¢ You can use ğ‘ ğ‘’ğ‘¡ğ‘ ğ‘œğ‘ğ‘˜ğ‘œğ‘ğ‘¡(2) for detecting a timeout.
â€¢ You need to build your own protocol, as Reliable UDP isnâ€™t a standard protocol (see a
draft of RUDP in this link), and no official header is provided. You can use this sketch
for a header, but you can come up with your own protocol, as long as it works.
Where:
o ğ‘³ğ’†ğ’ğ’ˆğ’•ğ’‰ is the length of the data itself, without the RUDP header.
o ğ‘ªğ’‰ğ’†ğ’„ğ’Œğ’”ğ’–ğ’ is a 16bit number that validates the correctness of the data.
o ğ‘­ğ’ğ’‚ğ’ˆğ’” is a special byte where we classify the packet itself (SYN, ACK, etc.).
â€¢ In your PDF, you must explain how your implementation of RUDP works â€“ How does
it detect a timeout to do retransmissions, how does the handshake work, what is the
header overhead, etc.
â€¢ For this part, youâ€™ll write three files: ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¨ğ‘·ğ‘°. ğ’„, ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and
ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
Reliable UDP Header proposed sketch
Byte 0 Byte 1 Byte 2 Byte 3
Length (2 Bytes) Checksum (2 Bytes)
Flags (1 Byte)
Figure 1 - RUDP Protocol Architecture, Geeksforgeeks
 Communication Networks Course
Page | 5
Notes:
â€¢ The Sender will send a random generated file and the Receiver will receive it and
measure the time it took for his program to receive the file. The file size should be at
least 2MB.
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). But, as the
RUDP is based on UDP, itâ€™s not reliable. You must use some form of error checking
(like checksum) to ensure that the packet wasnâ€™t alerted during the transfer.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
â€¢ The RUDP needs support only 1 sender and 1 receiver, for simplicity purposes.
Usage:
â€¢ Receiver:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
â€¢ Sender:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port that both the Sender and the Receiver will use.
The ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„ file will contain all the implementations of the RUDP API functions (That is, to
prevent reusing the same chuck of code both in the Sender and the Receiver.).
The API should support at the bare minimum the following functions (you decide what
parameters to implement, and what are the names of the functions, as long as the API is
explained in the PDF):
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘œğ‘ğ‘˜ğ‘’ğ‘¡() â€“ Creating a RUDP socket and creating a handshake between two
peers.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘’ğ‘›ğ‘‘() â€“ Sending data to the peer. The function should wait for an
acknowledgment packet, and if it didnâ€™t receive any, retransmits the data.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘Ÿğ‘’ğ‘ğ‘£() â€“ Receive data from a peer.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ğ‘™ğ‘œğ‘ ğ‘’() â€“ Closes a connection between peers.
 Communication Networks Course
Page | 6
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a UDP socket between the Sender and the
Receiver.
3) Send the file via the RUDP protocol.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a UDP connection between the Receiver and
the Sender.
2) Get a connection from the sender, by the custom
RUDP protocol youâ€™ve built.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./RUDP_Receiver -p 1234
Starting Receiver...
Waiting for RUDP connection...
Connection request received, sending ACK.
Sender connected, beginning to receive file...
File transfer completed.
ACK sent.
Waiting for Sender response...
Sender sent exit message.
ACK sent.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 7
Part C â€“ Research â€“ 30 points
In this part, youâ€™ll conduct research about your implementations of part A and part B.
In the research itself, each one of the versions (TCP version and UDP version) will be run at
least 5 times (meaning that the file transfer will occur at least 5 times) by the following
conditions:
â€¢ For TCP, youâ€™ll run it in TCP Reno and TCP Cubic, alternating each time, for each
scenario, meaning that you run 5 times with TCP Reno in both Sender and Receiver,
and 5 times with TCP Cubic in both Sender and Receiver.
Bonus (5 points): Create a very large data set â€“ 5 times with TCP Reno in both Sender
and Receiver, 5 times with TCP Reno in Sender and TCP Cubic in Receiver, 5 times
with TCP Cubic in Sender and TCP Reno in Receiver, and 5 times with TCP Cubic in
both Sender and Receiver. This will give you a data set large enough, which allows
you to work with, compare with and to reach a definite conclusion.
â€¢ For RUDP, you will run it 5 times for each scenario.
â€¢ For both TCP and RUDP, you will run them on those scenarios of packet loss:
o 0% packet loss â€“ Control group, simulating perfect connection.
o 2% packet loss â€“ Simulating unstable connection that commonly occur.
o 5% packet loss â€“ Simulating bad connection.
o 10% packet loss â€“ Simulating extremely poor connection.
For each scenario, you must provide a filtered PCAP file and relevant screenshots that
explain each one of the steps in the process. (10 points)
After youâ€™ve gathered the data set for both TCP and Reliable UDP, answer the following
questions:
1) In TCP, which congestion control algorithm gave better results overall? TCP Reno or
TCP Cubic? Which one gave better results on high packet loss? Explain how you came
to this conclusion based on the data set youâ€™ve gathered. (5 points)
2) How did your implementation of Reliable UDP perform overall compared to regular
TCP? Which one is better for high packet loss? (5 points)
3) According to the data youâ€™ve gathered, in which scenarios and applications would we
prefer to use TCP and in which situations would we prefer to use reliable UDP?
Explain your answer. (5 points)
 Communication Networks Course
Page | 8
×¢× ×• ×¢×œ ×”×©××œ×•×ª ×”×‘××•×ª )5 × ×§×•×“×•×ª(:
â— ×‘"×¨×©×ª ×××™× ×”" ×”×›×•×•× ×” ×”×™× ×œ×¨×©×ª ×©×‘×” ××¢×˜ ×××•×“ ×—×‘×™×œ×•×ª ×”×•×œ×›×•×ª ×œ××™×‘×•×“. ×‘"×§×©×¨ ××¨×•×š" ×”×›×•×•× ×” ×”×™×
×œ×§×©×¨ TCP ×©×™×© ×‘×• ×”×¨×‘×” ×××•×“ ××™×“×¢ ×œ×©×œ×•×—. ××•×¦×¢ ×œ×”×’×“×™×œ ×‘ -TCP ××ª SSThreshold ×‘×ª×—×™×œ×ª ×”×§×©×¨.
×‘××™×–×” ××”××§×¨×™× ×”×‘××™× ×”×©×™× ×•×™ ×”×–×” ×¢×©×•×™ ×œ×”×•×¢×™×œ ×‘××™×“×” ×”××™×¨×‘×™×ª? × ××§.
.1 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
.2 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.3 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.4 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.5 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.6 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.7 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.8 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
â— A ×©×•×œ×— ×œ -B ×—×‘×™×œ×•×ª ××™×“×¢ ×‘×××¦×¢×•×ª ×§×©×¨ TCP. × ×ª×•×Ÿ ×›×™ ×”×§×©×¨ ××ª×—×™×œ ×¢× ×—×œ×•×Ÿ ×‘×’×•×“×œ 1MSS. ×”×§×©×¨
××¡×ª×™×™× ×‘×¤×¢× ×”×¨××©×•× ×” ×©×”×•× ××’×™×¢ ×œ -SSthresh. ×‘××”×œ×š ×”×§×©×¨ ×œ× ××•×‘×“×•×ª ×—×‘×™×œ×•×ª. × ×¡××Ÿ ×‘×§×™×¦×•×¨:
.SSthresh=S*MSS
× ×ª×•×Ÿ ×›×™ ×œ××•×¨×š ×›×œ ×”×§×©×¨ rwnd < MSS*S.
××”×™ ×”×ª×¤×•×§×” ×©×œ ×”×§×©×¨ ×-A ×œ-B( ×‘ -sec / Bytes )×‘×–××Ÿ ×”× "×œ? × ××§×™.
]S*MSS / [lg (S) * RTT*2 ×‘×¢×¨×š .1
]S*MSS / [S^0.5 * RTT*2 ×‘×¢×¨×š .2
S*MSS / RTT ×‘×¢×¨×š .3
S^2)*MSS / RTT( ×‘×¢×¨×š .4
â— ×©×ª×™ ×ª×—× ×•×ª ××ª×§×©×¨×•×ª ×‘××•×¤×Ÿ ××œ×—×•×˜×™ ×‘×©×™×˜×ª N Back Go.
× ×¡××Ÿ ×‘-X ××ª ×¡×¤×¨×ª ×”×‘×™×§×•×¨×ª ×©×œ ×”×ª.×–. ×©×œ×š. ×× ×©× ×™ ×©×•×ª×¤×™× ××’×™×©×™× ××ª ×”×ª×¨×’×™×œ ×™×—×“, X ×”×•× ×¡×¤×¨×ª
×”×‘×™×§×•×¨×ª ×‘×¢×œ×ª ×”×¢×¨×š ×”× ××•×š ×™×•×ª×¨ ××‘×™×Ÿ ×”×©×ª×™×™×.
×§×¦×‘ ×”×ª×§×©×•×¨×ª ×”×•× 8Gbps, ×•×’×•×“×œ ×›×œ ×—×‘×™×œ×” ×”×•× KByte*X. ×’×“×œ×™ ×”-headers ×•×” -Acks ×–× ×™×—×™×.
ï¿½ğ‘’ğ‘ ï¿½/ï¿½ï¿½ 8 , ×•×”××¨×—×§ ×‘×™×Ÿ ×”×ª×—× ×•×ª ×”×•× 1Km. ×§×¦×‘ ×”×”×ª×¤×©×˜×•×ª ×”×•× 10 â‹… 2
×–××Ÿ ×¢×™×‘×•×“ ×”× ×ª×•× ×™× ×‘×ª×—× ×•×ª ×–× ×™×—.
××£ ×—×‘×™×œ×” ×•××£ Ack ×œ× ×”×•×œ×›×™× ×œ××™×‘×•×“.
â— ××”×• X ×©×œ×š?
â— ××” ×¦×¨×™×š ×œ×”×™×•×ª ×’×•×“×œ ×—×œ×•×Ÿ ×”××©×œ×•×— ×›×“×™ ×œ×”×‘×˜×™×— ×ª×¤×•×§×” ××§×¡×™××œ×™×ª?
 Communication Networks Course
Page | 9
Bonus â€“ Improving the Reliable UDP â€“ 15 points
Note: This part isnâ€™t mandatory and is a bonus only!
In this part, youâ€™ll improve your RUDP implementation by adding the concepts of flow
control and congestion control from TCP. Youâ€™re free to choose which algorithms to
implement, as long as you explain in your PDF which algorithms youâ€™ve used. Youâ€™ll probably
need to make changes in the original design of the RUDP. Changes only need to be to the API
itself, ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„.
Points distribution:
â€¢ Flow control improvement â€“ 7 Points
â€¢ Congestion control improvement â€“ 8 points.
Guidance:
â€¢ For flow control, you must use one of the Sliding window techniques: stop-and-wait
ARQ, Go-Back-N or Selective repeat.
â€¢ List of known TCP congestion control algorithms, which you can use any one of them
for this bonus task, or makeup your own:
Figure 2 â€“ List of known TCP congestion control algorithms, Wikipedia
 Communication Networks Course
Page | 10
Appendix A â€“ Linux local packet loss tool
To simulate a packet loss in a local network, we'll use a Linux tool that's called Linux Traffic
Control (ğ‘¡ğ‘). This requires a full Linux installation, so working with WSL won't work.
If the tool isn't installed in your machine, you can install it by using the following commands:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’
If the installation didn't work, you can use the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’2
To create a packet loss scenario, type the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘ğ‘‘ğ‘‘ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
After creating a packet loss scenario, you can change the percentage by typing the following
command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘â„ğ‘ğ‘›ğ‘”ğ‘’ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
To remove the packet loss scenario, write the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘‘ğ‘’ğ‘™ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š
 Communication Networks Course
Page | 11
Appendix B â€“ ğ’ğ’‚ğ’(ğŸ) system calls
This appendixâ€™s purpose is to give you a better understanding of socket handling in C.
A recommended reference is Beejâ€™s Guide to Network Programming, by Brian â€œBeej
Jorgensenâ€ Hall, which gives a lot of information about sockets in C and functions.
Functions and documentation links:
â€¢ ğ’”ğ’ğ’„ğ’Œğ’†ğ’•(ğŸ) â€“ A Factory method system call that creates a socket with the given
parameters.
â€¢ ğ’ƒğ’Šğ’ğ’…(ğŸ) â€“ Whenever we create a new socket, we need to bind it to a specific port in
our machine, â€œto catch a portâ€. The port number is managed and used by the kernel
to link incoming packets to the corresponding application socket. The port numbers
are usually fixed. The ğ‘ğ‘‘ğ‘‘ğ‘Ÿ parameter must match the current socket that is used.
â€¢ ğ’ğ’Šğ’”ğ’•ğ’†ğ’(ğŸ) â€“ The ğ‘™ğ‘–ğ‘ ğ‘¡ğ‘’ğ‘›(2) system call doesn't do anything in the mean of
communication but only memory allocation (malloc) for stream sockets only. If we
won't allocate memory, any incoming connection will fail.
â€¢ ğ’„ğ’ğ’ğ’ğ’†ğ’„ğ’•(ğŸ) â€“ The ğ‘ğ‘œğ‘›ğ‘›ğ‘’ğ‘ğ‘¡(2) system call starts the link between a client and a
specific IP address and port number. The connection would complete when the
other side will call the ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call.
â€¢ ğ’‚ğ’„ğ’„ğ’†ğ’‘ğ’•(ğŸ) â€“ The ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call accepts the incoming stream connection
request from the other side, by the listening socket. This system call completes the
three-way handshake of stream socket (like TCP) and opens a new socket that has a
direct communication channel only with the other party in the handshake.
â€¢ ğ’”ğ’†ğ’ğ’…(ğŸ) and ğ’”ğ’†ğ’ğ’…ğ’•ğ’(ğŸ) â€“ The ğ‘ ğ‘’ğ‘›ğ‘‘(2) and ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system calls are an analogy
for the ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’(2) system call, specifcly for sockets, with flags set to 0. Those system
calls return the number of bytes that were sent through the socket itself, as the
number of bytes can vary. The ğ‘ ğ‘’ğ‘›ğ‘‘(2)system call designed for stream sockets (like
TCP), while the ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system call designed for datagram connection-less
sockets (like UDP). When the ğ‘ ğ‘’ğ‘›ğ‘‘(2) system call returns 0, it means that the other
party closed the connection.
â€¢ ğ’“ğ’†ğ’„ğ’—(ğŸ) and ğ’“ğ’†ğ’„ğ’—ğ’‡ğ’“ğ’ğ’(ğŸ) â€“ The ğ‘Ÿğ‘’ğ‘ğ‘£(2) and ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system calls are an
analogy for the ğ‘Ÿğ‘’ğ‘ğ‘‘(2) system call, specifically for sockets, with flags set to 0.
Those system calls return the number of bytes that were received through the socket
itself, as the number of bytes can vary. The ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call designed for stream
sockets (like TCP), while the ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system call designed for datagram
connection-less sockets (like UDP). When the ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call returns 0, it means
that the other party closed the connection.
â€¢ ğ’„ğ’ğ’ğ’”ğ’†(ğŸ) and ğ’”ğ’‰ğ’–ğ’•ğ’…ğ’ğ’˜ğ’(ğŸ) â€“ The ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) and ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2) system calls close
the socket. While ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) system call closes the whole socket, the ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2)
system call partially closes the socket for read/write.
 Communication Networks Course
Page | 12
Appendix C â€“ Random data generator
The data that you are going to send in this assignment is randomly generated. You can use
your own file with appropriate size or use the following function (or a function of your own)
to generate the data:
/*
* @brief A random data generator function based on srand() and rand().
* @param size The size of the data to generate (up to 2^32 bytes).
* @return A pointer to the buffer.
*/
char *util_generate_random_data(unsigned int size) {
 char *buffer = NULL;
 // Argument check.
 if (size == 0)
 return NULL;
 buffer = (char *)calloc(size, sizeof(char));
 // Error checking.
 if (buffer == NULL)
 return NULL;
 // Randomize the seed of the random number generator.
 srand(time(NULL));
 for (unsigned int i = 0; i < size; i++)
 *(buffer + i) = ((unsigned int)rand() % 256);
 return buffer;
}
 Communication Networks Course
Page | 13
Appendix D â€“ Checksum function
A checksum is a small-sized block of data derived from another block of digital data for the
purpose of detecting errors that may have been introduced during its transmission or
storage. By themselves, checksums are often used to verify data integrity but are not relied
upon to verify data authenticity.
Below is a simple yet efficient implementation of the checksum function, you can use it for
the assignment, but you can implement your own checksum function.
/*
* @brief A checksum function that returns 16 bit checksum for data.
* @param data The data to do the checksum for.
* @param bytes The length of the data in bytes.
* @return The checksum itself as 16 bit unsigned number.
* @note This function is taken from RFC1071, can be found here:
* @note https://tools.ietf.org/html/rfc1071
* @note It is the simplest way to calculate a checksum and is not very strong.
* However, it is good enough for this assignment.
* @note You are free to use any other checksum function as well.
* You can also use this function as such without any change.
*/
unsigned short int calculate_checksum(void *data, unsigned int bytes) {
 unsigned short int *data_pointer = (unsigned short int *)data;
 unsigned int total_sum = 0;
 // Main summing loop
 while (bytes > 1) {
 total_sum += *data_pointer++;
 bytes -= 2;
 }
 // Add left-over byte, if any
 if (bytes > 0)
 total_sum += *((unsigned char *)data_pointer);
 // Fold 32-bit sum to 16 bits
 while (total_sum >> 16)
 total_sum = (total_sum & 0xFFFF) + (total_sum >> 16);
 return (~((unsigned short int)total_sum));
} Communication Networks Course
Page | 1
Assignment 3 â€“ Transport Layer
Assignment Notes and Instructions
This assignment is to be done in pairs only. You must upload all the necessary files in a ZIP
file named after both of the studentâ€™s ID. For example: ğŸğŸğŸ‘ğŸ’ğŸ“ğŸ”ğŸ•ğŸ–ğŸ—_ğŸ—ğŸ–ğŸ•ğŸ”ğŸ“ğŸ’ğŸ‘ğŸğŸ. ğ’›ğ’Šğ’‘.
1) The assignment must be submitted by the date specified in the submission box.
2) All the assignment files (Code, Wireshark pcap files, PDF) must be submitted in a ZIP file. The
PDF must contain all the necessary screenshots with a description for each one of them.
3) The assignment must be done in pairs only. In exceptional cases, you should send an email to
the course coordinator.
4) You can use any reference material available through the course Moodle website or any
material passed during the exercises.
5) You can use any reference from the web, but copying codes from websites is forbidden; this
includes codes from other GitHub repositories. A student who gets caught in the act will
automatically fail this assignment (score 0). Any website youâ€™ve used to solve the
assignment, every website you used to solve the assignment must be noted in the PDF.
6) No delays in submission without special permission. Lateness without approval will result in
failure of the assignment (score 0).
7) All submissions will be submitted via the course's Moodle website. Email submissions will not
be accepted, resulting in a failure in the assignment.
8) The order and design of the code must be carefully considered. Make sure that the program
output is as clear as possible, comments in the code, and meaningful variable names. You
must also submit a makefile that compiles all the programs.
9) The assignment code must be written in C only.
10) The assignment is personal for each pair, and you should not accept help from other people,
whether outside the university or inside it. You can contact the course staff during reception
hours for help or raise a question in the course forum. Do not transfer code sections
between students, upload solutions or parts of solutions to websites on the Internet or in
various communication groups.
11) Students who copy a solution will receive a 0 in all assignments in the course and a report will
be made to the institutional disciplinary committee.
12) All code files of the assignment are required to both compile and run properly on the Ubuntu
22.04 LTS operating system. This is the operating system where the submissions will be
tested. You mustnâ€™t code it in Windows, as it uses different API for sockets. WSL wonâ€™t work,
as the task needs a tool that works only in a fully Linux environment.
Good Luck!
 Communication Networks Course
Page | 2
Part A â€“ Transmission Control Protocol (TCP) â€“ 30 points
In this part, youâ€™ll write two program files: ğ‘»ğ‘ªğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and ğ‘»ğ‘ªğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
The Sender will send a randomly generated file and the Receiver will receive it and measure
the time it took for his program to receive the file. The file size should be at least 2MB.
When running the Sender and Receiver, they both should support two standard congestion
control algorithms: TCP Reno and TCP Cubic.
Notes:
â€¢ The main goal of this part is to get familiar with the TCP concept of sending
messages between two endpoints.
â€¢ For approaching this part of the assignment, please be sure that you are familiar
with the congestion control algorithms and how to change them using the correct
method in C (see Appendix B for more information).
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). You've
learned that TCP is reliable by design, so you can assume that all the data have been
passed correctly, and thus, no need to recheck.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
Usage:
â€¢ Receiver:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
â€¢ Sender:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port of the Receiver.
â€¢ ğ‘¨ğ‘³ğ‘®ğ‘¶ â€“ The TCP congestion control algorithm that will be used by the party
member (either ğ’“ğ’†ğ’ğ’ for TCP Reno or ğ’„ğ’–ğ’ƒğ’Šğ’„ for TCP Cubic).
 Communication Networks Course
Page | 3
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a TCP socket between the Sender and the
Receiver.
3) Send the file.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a TCP connection between the Receiver and
the Sender.
2) Get a connection from the sender.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./TCP_Receiver -p 1234 -algo reno
Starting Receiver...
Waiting for TCP connection...
Sender connected, beginning to receive file...
File transfer completed.
Waiting for Sender response...
Sender sent exit message.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 4
Part B â€“ Reliable User Datagram Protocol (Reliable UDP or RUDP) â€“ 40 points
Youâ€™ve learned that while TCP is reliable, it lacks speed and has an overhead data of 20 bytes,
compering to UDP that needs only 8 bytes of overhead data.
Reliable UDP or RUDP, is a protocol that uses the UDP protocol for a faster transmission of
data, while adding a reliability layer to it, but without adding too much overhead data like
TCP.
A simple sketch for a RUDP connection would look something like this:
Your task in this part is to implement a Reliable protocol using UDP only. For simplicity, your
implementation should only support a handshake, closing scheme, error checking,
acknowledgment of received packets, and retransmission of lost packets.
Guidance:
â€¢ You can use ğ‘ ğ‘’ğ‘¡ğ‘ ğ‘œğ‘ğ‘˜ğ‘œğ‘ğ‘¡(2) for detecting a timeout.
â€¢ You need to build your own protocol, as Reliable UDP isnâ€™t a standard protocol (see a
draft of RUDP in this link), and no official header is provided. You can use this sketch
for a header, but you can come up with your own protocol, as long as it works.
Where:
o ğ‘³ğ’†ğ’ğ’ˆğ’•ğ’‰ is the length of the data itself, without the RUDP header.
o ğ‘ªğ’‰ğ’†ğ’„ğ’Œğ’”ğ’–ğ’ is a 16bit number that validates the correctness of the data.
o ğ‘­ğ’ğ’‚ğ’ˆğ’” is a special byte where we classify the packet itself (SYN, ACK, etc.).
â€¢ In your PDF, you must explain how your implementation of RUDP works â€“ How does
it detect a timeout to do retransmissions, how does the handshake work, what is the
header overhead, etc.
â€¢ For this part, youâ€™ll write three files: ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¨ğ‘·ğ‘°. ğ’„, ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and
ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
Reliable UDP Header proposed sketch
Byte 0 Byte 1 Byte 2 Byte 3
Length (2 Bytes) Checksum (2 Bytes)
Flags (1 Byte)
Figure 1 - RUDP Protocol Architecture, Geeksforgeeks
 Communication Networks Course
Page | 5
Notes:
â€¢ The Sender will send a random generated file and the Receiver will receive it and
measure the time it took for his program to receive the file. The file size should be at
least 2MB.
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). But, as the
RUDP is based on UDP, itâ€™s not reliable. You must use some form of error checking
(like checksum) to ensure that the packet wasnâ€™t alerted during the transfer.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
â€¢ The RUDP needs support only 1 sender and 1 receiver, for simplicity purposes.
Usage:
â€¢ Receiver:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
â€¢ Sender:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port that both the Sender and the Receiver will use.
The ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„ file will contain all the implementations of the RUDP API functions (That is, to
prevent reusing the same chuck of code both in the Sender and the Receiver.).
The API should support at the bare minimum the following functions (you decide what
parameters to implement, and what are the names of the functions, as long as the API is
explained in the PDF):
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘œğ‘ğ‘˜ğ‘’ğ‘¡() â€“ Creating a RUDP socket and creating a handshake between two
peers.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘’ğ‘›ğ‘‘() â€“ Sending data to the peer. The function should wait for an
acknowledgment packet, and if it didnâ€™t receive any, retransmits the data.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘Ÿğ‘’ğ‘ğ‘£() â€“ Receive data from a peer.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ğ‘™ğ‘œğ‘ ğ‘’() â€“ Closes a connection between peers.
 Communication Networks Course
Page | 6
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a UDP socket between the Sender and the
Receiver.
3) Send the file via the RUDP protocol.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a UDP connection between the Receiver and
the Sender.
2) Get a connection from the sender, by the custom
RUDP protocol youâ€™ve built.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./RUDP_Receiver -p 1234
Starting Receiver...
Waiting for RUDP connection...
Connection request received, sending ACK.
Sender connected, beginning to receive file...
File transfer completed.
ACK sent.
Waiting for Sender response...
Sender sent exit message.
ACK sent.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 7
Part C â€“ Research â€“ 30 points
In this part, youâ€™ll conduct research about your implementations of part A and part B.
In the research itself, each one of the versions (TCP version and UDP version) will be run at
least 5 times (meaning that the file transfer will occur at least 5 times) by the following
conditions:
â€¢ For TCP, youâ€™ll run it in TCP Reno and TCP Cubic, alternating each time, for each
scenario, meaning that you run 5 times with TCP Reno in both Sender and Receiver,
and 5 times with TCP Cubic in both Sender and Receiver.
Bonus (5 points): Create a very large data set â€“ 5 times with TCP Reno in both Sender
and Receiver, 5 times with TCP Reno in Sender and TCP Cubic in Receiver, 5 times
with TCP Cubic in Sender and TCP Reno in Receiver, and 5 times with TCP Cubic in
both Sender and Receiver. This will give you a data set large enough, which allows
you to work with, compare with and to reach a definite conclusion.
â€¢ For RUDP, you will run it 5 times for each scenario.
â€¢ For both TCP and RUDP, you will run them on those scenarios of packet loss:
o 0% packet loss â€“ Control group, simulating perfect connection.
o 2% packet loss â€“ Simulating unstable connection that commonly occur.
o 5% packet loss â€“ Simulating bad connection.
o 10% packet loss â€“ Simulating extremely poor connection.
For each scenario, you must provide a filtered PCAP file and relevant screenshots that
explain each one of the steps in the process. (10 points)
After youâ€™ve gathered the data set for both TCP and Reliable UDP, answer the following
questions:
1) In TCP, which congestion control algorithm gave better results overall? TCP Reno or
TCP Cubic? Which one gave better results on high packet loss? Explain how you came
to this conclusion based on the data set youâ€™ve gathered. (5 points)
2) How did your implementation of Reliable UDP perform overall compared to regular
TCP? Which one is better for high packet loss? (5 points)
3) According to the data youâ€™ve gathered, in which scenarios and applications would we
prefer to use TCP and in which situations would we prefer to use reliable UDP?
Explain your answer. (5 points)
 Communication Networks Course
Page | 8
×¢× ×• ×¢×œ ×”×©××œ×•×ª ×”×‘××•×ª )5 × ×§×•×“×•×ª(:
â— ×‘"×¨×©×ª ×××™× ×”" ×”×›×•×•× ×” ×”×™× ×œ×¨×©×ª ×©×‘×” ××¢×˜ ×××•×“ ×—×‘×™×œ×•×ª ×”×•×œ×›×•×ª ×œ××™×‘×•×“. ×‘"×§×©×¨ ××¨×•×š" ×”×›×•×•× ×” ×”×™×
×œ×§×©×¨ TCP ×©×™×© ×‘×• ×”×¨×‘×” ×××•×“ ××™×“×¢ ×œ×©×œ×•×—. ××•×¦×¢ ×œ×”×’×“×™×œ ×‘ -TCP ××ª SSThreshold ×‘×ª×—×™×œ×ª ×”×§×©×¨.
×‘××™×–×” ××”××§×¨×™× ×”×‘××™× ×”×©×™× ×•×™ ×”×–×” ×¢×©×•×™ ×œ×”×•×¢×™×œ ×‘××™×“×” ×”××™×¨×‘×™×ª? × ××§.
.1 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
.2 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.3 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.4 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.5 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.6 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.7 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.8 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
â— A ×©×•×œ×— ×œ -B ×—×‘×™×œ×•×ª ××™×“×¢ ×‘×××¦×¢×•×ª ×§×©×¨ TCP. × ×ª×•×Ÿ ×›×™ ×”×§×©×¨ ××ª×—×™×œ ×¢× ×—×œ×•×Ÿ ×‘×’×•×“×œ 1MSS. ×”×§×©×¨
××¡×ª×™×™× ×‘×¤×¢× ×”×¨××©×•× ×” ×©×”×•× ××’×™×¢ ×œ -SSthresh. ×‘××”×œ×š ×”×§×©×¨ ×œ× ××•×‘×“×•×ª ×—×‘×™×œ×•×ª. × ×¡××Ÿ ×‘×§×™×¦×•×¨:
.SSthresh=S*MSS
× ×ª×•×Ÿ ×›×™ ×œ××•×¨×š ×›×œ ×”×§×©×¨ rwnd < MSS*S.
××”×™ ×”×ª×¤×•×§×” ×©×œ ×”×§×©×¨ ×-A ×œ-B( ×‘ -sec / Bytes )×‘×–××Ÿ ×”× "×œ? × ××§×™.
]S*MSS / [lg (S) * RTT*2 ×‘×¢×¨×š .1
]S*MSS / [S^0.5 * RTT*2 ×‘×¢×¨×š .2
S*MSS / RTT ×‘×¢×¨×š .3
S^2)*MSS / RTT( ×‘×¢×¨×š .4
â— ×©×ª×™ ×ª×—× ×•×ª ××ª×§×©×¨×•×ª ×‘××•×¤×Ÿ ××œ×—×•×˜×™ ×‘×©×™×˜×ª N Back Go.
× ×¡××Ÿ ×‘-X ××ª ×¡×¤×¨×ª ×”×‘×™×§×•×¨×ª ×©×œ ×”×ª.×–. ×©×œ×š. ×× ×©× ×™ ×©×•×ª×¤×™× ××’×™×©×™× ××ª ×”×ª×¨×’×™×œ ×™×—×“, X ×”×•× ×¡×¤×¨×ª
×”×‘×™×§×•×¨×ª ×‘×¢×œ×ª ×”×¢×¨×š ×”× ××•×š ×™×•×ª×¨ ××‘×™×Ÿ ×”×©×ª×™×™×.
×§×¦×‘ ×”×ª×§×©×•×¨×ª ×”×•× 8Gbps, ×•×’×•×“×œ ×›×œ ×—×‘×™×œ×” ×”×•× KByte*X. ×’×“×œ×™ ×”-headers ×•×” -Acks ×–× ×™×—×™×.
ï¿½ğ‘’ğ‘ ï¿½/ï¿½ï¿½ 8 , ×•×”××¨×—×§ ×‘×™×Ÿ ×”×ª×—× ×•×ª ×”×•× 1Km. ×§×¦×‘ ×”×”×ª×¤×©×˜×•×ª ×”×•× 10 â‹… 2
×–××Ÿ ×¢×™×‘×•×“ ×”× ×ª×•× ×™× ×‘×ª×—× ×•×ª ×–× ×™×—.
××£ ×—×‘×™×œ×” ×•××£ Ack ×œ× ×”×•×œ×›×™× ×œ××™×‘×•×“.
â— ××”×• X ×©×œ×š?
â— ××” ×¦×¨×™×š ×œ×”×™×•×ª ×’×•×“×œ ×—×œ×•×Ÿ ×”××©×œ×•×— ×›×“×™ ×œ×”×‘×˜×™×— ×ª×¤×•×§×” ××§×¡×™××œ×™×ª?
 Communication Networks Course
Page | 9
Bonus â€“ Improving the Reliable UDP â€“ 15 points
Note: This part isnâ€™t mandatory and is a bonus only!
In this part, youâ€™ll improve your RUDP implementation by adding the concepts of flow
control and congestion control from TCP. Youâ€™re free to choose which algorithms to
implement, as long as you explain in your PDF which algorithms youâ€™ve used. Youâ€™ll probably
need to make changes in the original design of the RUDP. Changes only need to be to the API
itself, ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„.
Points distribution:
â€¢ Flow control improvement â€“ 7 Points
â€¢ Congestion control improvement â€“ 8 points.
Guidance:
â€¢ For flow control, you must use one of the Sliding window techniques: stop-and-wait
ARQ, Go-Back-N or Selective repeat.
â€¢ List of known TCP congestion control algorithms, which you can use any one of them
for this bonus task, or makeup your own:
Figure 2 â€“ List of known TCP congestion control algorithms, Wikipedia
 Communication Networks Course
Page | 10
Appendix A â€“ Linux local packet loss tool
To simulate a packet loss in a local network, we'll use a Linux tool that's called Linux Traffic
Control (ğ‘¡ğ‘). This requires a full Linux installation, so working with WSL won't work.
If the tool isn't installed in your machine, you can install it by using the following commands:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’
If the installation didn't work, you can use the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’2
To create a packet loss scenario, type the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘ğ‘‘ğ‘‘ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
After creating a packet loss scenario, you can change the percentage by typing the following
command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘â„ğ‘ğ‘›ğ‘”ğ‘’ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
To remove the packet loss scenario, write the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘‘ğ‘’ğ‘™ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š
 Communication Networks Course
Page | 11
Appendix B â€“ ğ’ğ’‚ğ’(ğŸ) system calls
This appendixâ€™s purpose is to give you a better understanding of socket handling in C.
A recommended reference is Beejâ€™s Guide to Network Programming, by Brian â€œBeej
Jorgensenâ€ Hall, which gives a lot of information about sockets in C and functions.
Functions and documentation links:
â€¢ ğ’”ğ’ğ’„ğ’Œğ’†ğ’•(ğŸ) â€“ A Factory method system call that creates a socket with the given
parameters.
â€¢ ğ’ƒğ’Šğ’ğ’…(ğŸ) â€“ Whenever we create a new socket, we need to bind it to a specific port in
our machine, â€œto catch a portâ€. The port number is managed and used by the kernel
to link incoming packets to the corresponding application socket. The port numbers
are usually fixed. The ğ‘ğ‘‘ğ‘‘ğ‘Ÿ parameter must match the current socket that is used.
â€¢ ğ’ğ’Šğ’”ğ’•ğ’†ğ’(ğŸ) â€“ The ğ‘™ğ‘–ğ‘ ğ‘¡ğ‘’ğ‘›(2) system call doesn't do anything in the mean of
communication but only memory allocation (malloc) for stream sockets only. If we
won't allocate memory, any incoming connection will fail.
â€¢ ğ’„ğ’ğ’ğ’ğ’†ğ’„ğ’•(ğŸ) â€“ The ğ‘ğ‘œğ‘›ğ‘›ğ‘’ğ‘ğ‘¡(2) system call starts the link between a client and a
specific IP address and port number. The connection would complete when the
other side will call the ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call.
â€¢ ğ’‚ğ’„ğ’„ğ’†ğ’‘ğ’•(ğŸ) â€“ The ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call accepts the incoming stream connection
request from the other side, by the listening socket. This system call completes the
three-way handshake of stream socket (like TCP) and opens a new socket that has a
direct communication channel only with the other party in the handshake.
â€¢ ğ’”ğ’†ğ’ğ’…(ğŸ) and ğ’”ğ’†ğ’ğ’…ğ’•ğ’(ğŸ) â€“ The ğ‘ ğ‘’ğ‘›ğ‘‘(2) and ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system calls are an analogy
for the ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’(2) system call, specifcly for sockets, with flags set to 0. Those system
calls return the number of bytes that were sent through the socket itself, as the
number of bytes can vary. The ğ‘ ğ‘’ğ‘›ğ‘‘(2)system call designed for stream sockets (like
TCP), while the ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system call designed for datagram connection-less
sockets (like UDP). When the ğ‘ ğ‘’ğ‘›ğ‘‘(2) system call returns 0, it means that the other
party closed the connection.
â€¢ ğ’“ğ’†ğ’„ğ’—(ğŸ) and ğ’“ğ’†ğ’„ğ’—ğ’‡ğ’“ğ’ğ’(ğŸ) â€“ The ğ‘Ÿğ‘’ğ‘ğ‘£(2) and ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system calls are an
analogy for the ğ‘Ÿğ‘’ğ‘ğ‘‘(2) system call, specifically for sockets, with flags set to 0.
Those system calls return the number of bytes that were received through the socket
itself, as the number of bytes can vary. The ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call designed for stream
sockets (like TCP), while the ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system call designed for datagram
connection-less sockets (like UDP). When the ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call returns 0, it means
that the other party closed the connection.
â€¢ ğ’„ğ’ğ’ğ’”ğ’†(ğŸ) and ğ’”ğ’‰ğ’–ğ’•ğ’…ğ’ğ’˜ğ’(ğŸ) â€“ The ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) and ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2) system calls close
the socket. While ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) system call closes the whole socket, the ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2)
system call partially closes the socket for read/write.
 Communication Networks Course
Page | 12
Appendix C â€“ Random data generator
The data that you are going to send in this assignment is randomly generated. You can use
your own file with appropriate size or use the following function (or a function of your own)
to generate the data:
/*
* @brief A random data generator function based on srand() and rand().
* @param size The size of the data to generate (up to 2^32 bytes).
* @return A pointer to the buffer.
*/
char *util_generate_random_data(unsigned int size) {
 char *buffer = NULL;
 // Argument check.
 if (size == 0)
 return NULL;
 buffer = (char *)calloc(size, sizeof(char));
 // Error checking.
 if (buffer == NULL)
 return NULL;
 // Randomize the seed of the random number generator.
 srand(time(NULL));
 for (unsigned int i = 0; i < size; i++)
 *(buffer + i) = ((unsigned int)rand() % 256);
 return buffer;
}
 Communication Networks Course
Page | 13
Appendix D â€“ Checksum function
A checksum is a small-sized block of data derived from another block of digital data for the
purpose of detecting errors that may have been introduced during its transmission or
storage. By themselves, checksums are often used to verify data integrity but are not relied
upon to verify data authenticity.
Below is a simple yet efficient implementation of the checksum function, you can use it for
the assignment, but you can implement your own checksum function.
/*
* @brief A checksum function that returns 16 bit checksum for data.
* @param data The data to do the checksum for.
* @param bytes The length of the data in bytes.
* @return The checksum itself as 16 bit unsigned number.
* @note This function is taken from RFC1071, can be found here:
* @note https://tools.ietf.org/html/rfc1071
* @note It is the simplest way to calculate a checksum and is not very strong.
* However, it is good enough for this assignment.
* @note You are free to use any other checksum function as well.
* You can also use this function as such without any change.
*/
unsigned short int calculate_checksum(void *data, unsigned int bytes) {
 unsigned short int *data_pointer = (unsigned short int *)data;
 unsigned int total_sum = 0;
 // Main summing loop
 while (bytes > 1) {
 total_sum += *data_pointer++;
 bytes -= 2;
 }
 // Add left-over byte, if any
 if (bytes > 0)
 total_sum += *((unsigned char *)data_pointer);
 // Fold 32-bit sum to 16 bits
 while (total_sum >> 16)
 total_sum = (total_sum & 0xFFFF) + (total_sum >> 16);
 return (~((unsigned short int)total_sum));
} Communication Networks Course
Page | 1
Assignment 3 â€“ Transport Layer
Assignment Notes and Instructions
This assignment is to be done in pairs only. You must upload all the necessary files in a ZIP
file named after both of the studentâ€™s ID. For example: ğŸğŸğŸ‘ğŸ’ğŸ“ğŸ”ğŸ•ğŸ–ğŸ—_ğŸ—ğŸ–ğŸ•ğŸ”ğŸ“ğŸ’ğŸ‘ğŸğŸ. ğ’›ğ’Šğ’‘.
1) The assignment must be submitted by the date specified in the submission box.
2) All the assignment files (Code, Wireshark pcap files, PDF) must be submitted in a ZIP file. The
PDF must contain all the necessary screenshots with a description for each one of them.
3) The assignment must be done in pairs only. In exceptional cases, you should send an email to
the course coordinator.
4) You can use any reference material available through the course Moodle website or any
material passed during the exercises.
5) You can use any reference from the web, but copying codes from websites is forbidden; this
includes codes from other GitHub repositories. A student who gets caught in the act will
automatically fail this assignment (score 0). Any website youâ€™ve used to solve the
assignment, every website you used to solve the assignment must be noted in the PDF.
6) No delays in submission without special permission. Lateness without approval will result in
failure of the assignment (score 0).
7) All submissions will be submitted via the course's Moodle website. Email submissions will not
be accepted, resulting in a failure in the assignment.
8) The order and design of the code must be carefully considered. Make sure that the program
output is as clear as possible, comments in the code, and meaningful variable names. You
must also submit a makefile that compiles all the programs.
9) The assignment code must be written in C only.
10) The assignment is personal for each pair, and you should not accept help from other people,
whether outside the university or inside it. You can contact the course staff during reception
hours for help or raise a question in the course forum. Do not transfer code sections
between students, upload solutions or parts of solutions to websites on the Internet or in
various communication groups.
11) Students who copy a solution will receive a 0 in all assignments in the course and a report will
be made to the institutional disciplinary committee.
12) All code files of the assignment are required to both compile and run properly on the Ubuntu
22.04 LTS operating system. This is the operating system where the submissions will be
tested. You mustnâ€™t code it in Windows, as it uses different API for sockets. WSL wonâ€™t work,
as the task needs a tool that works only in a fully Linux environment.
Good Luck!
 Communication Networks Course
Page | 2
Part A â€“ Transmission Control Protocol (TCP) â€“ 30 points
In this part, youâ€™ll write two program files: ğ‘»ğ‘ªğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and ğ‘»ğ‘ªğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
The Sender will send a randomly generated file and the Receiver will receive it and measure
the time it took for his program to receive the file. The file size should be at least 2MB.
When running the Sender and Receiver, they both should support two standard congestion
control algorithms: TCP Reno and TCP Cubic.
Notes:
â€¢ The main goal of this part is to get familiar with the TCP concept of sending
messages between two endpoints.
â€¢ For approaching this part of the assignment, please be sure that you are familiar
with the congestion control algorithms and how to change them using the correct
method in C (see Appendix B for more information).
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). You've
learned that TCP is reliable by design, so you can assume that all the data have been
passed correctly, and thus, no need to recheck.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
Usage:
â€¢ Receiver:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
â€¢ Sender:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port of the Receiver.
â€¢ ğ‘¨ğ‘³ğ‘®ğ‘¶ â€“ The TCP congestion control algorithm that will be used by the party
member (either ğ’“ğ’†ğ’ğ’ for TCP Reno or ğ’„ğ’–ğ’ƒğ’Šğ’„ for TCP Cubic).
 Communication Networks Course
Page | 3
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a TCP socket between the Sender and the
Receiver.
3) Send the file.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a TCP connection between the Receiver and
the Sender.
2) Get a connection from the sender.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./TCP_Receiver -p 1234 -algo reno
Starting Receiver...
Waiting for TCP connection...
Sender connected, beginning to receive file...
File transfer completed.
Waiting for Sender response...
Sender sent exit message.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 4
Part B â€“ Reliable User Datagram Protocol (Reliable UDP or RUDP) â€“ 40 points
Youâ€™ve learned that while TCP is reliable, it lacks speed and has an overhead data of 20 bytes,
compering to UDP that needs only 8 bytes of overhead data.
Reliable UDP or RUDP, is a protocol that uses the UDP protocol for a faster transmission of
data, while adding a reliability layer to it, but without adding too much overhead data like
TCP.
A simple sketch for a RUDP connection would look something like this:
Your task in this part is to implement a Reliable protocol using UDP only. For simplicity, your
implementation should only support a handshake, closing scheme, error checking,
acknowledgment of received packets, and retransmission of lost packets.
Guidance:
â€¢ You can use ğ‘ ğ‘’ğ‘¡ğ‘ ğ‘œğ‘ğ‘˜ğ‘œğ‘ğ‘¡(2) for detecting a timeout.
â€¢ You need to build your own protocol, as Reliable UDP isnâ€™t a standard protocol (see a
draft of RUDP in this link), and no official header is provided. You can use this sketch
for a header, but you can come up with your own protocol, as long as it works.
Where:
o ğ‘³ğ’†ğ’ğ’ˆğ’•ğ’‰ is the length of the data itself, without the RUDP header.
o ğ‘ªğ’‰ğ’†ğ’„ğ’Œğ’”ğ’–ğ’ is a 16bit number that validates the correctness of the data.
o ğ‘­ğ’ğ’‚ğ’ˆğ’” is a special byte where we classify the packet itself (SYN, ACK, etc.).
â€¢ In your PDF, you must explain how your implementation of RUDP works â€“ How does
it detect a timeout to do retransmissions, how does the handshake work, what is the
header overhead, etc.
â€¢ For this part, youâ€™ll write three files: ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¨ğ‘·ğ‘°. ğ’„, ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and
ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
Reliable UDP Header proposed sketch
Byte 0 Byte 1 Byte 2 Byte 3
Length (2 Bytes) Checksum (2 Bytes)
Flags (1 Byte)
Figure 1 - RUDP Protocol Architecture, Geeksforgeeks
 Communication Networks Course
Page | 5
Notes:
â€¢ The Sender will send a random generated file and the Receiver will receive it and
measure the time it took for his program to receive the file. The file size should be at
least 2MB.
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). But, as the
RUDP is based on UDP, itâ€™s not reliable. You must use some form of error checking
(like checksum) to ensure that the packet wasnâ€™t alerted during the transfer.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
â€¢ The RUDP needs support only 1 sender and 1 receiver, for simplicity purposes.
Usage:
â€¢ Receiver:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
â€¢ Sender:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port that both the Sender and the Receiver will use.
The ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„ file will contain all the implementations of the RUDP API functions (That is, to
prevent reusing the same chuck of code both in the Sender and the Receiver.).
The API should support at the bare minimum the following functions (you decide what
parameters to implement, and what are the names of the functions, as long as the API is
explained in the PDF):
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘œğ‘ğ‘˜ğ‘’ğ‘¡() â€“ Creating a RUDP socket and creating a handshake between two
peers.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘’ğ‘›ğ‘‘() â€“ Sending data to the peer. The function should wait for an
acknowledgment packet, and if it didnâ€™t receive any, retransmits the data.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘Ÿğ‘’ğ‘ğ‘£() â€“ Receive data from a peer.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ğ‘™ğ‘œğ‘ ğ‘’() â€“ Closes a connection between peers.
 Communication Networks Course
Page | 6
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a UDP socket between the Sender and the
Receiver.
3) Send the file via the RUDP protocol.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a UDP connection between the Receiver and
the Sender.
2) Get a connection from the sender, by the custom
RUDP protocol youâ€™ve built.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./RUDP_Receiver -p 1234
Starting Receiver...
Waiting for RUDP connection...
Connection request received, sending ACK.
Sender connected, beginning to receive file...
File transfer completed.
ACK sent.
Waiting for Sender response...
Sender sent exit message.
ACK sent.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 7
Part C â€“ Research â€“ 30 points
In this part, youâ€™ll conduct research about your implementations of part A and part B.
In the research itself, each one of the versions (TCP version and UDP version) will be run at
least 5 times (meaning that the file transfer will occur at least 5 times) by the following
conditions:
â€¢ For TCP, youâ€™ll run it in TCP Reno and TCP Cubic, alternating each time, for each
scenario, meaning that you run 5 times with TCP Reno in both Sender and Receiver,
and 5 times with TCP Cubic in both Sender and Receiver.
Bonus (5 points): Create a very large data set â€“ 5 times with TCP Reno in both Sender
and Receiver, 5 times with TCP Reno in Sender and TCP Cubic in Receiver, 5 times
with TCP Cubic in Sender and TCP Reno in Receiver, and 5 times with TCP Cubic in
both Sender and Receiver. This will give you a data set large enough, which allows
you to work with, compare with and to reach a definite conclusion.
â€¢ For RUDP, you will run it 5 times for each scenario.
â€¢ For both TCP and RUDP, you will run them on those scenarios of packet loss:
o 0% packet loss â€“ Control group, simulating perfect connection.
o 2% packet loss â€“ Simulating unstable connection that commonly occur.
o 5% packet loss â€“ Simulating bad connection.
o 10% packet loss â€“ Simulating extremely poor connection.
For each scenario, you must provide a filtered PCAP file and relevant screenshots that
explain each one of the steps in the process. (10 points)
After youâ€™ve gathered the data set for both TCP and Reliable UDP, answer the following
questions:
1) In TCP, which congestion control algorithm gave better results overall? TCP Reno or
TCP Cubic? Which one gave better results on high packet loss? Explain how you came
to this conclusion based on the data set youâ€™ve gathered. (5 points)
2) How did your implementation of Reliable UDP perform overall compared to regular
TCP? Which one is better for high packet loss? (5 points)
3) According to the data youâ€™ve gathered, in which scenarios and applications would we
prefer to use TCP and in which situations would we prefer to use reliable UDP?
Explain your answer. (5 points)
 Communication Networks Course
Page | 8
×¢× ×• ×¢×œ ×”×©××œ×•×ª ×”×‘××•×ª )5 × ×§×•×“×•×ª(:
â— ×‘"×¨×©×ª ×××™× ×”" ×”×›×•×•× ×” ×”×™× ×œ×¨×©×ª ×©×‘×” ××¢×˜ ×××•×“ ×—×‘×™×œ×•×ª ×”×•×œ×›×•×ª ×œ××™×‘×•×“. ×‘"×§×©×¨ ××¨×•×š" ×”×›×•×•× ×” ×”×™×
×œ×§×©×¨ TCP ×©×™×© ×‘×• ×”×¨×‘×” ×××•×“ ××™×“×¢ ×œ×©×œ×•×—. ××•×¦×¢ ×œ×”×’×“×™×œ ×‘ -TCP ××ª SSThreshold ×‘×ª×—×™×œ×ª ×”×§×©×¨.
×‘××™×–×” ××”××§×¨×™× ×”×‘××™× ×”×©×™× ×•×™ ×”×–×” ×¢×©×•×™ ×œ×”×•×¢×™×œ ×‘××™×“×” ×”××™×¨×‘×™×ª? × ××§.
.1 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
.2 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.3 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.4 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.5 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.6 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.7 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.8 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
â— A ×©×•×œ×— ×œ -B ×—×‘×™×œ×•×ª ××™×“×¢ ×‘×××¦×¢×•×ª ×§×©×¨ TCP. × ×ª×•×Ÿ ×›×™ ×”×§×©×¨ ××ª×—×™×œ ×¢× ×—×œ×•×Ÿ ×‘×’×•×“×œ 1MSS. ×”×§×©×¨
××¡×ª×™×™× ×‘×¤×¢× ×”×¨××©×•× ×” ×©×”×•× ××’×™×¢ ×œ -SSthresh. ×‘××”×œ×š ×”×§×©×¨ ×œ× ××•×‘×“×•×ª ×—×‘×™×œ×•×ª. × ×¡××Ÿ ×‘×§×™×¦×•×¨:
.SSthresh=S*MSS
× ×ª×•×Ÿ ×›×™ ×œ××•×¨×š ×›×œ ×”×§×©×¨ rwnd < MSS*S.
××”×™ ×”×ª×¤×•×§×” ×©×œ ×”×§×©×¨ ×-A ×œ-B( ×‘ -sec / Bytes )×‘×–××Ÿ ×”× "×œ? × ××§×™.
]S*MSS / [lg (S) * RTT*2 ×‘×¢×¨×š .1
]S*MSS / [S^0.5 * RTT*2 ×‘×¢×¨×š .2
S*MSS / RTT ×‘×¢×¨×š .3
S^2)*MSS / RTT( ×‘×¢×¨×š .4
â— ×©×ª×™ ×ª×—× ×•×ª ××ª×§×©×¨×•×ª ×‘××•×¤×Ÿ ××œ×—×•×˜×™ ×‘×©×™×˜×ª N Back Go.
× ×¡××Ÿ ×‘-X ××ª ×¡×¤×¨×ª ×”×‘×™×§×•×¨×ª ×©×œ ×”×ª.×–. ×©×œ×š. ×× ×©× ×™ ×©×•×ª×¤×™× ××’×™×©×™× ××ª ×”×ª×¨×’×™×œ ×™×—×“, X ×”×•× ×¡×¤×¨×ª
×”×‘×™×§×•×¨×ª ×‘×¢×œ×ª ×”×¢×¨×š ×”× ××•×š ×™×•×ª×¨ ××‘×™×Ÿ ×”×©×ª×™×™×.
×§×¦×‘ ×”×ª×§×©×•×¨×ª ×”×•× 8Gbps, ×•×’×•×“×œ ×›×œ ×—×‘×™×œ×” ×”×•× KByte*X. ×’×“×œ×™ ×”-headers ×•×” -Acks ×–× ×™×—×™×.
ï¿½ğ‘’ğ‘ ï¿½/ï¿½ï¿½ 8 , ×•×”××¨×—×§ ×‘×™×Ÿ ×”×ª×—× ×•×ª ×”×•× 1Km. ×§×¦×‘ ×”×”×ª×¤×©×˜×•×ª ×”×•× 10 â‹… 2
×–××Ÿ ×¢×™×‘×•×“ ×”× ×ª×•× ×™× ×‘×ª×—× ×•×ª ×–× ×™×—.
××£ ×—×‘×™×œ×” ×•××£ Ack ×œ× ×”×•×œ×›×™× ×œ××™×‘×•×“.
â— ××”×• X ×©×œ×š?
â— ××” ×¦×¨×™×š ×œ×”×™×•×ª ×’×•×“×œ ×—×œ×•×Ÿ ×”××©×œ×•×— ×›×“×™ ×œ×”×‘×˜×™×— ×ª×¤×•×§×” ××§×¡×™××œ×™×ª?
 Communication Networks Course
Page | 9
Bonus â€“ Improving the Reliable UDP â€“ 15 points
Note: This part isnâ€™t mandatory and is a bonus only!
In this part, youâ€™ll improve your RUDP implementation by adding the concepts of flow
control and congestion control from TCP. Youâ€™re free to choose which algorithms to
implement, as long as you explain in your PDF which algorithms youâ€™ve used. Youâ€™ll probably
need to make changes in the original design of the RUDP. Changes only need to be to the API
itself, ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„.
Points distribution:
â€¢ Flow control improvement â€“ 7 Points
â€¢ Congestion control improvement â€“ 8 points.
Guidance:
â€¢ For flow control, you must use one of the Sliding window techniques: stop-and-wait
ARQ, Go-Back-N or Selective repeat.
â€¢ List of known TCP congestion control algorithms, which you can use any one of them
for this bonus task, or makeup your own:
Figure 2 â€“ List of known TCP congestion control algorithms, Wikipedia
 Communication Networks Course
Page | 10
Appendix A â€“ Linux local packet loss tool
To simulate a packet loss in a local network, we'll use a Linux tool that's called Linux Traffic
Control (ğ‘¡ğ‘). This requires a full Linux installation, so working with WSL won't work.
If the tool isn't installed in your machine, you can install it by using the following commands:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’
If the installation didn't work, you can use the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’2
To create a packet loss scenario, type the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘ğ‘‘ğ‘‘ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
After creating a packet loss scenario, you can change the percentage by typing the following
command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘â„ğ‘ğ‘›ğ‘”ğ‘’ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
To remove the packet loss scenario, write the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘‘ğ‘’ğ‘™ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š
 Communication Networks Course
Page | 11
Appendix B â€“ ğ’ğ’‚ğ’(ğŸ) system calls
This appendixâ€™s purpose is to give you a better understanding of socket handling in C.
A recommended reference is Beejâ€™s Guide to Network Programming, by Brian â€œBeej
Jorgensenâ€ Hall, which gives a lot of information about sockets in C and functions.
Functions and documentation links:
â€¢ ğ’”ğ’ğ’„ğ’Œğ’†ğ’•(ğŸ) â€“ A Factory method system call that creates a socket with the given
parameters.
â€¢ ğ’ƒğ’Šğ’ğ’…(ğŸ) â€“ Whenever we create a new socket, we need to bind it to a specific port in
our machine, â€œto catch a portâ€. The port number is managed and used by the kernel
to link incoming packets to the corresponding application socket. The port numbers
are usually fixed. The ğ‘ğ‘‘ğ‘‘ğ‘Ÿ parameter must match the current socket that is used.
â€¢ ğ’ğ’Šğ’”ğ’•ğ’†ğ’(ğŸ) â€“ The ğ‘™ğ‘–ğ‘ ğ‘¡ğ‘’ğ‘›(2) system call doesn't do anything in the mean of
communication but only memory allocation (malloc) for stream sockets only. If we
won't allocate memory, any incoming connection will fail.
â€¢ ğ’„ğ’ğ’ğ’ğ’†ğ’„ğ’•(ğŸ) â€“ The ğ‘ğ‘œğ‘›ğ‘›ğ‘’ğ‘ğ‘¡(2) system call starts the link between a client and a
specific IP address and port number. The connection would complete when the
other side will call the ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call.
â€¢ ğ’‚ğ’„ğ’„ğ’†ğ’‘ğ’•(ğŸ) â€“ The ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call accepts the incoming stream connection
request from the other side, by the listening socket. This system call completes the
three-way handshake of stream socket (like TCP) and opens a new socket that has a
direct communication channel only with the other party in the handshake.
â€¢ ğ’”ğ’†ğ’ğ’…(ğŸ) and ğ’”ğ’†ğ’ğ’…ğ’•ğ’(ğŸ) â€“ The ğ‘ ğ‘’ğ‘›ğ‘‘(2) and ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system calls are an analogy
for the ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’(2) system call, specifcly for sockets, with flags set to 0. Those system
calls return the number of bytes that were sent through the socket itself, as the
number of bytes can vary. The ğ‘ ğ‘’ğ‘›ğ‘‘(2)system call designed for stream sockets (like
TCP), while the ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system call designed for datagram connection-less
sockets (like UDP). When the ğ‘ ğ‘’ğ‘›ğ‘‘(2) system call returns 0, it means that the other
party closed the connection.
â€¢ ğ’“ğ’†ğ’„ğ’—(ğŸ) and ğ’“ğ’†ğ’„ğ’—ğ’‡ğ’“ğ’ğ’(ğŸ) â€“ The ğ‘Ÿğ‘’ğ‘ğ‘£(2) and ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system calls are an
analogy for the ğ‘Ÿğ‘’ğ‘ğ‘‘(2) system call, specifically for sockets, with flags set to 0.
Those system calls return the number of bytes that were received through the socket
itself, as the number of bytes can vary. The ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call designed for stream
sockets (like TCP), while the ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system call designed for datagram
connection-less sockets (like UDP). When the ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call returns 0, it means
that the other party closed the connection.
â€¢ ğ’„ğ’ğ’ğ’”ğ’†(ğŸ) and ğ’”ğ’‰ğ’–ğ’•ğ’…ğ’ğ’˜ğ’(ğŸ) â€“ The ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) and ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2) system calls close
the socket. While ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) system call closes the whole socket, the ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2)
system call partially closes the socket for read/write.
 Communication Networks Course
Page | 12
Appendix C â€“ Random data generator
The data that you are going to send in this assignment is randomly generated. You can use
your own file with appropriate size or use the following function (or a function of your own)
to generate the data:
/*
* @brief A random data generator function based on srand() and rand().
* @param size The size of the data to generate (up to 2^32 bytes).
* @return A pointer to the buffer.
*/
char *util_generate_random_data(unsigned int size) {
 char *buffer = NULL;
 // Argument check.
 if (size == 0)
 return NULL;
 buffer = (char *)calloc(size, sizeof(char));
 // Error checking.
 if (buffer == NULL)
 return NULL;
 // Randomize the seed of the random number generator.
 srand(time(NULL));
 for (unsigned int i = 0; i < size; i++)
 *(buffer + i) = ((unsigned int)rand() % 256);
 return buffer;
}
 Communication Networks Course
Page | 13
Appendix D â€“ Checksum function
A checksum is a small-sized block of data derived from another block of digital data for the
purpose of detecting errors that may have been introduced during its transmission or
storage. By themselves, checksums are often used to verify data integrity but are not relied
upon to verify data authenticity.
Below is a simple yet efficient implementation of the checksum function, you can use it for
the assignment, but you can implement your own checksum function.
/*
* @brief A checksum function that returns 16 bit checksum for data.
* @param data The data to do the checksum for.
* @param bytes The length of the data in bytes.
* @return The checksum itself as 16 bit unsigned number.
* @note This function is taken from RFC1071, can be found here:
* @note https://tools.ietf.org/html/rfc1071
* @note It is the simplest way to calculate a checksum and is not very strong.
* However, it is good enough for this assignment.
* @note You are free to use any other checksum function as well.
* You can also use this function as such without any change.
*/
unsigned short int calculate_checksum(void *data, unsigned int bytes) {
 unsigned short int *data_pointer = (unsigned short int *)data;
 unsigned int total_sum = 0;
 // Main summing loop
 while (bytes > 1) {
 total_sum += *data_pointer++;
 bytes -= 2;
 }
 // Add left-over byte, if any
 if (bytes > 0)
 total_sum += *((unsigned char *)data_pointer);
 // Fold 32-bit sum to 16 bits
 while (total_sum >> 16)
 total_sum = (total_sum & 0xFFFF) + (total_sum >> 16);
 return (~((unsigned short int)total_sum));
} Communication Networks Course
Page | 1
Assignment 3 â€“ Transport Layer
Assignment Notes and Instructions
This assignment is to be done in pairs only. You must upload all the necessary files in a ZIP
file named after both of the studentâ€™s ID. For example: ğŸğŸğŸ‘ğŸ’ğŸ“ğŸ”ğŸ•ğŸ–ğŸ—_ğŸ—ğŸ–ğŸ•ğŸ”ğŸ“ğŸ’ğŸ‘ğŸğŸ. ğ’›ğ’Šğ’‘.
1) The assignment must be submitted by the date specified in the submission box.
2) All the assignment files (Code, Wireshark pcap files, PDF) must be submitted in a ZIP file. The
PDF must contain all the necessary screenshots with a description for each one of them.
3) The assignment must be done in pairs only. In exceptional cases, you should send an email to
the course coordinator.
4) You can use any reference material available through the course Moodle website or any
material passed during the exercises.
5) You can use any reference from the web, but copying codes from websites is forbidden; this
includes codes from other GitHub repositories. A student who gets caught in the act will
automatically fail this assignment (score 0). Any website youâ€™ve used to solve the
assignment, every website you used to solve the assignment must be noted in the PDF.
6) No delays in submission without special permission. Lateness without approval will result in
failure of the assignment (score 0).
7) All submissions will be submitted via the course's Moodle website. Email submissions will not
be accepted, resulting in a failure in the assignment.
8) The order and design of the code must be carefully considered. Make sure that the program
output is as clear as possible, comments in the code, and meaningful variable names. You
must also submit a makefile that compiles all the programs.
9) The assignment code must be written in C only.
10) The assignment is personal for each pair, and you should not accept help from other people,
whether outside the university or inside it. You can contact the course staff during reception
hours for help or raise a question in the course forum. Do not transfer code sections
between students, upload solutions or parts of solutions to websites on the Internet or in
various communication groups.
11) Students who copy a solution will receive a 0 in all assignments in the course and a report will
be made to the institutional disciplinary committee.
12) All code files of the assignment are required to both compile and run properly on the Ubuntu
22.04 LTS operating system. This is the operating system where the submissions will be
tested. You mustnâ€™t code it in Windows, as it uses different API for sockets. WSL wonâ€™t work,
as the task needs a tool that works only in a fully Linux environment.
Good Luck!
 Communication Networks Course
Page | 2
Part A â€“ Transmission Control Protocol (TCP) â€“ 30 points
In this part, youâ€™ll write two program files: ğ‘»ğ‘ªğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and ğ‘»ğ‘ªğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
The Sender will send a randomly generated file and the Receiver will receive it and measure
the time it took for his program to receive the file. The file size should be at least 2MB.
When running the Sender and Receiver, they both should support two standard congestion
control algorithms: TCP Reno and TCP Cubic.
Notes:
â€¢ The main goal of this part is to get familiar with the TCP concept of sending
messages between two endpoints.
â€¢ For approaching this part of the assignment, please be sure that you are familiar
with the congestion control algorithms and how to change them using the correct
method in C (see Appendix B for more information).
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). You've
learned that TCP is reliable by design, so you can assume that all the data have been
passed correctly, and thus, no need to recheck.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
Usage:
â€¢ Receiver:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
â€¢ Sender:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port of the Receiver.
â€¢ ğ‘¨ğ‘³ğ‘®ğ‘¶ â€“ The TCP congestion control algorithm that will be used by the party
member (either ğ’“ğ’†ğ’ğ’ for TCP Reno or ğ’„ğ’–ğ’ƒğ’Šğ’„ for TCP Cubic).
 Communication Networks Course
Page | 3
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a TCP socket between the Sender and the
Receiver.
3) Send the file.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a TCP connection between the Receiver and
the Sender.
2) Get a connection from the sender.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./TCP_Receiver -p 1234 -algo reno
Starting Receiver...
Waiting for TCP connection...
Sender connected, beginning to receive file...
File transfer completed.
Waiting for Sender response...
Sender sent exit message.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 4
Part B â€“ Reliable User Datagram Protocol (Reliable UDP or RUDP) â€“ 40 points
Youâ€™ve learned that while TCP is reliable, it lacks speed and has an overhead data of 20 bytes,
compering to UDP that needs only 8 bytes of overhead data.
Reliable UDP or RUDP, is a protocol that uses the UDP protocol for a faster transmission of
data, while adding a reliability layer to it, but without adding too much overhead data like
TCP.
A simple sketch for a RUDP connection would look something like this:
Your task in this part is to implement a Reliable protocol using UDP only. For simplicity, your
implementation should only support a handshake, closing scheme, error checking,
acknowledgment of received packets, and retransmission of lost packets.
Guidance:
â€¢ You can use ğ‘ ğ‘’ğ‘¡ğ‘ ğ‘œğ‘ğ‘˜ğ‘œğ‘ğ‘¡(2) for detecting a timeout.
â€¢ You need to build your own protocol, as Reliable UDP isnâ€™t a standard protocol (see a
draft of RUDP in this link), and no official header is provided. You can use this sketch
for a header, but you can come up with your own protocol, as long as it works.
Where:
o ğ‘³ğ’†ğ’ğ’ˆğ’•ğ’‰ is the length of the data itself, without the RUDP header.
o ğ‘ªğ’‰ğ’†ğ’„ğ’Œğ’”ğ’–ğ’ is a 16bit number that validates the correctness of the data.
o ğ‘­ğ’ğ’‚ğ’ˆğ’” is a special byte where we classify the packet itself (SYN, ACK, etc.).
â€¢ In your PDF, you must explain how your implementation of RUDP works â€“ How does
it detect a timeout to do retransmissions, how does the handshake work, what is the
header overhead, etc.
â€¢ For this part, youâ€™ll write three files: ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¨ğ‘·ğ‘°. ğ’„, ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and
ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
Reliable UDP Header proposed sketch
Byte 0 Byte 1 Byte 2 Byte 3
Length (2 Bytes) Checksum (2 Bytes)
Flags (1 Byte)
Figure 1 - RUDP Protocol Architecture, Geeksforgeeks
 Communication Networks Course
Page | 5
Notes:
â€¢ The Sender will send a random generated file and the Receiver will receive it and
measure the time it took for his program to receive the file. The file size should be at
least 2MB.
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). But, as the
RUDP is based on UDP, itâ€™s not reliable. You must use some form of error checking
(like checksum) to ensure that the packet wasnâ€™t alerted during the transfer.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
â€¢ The RUDP needs support only 1 sender and 1 receiver, for simplicity purposes.
Usage:
â€¢ Receiver:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
â€¢ Sender:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port that both the Sender and the Receiver will use.
The ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„ file will contain all the implementations of the RUDP API functions (That is, to
prevent reusing the same chuck of code both in the Sender and the Receiver.).
The API should support at the bare minimum the following functions (you decide what
parameters to implement, and what are the names of the functions, as long as the API is
explained in the PDF):
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘œğ‘ğ‘˜ğ‘’ğ‘¡() â€“ Creating a RUDP socket and creating a handshake between two
peers.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘’ğ‘›ğ‘‘() â€“ Sending data to the peer. The function should wait for an
acknowledgment packet, and if it didnâ€™t receive any, retransmits the data.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘Ÿğ‘’ğ‘ğ‘£() â€“ Receive data from a peer.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ğ‘™ğ‘œğ‘ ğ‘’() â€“ Closes a connection between peers.
 Communication Networks Course
Page | 6
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a UDP socket between the Sender and the
Receiver.
3) Send the file via the RUDP protocol.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a UDP connection between the Receiver and
the Sender.
2) Get a connection from the sender, by the custom
RUDP protocol youâ€™ve built.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./RUDP_Receiver -p 1234
Starting Receiver...
Waiting for RUDP connection...
Connection request received, sending ACK.
Sender connected, beginning to receive file...
File transfer completed.
ACK sent.
Waiting for Sender response...
Sender sent exit message.
ACK sent.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 7
Part C â€“ Research â€“ 30 points
In this part, youâ€™ll conduct research about your implementations of part A and part B.
In the research itself, each one of the versions (TCP version and UDP version) will be run at
least 5 times (meaning that the file transfer will occur at least 5 times) by the following
conditions:
â€¢ For TCP, youâ€™ll run it in TCP Reno and TCP Cubic, alternating each time, for each
scenario, meaning that you run 5 times with TCP Reno in both Sender and Receiver,
and 5 times with TCP Cubic in both Sender and Receiver.
Bonus (5 points): Create a very large data set â€“ 5 times with TCP Reno in both Sender
and Receiver, 5 times with TCP Reno in Sender and TCP Cubic in Receiver, 5 times
with TCP Cubic in Sender and TCP Reno in Receiver, and 5 times with TCP Cubic in
both Sender and Receiver. This will give you a data set large enough, which allows
you to work with, compare with and to reach a definite conclusion.
â€¢ For RUDP, you will run it 5 times for each scenario.
â€¢ For both TCP and RUDP, you will run them on those scenarios of packet loss:
o 0% packet loss â€“ Control group, simulating perfect connection.
o 2% packet loss â€“ Simulating unstable connection that commonly occur.
o 5% packet loss â€“ Simulating bad connection.
o 10% packet loss â€“ Simulating extremely poor connection.
For each scenario, you must provide a filtered PCAP file and relevant screenshots that
explain each one of the steps in the process. (10 points)
After youâ€™ve gathered the data set for both TCP and Reliable UDP, answer the following
questions:
1) In TCP, which congestion control algorithm gave better results overall? TCP Reno or
TCP Cubic? Which one gave better results on high packet loss? Explain how you came
to this conclusion based on the data set youâ€™ve gathered. (5 points)
2) How did your implementation of Reliable UDP perform overall compared to regular
TCP? Which one is better for high packet loss? (5 points)
3) According to the data youâ€™ve gathered, in which scenarios and applications would we
prefer to use TCP and in which situations would we prefer to use reliable UDP?
Explain your answer. (5 points)
 Communication Networks Course
Page | 8
×¢× ×• ×¢×œ ×”×©××œ×•×ª ×”×‘××•×ª )5 × ×§×•×“×•×ª(:
â— ×‘"×¨×©×ª ×××™× ×”" ×”×›×•×•× ×” ×”×™× ×œ×¨×©×ª ×©×‘×” ××¢×˜ ×××•×“ ×—×‘×™×œ×•×ª ×”×•×œ×›×•×ª ×œ××™×‘×•×“. ×‘"×§×©×¨ ××¨×•×š" ×”×›×•×•× ×” ×”×™×
×œ×§×©×¨ TCP ×©×™×© ×‘×• ×”×¨×‘×” ×××•×“ ××™×“×¢ ×œ×©×œ×•×—. ××•×¦×¢ ×œ×”×’×“×™×œ ×‘ -TCP ××ª SSThreshold ×‘×ª×—×™×œ×ª ×”×§×©×¨.
×‘××™×–×” ××”××§×¨×™× ×”×‘××™× ×”×©×™× ×•×™ ×”×–×” ×¢×©×•×™ ×œ×”×•×¢×™×œ ×‘××™×“×” ×”××™×¨×‘×™×ª? × ××§.
.1 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
.2 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.3 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.4 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.5 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.6 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.7 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.8 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
â— A ×©×•×œ×— ×œ -B ×—×‘×™×œ×•×ª ××™×“×¢ ×‘×××¦×¢×•×ª ×§×©×¨ TCP. × ×ª×•×Ÿ ×›×™ ×”×§×©×¨ ××ª×—×™×œ ×¢× ×—×œ×•×Ÿ ×‘×’×•×“×œ 1MSS. ×”×§×©×¨
××¡×ª×™×™× ×‘×¤×¢× ×”×¨××©×•× ×” ×©×”×•× ××’×™×¢ ×œ -SSthresh. ×‘××”×œ×š ×”×§×©×¨ ×œ× ××•×‘×“×•×ª ×—×‘×™×œ×•×ª. × ×¡××Ÿ ×‘×§×™×¦×•×¨:
.SSthresh=S*MSS
× ×ª×•×Ÿ ×›×™ ×œ××•×¨×š ×›×œ ×”×§×©×¨ rwnd < MSS*S.
××”×™ ×”×ª×¤×•×§×” ×©×œ ×”×§×©×¨ ×-A ×œ-B( ×‘ -sec / Bytes )×‘×–××Ÿ ×”× "×œ? × ××§×™.
]S*MSS / [lg (S) * RTT*2 ×‘×¢×¨×š .1
]S*MSS / [S^0.5 * RTT*2 ×‘×¢×¨×š .2
S*MSS / RTT ×‘×¢×¨×š .3
S^2)*MSS / RTT( ×‘×¢×¨×š .4
â— ×©×ª×™ ×ª×—× ×•×ª ××ª×§×©×¨×•×ª ×‘××•×¤×Ÿ ××œ×—×•×˜×™ ×‘×©×™×˜×ª N Back Go.
× ×¡××Ÿ ×‘-X ××ª ×¡×¤×¨×ª ×”×‘×™×§×•×¨×ª ×©×œ ×”×ª.×–. ×©×œ×š. ×× ×©× ×™ ×©×•×ª×¤×™× ××’×™×©×™× ××ª ×”×ª×¨×’×™×œ ×™×—×“, X ×”×•× ×¡×¤×¨×ª
×”×‘×™×§×•×¨×ª ×‘×¢×œ×ª ×”×¢×¨×š ×”× ××•×š ×™×•×ª×¨ ××‘×™×Ÿ ×”×©×ª×™×™×.
×§×¦×‘ ×”×ª×§×©×•×¨×ª ×”×•× 8Gbps, ×•×’×•×“×œ ×›×œ ×—×‘×™×œ×” ×”×•× KByte*X. ×’×“×œ×™ ×”-headers ×•×” -Acks ×–× ×™×—×™×.
ï¿½ğ‘’ğ‘ ï¿½/ï¿½ï¿½ 8 , ×•×”××¨×—×§ ×‘×™×Ÿ ×”×ª×—× ×•×ª ×”×•× 1Km. ×§×¦×‘ ×”×”×ª×¤×©×˜×•×ª ×”×•× 10 â‹… 2
×–××Ÿ ×¢×™×‘×•×“ ×”× ×ª×•× ×™× ×‘×ª×—× ×•×ª ×–× ×™×—.
××£ ×—×‘×™×œ×” ×•××£ Ack ×œ× ×”×•×œ×›×™× ×œ××™×‘×•×“.
â— ××”×• X ×©×œ×š?
â— ××” ×¦×¨×™×š ×œ×”×™×•×ª ×’×•×“×œ ×—×œ×•×Ÿ ×”××©×œ×•×— ×›×“×™ ×œ×”×‘×˜×™×— ×ª×¤×•×§×” ××§×¡×™××œ×™×ª?
 Communication Networks Course
Page | 9
Bonus â€“ Improving the Reliable UDP â€“ 15 points
Note: This part isnâ€™t mandatory and is a bonus only!
In this part, youâ€™ll improve your RUDP implementation by adding the concepts of flow
control and congestion control from TCP. Youâ€™re free to choose which algorithms to
implement, as long as you explain in your PDF which algorithms youâ€™ve used. Youâ€™ll probably
need to make changes in the original design of the RUDP. Changes only need to be to the API
itself, ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„.
Points distribution:
â€¢ Flow control improvement â€“ 7 Points
â€¢ Congestion control improvement â€“ 8 points.
Guidance:
â€¢ For flow control, you must use one of the Sliding window techniques: stop-and-wait
ARQ, Go-Back-N or Selective repeat.
â€¢ List of known TCP congestion control algorithms, which you can use any one of them
for this bonus task, or makeup your own:
Figure 2 â€“ List of known TCP congestion control algorithms, Wikipedia
 Communication Networks Course
Page | 10
Appendix A â€“ Linux local packet loss tool
To simulate a packet loss in a local network, we'll use a Linux tool that's called Linux Traffic
Control (ğ‘¡ğ‘). This requires a full Linux installation, so working with WSL won't work.
If the tool isn't installed in your machine, you can install it by using the following commands:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’
If the installation didn't work, you can use the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’2
To create a packet loss scenario, type the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘ğ‘‘ğ‘‘ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
After creating a packet loss scenario, you can change the percentage by typing the following
command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘â„ğ‘ğ‘›ğ‘”ğ‘’ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
To remove the packet loss scenario, write the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘‘ğ‘’ğ‘™ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š
 Communication Networks Course
Page | 11
Appendix B â€“ ğ’ğ’‚ğ’(ğŸ) system calls
This appendixâ€™s purpose is to give you a better understanding of socket handling in C.
A recommended reference is Beejâ€™s Guide to Network Programming, by Brian â€œBeej
Jorgensenâ€ Hall, which gives a lot of information about sockets in C and functions.
Functions and documentation links:
â€¢ ğ’”ğ’ğ’„ğ’Œğ’†ğ’•(ğŸ) â€“ A Factory method system call that creates a socket with the given
parameters.
â€¢ ğ’ƒğ’Šğ’ğ’…(ğŸ) â€“ Whenever we create a new socket, we need to bind it to a specific port in
our machine, â€œto catch a portâ€. The port number is managed and used by the kernel
to link incoming packets to the corresponding application socket. The port numbers
are usually fixed. The ğ‘ğ‘‘ğ‘‘ğ‘Ÿ parameter must match the current socket that is used.
â€¢ ğ’ğ’Šğ’”ğ’•ğ’†ğ’(ğŸ) â€“ The ğ‘™ğ‘–ğ‘ ğ‘¡ğ‘’ğ‘›(2) system call doesn't do anything in the mean of
communication but only memory allocation (malloc) for stream sockets only. If we
won't allocate memory, any incoming connection will fail.
â€¢ ğ’„ğ’ğ’ğ’ğ’†ğ’„ğ’•(ğŸ) â€“ The ğ‘ğ‘œğ‘›ğ‘›ğ‘’ğ‘ğ‘¡(2) system call starts the link between a client and a
specific IP address and port number. The connection would complete when the
other side will call the ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call.
â€¢ ğ’‚ğ’„ğ’„ğ’†ğ’‘ğ’•(ğŸ) â€“ The ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call accepts the incoming stream connection
request from the other side, by the listening socket. This system call completes the
three-way handshake of stream socket (like TCP) and opens a new socket that has a
direct communication channel only with the other party in the handshake.
â€¢ ğ’”ğ’†ğ’ğ’…(ğŸ) and ğ’”ğ’†ğ’ğ’…ğ’•ğ’(ğŸ) â€“ The ğ‘ ğ‘’ğ‘›ğ‘‘(2) and ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system calls are an analogy
for the ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’(2) system call, specifcly for sockets, with flags set to 0. Those system
calls return the number of bytes that were sent through the socket itself, as the
number of bytes can vary. The ğ‘ ğ‘’ğ‘›ğ‘‘(2)system call designed for stream sockets (like
TCP), while the ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system call designed for datagram connection-less
sockets (like UDP). When the ğ‘ ğ‘’ğ‘›ğ‘‘(2) system call returns 0, it means that the other
party closed the connection.
â€¢ ğ’“ğ’†ğ’„ğ’—(ğŸ) and ğ’“ğ’†ğ’„ğ’—ğ’‡ğ’“ğ’ğ’(ğŸ) â€“ The ğ‘Ÿğ‘’ğ‘ğ‘£(2) and ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system calls are an
analogy for the ğ‘Ÿğ‘’ğ‘ğ‘‘(2) system call, specifically for sockets, with flags set to 0.
Those system calls return the number of bytes that were received through the socket
itself, as the number of bytes can vary. The ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call designed for stream
sockets (like TCP), while the ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system call designed for datagram
connection-less sockets (like UDP). When the ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call returns 0, it means
that the other party closed the connection.
â€¢ ğ’„ğ’ğ’ğ’”ğ’†(ğŸ) and ğ’”ğ’‰ğ’–ğ’•ğ’…ğ’ğ’˜ğ’(ğŸ) â€“ The ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) and ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2) system calls close
the socket. While ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) system call closes the whole socket, the ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2)
system call partially closes the socket for read/write.
 Communication Networks Course
Page | 12
Appendix C â€“ Random data generator
The data that you are going to send in this assignment is randomly generated. You can use
your own file with appropriate size or use the following function (or a function of your own)
to generate the data:
/*
* @brief A random data generator function based on srand() and rand().
* @param size The size of the data to generate (up to 2^32 bytes).
* @return A pointer to the buffer.
*/
char *util_generate_random_data(unsigned int size) {
 char *buffer = NULL;
 // Argument check.
 if (size == 0)
 return NULL;
 buffer = (char *)calloc(size, sizeof(char));
 // Error checking.
 if (buffer == NULL)
 return NULL;
 // Randomize the seed of the random number generator.
 srand(time(NULL));
 for (unsigned int i = 0; i < size; i++)
 *(buffer + i) = ((unsigned int)rand() % 256);
 return buffer;
}
 Communication Networks Course
Page | 13
Appendix D â€“ Checksum function
A checksum is a small-sized block of data derived from another block of digital data for the
purpose of detecting errors that may have been introduced during its transmission or
storage. By themselves, checksums are often used to verify data integrity but are not relied
upon to verify data authenticity.
Below is a simple yet efficient implementation of the checksum function, you can use it for
the assignment, but you can implement your own checksum function.
/*
* @brief A checksum function that returns 16 bit checksum for data.
* @param data The data to do the checksum for.
* @param bytes The length of the data in bytes.
* @return The checksum itself as 16 bit unsigned number.
* @note This function is taken from RFC1071, can be found here:
* @note https://tools.ietf.org/html/rfc1071
* @note It is the simplest way to calculate a checksum and is not very strong.
* However, it is good enough for this assignment.
* @note You are free to use any other checksum function as well.
* You can also use this function as such without any change.
*/
unsigned short int calculate_checksum(void *data, unsigned int bytes) {
 unsigned short int *data_pointer = (unsigned short int *)data;
 unsigned int total_sum = 0;
 // Main summing loop
 while (bytes > 1) {
 total_sum += *data_pointer++;
 bytes -= 2;
 }
 // Add left-over byte, if any
 if (bytes > 0)
 total_sum += *((unsigned char *)data_pointer);
 // Fold 32-bit sum to 16 bits
 while (total_sum >> 16)
 total_sum = (total_sum & 0xFFFF) + (total_sum >> 16);
 return (~((unsigned short int)total_sum));
} Communication Networks Course
Page | 1
Assignment 3 â€“ Transport Layer
Assignment Notes and Instructions
This assignment is to be done in pairs only. You must upload all the necessary files in a ZIP
file named after both of the studentâ€™s ID. For example: ğŸğŸğŸ‘ğŸ’ğŸ“ğŸ”ğŸ•ğŸ–ğŸ—_ğŸ—ğŸ–ğŸ•ğŸ”ğŸ“ğŸ’ğŸ‘ğŸğŸ. ğ’›ğ’Šğ’‘.
1) The assignment must be submitted by the date specified in the submission box.
2) All the assignment files (Code, Wireshark pcap files, PDF) must be submitted in a ZIP file. The
PDF must contain all the necessary screenshots with a description for each one of them.
3) The assignment must be done in pairs only. In exceptional cases, you should send an email to
the course coordinator.
4) You can use any reference material available through the course Moodle website or any
material passed during the exercises.
5) You can use any reference from the web, but copying codes from websites is forbidden; this
includes codes from other GitHub repositories. A student who gets caught in the act will
automatically fail this assignment (score 0). Any website youâ€™ve used to solve the
assignment, every website you used to solve the assignment must be noted in the PDF.
6) No delays in submission without special permission. Lateness without approval will result in
failure of the assignment (score 0).
7) All submissions will be submitted via the course's Moodle website. Email submissions will not
be accepted, resulting in a failure in the assignment.
8) The order and design of the code must be carefully considered. Make sure that the program
output is as clear as possible, comments in the code, and meaningful variable names. You
must also submit a makefile that compiles all the programs.
9) The assignment code must be written in C only.
10) The assignment is personal for each pair, and you should not accept help from other people,
whether outside the university or inside it. You can contact the course staff during reception
hours for help or raise a question in the course forum. Do not transfer code sections
between students, upload solutions or parts of solutions to websites on the Internet or in
various communication groups.
11) Students who copy a solution will receive a 0 in all assignments in the course and a report will
be made to the institutional disciplinary committee.
12) All code files of the assignment are required to both compile and run properly on the Ubuntu
22.04 LTS operating system. This is the operating system where the submissions will be
tested. You mustnâ€™t code it in Windows, as it uses different API for sockets. WSL wonâ€™t work,
as the task needs a tool that works only in a fully Linux environment.
Good Luck!
 Communication Networks Course
Page | 2
Part A â€“ Transmission Control Protocol (TCP) â€“ 30 points
In this part, youâ€™ll write two program files: ğ‘»ğ‘ªğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and ğ‘»ğ‘ªğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
The Sender will send a randomly generated file and the Receiver will receive it and measure
the time it took for his program to receive the file. The file size should be at least 2MB.
When running the Sender and Receiver, they both should support two standard congestion
control algorithms: TCP Reno and TCP Cubic.
Notes:
â€¢ The main goal of this part is to get familiar with the TCP concept of sending
messages between two endpoints.
â€¢ For approaching this part of the assignment, please be sure that you are familiar
with the congestion control algorithms and how to change them using the correct
method in C (see Appendix B for more information).
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). You've
learned that TCP is reliable by design, so you can assume that all the data have been
passed correctly, and thus, no need to recheck.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
Usage:
â€¢ Receiver:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
â€¢ Sender:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port of the Receiver.
â€¢ ğ‘¨ğ‘³ğ‘®ğ‘¶ â€“ The TCP congestion control algorithm that will be used by the party
member (either ğ’“ğ’†ğ’ğ’ for TCP Reno or ğ’„ğ’–ğ’ƒğ’Šğ’„ for TCP Cubic).
 Communication Networks Course
Page | 3
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a TCP socket between the Sender and the
Receiver.
3) Send the file.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a TCP connection between the Receiver and
the Sender.
2) Get a connection from the sender.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./TCP_Receiver -p 1234 -algo reno
Starting Receiver...
Waiting for TCP connection...
Sender connected, beginning to receive file...
File transfer completed.
Waiting for Sender response...
Sender sent exit message.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 4
Part B â€“ Reliable User Datagram Protocol (Reliable UDP or RUDP) â€“ 40 points
Youâ€™ve learned that while TCP is reliable, it lacks speed and has an overhead data of 20 bytes,
compering to UDP that needs only 8 bytes of overhead data.
Reliable UDP or RUDP, is a protocol that uses the UDP protocol for a faster transmission of
data, while adding a reliability layer to it, but without adding too much overhead data like
TCP.
A simple sketch for a RUDP connection would look something like this:
Your task in this part is to implement a Reliable protocol using UDP only. For simplicity, your
implementation should only support a handshake, closing scheme, error checking,
acknowledgment of received packets, and retransmission of lost packets.
Guidance:
â€¢ You can use ğ‘ ğ‘’ğ‘¡ğ‘ ğ‘œğ‘ğ‘˜ğ‘œğ‘ğ‘¡(2) for detecting a timeout.
â€¢ You need to build your own protocol, as Reliable UDP isnâ€™t a standard protocol (see a
draft of RUDP in this link), and no official header is provided. You can use this sketch
for a header, but you can come up with your own protocol, as long as it works.
Where:
o ğ‘³ğ’†ğ’ğ’ˆğ’•ğ’‰ is the length of the data itself, without the RUDP header.
o ğ‘ªğ’‰ğ’†ğ’„ğ’Œğ’”ğ’–ğ’ is a 16bit number that validates the correctness of the data.
o ğ‘­ğ’ğ’‚ğ’ˆğ’” is a special byte where we classify the packet itself (SYN, ACK, etc.).
â€¢ In your PDF, you must explain how your implementation of RUDP works â€“ How does
it detect a timeout to do retransmissions, how does the handshake work, what is the
header overhead, etc.
â€¢ For this part, youâ€™ll write three files: ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¨ğ‘·ğ‘°. ğ’„, ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and
ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
Reliable UDP Header proposed sketch
Byte 0 Byte 1 Byte 2 Byte 3
Length (2 Bytes) Checksum (2 Bytes)
Flags (1 Byte)
Figure 1 - RUDP Protocol Architecture, Geeksforgeeks
 Communication Networks Course
Page | 5
Notes:
â€¢ The Sender will send a random generated file and the Receiver will receive it and
measure the time it took for his program to receive the file. The file size should be at
least 2MB.
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). But, as the
RUDP is based on UDP, itâ€™s not reliable. You must use some form of error checking
(like checksum) to ensure that the packet wasnâ€™t alerted during the transfer.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
â€¢ The RUDP needs support only 1 sender and 1 receiver, for simplicity purposes.
Usage:
â€¢ Receiver:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
â€¢ Sender:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port that both the Sender and the Receiver will use.
The ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„ file will contain all the implementations of the RUDP API functions (That is, to
prevent reusing the same chuck of code both in the Sender and the Receiver.).
The API should support at the bare minimum the following functions (you decide what
parameters to implement, and what are the names of the functions, as long as the API is
explained in the PDF):
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘œğ‘ğ‘˜ğ‘’ğ‘¡() â€“ Creating a RUDP socket and creating a handshake between two
peers.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘’ğ‘›ğ‘‘() â€“ Sending data to the peer. The function should wait for an
acknowledgment packet, and if it didnâ€™t receive any, retransmits the data.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘Ÿğ‘’ğ‘ğ‘£() â€“ Receive data from a peer.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ğ‘™ğ‘œğ‘ ğ‘’() â€“ Closes a connection between peers.
 Communication Networks Course
Page | 6
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a UDP socket between the Sender and the
Receiver.
3) Send the file via the RUDP protocol.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a UDP connection between the Receiver and
the Sender.
2) Get a connection from the sender, by the custom
RUDP protocol youâ€™ve built.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./RUDP_Receiver -p 1234
Starting Receiver...
Waiting for RUDP connection...
Connection request received, sending ACK.
Sender connected, beginning to receive file...
File transfer completed.
ACK sent.
Waiting for Sender response...
Sender sent exit message.
ACK sent.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 7
Part C â€“ Research â€“ 30 points
In this part, youâ€™ll conduct research about your implementations of part A and part B.
In the research itself, each one of the versions (TCP version and UDP version) will be run at
least 5 times (meaning that the file transfer will occur at least 5 times) by the following
conditions:
â€¢ For TCP, youâ€™ll run it in TCP Reno and TCP Cubic, alternating each time, for each
scenario, meaning that you run 5 times with TCP Reno in both Sender and Receiver,
and 5 times with TCP Cubic in both Sender and Receiver.
Bonus (5 points): Create a very large data set â€“ 5 times with TCP Reno in both Sender
and Receiver, 5 times with TCP Reno in Sender and TCP Cubic in Receiver, 5 times
with TCP Cubic in Sender and TCP Reno in Receiver, and 5 times with TCP Cubic in
both Sender and Receiver. This will give you a data set large enough, which allows
you to work with, compare with and to reach a definite conclusion.
â€¢ For RUDP, you will run it 5 times for each scenario.
â€¢ For both TCP and RUDP, you will run them on those scenarios of packet loss:
o 0% packet loss â€“ Control group, simulating perfect connection.
o 2% packet loss â€“ Simulating unstable connection that commonly occur.
o 5% packet loss â€“ Simulating bad connection.
o 10% packet loss â€“ Simulating extremely poor connection.
For each scenario, you must provide a filtered PCAP file and relevant screenshots that
explain each one of the steps in the process. (10 points)
After youâ€™ve gathered the data set for both TCP and Reliable UDP, answer the following
questions:
1) In TCP, which congestion control algorithm gave better results overall? TCP Reno or
TCP Cubic? Which one gave better results on high packet loss? Explain how you came
to this conclusion based on the data set youâ€™ve gathered. (5 points)
2) How did your implementation of Reliable UDP perform overall compared to regular
TCP? Which one is better for high packet loss? (5 points)
3) According to the data youâ€™ve gathered, in which scenarios and applications would we
prefer to use TCP and in which situations would we prefer to use reliable UDP?
Explain your answer. (5 points)
 Communication Networks Course
Page | 8
×¢× ×• ×¢×œ ×”×©××œ×•×ª ×”×‘××•×ª )5 × ×§×•×“×•×ª(:
â— ×‘"×¨×©×ª ×××™× ×”" ×”×›×•×•× ×” ×”×™× ×œ×¨×©×ª ×©×‘×” ××¢×˜ ×××•×“ ×—×‘×™×œ×•×ª ×”×•×œ×›×•×ª ×œ××™×‘×•×“. ×‘"×§×©×¨ ××¨×•×š" ×”×›×•×•× ×” ×”×™×
×œ×§×©×¨ TCP ×©×™×© ×‘×• ×”×¨×‘×” ×××•×“ ××™×“×¢ ×œ×©×œ×•×—. ××•×¦×¢ ×œ×”×’×“×™×œ ×‘ -TCP ××ª SSThreshold ×‘×ª×—×™×œ×ª ×”×§×©×¨.
×‘××™×–×” ××”××§×¨×™× ×”×‘××™× ×”×©×™× ×•×™ ×”×–×” ×¢×©×•×™ ×œ×”×•×¢×™×œ ×‘××™×“×” ×”××™×¨×‘×™×ª? × ××§.
.1 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
.2 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.3 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.4 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.5 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.6 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.7 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.8 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
â— A ×©×•×œ×— ×œ -B ×—×‘×™×œ×•×ª ××™×“×¢ ×‘×××¦×¢×•×ª ×§×©×¨ TCP. × ×ª×•×Ÿ ×›×™ ×”×§×©×¨ ××ª×—×™×œ ×¢× ×—×œ×•×Ÿ ×‘×’×•×“×œ 1MSS. ×”×§×©×¨
××¡×ª×™×™× ×‘×¤×¢× ×”×¨××©×•× ×” ×©×”×•× ××’×™×¢ ×œ -SSthresh. ×‘××”×œ×š ×”×§×©×¨ ×œ× ××•×‘×“×•×ª ×—×‘×™×œ×•×ª. × ×¡××Ÿ ×‘×§×™×¦×•×¨:
.SSthresh=S*MSS
× ×ª×•×Ÿ ×›×™ ×œ××•×¨×š ×›×œ ×”×§×©×¨ rwnd < MSS*S.
××”×™ ×”×ª×¤×•×§×” ×©×œ ×”×§×©×¨ ×-A ×œ-B( ×‘ -sec / Bytes )×‘×–××Ÿ ×”× "×œ? × ××§×™.
]S*MSS / [lg (S) * RTT*2 ×‘×¢×¨×š .1
]S*MSS / [S^0.5 * RTT*2 ×‘×¢×¨×š .2
S*MSS / RTT ×‘×¢×¨×š .3
S^2)*MSS / RTT( ×‘×¢×¨×š .4
â— ×©×ª×™ ×ª×—× ×•×ª ××ª×§×©×¨×•×ª ×‘××•×¤×Ÿ ××œ×—×•×˜×™ ×‘×©×™×˜×ª N Back Go.
× ×¡××Ÿ ×‘-X ××ª ×¡×¤×¨×ª ×”×‘×™×§×•×¨×ª ×©×œ ×”×ª.×–. ×©×œ×š. ×× ×©× ×™ ×©×•×ª×¤×™× ××’×™×©×™× ××ª ×”×ª×¨×’×™×œ ×™×—×“, X ×”×•× ×¡×¤×¨×ª
×”×‘×™×§×•×¨×ª ×‘×¢×œ×ª ×”×¢×¨×š ×”× ××•×š ×™×•×ª×¨ ××‘×™×Ÿ ×”×©×ª×™×™×.
×§×¦×‘ ×”×ª×§×©×•×¨×ª ×”×•× 8Gbps, ×•×’×•×“×œ ×›×œ ×—×‘×™×œ×” ×”×•× KByte*X. ×’×“×œ×™ ×”-headers ×•×” -Acks ×–× ×™×—×™×.
ï¿½ğ‘’ğ‘ ï¿½/ï¿½ï¿½ 8 , ×•×”××¨×—×§ ×‘×™×Ÿ ×”×ª×—× ×•×ª ×”×•× 1Km. ×§×¦×‘ ×”×”×ª×¤×©×˜×•×ª ×”×•× 10 â‹… 2
×–××Ÿ ×¢×™×‘×•×“ ×”× ×ª×•× ×™× ×‘×ª×—× ×•×ª ×–× ×™×—.
××£ ×—×‘×™×œ×” ×•××£ Ack ×œ× ×”×•×œ×›×™× ×œ××™×‘×•×“.
â— ××”×• X ×©×œ×š?
â— ××” ×¦×¨×™×š ×œ×”×™×•×ª ×’×•×“×œ ×—×œ×•×Ÿ ×”××©×œ×•×— ×›×“×™ ×œ×”×‘×˜×™×— ×ª×¤×•×§×” ××§×¡×™××œ×™×ª?
 Communication Networks Course
Page | 9
Bonus â€“ Improving the Reliable UDP â€“ 15 points
Note: This part isnâ€™t mandatory and is a bonus only!
In this part, youâ€™ll improve your RUDP implementation by adding the concepts of flow
control and congestion control from TCP. Youâ€™re free to choose which algorithms to
implement, as long as you explain in your PDF which algorithms youâ€™ve used. Youâ€™ll probably
need to make changes in the original design of the RUDP. Changes only need to be to the API
itself, ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„.
Points distribution:
â€¢ Flow control improvement â€“ 7 Points
â€¢ Congestion control improvement â€“ 8 points.
Guidance:
â€¢ For flow control, you must use one of the Sliding window techniques: stop-and-wait
ARQ, Go-Back-N or Selective repeat.
â€¢ List of known TCP congestion control algorithms, which you can use any one of them
for this bonus task, or makeup your own:
Figure 2 â€“ List of known TCP congestion control algorithms, Wikipedia
 Communication Networks Course
Page | 10
Appendix A â€“ Linux local packet loss tool
To simulate a packet loss in a local network, we'll use a Linux tool that's called Linux Traffic
Control (ğ‘¡ğ‘). This requires a full Linux installation, so working with WSL won't work.
If the tool isn't installed in your machine, you can install it by using the following commands:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’
If the installation didn't work, you can use the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’2
To create a packet loss scenario, type the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘ğ‘‘ğ‘‘ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
After creating a packet loss scenario, you can change the percentage by typing the following
command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘â„ğ‘ğ‘›ğ‘”ğ‘’ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
To remove the packet loss scenario, write the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘‘ğ‘’ğ‘™ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š
 Communication Networks Course
Page | 11
Appendix B â€“ ğ’ğ’‚ğ’(ğŸ) system calls
This appendixâ€™s purpose is to give you a better understanding of socket handling in C.
A recommended reference is Beejâ€™s Guide to Network Programming, by Brian â€œBeej
Jorgensenâ€ Hall, which gives a lot of information about sockets in C and functions.
Functions and documentation links:
â€¢ ğ’”ğ’ğ’„ğ’Œğ’†ğ’•(ğŸ) â€“ A Factory method system call that creates a socket with the given
parameters.
â€¢ ğ’ƒğ’Šğ’ğ’…(ğŸ) â€“ Whenever we create a new socket, we need to bind it to a specific port in
our machine, â€œto catch a portâ€. The port number is managed and used by the kernel
to link incoming packets to the corresponding application socket. The port numbers
are usually fixed. The ğ‘ğ‘‘ğ‘‘ğ‘Ÿ parameter must match the current socket that is used.
â€¢ ğ’ğ’Šğ’”ğ’•ğ’†ğ’(ğŸ) â€“ The ğ‘™ğ‘–ğ‘ ğ‘¡ğ‘’ğ‘›(2) system call doesn't do anything in the mean of
communication but only memory allocation (malloc) for stream sockets only. If we
won't allocate memory, any incoming connection will fail.
â€¢ ğ’„ğ’ğ’ğ’ğ’†ğ’„ğ’•(ğŸ) â€“ The ğ‘ğ‘œğ‘›ğ‘›ğ‘’ğ‘ğ‘¡(2) system call starts the link between a client and a
specific IP address and port number. The connection would complete when the
other side will call the ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call.
â€¢ ğ’‚ğ’„ğ’„ğ’†ğ’‘ğ’•(ğŸ) â€“ The ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call accepts the incoming stream connection
request from the other side, by the listening socket. This system call completes the
three-way handshake of stream socket (like TCP) and opens a new socket that has a
direct communication channel only with the other party in the handshake.
â€¢ ğ’”ğ’†ğ’ğ’…(ğŸ) and ğ’”ğ’†ğ’ğ’…ğ’•ğ’(ğŸ) â€“ The ğ‘ ğ‘’ğ‘›ğ‘‘(2) and ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system calls are an analogy
for the ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’(2) system call, specifcly for sockets, with flags set to 0. Those system
calls return the number of bytes that were sent through the socket itself, as the
number of bytes can vary. The ğ‘ ğ‘’ğ‘›ğ‘‘(2)system call designed for stream sockets (like
TCP), while the ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system call designed for datagram connection-less
sockets (like UDP). When the ğ‘ ğ‘’ğ‘›ğ‘‘(2) system call returns 0, it means that the other
party closed the connection.
â€¢ ğ’“ğ’†ğ’„ğ’—(ğŸ) and ğ’“ğ’†ğ’„ğ’—ğ’‡ğ’“ğ’ğ’(ğŸ) â€“ The ğ‘Ÿğ‘’ğ‘ğ‘£(2) and ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system calls are an
analogy for the ğ‘Ÿğ‘’ğ‘ğ‘‘(2) system call, specifically for sockets, with flags set to 0.
Those system calls return the number of bytes that were received through the socket
itself, as the number of bytes can vary. The ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call designed for stream
sockets (like TCP), while the ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system call designed for datagram
connection-less sockets (like UDP). When the ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call returns 0, it means
that the other party closed the connection.
â€¢ ğ’„ğ’ğ’ğ’”ğ’†(ğŸ) and ğ’”ğ’‰ğ’–ğ’•ğ’…ğ’ğ’˜ğ’(ğŸ) â€“ The ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) and ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2) system calls close
the socket. While ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) system call closes the whole socket, the ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2)
system call partially closes the socket for read/write.
 Communication Networks Course
Page | 12
Appendix C â€“ Random data generator
The data that you are going to send in this assignment is randomly generated. You can use
your own file with appropriate size or use the following function (or a function of your own)
to generate the data:
/*
* @brief A random data generator function based on srand() and rand().
* @param size The size of the data to generate (up to 2^32 bytes).
* @return A pointer to the buffer.
*/
char *util_generate_random_data(unsigned int size) {
 char *buffer = NULL;
 // Argument check.
 if (size == 0)
 return NULL;
 buffer = (char *)calloc(size, sizeof(char));
 // Error checking.
 if (buffer == NULL)
 return NULL;
 // Randomize the seed of the random number generator.
 srand(time(NULL));
 for (unsigned int i = 0; i < size; i++)
 *(buffer + i) = ((unsigned int)rand() % 256);
 return buffer;
}
 Communication Networks Course
Page | 13
Appendix D â€“ Checksum function
A checksum is a small-sized block of data derived from another block of digital data for the
purpose of detecting errors that may have been introduced during its transmission or
storage. By themselves, checksums are often used to verify data integrity but are not relied
upon to verify data authenticity.
Below is a simple yet efficient implementation of the checksum function, you can use it for
the assignment, but you can implement your own checksum function.
/*
* @brief A checksum function that returns 16 bit checksum for data.
* @param data The data to do the checksum for.
* @param bytes The length of the data in bytes.
* @return The checksum itself as 16 bit unsigned number.
* @note This function is taken from RFC1071, can be found here:
* @note https://tools.ietf.org/html/rfc1071
* @note It is the simplest way to calculate a checksum and is not very strong.
* However, it is good enough for this assignment.
* @note You are free to use any other checksum function as well.
* You can also use this function as such without any change.
*/
unsigned short int calculate_checksum(void *data, unsigned int bytes) {
 unsigned short int *data_pointer = (unsigned short int *)data;
 unsigned int total_sum = 0;
 // Main summing loop
 while (bytes > 1) {
 total_sum += *data_pointer++;
 bytes -= 2;
 }
 // Add left-over byte, if any
 if (bytes > 0)
 total_sum += *((unsigned char *)data_pointer);
 // Fold 32-bit sum to 16 bits
 while (total_sum >> 16)
 total_sum = (total_sum & 0xFFFF) + (total_sum >> 16);
 return (~((unsigned short int)total_sum));
} Communication Networks Course
Page | 1
Assignment 3 â€“ Transport Layer
Assignment Notes and Instructions
This assignment is to be done in pairs only. You must upload all the necessary files in a ZIP
file named after both of the studentâ€™s ID. For example: ğŸğŸğŸ‘ğŸ’ğŸ“ğŸ”ğŸ•ğŸ–ğŸ—_ğŸ—ğŸ–ğŸ•ğŸ”ğŸ“ğŸ’ğŸ‘ğŸğŸ. ğ’›ğ’Šğ’‘.
1) The assignment must be submitted by the date specified in the submission box.
2) All the assignment files (Code, Wireshark pcap files, PDF) must be submitted in a ZIP file. The
PDF must contain all the necessary screenshots with a description for each one of them.
3) The assignment must be done in pairs only. In exceptional cases, you should send an email to
the course coordinator.
4) You can use any reference material available through the course Moodle website or any
material passed during the exercises.
5) You can use any reference from the web, but copying codes from websites is forbidden; this
includes codes from other GitHub repositories. A student who gets caught in the act will
automatically fail this assignment (score 0). Any website youâ€™ve used to solve the
assignment, every website you used to solve the assignment must be noted in the PDF.
6) No delays in submission without special permission. Lateness without approval will result in
failure of the assignment (score 0).
7) All submissions will be submitted via the course's Moodle website. Email submissions will not
be accepted, resulting in a failure in the assignment.
8) The order and design of the code must be carefully considered. Make sure that the program
output is as clear as possible, comments in the code, and meaningful variable names. You
must also submit a makefile that compiles all the programs.
9) The assignment code must be written in C only.
10) The assignment is personal for each pair, and you should not accept help from other people,
whether outside the university or inside it. You can contact the course staff during reception
hours for help or raise a question in the course forum. Do not transfer code sections
between students, upload solutions or parts of solutions to websites on the Internet or in
various communication groups.
11) Students who copy a solution will receive a 0 in all assignments in the course and a report will
be made to the institutional disciplinary committee.
12) All code files of the assignment are required to both compile and run properly on the Ubuntu
22.04 LTS operating system. This is the operating system where the submissions will be
tested. You mustnâ€™t code it in Windows, as it uses different API for sockets. WSL wonâ€™t work,
as the task needs a tool that works only in a fully Linux environment.
Good Luck!
 Communication Networks Course
Page | 2
Part A â€“ Transmission Control Protocol (TCP) â€“ 30 points
In this part, youâ€™ll write two program files: ğ‘»ğ‘ªğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and ğ‘»ğ‘ªğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
The Sender will send a randomly generated file and the Receiver will receive it and measure
the time it took for his program to receive the file. The file size should be at least 2MB.
When running the Sender and Receiver, they both should support two standard congestion
control algorithms: TCP Reno and TCP Cubic.
Notes:
â€¢ The main goal of this part is to get familiar with the TCP concept of sending
messages between two endpoints.
â€¢ For approaching this part of the assignment, please be sure that you are familiar
with the congestion control algorithms and how to change them using the correct
method in C (see Appendix B for more information).
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). You've
learned that TCP is reliable by design, so you can assume that all the data have been
passed correctly, and thus, no need to recheck.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
Usage:
â€¢ Receiver:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
â€¢ Sender:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port of the Receiver.
â€¢ ğ‘¨ğ‘³ğ‘®ğ‘¶ â€“ The TCP congestion control algorithm that will be used by the party
member (either ğ’“ğ’†ğ’ğ’ for TCP Reno or ğ’„ğ’–ğ’ƒğ’Šğ’„ for TCP Cubic).
 Communication Networks Course
Page | 3
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a TCP socket between the Sender and the
Receiver.
3) Send the file.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a TCP connection between the Receiver and
the Sender.
2) Get a connection from the sender.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./TCP_Receiver -p 1234 -algo reno
Starting Receiver...
Waiting for TCP connection...
Sender connected, beginning to receive file...
File transfer completed.
Waiting for Sender response...
Sender sent exit message.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 4
Part B â€“ Reliable User Datagram Protocol (Reliable UDP or RUDP) â€“ 40 points
Youâ€™ve learned that while TCP is reliable, it lacks speed and has an overhead data of 20 bytes,
compering to UDP that needs only 8 bytes of overhead data.
Reliable UDP or RUDP, is a protocol that uses the UDP protocol for a faster transmission of
data, while adding a reliability layer to it, but without adding too much overhead data like
TCP.
A simple sketch for a RUDP connection would look something like this:
Your task in this part is to implement a Reliable protocol using UDP only. For simplicity, your
implementation should only support a handshake, closing scheme, error checking,
acknowledgment of received packets, and retransmission of lost packets.
Guidance:
â€¢ You can use ğ‘ ğ‘’ğ‘¡ğ‘ ğ‘œğ‘ğ‘˜ğ‘œğ‘ğ‘¡(2) for detecting a timeout.
â€¢ You need to build your own protocol, as Reliable UDP isnâ€™t a standard protocol (see a
draft of RUDP in this link), and no official header is provided. You can use this sketch
for a header, but you can come up with your own protocol, as long as it works.
Where:
o ğ‘³ğ’†ğ’ğ’ˆğ’•ğ’‰ is the length of the data itself, without the RUDP header.
o ğ‘ªğ’‰ğ’†ğ’„ğ’Œğ’”ğ’–ğ’ is a 16bit number that validates the correctness of the data.
o ğ‘­ğ’ğ’‚ğ’ˆğ’” is a special byte where we classify the packet itself (SYN, ACK, etc.).
â€¢ In your PDF, you must explain how your implementation of RUDP works â€“ How does
it detect a timeout to do retransmissions, how does the handshake work, what is the
header overhead, etc.
â€¢ For this part, youâ€™ll write three files: ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¨ğ‘·ğ‘°. ğ’„, ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and
ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
Reliable UDP Header proposed sketch
Byte 0 Byte 1 Byte 2 Byte 3
Length (2 Bytes) Checksum (2 Bytes)
Flags (1 Byte)
Figure 1 - RUDP Protocol Architecture, Geeksforgeeks
 Communication Networks Course
Page | 5
Notes:
â€¢ The Sender will send a random generated file and the Receiver will receive it and
measure the time it took for his program to receive the file. The file size should be at
least 2MB.
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). But, as the
RUDP is based on UDP, itâ€™s not reliable. You must use some form of error checking
(like checksum) to ensure that the packet wasnâ€™t alerted during the transfer.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
â€¢ The RUDP needs support only 1 sender and 1 receiver, for simplicity purposes.
Usage:
â€¢ Receiver:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
â€¢ Sender:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port that both the Sender and the Receiver will use.
The ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„ file will contain all the implementations of the RUDP API functions (That is, to
prevent reusing the same chuck of code both in the Sender and the Receiver.).
The API should support at the bare minimum the following functions (you decide what
parameters to implement, and what are the names of the functions, as long as the API is
explained in the PDF):
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘œğ‘ğ‘˜ğ‘’ğ‘¡() â€“ Creating a RUDP socket and creating a handshake between two
peers.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘’ğ‘›ğ‘‘() â€“ Sending data to the peer. The function should wait for an
acknowledgment packet, and if it didnâ€™t receive any, retransmits the data.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘Ÿğ‘’ğ‘ğ‘£() â€“ Receive data from a peer.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ğ‘™ğ‘œğ‘ ğ‘’() â€“ Closes a connection between peers.
 Communication Networks Course
Page | 6
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a UDP socket between the Sender and the
Receiver.
3) Send the file via the RUDP protocol.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a UDP connection between the Receiver and
the Sender.
2) Get a connection from the sender, by the custom
RUDP protocol youâ€™ve built.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./RUDP_Receiver -p 1234
Starting Receiver...
Waiting for RUDP connection...
Connection request received, sending ACK.
Sender connected, beginning to receive file...
File transfer completed.
ACK sent.
Waiting for Sender response...
Sender sent exit message.
ACK sent.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 7
Part C â€“ Research â€“ 30 points
In this part, youâ€™ll conduct research about your implementations of part A and part B.
In the research itself, each one of the versions (TCP version and UDP version) will be run at
least 5 times (meaning that the file transfer will occur at least 5 times) by the following
conditions:
â€¢ For TCP, youâ€™ll run it in TCP Reno and TCP Cubic, alternating each time, for each
scenario, meaning that you run 5 times with TCP Reno in both Sender and Receiver,
and 5 times with TCP Cubic in both Sender and Receiver.
Bonus (5 points): Create a very large data set â€“ 5 times with TCP Reno in both Sender
and Receiver, 5 times with TCP Reno in Sender and TCP Cubic in Receiver, 5 times
with TCP Cubic in Sender and TCP Reno in Receiver, and 5 times with TCP Cubic in
both Sender and Receiver. This will give you a data set large enough, which allows
you to work with, compare with and to reach a definite conclusion.
â€¢ For RUDP, you will run it 5 times for each scenario.
â€¢ For both TCP and RUDP, you will run them on those scenarios of packet loss:
o 0% packet loss â€“ Control group, simulating perfect connection.
o 2% packet loss â€“ Simulating unstable connection that commonly occur.
o 5% packet loss â€“ Simulating bad connection.
o 10% packet loss â€“ Simulating extremely poor connection.
For each scenario, you must provide a filtered PCAP file and relevant screenshots that
explain each one of the steps in the process. (10 points)
After youâ€™ve gathered the data set for both TCP and Reliable UDP, answer the following
questions:
1) In TCP, which congestion control algorithm gave better results overall? TCP Reno or
TCP Cubic? Which one gave better results on high packet loss? Explain how you came
to this conclusion based on the data set youâ€™ve gathered. (5 points)
2) How did your implementation of Reliable UDP perform overall compared to regular
TCP? Which one is better for high packet loss? (5 points)
3) According to the data youâ€™ve gathered, in which scenarios and applications would we
prefer to use TCP and in which situations would we prefer to use reliable UDP?
Explain your answer. (5 points)
 Communication Networks Course
Page | 8
×¢× ×• ×¢×œ ×”×©××œ×•×ª ×”×‘××•×ª )5 × ×§×•×“×•×ª(:
â— ×‘"×¨×©×ª ×××™× ×”" ×”×›×•×•× ×” ×”×™× ×œ×¨×©×ª ×©×‘×” ××¢×˜ ×××•×“ ×—×‘×™×œ×•×ª ×”×•×œ×›×•×ª ×œ××™×‘×•×“. ×‘"×§×©×¨ ××¨×•×š" ×”×›×•×•× ×” ×”×™×
×œ×§×©×¨ TCP ×©×™×© ×‘×• ×”×¨×‘×” ×××•×“ ××™×“×¢ ×œ×©×œ×•×—. ××•×¦×¢ ×œ×”×’×“×™×œ ×‘ -TCP ××ª SSThreshold ×‘×ª×—×™×œ×ª ×”×§×©×¨.
×‘××™×–×” ××”××§×¨×™× ×”×‘××™× ×”×©×™× ×•×™ ×”×–×” ×¢×©×•×™ ×œ×”×•×¢×™×œ ×‘××™×“×” ×”××™×¨×‘×™×ª? × ××§.
.1 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
.2 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.3 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.4 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.5 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.6 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.7 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.8 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
â— A ×©×•×œ×— ×œ -B ×—×‘×™×œ×•×ª ××™×“×¢ ×‘×××¦×¢×•×ª ×§×©×¨ TCP. × ×ª×•×Ÿ ×›×™ ×”×§×©×¨ ××ª×—×™×œ ×¢× ×—×œ×•×Ÿ ×‘×’×•×“×œ 1MSS. ×”×§×©×¨
××¡×ª×™×™× ×‘×¤×¢× ×”×¨××©×•× ×” ×©×”×•× ××’×™×¢ ×œ -SSthresh. ×‘××”×œ×š ×”×§×©×¨ ×œ× ××•×‘×“×•×ª ×—×‘×™×œ×•×ª. × ×¡××Ÿ ×‘×§×™×¦×•×¨:
.SSthresh=S*MSS
× ×ª×•×Ÿ ×›×™ ×œ××•×¨×š ×›×œ ×”×§×©×¨ rwnd < MSS*S.
××”×™ ×”×ª×¤×•×§×” ×©×œ ×”×§×©×¨ ×-A ×œ-B( ×‘ -sec / Bytes )×‘×–××Ÿ ×”× "×œ? × ××§×™.
]S*MSS / [lg (S) * RTT*2 ×‘×¢×¨×š .1
]S*MSS / [S^0.5 * RTT*2 ×‘×¢×¨×š .2
S*MSS / RTT ×‘×¢×¨×š .3
S^2)*MSS / RTT( ×‘×¢×¨×š .4
â— ×©×ª×™ ×ª×—× ×•×ª ××ª×§×©×¨×•×ª ×‘××•×¤×Ÿ ××œ×—×•×˜×™ ×‘×©×™×˜×ª N Back Go.
× ×¡××Ÿ ×‘-X ××ª ×¡×¤×¨×ª ×”×‘×™×§×•×¨×ª ×©×œ ×”×ª.×–. ×©×œ×š. ×× ×©× ×™ ×©×•×ª×¤×™× ××’×™×©×™× ××ª ×”×ª×¨×’×™×œ ×™×—×“, X ×”×•× ×¡×¤×¨×ª
×”×‘×™×§×•×¨×ª ×‘×¢×œ×ª ×”×¢×¨×š ×”× ××•×š ×™×•×ª×¨ ××‘×™×Ÿ ×”×©×ª×™×™×.
×§×¦×‘ ×”×ª×§×©×•×¨×ª ×”×•× 8Gbps, ×•×’×•×“×œ ×›×œ ×—×‘×™×œ×” ×”×•× KByte*X. ×’×“×œ×™ ×”-headers ×•×” -Acks ×–× ×™×—×™×.
ï¿½ğ‘’ğ‘ ï¿½/ï¿½ï¿½ 8 , ×•×”××¨×—×§ ×‘×™×Ÿ ×”×ª×—× ×•×ª ×”×•× 1Km. ×§×¦×‘ ×”×”×ª×¤×©×˜×•×ª ×”×•× 10 â‹… 2
×–××Ÿ ×¢×™×‘×•×“ ×”× ×ª×•× ×™× ×‘×ª×—× ×•×ª ×–× ×™×—.
××£ ×—×‘×™×œ×” ×•××£ Ack ×œ× ×”×•×œ×›×™× ×œ××™×‘×•×“.
â— ××”×• X ×©×œ×š?
â— ××” ×¦×¨×™×š ×œ×”×™×•×ª ×’×•×“×œ ×—×œ×•×Ÿ ×”××©×œ×•×— ×›×“×™ ×œ×”×‘×˜×™×— ×ª×¤×•×§×” ××§×¡×™××œ×™×ª?
 Communication Networks Course
Page | 9
Bonus â€“ Improving the Reliable UDP â€“ 15 points
Note: This part isnâ€™t mandatory and is a bonus only!
In this part, youâ€™ll improve your RUDP implementation by adding the concepts of flow
control and congestion control from TCP. Youâ€™re free to choose which algorithms to
implement, as long as you explain in your PDF which algorithms youâ€™ve used. Youâ€™ll probably
need to make changes in the original design of the RUDP. Changes only need to be to the API
itself, ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„.
Points distribution:
â€¢ Flow control improvement â€“ 7 Points
â€¢ Congestion control improvement â€“ 8 points.
Guidance:
â€¢ For flow control, you must use one of the Sliding window techniques: stop-and-wait
ARQ, Go-Back-N or Selective repeat.
â€¢ List of known TCP congestion control algorithms, which you can use any one of them
for this bonus task, or makeup your own:
Figure 2 â€“ List of known TCP congestion control algorithms, Wikipedia
 Communication Networks Course
Page | 10
Appendix A â€“ Linux local packet loss tool
To simulate a packet loss in a local network, we'll use a Linux tool that's called Linux Traffic
Control (ğ‘¡ğ‘). This requires a full Linux installation, so working with WSL won't work.
If the tool isn't installed in your machine, you can install it by using the following commands:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’
If the installation didn't work, you can use the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’2
To create a packet loss scenario, type the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘ğ‘‘ğ‘‘ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
After creating a packet loss scenario, you can change the percentage by typing the following
command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘â„ğ‘ğ‘›ğ‘”ğ‘’ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
To remove the packet loss scenario, write the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘‘ğ‘’ğ‘™ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š
 Communication Networks Course
Page | 11
Appendix B â€“ ğ’ğ’‚ğ’(ğŸ) system calls
This appendixâ€™s purpose is to give you a better understanding of socket handling in C.
A recommended reference is Beejâ€™s Guide to Network Programming, by Brian â€œBeej
Jorgensenâ€ Hall, which gives a lot of information about sockets in C and functions.
Functions and documentation links:
â€¢ ğ’”ğ’ğ’„ğ’Œğ’†ğ’•(ğŸ) â€“ A Factory method system call that creates a socket with the given
parameters.
â€¢ ğ’ƒğ’Šğ’ğ’…(ğŸ) â€“ Whenever we create a new socket, we need to bind it to a specific port in
our machine, â€œto catch a portâ€. The port number is managed and used by the kernel
to link incoming packets to the corresponding application socket. The port numbers
are usually fixed. The ğ‘ğ‘‘ğ‘‘ğ‘Ÿ parameter must match the current socket that is used.
â€¢ ğ’ğ’Šğ’”ğ’•ğ’†ğ’(ğŸ) â€“ The ğ‘™ğ‘–ğ‘ ğ‘¡ğ‘’ğ‘›(2) system call doesn't do anything in the mean of
communication but only memory allocation (malloc) for stream sockets only. If we
won't allocate memory, any incoming connection will fail.
â€¢ ğ’„ğ’ğ’ğ’ğ’†ğ’„ğ’•(ğŸ) â€“ The ğ‘ğ‘œğ‘›ğ‘›ğ‘’ğ‘ğ‘¡(2) system call starts the link between a client and a
specific IP address and port number. The connection would complete when the
other side will call the ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call.
â€¢ ğ’‚ğ’„ğ’„ğ’†ğ’‘ğ’•(ğŸ) â€“ The ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call accepts the incoming stream connection
request from the other side, by the listening socket. This system call completes the
three-way handshake of stream socket (like TCP) and opens a new socket that has a
direct communication channel only with the other party in the handshake.
â€¢ ğ’”ğ’†ğ’ğ’…(ğŸ) and ğ’”ğ’†ğ’ğ’…ğ’•ğ’(ğŸ) â€“ The ğ‘ ğ‘’ğ‘›ğ‘‘(2) and ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system calls are an analogy
for the ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’(2) system call, specifcly for sockets, with flags set to 0. Those system
calls return the number of bytes that were sent through the socket itself, as the
number of bytes can vary. The ğ‘ ğ‘’ğ‘›ğ‘‘(2)system call designed for stream sockets (like
TCP), while the ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system call designed for datagram connection-less
sockets (like UDP). When the ğ‘ ğ‘’ğ‘›ğ‘‘(2) system call returns 0, it means that the other
party closed the connection.
â€¢ ğ’“ğ’†ğ’„ğ’—(ğŸ) and ğ’“ğ’†ğ’„ğ’—ğ’‡ğ’“ğ’ğ’(ğŸ) â€“ The ğ‘Ÿğ‘’ğ‘ğ‘£(2) and ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system calls are an
analogy for the ğ‘Ÿğ‘’ğ‘ğ‘‘(2) system call, specifically for sockets, with flags set to 0.
Those system calls return the number of bytes that were received through the socket
itself, as the number of bytes can vary. The ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call designed for stream
sockets (like TCP), while the ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system call designed for datagram
connection-less sockets (like UDP). When the ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call returns 0, it means
that the other party closed the connection.
â€¢ ğ’„ğ’ğ’ğ’”ğ’†(ğŸ) and ğ’”ğ’‰ğ’–ğ’•ğ’…ğ’ğ’˜ğ’(ğŸ) â€“ The ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) and ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2) system calls close
the socket. While ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) system call closes the whole socket, the ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2)
system call partially closes the socket for read/write.
 Communication Networks Course
Page | 12
Appendix C â€“ Random data generator
The data that you are going to send in this assignment is randomly generated. You can use
your own file with appropriate size or use the following function (or a function of your own)
to generate the data:
/*
* @brief A random data generator function based on srand() and rand().
* @param size The size of the data to generate (up to 2^32 bytes).
* @return A pointer to the buffer.
*/
char *util_generate_random_data(unsigned int size) {
 char *buffer = NULL;
 // Argument check.
 if (size == 0)
 return NULL;
 buffer = (char *)calloc(size, sizeof(char));
 // Error checking.
 if (buffer == NULL)
 return NULL;
 // Randomize the seed of the random number generator.
 srand(time(NULL));
 for (unsigned int i = 0; i < size; i++)
 *(buffer + i) = ((unsigned int)rand() % 256);
 return buffer;
}
 Communication Networks Course
Page | 13
Appendix D â€“ Checksum function
A checksum is a small-sized block of data derived from another block of digital data for the
purpose of detecting errors that may have been introduced during its transmission or
storage. By themselves, checksums are often used to verify data integrity but are not relied
upon to verify data authenticity.
Below is a simple yet efficient implementation of the checksum function, you can use it for
the assignment, but you can implement your own checksum function.
/*
* @brief A checksum function that returns 16 bit checksum for data.
* @param data The data to do the checksum for.
* @param bytes The length of the data in bytes.
* @return The checksum itself as 16 bit unsigned number.
* @note This function is taken from RFC1071, can be found here:
* @note https://tools.ietf.org/html/rfc1071
* @note It is the simplest way to calculate a checksum and is not very strong.
* However, it is good enough for this assignment.
* @note You are free to use any other checksum function as well.
* You can also use this function as such without any change.
*/
unsigned short int calculate_checksum(void *data, unsigned int bytes) {
 unsigned short int *data_pointer = (unsigned short int *)data;
 unsigned int total_sum = 0;
 // Main summing loop
 while (bytes > 1) {
 total_sum += *data_pointer++;
 bytes -= 2;
 }
 // Add left-over byte, if any
 if (bytes > 0)
 total_sum += *((unsigned char *)data_pointer);
 // Fold 32-bit sum to 16 bits
 while (total_sum >> 16)
 total_sum = (total_sum & 0xFFFF) + (total_sum >> 16);
 return (~((unsigned short int)total_sum));
} Communication Networks Course
Page | 1
Assignment 3 â€“ Transport Layer
Assignment Notes and Instructions
This assignment is to be done in pairs only. You must upload all the necessary files in a ZIP
file named after both of the studentâ€™s ID. For example: ğŸğŸğŸ‘ğŸ’ğŸ“ğŸ”ğŸ•ğŸ–ğŸ—_ğŸ—ğŸ–ğŸ•ğŸ”ğŸ“ğŸ’ğŸ‘ğŸğŸ. ğ’›ğ’Šğ’‘.
1) The assignment must be submitted by the date specified in the submission box.
2) All the assignment files (Code, Wireshark pcap files, PDF) must be submitted in a ZIP file. The
PDF must contain all the necessary screenshots with a description for each one of them.
3) The assignment must be done in pairs only. In exceptional cases, you should send an email to
the course coordinator.
4) You can use any reference material available through the course Moodle website or any
material passed during the exercises.
5) You can use any reference from the web, but copying codes from websites is forbidden; this
includes codes from other GitHub repositories. A student who gets caught in the act will
automatically fail this assignment (score 0). Any website youâ€™ve used to solve the
assignment, every website you used to solve the assignment must be noted in the PDF.
6) No delays in submission without special permission. Lateness without approval will result in
failure of the assignment (score 0).
7) All submissions will be submitted via the course's Moodle website. Email submissions will not
be accepted, resulting in a failure in the assignment.
8) The order and design of the code must be carefully considered. Make sure that the program
output is as clear as possible, comments in the code, and meaningful variable names. You
must also submit a makefile that compiles all the programs.
9) The assignment code must be written in C only.
10) The assignment is personal for each pair, and you should not accept help from other people,
whether outside the university or inside it. You can contact the course staff during reception
hours for help or raise a question in the course forum. Do not transfer code sections
between students, upload solutions or parts of solutions to websites on the Internet or in
various communication groups.
11) Students who copy a solution will receive a 0 in all assignments in the course and a report will
be made to the institutional disciplinary committee.
12) All code files of the assignment are required to both compile and run properly on the Ubuntu
22.04 LTS operating system. This is the operating system where the submissions will be
tested. You mustnâ€™t code it in Windows, as it uses different API for sockets. WSL wonâ€™t work,
as the task needs a tool that works only in a fully Linux environment.
Good Luck!
 Communication Networks Course
Page | 2
Part A â€“ Transmission Control Protocol (TCP) â€“ 30 points
In this part, youâ€™ll write two program files: ğ‘»ğ‘ªğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and ğ‘»ğ‘ªğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
The Sender will send a randomly generated file and the Receiver will receive it and measure
the time it took for his program to receive the file. The file size should be at least 2MB.
When running the Sender and Receiver, they both should support two standard congestion
control algorithms: TCP Reno and TCP Cubic.
Notes:
â€¢ The main goal of this part is to get familiar with the TCP concept of sending
messages between two endpoints.
â€¢ For approaching this part of the assignment, please be sure that you are familiar
with the congestion control algorithms and how to change them using the correct
method in C (see Appendix B for more information).
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). You've
learned that TCP is reliable by design, so you can assume that all the data have been
passed correctly, and thus, no need to recheck.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
Usage:
â€¢ Receiver:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
â€¢ Sender:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port of the Receiver.
â€¢ ğ‘¨ğ‘³ğ‘®ğ‘¶ â€“ The TCP congestion control algorithm that will be used by the party
member (either ğ’“ğ’†ğ’ğ’ for TCP Reno or ğ’„ğ’–ğ’ƒğ’Šğ’„ for TCP Cubic).
 Communication Networks Course
Page | 3
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a TCP socket between the Sender and the
Receiver.
3) Send the file.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a TCP connection between the Receiver and
the Sender.
2) Get a connection from the sender.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./TCP_Receiver -p 1234 -algo reno
Starting Receiver...
Waiting for TCP connection...
Sender connected, beginning to receive file...
File transfer completed.
Waiting for Sender response...
Sender sent exit message.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 4
Part B â€“ Reliable User Datagram Protocol (Reliable UDP or RUDP) â€“ 40 points
Youâ€™ve learned that while TCP is reliable, it lacks speed and has an overhead data of 20 bytes,
compering to UDP that needs only 8 bytes of overhead data.
Reliable UDP or RUDP, is a protocol that uses the UDP protocol for a faster transmission of
data, while adding a reliability layer to it, but without adding too much overhead data like
TCP.
A simple sketch for a RUDP connection would look something like this:
Your task in this part is to implement a Reliable protocol using UDP only. For simplicity, your
implementation should only support a handshake, closing scheme, error checking,
acknowledgment of received packets, and retransmission of lost packets.
Guidance:
â€¢ You can use ğ‘ ğ‘’ğ‘¡ğ‘ ğ‘œğ‘ğ‘˜ğ‘œğ‘ğ‘¡(2) for detecting a timeout.
â€¢ You need to build your own protocol, as Reliable UDP isnâ€™t a standard protocol (see a
draft of RUDP in this link), and no official header is provided. You can use this sketch
for a header, but you can come up with your own protocol, as long as it works.
Where:
o ğ‘³ğ’†ğ’ğ’ˆğ’•ğ’‰ is the length of the data itself, without the RUDP header.
o ğ‘ªğ’‰ğ’†ğ’„ğ’Œğ’”ğ’–ğ’ is a 16bit number that validates the correctness of the data.
o ğ‘­ğ’ğ’‚ğ’ˆğ’” is a special byte where we classify the packet itself (SYN, ACK, etc.).
â€¢ In your PDF, you must explain how your implementation of RUDP works â€“ How does
it detect a timeout to do retransmissions, how does the handshake work, what is the
header overhead, etc.
â€¢ For this part, youâ€™ll write three files: ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¨ğ‘·ğ‘°. ğ’„, ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and
ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
Reliable UDP Header proposed sketch
Byte 0 Byte 1 Byte 2 Byte 3
Length (2 Bytes) Checksum (2 Bytes)
Flags (1 Byte)
Figure 1 - RUDP Protocol Architecture, Geeksforgeeks
 Communication Networks Course
Page | 5
Notes:
â€¢ The Sender will send a random generated file and the Receiver will receive it and
measure the time it took for his program to receive the file. The file size should be at
least 2MB.
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). But, as the
RUDP is based on UDP, itâ€™s not reliable. You must use some form of error checking
(like checksum) to ensure that the packet wasnâ€™t alerted during the transfer.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
â€¢ The RUDP needs support only 1 sender and 1 receiver, for simplicity purposes.
Usage:
â€¢ Receiver:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
â€¢ Sender:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port that both the Sender and the Receiver will use.
The ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„ file will contain all the implementations of the RUDP API functions (That is, to
prevent reusing the same chuck of code both in the Sender and the Receiver.).
The API should support at the bare minimum the following functions (you decide what
parameters to implement, and what are the names of the functions, as long as the API is
explained in the PDF):
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘œğ‘ğ‘˜ğ‘’ğ‘¡() â€“ Creating a RUDP socket and creating a handshake between two
peers.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘’ğ‘›ğ‘‘() â€“ Sending data to the peer. The function should wait for an
acknowledgment packet, and if it didnâ€™t receive any, retransmits the data.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘Ÿğ‘’ğ‘ğ‘£() â€“ Receive data from a peer.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ğ‘™ğ‘œğ‘ ğ‘’() â€“ Closes a connection between peers.
 Communication Networks Course
Page | 6
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a UDP socket between the Sender and the
Receiver.
3) Send the file via the RUDP protocol.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a UDP connection between the Receiver and
the Sender.
2) Get a connection from the sender, by the custom
RUDP protocol youâ€™ve built.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./RUDP_Receiver -p 1234
Starting Receiver...
Waiting for RUDP connection...
Connection request received, sending ACK.
Sender connected, beginning to receive file...
File transfer completed.
ACK sent.
Waiting for Sender response...
Sender sent exit message.
ACK sent.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 7
Part C â€“ Research â€“ 30 points
In this part, youâ€™ll conduct research about your implementations of part A and part B.
In the research itself, each one of the versions (TCP version and UDP version) will be run at
least 5 times (meaning that the file transfer will occur at least 5 times) by the following
conditions:
â€¢ For TCP, youâ€™ll run it in TCP Reno and TCP Cubic, alternating each time, for each
scenario, meaning that you run 5 times with TCP Reno in both Sender and Receiver,
and 5 times with TCP Cubic in both Sender and Receiver.
Bonus (5 points): Create a very large data set â€“ 5 times with TCP Reno in both Sender
and Receiver, 5 times with TCP Reno in Sender and TCP Cubic in Receiver, 5 times
with TCP Cubic in Sender and TCP Reno in Receiver, and 5 times with TCP Cubic in
both Sender and Receiver. This will give you a data set large enough, which allows
you to work with, compare with and to reach a definite conclusion.
â€¢ For RUDP, you will run it 5 times for each scenario.
â€¢ For both TCP and RUDP, you will run them on those scenarios of packet loss:
o 0% packet loss â€“ Control group, simulating perfect connection.
o 2% packet loss â€“ Simulating unstable connection that commonly occur.
o 5% packet loss â€“ Simulating bad connection.
o 10% packet loss â€“ Simulating extremely poor connection.
For each scenario, you must provide a filtered PCAP file and relevant screenshots that
explain each one of the steps in the process. (10 points)
After youâ€™ve gathered the data set for both TCP and Reliable UDP, answer the following
questions:
1) In TCP, which congestion control algorithm gave better results overall? TCP Reno or
TCP Cubic? Which one gave better results on high packet loss? Explain how you came
to this conclusion based on the data set youâ€™ve gathered. (5 points)
2) How did your implementation of Reliable UDP perform overall compared to regular
TCP? Which one is better for high packet loss? (5 points)
3) According to the data youâ€™ve gathered, in which scenarios and applications would we
prefer to use TCP and in which situations would we prefer to use reliable UDP?
Explain your answer. (5 points)
 Communication Networks Course
Page | 8
×¢× ×• ×¢×œ ×”×©××œ×•×ª ×”×‘××•×ª )5 × ×§×•×“×•×ª(:
â— ×‘"×¨×©×ª ×××™× ×”" ×”×›×•×•× ×” ×”×™× ×œ×¨×©×ª ×©×‘×” ××¢×˜ ×××•×“ ×—×‘×™×œ×•×ª ×”×•×œ×›×•×ª ×œ××™×‘×•×“. ×‘"×§×©×¨ ××¨×•×š" ×”×›×•×•× ×” ×”×™×
×œ×§×©×¨ TCP ×©×™×© ×‘×• ×”×¨×‘×” ×××•×“ ××™×“×¢ ×œ×©×œ×•×—. ××•×¦×¢ ×œ×”×’×“×™×œ ×‘ -TCP ××ª SSThreshold ×‘×ª×—×™×œ×ª ×”×§×©×¨.
×‘××™×–×” ××”××§×¨×™× ×”×‘××™× ×”×©×™× ×•×™ ×”×–×” ×¢×©×•×™ ×œ×”×•×¢×™×œ ×‘××™×“×” ×”××™×¨×‘×™×ª? × ××§.
.1 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
.2 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.3 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.4 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.5 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.6 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.7 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.8 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
â— A ×©×•×œ×— ×œ -B ×—×‘×™×œ×•×ª ××™×“×¢ ×‘×××¦×¢×•×ª ×§×©×¨ TCP. × ×ª×•×Ÿ ×›×™ ×”×§×©×¨ ××ª×—×™×œ ×¢× ×—×œ×•×Ÿ ×‘×’×•×“×œ 1MSS. ×”×§×©×¨
××¡×ª×™×™× ×‘×¤×¢× ×”×¨××©×•× ×” ×©×”×•× ××’×™×¢ ×œ -SSthresh. ×‘××”×œ×š ×”×§×©×¨ ×œ× ××•×‘×“×•×ª ×—×‘×™×œ×•×ª. × ×¡××Ÿ ×‘×§×™×¦×•×¨:
.SSthresh=S*MSS
× ×ª×•×Ÿ ×›×™ ×œ××•×¨×š ×›×œ ×”×§×©×¨ rwnd < MSS*S.
××”×™ ×”×ª×¤×•×§×” ×©×œ ×”×§×©×¨ ×-A ×œ-B( ×‘ -sec / Bytes )×‘×–××Ÿ ×”× "×œ? × ××§×™.
]S*MSS / [lg (S) * RTT*2 ×‘×¢×¨×š .1
]S*MSS / [S^0.5 * RTT*2 ×‘×¢×¨×š .2
S*MSS / RTT ×‘×¢×¨×š .3
S^2)*MSS / RTT( ×‘×¢×¨×š .4
â— ×©×ª×™ ×ª×—× ×•×ª ××ª×§×©×¨×•×ª ×‘××•×¤×Ÿ ××œ×—×•×˜×™ ×‘×©×™×˜×ª N Back Go.
× ×¡××Ÿ ×‘-X ××ª ×¡×¤×¨×ª ×”×‘×™×§×•×¨×ª ×©×œ ×”×ª.×–. ×©×œ×š. ×× ×©× ×™ ×©×•×ª×¤×™× ××’×™×©×™× ××ª ×”×ª×¨×’×™×œ ×™×—×“, X ×”×•× ×¡×¤×¨×ª
×”×‘×™×§×•×¨×ª ×‘×¢×œ×ª ×”×¢×¨×š ×”× ××•×š ×™×•×ª×¨ ××‘×™×Ÿ ×”×©×ª×™×™×.
×§×¦×‘ ×”×ª×§×©×•×¨×ª ×”×•× 8Gbps, ×•×’×•×“×œ ×›×œ ×—×‘×™×œ×” ×”×•× KByte*X. ×’×“×œ×™ ×”-headers ×•×” -Acks ×–× ×™×—×™×.
ï¿½ğ‘’ğ‘ ï¿½/ï¿½ï¿½ 8 , ×•×”××¨×—×§ ×‘×™×Ÿ ×”×ª×—× ×•×ª ×”×•× 1Km. ×§×¦×‘ ×”×”×ª×¤×©×˜×•×ª ×”×•× 10 â‹… 2
×–××Ÿ ×¢×™×‘×•×“ ×”× ×ª×•× ×™× ×‘×ª×—× ×•×ª ×–× ×™×—.
××£ ×—×‘×™×œ×” ×•××£ Ack ×œ× ×”×•×œ×›×™× ×œ××™×‘×•×“.
â— ××”×• X ×©×œ×š?
â— ××” ×¦×¨×™×š ×œ×”×™×•×ª ×’×•×“×œ ×—×œ×•×Ÿ ×”××©×œ×•×— ×›×“×™ ×œ×”×‘×˜×™×— ×ª×¤×•×§×” ××§×¡×™××œ×™×ª?
 Communication Networks Course
Page | 9
Bonus â€“ Improving the Reliable UDP â€“ 15 points
Note: This part isnâ€™t mandatory and is a bonus only!
In this part, youâ€™ll improve your RUDP implementation by adding the concepts of flow
control and congestion control from TCP. Youâ€™re free to choose which algorithms to
implement, as long as you explain in your PDF which algorithms youâ€™ve used. Youâ€™ll probably
need to make changes in the original design of the RUDP. Changes only need to be to the API
itself, ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„.
Points distribution:
â€¢ Flow control improvement â€“ 7 Points
â€¢ Congestion control improvement â€“ 8 points.
Guidance:
â€¢ For flow control, you must use one of the Sliding window techniques: stop-and-wait
ARQ, Go-Back-N or Selective repeat.
â€¢ List of known TCP congestion control algorithms, which you can use any one of them
for this bonus task, or makeup your own:
Figure 2 â€“ List of known TCP congestion control algorithms, Wikipedia
 Communication Networks Course
Page | 10
Appendix A â€“ Linux local packet loss tool
To simulate a packet loss in a local network, we'll use a Linux tool that's called Linux Traffic
Control (ğ‘¡ğ‘). This requires a full Linux installation, so working with WSL won't work.
If the tool isn't installed in your machine, you can install it by using the following commands:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’
If the installation didn't work, you can use the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’2
To create a packet loss scenario, type the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘ğ‘‘ğ‘‘ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
After creating a packet loss scenario, you can change the percentage by typing the following
command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘â„ğ‘ğ‘›ğ‘”ğ‘’ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
To remove the packet loss scenario, write the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘‘ğ‘’ğ‘™ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š
 Communication Networks Course
Page | 11
Appendix B â€“ ğ’ğ’‚ğ’(ğŸ) system calls
This appendixâ€™s purpose is to give you a better understanding of socket handling in C.
A recommended reference is Beejâ€™s Guide to Network Programming, by Brian â€œBeej
Jorgensenâ€ Hall, which gives a lot of information about sockets in C and functions.
Functions and documentation links:
â€¢ ğ’”ğ’ğ’„ğ’Œğ’†ğ’•(ğŸ) â€“ A Factory method system call that creates a socket with the given
parameters.
â€¢ ğ’ƒğ’Šğ’ğ’…(ğŸ) â€“ Whenever we create a new socket, we need to bind it to a specific port in
our machine, â€œto catch a portâ€. The port number is managed and used by the kernel
to link incoming packets to the corresponding application socket. The port numbers
are usually fixed. The ğ‘ğ‘‘ğ‘‘ğ‘Ÿ parameter must match the current socket that is used.
â€¢ ğ’ğ’Šğ’”ğ’•ğ’†ğ’(ğŸ) â€“ The ğ‘™ğ‘–ğ‘ ğ‘¡ğ‘’ğ‘›(2) system call doesn't do anything in the mean of
communication but only memory allocation (malloc) for stream sockets only. If we
won't allocate memory, any incoming connection will fail.
â€¢ ğ’„ğ’ğ’ğ’ğ’†ğ’„ğ’•(ğŸ) â€“ The ğ‘ğ‘œğ‘›ğ‘›ğ‘’ğ‘ğ‘¡(2) system call starts the link between a client and a
specific IP address and port number. The connection would complete when the
other side will call the ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call.
â€¢ ğ’‚ğ’„ğ’„ğ’†ğ’‘ğ’•(ğŸ) â€“ The ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call accepts the incoming stream connection
request from the other side, by the listening socket. This system call completes the
three-way handshake of stream socket (like TCP) and opens a new socket that has a
direct communication channel only with the other party in the handshake.
â€¢ ğ’”ğ’†ğ’ğ’…(ğŸ) and ğ’”ğ’†ğ’ğ’…ğ’•ğ’(ğŸ) â€“ The ğ‘ ğ‘’ğ‘›ğ‘‘(2) and ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system calls are an analogy
for the ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’(2) system call, specifcly for sockets, with flags set to 0. Those system
calls return the number of bytes that were sent through the socket itself, as the
number of bytes can vary. The ğ‘ ğ‘’ğ‘›ğ‘‘(2)system call designed for stream sockets (like
TCP), while the ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system call designed for datagram connection-less
sockets (like UDP). When the ğ‘ ğ‘’ğ‘›ğ‘‘(2) system call returns 0, it means that the other
party closed the connection.
â€¢ ğ’“ğ’†ğ’„ğ’—(ğŸ) and ğ’“ğ’†ğ’„ğ’—ğ’‡ğ’“ğ’ğ’(ğŸ) â€“ The ğ‘Ÿğ‘’ğ‘ğ‘£(2) and ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system calls are an
analogy for the ğ‘Ÿğ‘’ğ‘ğ‘‘(2) system call, specifically for sockets, with flags set to 0.
Those system calls return the number of bytes that were received through the socket
itself, as the number of bytes can vary. The ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call designed for stream
sockets (like TCP), while the ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system call designed for datagram
connection-less sockets (like UDP). When the ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call returns 0, it means
that the other party closed the connection.
â€¢ ğ’„ğ’ğ’ğ’”ğ’†(ğŸ) and ğ’”ğ’‰ğ’–ğ’•ğ’…ğ’ğ’˜ğ’(ğŸ) â€“ The ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) and ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2) system calls close
the socket. While ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) system call closes the whole socket, the ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2)
system call partially closes the socket for read/write.
 Communication Networks Course
Page | 12
Appendix C â€“ Random data generator
The data that you are going to send in this assignment is randomly generated. You can use
your own file with appropriate size or use the following function (or a function of your own)
to generate the data:
/*
* @brief A random data generator function based on srand() and rand().
* @param size The size of the data to generate (up to 2^32 bytes).
* @return A pointer to the buffer.
*/
char *util_generate_random_data(unsigned int size) {
 char *buffer = NULL;
 // Argument check.
 if (size == 0)
 return NULL;
 buffer = (char *)calloc(size, sizeof(char));
 // Error checking.
 if (buffer == NULL)
 return NULL;
 // Randomize the seed of the random number generator.
 srand(time(NULL));
 for (unsigned int i = 0; i < size; i++)
 *(buffer + i) = ((unsigned int)rand() % 256);
 return buffer;
}
 Communication Networks Course
Page | 13
Appendix D â€“ Checksum function
A checksum is a small-sized block of data derived from another block of digital data for the
purpose of detecting errors that may have been introduced during its transmission or
storage. By themselves, checksums are often used to verify data integrity but are not relied
upon to verify data authenticity.
Below is a simple yet efficient implementation of the checksum function, you can use it for
the assignment, but you can implement your own checksum function.
/*
* @brief A checksum function that returns 16 bit checksum for data.
* @param data The data to do the checksum for.
* @param bytes The length of the data in bytes.
* @return The checksum itself as 16 bit unsigned number.
* @note This function is taken from RFC1071, can be found here:
* @note https://tools.ietf.org/html/rfc1071
* @note It is the simplest way to calculate a checksum and is not very strong.
* However, it is good enough for this assignment.
* @note You are free to use any other checksum function as well.
* You can also use this function as such without any change.
*/
unsigned short int calculate_checksum(void *data, unsigned int bytes) {
 unsigned short int *data_pointer = (unsigned short int *)data;
 unsigned int total_sum = 0;
 // Main summing loop
 while (bytes > 1) {
 total_sum += *data_pointer++;
 bytes -= 2;
 }
 // Add left-over byte, if any
 if (bytes > 0)
 total_sum += *((unsigned char *)data_pointer);
 // Fold 32-bit sum to 16 bits
 while (total_sum >> 16)
 total_sum = (total_sum & 0xFFFF) + (total_sum >> 16);
 return (~((unsigned short int)total_sum));
} Communication Networks Course
Page | 1
Assignment 3 â€“ Transport Layer
Assignment Notes and Instructions
This assignment is to be done in pairs only. You must upload all the necessary files in a ZIP
file named after both of the studentâ€™s ID. For example: ğŸğŸğŸ‘ğŸ’ğŸ“ğŸ”ğŸ•ğŸ–ğŸ—_ğŸ—ğŸ–ğŸ•ğŸ”ğŸ“ğŸ’ğŸ‘ğŸğŸ. ğ’›ğ’Šğ’‘.
1) The assignment must be submitted by the date specified in the submission box.
2) All the assignment files (Code, Wireshark pcap files, PDF) must be submitted in a ZIP file. The
PDF must contain all the necessary screenshots with a description for each one of them.
3) The assignment must be done in pairs only. In exceptional cases, you should send an email to
the course coordinator.
4) You can use any reference material available through the course Moodle website or any
material passed during the exercises.
5) You can use any reference from the web, but copying codes from websites is forbidden; this
includes codes from other GitHub repositories. A student who gets caught in the act will
automatically fail this assignment (score 0). Any website youâ€™ve used to solve the
assignment, every website you used to solve the assignment must be noted in the PDF.
6) No delays in submission without special permission. Lateness without approval will result in
failure of the assignment (score 0).
7) All submissions will be submitted via the course's Moodle website. Email submissions will not
be accepted, resulting in a failure in the assignment.
8) The order and design of the code must be carefully considered. Make sure that the program
output is as clear as possible, comments in the code, and meaningful variable names. You
must also submit a makefile that compiles all the programs.
9) The assignment code must be written in C only.
10) The assignment is personal for each pair, and you should not accept help from other people,
whether outside the university or inside it. You can contact the course staff during reception
hours for help or raise a question in the course forum. Do not transfer code sections
between students, upload solutions or parts of solutions to websites on the Internet or in
various communication groups.
11) Students who copy a solution will receive a 0 in all assignments in the course and a report will
be made to the institutional disciplinary committee.
12) All code files of the assignment are required to both compile and run properly on the Ubuntu
22.04 LTS operating system. This is the operating system where the submissions will be
tested. You mustnâ€™t code it in Windows, as it uses different API for sockets. WSL wonâ€™t work,
as the task needs a tool that works only in a fully Linux environment.
Good Luck!
 Communication Networks Course
Page | 2
Part A â€“ Transmission Control Protocol (TCP) â€“ 30 points
In this part, youâ€™ll write two program files: ğ‘»ğ‘ªğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and ğ‘»ğ‘ªğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
The Sender will send a randomly generated file and the Receiver will receive it and measure
the time it took for his program to receive the file. The file size should be at least 2MB.
When running the Sender and Receiver, they both should support two standard congestion
control algorithms: TCP Reno and TCP Cubic.
Notes:
â€¢ The main goal of this part is to get familiar with the TCP concept of sending
messages between two endpoints.
â€¢ For approaching this part of the assignment, please be sure that you are familiar
with the congestion control algorithms and how to change them using the correct
method in C (see Appendix B for more information).
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). You've
learned that TCP is reliable by design, so you can assume that all the data have been
passed correctly, and thus, no need to recheck.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
Usage:
â€¢ Receiver:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
â€¢ Sender:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port of the Receiver.
â€¢ ğ‘¨ğ‘³ğ‘®ğ‘¶ â€“ The TCP congestion control algorithm that will be used by the party
member (either ğ’“ğ’†ğ’ğ’ for TCP Reno or ğ’„ğ’–ğ’ƒğ’Šğ’„ for TCP Cubic).
 Communication Networks Course
Page | 3
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a TCP socket between the Sender and the
Receiver.
3) Send the file.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a TCP connection between the Receiver and
the Sender.
2) Get a connection from the sender.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./TCP_Receiver -p 1234 -algo reno
Starting Receiver...
Waiting for TCP connection...
Sender connected, beginning to receive file...
File transfer completed.
Waiting for Sender response...
Sender sent exit message.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 4
Part B â€“ Reliable User Datagram Protocol (Reliable UDP or RUDP) â€“ 40 points
Youâ€™ve learned that while TCP is reliable, it lacks speed and has an overhead data of 20 bytes,
compering to UDP that needs only 8 bytes of overhead data.
Reliable UDP or RUDP, is a protocol that uses the UDP protocol for a faster transmission of
data, while adding a reliability layer to it, but without adding too much overhead data like
TCP.
A simple sketch for a RUDP connection would look something like this:
Your task in this part is to implement a Reliable protocol using UDP only. For simplicity, your
implementation should only support a handshake, closing scheme, error checking,
acknowledgment of received packets, and retransmission of lost packets.
Guidance:
â€¢ You can use ğ‘ ğ‘’ğ‘¡ğ‘ ğ‘œğ‘ğ‘˜ğ‘œğ‘ğ‘¡(2) for detecting a timeout.
â€¢ You need to build your own protocol, as Reliable UDP isnâ€™t a standard protocol (see a
draft of RUDP in this link), and no official header is provided. You can use this sketch
for a header, but you can come up with your own protocol, as long as it works.
Where:
o ğ‘³ğ’†ğ’ğ’ˆğ’•ğ’‰ is the length of the data itself, without the RUDP header.
o ğ‘ªğ’‰ğ’†ğ’„ğ’Œğ’”ğ’–ğ’ is a 16bit number that validates the correctness of the data.
o ğ‘­ğ’ğ’‚ğ’ˆğ’” is a special byte where we classify the packet itself (SYN, ACK, etc.).
â€¢ In your PDF, you must explain how your implementation of RUDP works â€“ How does
it detect a timeout to do retransmissions, how does the handshake work, what is the
header overhead, etc.
â€¢ For this part, youâ€™ll write three files: ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¨ğ‘·ğ‘°. ğ’„, ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and
ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
Reliable UDP Header proposed sketch
Byte 0 Byte 1 Byte 2 Byte 3
Length (2 Bytes) Checksum (2 Bytes)
Flags (1 Byte)
Figure 1 - RUDP Protocol Architecture, Geeksforgeeks
 Communication Networks Course
Page | 5
Notes:
â€¢ The Sender will send a random generated file and the Receiver will receive it and
measure the time it took for his program to receive the file. The file size should be at
least 2MB.
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). But, as the
RUDP is based on UDP, itâ€™s not reliable. You must use some form of error checking
(like checksum) to ensure that the packet wasnâ€™t alerted during the transfer.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
â€¢ The RUDP needs support only 1 sender and 1 receiver, for simplicity purposes.
Usage:
â€¢ Receiver:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
â€¢ Sender:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port that both the Sender and the Receiver will use.
The ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„ file will contain all the implementations of the RUDP API functions (That is, to
prevent reusing the same chuck of code both in the Sender and the Receiver.).
The API should support at the bare minimum the following functions (you decide what
parameters to implement, and what are the names of the functions, as long as the API is
explained in the PDF):
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘œğ‘ğ‘˜ğ‘’ğ‘¡() â€“ Creating a RUDP socket and creating a handshake between two
peers.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘’ğ‘›ğ‘‘() â€“ Sending data to the peer. The function should wait for an
acknowledgment packet, and if it didnâ€™t receive any, retransmits the data.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘Ÿğ‘’ğ‘ğ‘£() â€“ Receive data from a peer.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ğ‘™ğ‘œğ‘ ğ‘’() â€“ Closes a connection between peers.
 Communication Networks Course
Page | 6
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a UDP socket between the Sender and the
Receiver.
3) Send the file via the RUDP protocol.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a UDP connection between the Receiver and
the Sender.
2) Get a connection from the sender, by the custom
RUDP protocol youâ€™ve built.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./RUDP_Receiver -p 1234
Starting Receiver...
Waiting for RUDP connection...
Connection request received, sending ACK.
Sender connected, beginning to receive file...
File transfer completed.
ACK sent.
Waiting for Sender response...
Sender sent exit message.
ACK sent.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 7
Part C â€“ Research â€“ 30 points
In this part, youâ€™ll conduct research about your implementations of part A and part B.
In the research itself, each one of the versions (TCP version and UDP version) will be run at
least 5 times (meaning that the file transfer will occur at least 5 times) by the following
conditions:
â€¢ For TCP, youâ€™ll run it in TCP Reno and TCP Cubic, alternating each time, for each
scenario, meaning that you run 5 times with TCP Reno in both Sender and Receiver,
and 5 times with TCP Cubic in both Sender and Receiver.
Bonus (5 points): Create a very large data set â€“ 5 times with TCP Reno in both Sender
and Receiver, 5 times with TCP Reno in Sender and TCP Cubic in Receiver, 5 times
with TCP Cubic in Sender and TCP Reno in Receiver, and 5 times with TCP Cubic in
both Sender and Receiver. This will give you a data set large enough, which allows
you to work with, compare with and to reach a definite conclusion.
â€¢ For RUDP, you will run it 5 times for each scenario.
â€¢ For both TCP and RUDP, you will run them on those scenarios of packet loss:
o 0% packet loss â€“ Control group, simulating perfect connection.
o 2% packet loss â€“ Simulating unstable connection that commonly occur.
o 5% packet loss â€“ Simulating bad connection.
o 10% packet loss â€“ Simulating extremely poor connection.
For each scenario, you must provide a filtered PCAP file and relevant screenshots that
explain each one of the steps in the process. (10 points)
After youâ€™ve gathered the data set for both TCP and Reliable UDP, answer the following
questions:
1) In TCP, which congestion control algorithm gave better results overall? TCP Reno or
TCP Cubic? Which one gave better results on high packet loss? Explain how you came
to this conclusion based on the data set youâ€™ve gathered. (5 points)
2) How did your implementation of Reliable UDP perform overall compared to regular
TCP? Which one is better for high packet loss? (5 points)
3) According to the data youâ€™ve gathered, in which scenarios and applications would we
prefer to use TCP and in which situations would we prefer to use reliable UDP?
Explain your answer. (5 points)
 Communication Networks Course
Page | 8
×¢× ×• ×¢×œ ×”×©××œ×•×ª ×”×‘××•×ª )5 × ×§×•×“×•×ª(:
â— ×‘"×¨×©×ª ×××™× ×”" ×”×›×•×•× ×” ×”×™× ×œ×¨×©×ª ×©×‘×” ××¢×˜ ×××•×“ ×—×‘×™×œ×•×ª ×”×•×œ×›×•×ª ×œ××™×‘×•×“. ×‘"×§×©×¨ ××¨×•×š" ×”×›×•×•× ×” ×”×™×
×œ×§×©×¨ TCP ×©×™×© ×‘×• ×”×¨×‘×” ×××•×“ ××™×“×¢ ×œ×©×œ×•×—. ××•×¦×¢ ×œ×”×’×“×™×œ ×‘ -TCP ××ª SSThreshold ×‘×ª×—×™×œ×ª ×”×§×©×¨.
×‘××™×–×” ××”××§×¨×™× ×”×‘××™× ×”×©×™× ×•×™ ×”×–×” ×¢×©×•×™ ×œ×”×•×¢×™×œ ×‘××™×“×” ×”××™×¨×‘×™×ª? × ××§.
.1 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
.2 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.3 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.4 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.5 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.6 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.7 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.8 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
â— A ×©×•×œ×— ×œ -B ×—×‘×™×œ×•×ª ××™×“×¢ ×‘×××¦×¢×•×ª ×§×©×¨ TCP. × ×ª×•×Ÿ ×›×™ ×”×§×©×¨ ××ª×—×™×œ ×¢× ×—×œ×•×Ÿ ×‘×’×•×“×œ 1MSS. ×”×§×©×¨
××¡×ª×™×™× ×‘×¤×¢× ×”×¨××©×•× ×” ×©×”×•× ××’×™×¢ ×œ -SSthresh. ×‘××”×œ×š ×”×§×©×¨ ×œ× ××•×‘×“×•×ª ×—×‘×™×œ×•×ª. × ×¡××Ÿ ×‘×§×™×¦×•×¨:
.SSthresh=S*MSS
× ×ª×•×Ÿ ×›×™ ×œ××•×¨×š ×›×œ ×”×§×©×¨ rwnd < MSS*S.
××”×™ ×”×ª×¤×•×§×” ×©×œ ×”×§×©×¨ ×-A ×œ-B( ×‘ -sec / Bytes )×‘×–××Ÿ ×”× "×œ? × ××§×™.
]S*MSS / [lg (S) * RTT*2 ×‘×¢×¨×š .1
]S*MSS / [S^0.5 * RTT*2 ×‘×¢×¨×š .2
S*MSS / RTT ×‘×¢×¨×š .3
S^2)*MSS / RTT( ×‘×¢×¨×š .4
â— ×©×ª×™ ×ª×—× ×•×ª ××ª×§×©×¨×•×ª ×‘××•×¤×Ÿ ××œ×—×•×˜×™ ×‘×©×™×˜×ª N Back Go.
× ×¡××Ÿ ×‘-X ××ª ×¡×¤×¨×ª ×”×‘×™×§×•×¨×ª ×©×œ ×”×ª.×–. ×©×œ×š. ×× ×©× ×™ ×©×•×ª×¤×™× ××’×™×©×™× ××ª ×”×ª×¨×’×™×œ ×™×—×“, X ×”×•× ×¡×¤×¨×ª
×”×‘×™×§×•×¨×ª ×‘×¢×œ×ª ×”×¢×¨×š ×”× ××•×š ×™×•×ª×¨ ××‘×™×Ÿ ×”×©×ª×™×™×.
×§×¦×‘ ×”×ª×§×©×•×¨×ª ×”×•× 8Gbps, ×•×’×•×“×œ ×›×œ ×—×‘×™×œ×” ×”×•× KByte*X. ×’×“×œ×™ ×”-headers ×•×” -Acks ×–× ×™×—×™×.
ï¿½ğ‘’ğ‘ ï¿½/ï¿½ï¿½ 8 , ×•×”××¨×—×§ ×‘×™×Ÿ ×”×ª×—× ×•×ª ×”×•× 1Km. ×§×¦×‘ ×”×”×ª×¤×©×˜×•×ª ×”×•× 10 â‹… 2
×–××Ÿ ×¢×™×‘×•×“ ×”× ×ª×•× ×™× ×‘×ª×—× ×•×ª ×–× ×™×—.
××£ ×—×‘×™×œ×” ×•××£ Ack ×œ× ×”×•×œ×›×™× ×œ××™×‘×•×“.
â— ××”×• X ×©×œ×š?
â— ××” ×¦×¨×™×š ×œ×”×™×•×ª ×’×•×“×œ ×—×œ×•×Ÿ ×”××©×œ×•×— ×›×“×™ ×œ×”×‘×˜×™×— ×ª×¤×•×§×” ××§×¡×™××œ×™×ª?
 Communication Networks Course
Page | 9
Bonus â€“ Improving the Reliable UDP â€“ 15 points
Note: This part isnâ€™t mandatory and is a bonus only!
In this part, youâ€™ll improve your RUDP implementation by adding the concepts of flow
control and congestion control from TCP. Youâ€™re free to choose which algorithms to
implement, as long as you explain in your PDF which algorithms youâ€™ve used. Youâ€™ll probably
need to make changes in the original design of the RUDP. Changes only need to be to the API
itself, ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„.
Points distribution:
â€¢ Flow control improvement â€“ 7 Points
â€¢ Congestion control improvement â€“ 8 points.
Guidance:
â€¢ For flow control, you must use one of the Sliding window techniques: stop-and-wait
ARQ, Go-Back-N or Selective repeat.
â€¢ List of known TCP congestion control algorithms, which you can use any one of them
for this bonus task, or makeup your own:
Figure 2 â€“ List of known TCP congestion control algorithms, Wikipedia
 Communication Networks Course
Page | 10
Appendix A â€“ Linux local packet loss tool
To simulate a packet loss in a local network, we'll use a Linux tool that's called Linux Traffic
Control (ğ‘¡ğ‘). This requires a full Linux installation, so working with WSL won't work.
If the tool isn't installed in your machine, you can install it by using the following commands:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’
If the installation didn't work, you can use the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’2
To create a packet loss scenario, type the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘ğ‘‘ğ‘‘ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
After creating a packet loss scenario, you can change the percentage by typing the following
command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘â„ğ‘ğ‘›ğ‘”ğ‘’ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
To remove the packet loss scenario, write the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘‘ğ‘’ğ‘™ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š
 Communication Networks Course
Page | 11
Appendix B â€“ ğ’ğ’‚ğ’(ğŸ) system calls
This appendixâ€™s purpose is to give you a better understanding of socket handling in C.
A recommended reference is Beejâ€™s Guide to Network Programming, by Brian â€œBeej
Jorgensenâ€ Hall, which gives a lot of information about sockets in C and functions.
Functions and documentation links:
â€¢ ğ’”ğ’ğ’„ğ’Œğ’†ğ’•(ğŸ) â€“ A Factory method system call that creates a socket with the given
parameters.
â€¢ ğ’ƒğ’Šğ’ğ’…(ğŸ) â€“ Whenever we create a new socket, we need to bind it to a specific port in
our machine, â€œto catch a portâ€. The port number is managed and used by the kernel
to link incoming packets to the corresponding application socket. The port numbers
are usually fixed. The ğ‘ğ‘‘ğ‘‘ğ‘Ÿ parameter must match the current socket that is used.
â€¢ ğ’ğ’Šğ’”ğ’•ğ’†ğ’(ğŸ) â€“ The ğ‘™ğ‘–ğ‘ ğ‘¡ğ‘’ğ‘›(2) system call doesn't do anything in the mean of
communication but only memory allocation (malloc) for stream sockets only. If we
won't allocate memory, any incoming connection will fail.
â€¢ ğ’„ğ’ğ’ğ’ğ’†ğ’„ğ’•(ğŸ) â€“ The ğ‘ğ‘œğ‘›ğ‘›ğ‘’ğ‘ğ‘¡(2) system call starts the link between a client and a
specific IP address and port number. The connection would complete when the
other side will call the ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call.
â€¢ ğ’‚ğ’„ğ’„ğ’†ğ’‘ğ’•(ğŸ) â€“ The ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call accepts the incoming stream connection
request from the other side, by the listening socket. This system call completes the
three-way handshake of stream socket (like TCP) and opens a new socket that has a
direct communication channel only with the other party in the handshake.
â€¢ ğ’”ğ’†ğ’ğ’…(ğŸ) and ğ’”ğ’†ğ’ğ’…ğ’•ğ’(ğŸ) â€“ The ğ‘ ğ‘’ğ‘›ğ‘‘(2) and ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system calls are an analogy
for the ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’(2) system call, specifcly for sockets, with flags set to 0. Those system
calls return the number of bytes that were sent through the socket itself, as the
number of bytes can vary. The ğ‘ ğ‘’ğ‘›ğ‘‘(2)system call designed for stream sockets (like
TCP), while the ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system call designed for datagram connection-less
sockets (like UDP). When the ğ‘ ğ‘’ğ‘›ğ‘‘(2) system call returns 0, it means that the other
party closed the connection.
â€¢ ğ’“ğ’†ğ’„ğ’—(ğŸ) and ğ’“ğ’†ğ’„ğ’—ğ’‡ğ’“ğ’ğ’(ğŸ) â€“ The ğ‘Ÿğ‘’ğ‘ğ‘£(2) and ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system calls are an
analogy for the ğ‘Ÿğ‘’ğ‘ğ‘‘(2) system call, specifically for sockets, with flags set to 0.
Those system calls return the number of bytes that were received through the socket
itself, as the number of bytes can vary. The ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call designed for stream
sockets (like TCP), while the ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system call designed for datagram
connection-less sockets (like UDP). When the ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call returns 0, it means
that the other party closed the connection.
â€¢ ğ’„ğ’ğ’ğ’”ğ’†(ğŸ) and ğ’”ğ’‰ğ’–ğ’•ğ’…ğ’ğ’˜ğ’(ğŸ) â€“ The ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) and ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2) system calls close
the socket. While ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) system call closes the whole socket, the ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2)
system call partially closes the socket for read/write.
 Communication Networks Course
Page | 12
Appendix C â€“ Random data generator
The data that you are going to send in this assignment is randomly generated. You can use
your own file with appropriate size or use the following function (or a function of your own)
to generate the data:
/*
* @brief A random data generator function based on srand() and rand().
* @param size The size of the data to generate (up to 2^32 bytes).
* @return A pointer to the buffer.
*/
char *util_generate_random_data(unsigned int size) {
 char *buffer = NULL;
 // Argument check.
 if (size == 0)
 return NULL;
 buffer = (char *)calloc(size, sizeof(char));
 // Error checking.
 if (buffer == NULL)
 return NULL;
 // Randomize the seed of the random number generator.
 srand(time(NULL));
 for (unsigned int i = 0; i < size; i++)
 *(buffer + i) = ((unsigned int)rand() % 256);
 return buffer;
}
 Communication Networks Course
Page | 13
Appendix D â€“ Checksum function
A checksum is a small-sized block of data derived from another block of digital data for the
purpose of detecting errors that may have been introduced during its transmission or
storage. By themselves, checksums are often used to verify data integrity but are not relied
upon to verify data authenticity.
Below is a simple yet efficient implementation of the checksum function, you can use it for
the assignment, but you can implement your own checksum function.
/*
* @brief A checksum function that returns 16 bit checksum for data.
* @param data The data to do the checksum for.
* @param bytes The length of the data in bytes.
* @return The checksum itself as 16 bit unsigned number.
* @note This function is taken from RFC1071, can be found here:
* @note https://tools.ietf.org/html/rfc1071
* @note It is the simplest way to calculate a checksum and is not very strong.
* However, it is good enough for this assignment.
* @note You are free to use any other checksum function as well.
* You can also use this function as such without any change.
*/
unsigned short int calculate_checksum(void *data, unsigned int bytes) {
 unsigned short int *data_pointer = (unsigned short int *)data;
 unsigned int total_sum = 0;
 // Main summing loop
 while (bytes > 1) {
 total_sum += *data_pointer++;
 bytes -= 2;
 }
 // Add left-over byte, if any
 if (bytes > 0)
 total_sum += *((unsigned char *)data_pointer);
 // Fold 32-bit sum to 16 bits
 while (total_sum >> 16)
 total_sum = (total_sum & 0xFFFF) + (total_sum >> 16);
 return (~((unsigned short int)total_sum));
} Communication Networks Course
Page | 1
Assignment 3 â€“ Transport Layer
Assignment Notes and Instructions
This assignment is to be done in pairs only. You must upload all the necessary files in a ZIP
file named after both of the studentâ€™s ID. For example: ğŸğŸğŸ‘ğŸ’ğŸ“ğŸ”ğŸ•ğŸ–ğŸ—_ğŸ—ğŸ–ğŸ•ğŸ”ğŸ“ğŸ’ğŸ‘ğŸğŸ. ğ’›ğ’Šğ’‘.
1) The assignment must be submitted by the date specified in the submission box.
2) All the assignment files (Code, Wireshark pcap files, PDF) must be submitted in a ZIP file. The
PDF must contain all the necessary screenshots with a description for each one of them.
3) The assignment must be done in pairs only. In exceptional cases, you should send an email to
the course coordinator.
4) You can use any reference material available through the course Moodle website or any
material passed during the exercises.
5) You can use any reference from the web, but copying codes from websites is forbidden; this
includes codes from other GitHub repositories. A student who gets caught in the act will
automatically fail this assignment (score 0). Any website youâ€™ve used to solve the
assignment, every website you used to solve the assignment must be noted in the PDF.
6) No delays in submission without special permission. Lateness without approval will result in
failure of the assignment (score 0).
7) All submissions will be submitted via the course's Moodle website. Email submissions will not
be accepted, resulting in a failure in the assignment.
8) The order and design of the code must be carefully considered. Make sure that the program
output is as clear as possible, comments in the code, and meaningful variable names. You
must also submit a makefile that compiles all the programs.
9) The assignment code must be written in C only.
10) The assignment is personal for each pair, and you should not accept help from other people,
whether outside the university or inside it. You can contact the course staff during reception
hours for help or raise a question in the course forum. Do not transfer code sections
between students, upload solutions or parts of solutions to websites on the Internet or in
various communication groups.
11) Students who copy a solution will receive a 0 in all assignments in the course and a report will
be made to the institutional disciplinary committee.
12) All code files of the assignment are required to both compile and run properly on the Ubuntu
22.04 LTS operating system. This is the operating system where the submissions will be
tested. You mustnâ€™t code it in Windows, as it uses different API for sockets. WSL wonâ€™t work,
as the task needs a tool that works only in a fully Linux environment.
Good Luck!
 Communication Networks Course
Page | 2
Part A â€“ Transmission Control Protocol (TCP) â€“ 30 points
In this part, youâ€™ll write two program files: ğ‘»ğ‘ªğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and ğ‘»ğ‘ªğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
The Sender will send a randomly generated file and the Receiver will receive it and measure
the time it took for his program to receive the file. The file size should be at least 2MB.
When running the Sender and Receiver, they both should support two standard congestion
control algorithms: TCP Reno and TCP Cubic.
Notes:
â€¢ The main goal of this part is to get familiar with the TCP concept of sending
messages between two endpoints.
â€¢ For approaching this part of the assignment, please be sure that you are familiar
with the congestion control algorithms and how to change them using the correct
method in C (see Appendix B for more information).
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). You've
learned that TCP is reliable by design, so you can assume that all the data have been
passed correctly, and thus, no need to recheck.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
Usage:
â€¢ Receiver:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
â€¢ Sender:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port of the Receiver.
â€¢ ğ‘¨ğ‘³ğ‘®ğ‘¶ â€“ The TCP congestion control algorithm that will be used by the party
member (either ğ’“ğ’†ğ’ğ’ for TCP Reno or ğ’„ğ’–ğ’ƒğ’Šğ’„ for TCP Cubic).
 Communication Networks Course
Page | 3
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a TCP socket between the Sender and the
Receiver.
3) Send the file.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a TCP connection between the Receiver and
the Sender.
2) Get a connection from the sender.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./TCP_Receiver -p 1234 -algo reno
Starting Receiver...
Waiting for TCP connection...
Sender connected, beginning to receive file...
File transfer completed.
Waiting for Sender response...
Sender sent exit message.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 4
Part B â€“ Reliable User Datagram Protocol (Reliable UDP or RUDP) â€“ 40 points
Youâ€™ve learned that while TCP is reliable, it lacks speed and has an overhead data of 20 bytes,
compering to UDP that needs only 8 bytes of overhead data.
Reliable UDP or RUDP, is a protocol that uses the UDP protocol for a faster transmission of
data, while adding a reliability layer to it, but without adding too much overhead data like
TCP.
A simple sketch for a RUDP connection would look something like this:
Your task in this part is to implement a Reliable protocol using UDP only. For simplicity, your
implementation should only support a handshake, closing scheme, error checking,
acknowledgment of received packets, and retransmission of lost packets.
Guidance:
â€¢ You can use ğ‘ ğ‘’ğ‘¡ğ‘ ğ‘œğ‘ğ‘˜ğ‘œğ‘ğ‘¡(2) for detecting a timeout.
â€¢ You need to build your own protocol, as Reliable UDP isnâ€™t a standard protocol (see a
draft of RUDP in this link), and no official header is provided. You can use this sketch
for a header, but you can come up with your own protocol, as long as it works.
Where:
o ğ‘³ğ’†ğ’ğ’ˆğ’•ğ’‰ is the length of the data itself, without the RUDP header.
o ğ‘ªğ’‰ğ’†ğ’„ğ’Œğ’”ğ’–ğ’ is a 16bit number that validates the correctness of the data.
o ğ‘­ğ’ğ’‚ğ’ˆğ’” is a special byte where we classify the packet itself (SYN, ACK, etc.).
â€¢ In your PDF, you must explain how your implementation of RUDP works â€“ How does
it detect a timeout to do retransmissions, how does the handshake work, what is the
header overhead, etc.
â€¢ For this part, youâ€™ll write three files: ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¨ğ‘·ğ‘°. ğ’„, ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and
ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
Reliable UDP Header proposed sketch
Byte 0 Byte 1 Byte 2 Byte 3
Length (2 Bytes) Checksum (2 Bytes)
Flags (1 Byte)
Figure 1 - RUDP Protocol Architecture, Geeksforgeeks
 Communication Networks Course
Page | 5
Notes:
â€¢ The Sender will send a random generated file and the Receiver will receive it and
measure the time it took for his program to receive the file. The file size should be at
least 2MB.
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). But, as the
RUDP is based on UDP, itâ€™s not reliable. You must use some form of error checking
(like checksum) to ensure that the packet wasnâ€™t alerted during the transfer.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
â€¢ The RUDP needs support only 1 sender and 1 receiver, for simplicity purposes.
Usage:
â€¢ Receiver:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
â€¢ Sender:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port that both the Sender and the Receiver will use.
The ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„ file will contain all the implementations of the RUDP API functions (That is, to
prevent reusing the same chuck of code both in the Sender and the Receiver.).
The API should support at the bare minimum the following functions (you decide what
parameters to implement, and what are the names of the functions, as long as the API is
explained in the PDF):
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘œğ‘ğ‘˜ğ‘’ğ‘¡() â€“ Creating a RUDP socket and creating a handshake between two
peers.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘’ğ‘›ğ‘‘() â€“ Sending data to the peer. The function should wait for an
acknowledgment packet, and if it didnâ€™t receive any, retransmits the data.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘Ÿğ‘’ğ‘ğ‘£() â€“ Receive data from a peer.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ğ‘™ğ‘œğ‘ ğ‘’() â€“ Closes a connection between peers.
 Communication Networks Course
Page | 6
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a UDP socket between the Sender and the
Receiver.
3) Send the file via the RUDP protocol.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a UDP connection between the Receiver and
the Sender.
2) Get a connection from the sender, by the custom
RUDP protocol youâ€™ve built.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./RUDP_Receiver -p 1234
Starting Receiver...
Waiting for RUDP connection...
Connection request received, sending ACK.
Sender connected, beginning to receive file...
File transfer completed.
ACK sent.
Waiting for Sender response...
Sender sent exit message.
ACK sent.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 7
Part C â€“ Research â€“ 30 points
In this part, youâ€™ll conduct research about your implementations of part A and part B.
In the research itself, each one of the versions (TCP version and UDP version) will be run at
least 5 times (meaning that the file transfer will occur at least 5 times) by the following
conditions:
â€¢ For TCP, youâ€™ll run it in TCP Reno and TCP Cubic, alternating each time, for each
scenario, meaning that you run 5 times with TCP Reno in both Sender and Receiver,
and 5 times with TCP Cubic in both Sender and Receiver.
Bonus (5 points): Create a very large data set â€“ 5 times with TCP Reno in both Sender
and Receiver, 5 times with TCP Reno in Sender and TCP Cubic in Receiver, 5 times
with TCP Cubic in Sender and TCP Reno in Receiver, and 5 times with TCP Cubic in
both Sender and Receiver. This will give you a data set large enough, which allows
you to work with, compare with and to reach a definite conclusion.
â€¢ For RUDP, you will run it 5 times for each scenario.
â€¢ For both TCP and RUDP, you will run them on those scenarios of packet loss:
o 0% packet loss â€“ Control group, simulating perfect connection.
o 2% packet loss â€“ Simulating unstable connection that commonly occur.
o 5% packet loss â€“ Simulating bad connection.
o 10% packet loss â€“ Simulating extremely poor connection.
For each scenario, you must provide a filtered PCAP file and relevant screenshots that
explain each one of the steps in the process. (10 points)
After youâ€™ve gathered the data set for both TCP and Reliable UDP, answer the following
questions:
1) In TCP, which congestion control algorithm gave better results overall? TCP Reno or
TCP Cubic? Which one gave better results on high packet loss? Explain how you came
to this conclusion based on the data set youâ€™ve gathered. (5 points)
2) How did your implementation of Reliable UDP perform overall compared to regular
TCP? Which one is better for high packet loss? (5 points)
3) According to the data youâ€™ve gathered, in which scenarios and applications would we
prefer to use TCP and in which situations would we prefer to use reliable UDP?
Explain your answer. (5 points)
 Communication Networks Course
Page | 8
×¢× ×• ×¢×œ ×”×©××œ×•×ª ×”×‘××•×ª )5 × ×§×•×“×•×ª(:
â— ×‘"×¨×©×ª ×××™× ×”" ×”×›×•×•× ×” ×”×™× ×œ×¨×©×ª ×©×‘×” ××¢×˜ ×××•×“ ×—×‘×™×œ×•×ª ×”×•×œ×›×•×ª ×œ××™×‘×•×“. ×‘"×§×©×¨ ××¨×•×š" ×”×›×•×•× ×” ×”×™×
×œ×§×©×¨ TCP ×©×™×© ×‘×• ×”×¨×‘×” ×××•×“ ××™×“×¢ ×œ×©×œ×•×—. ××•×¦×¢ ×œ×”×’×“×™×œ ×‘ -TCP ××ª SSThreshold ×‘×ª×—×™×œ×ª ×”×§×©×¨.
×‘××™×–×” ××”××§×¨×™× ×”×‘××™× ×”×©×™× ×•×™ ×”×–×” ×¢×©×•×™ ×œ×”×•×¢×™×œ ×‘××™×“×” ×”××™×¨×‘×™×ª? × ××§.
.1 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
.2 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.3 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.4 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.5 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.6 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.7 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.8 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
â— A ×©×•×œ×— ×œ -B ×—×‘×™×œ×•×ª ××™×“×¢ ×‘×××¦×¢×•×ª ×§×©×¨ TCP. × ×ª×•×Ÿ ×›×™ ×”×§×©×¨ ××ª×—×™×œ ×¢× ×—×œ×•×Ÿ ×‘×’×•×“×œ 1MSS. ×”×§×©×¨
××¡×ª×™×™× ×‘×¤×¢× ×”×¨××©×•× ×” ×©×”×•× ××’×™×¢ ×œ -SSthresh. ×‘××”×œ×š ×”×§×©×¨ ×œ× ××•×‘×“×•×ª ×—×‘×™×œ×•×ª. × ×¡××Ÿ ×‘×§×™×¦×•×¨:
.SSthresh=S*MSS
× ×ª×•×Ÿ ×›×™ ×œ××•×¨×š ×›×œ ×”×§×©×¨ rwnd < MSS*S.
××”×™ ×”×ª×¤×•×§×” ×©×œ ×”×§×©×¨ ×-A ×œ-B( ×‘ -sec / Bytes )×‘×–××Ÿ ×”× "×œ? × ××§×™.
]S*MSS / [lg (S) * RTT*2 ×‘×¢×¨×š .1
]S*MSS / [S^0.5 * RTT*2 ×‘×¢×¨×š .2
S*MSS / RTT ×‘×¢×¨×š .3
S^2)*MSS / RTT( ×‘×¢×¨×š .4
â— ×©×ª×™ ×ª×—× ×•×ª ××ª×§×©×¨×•×ª ×‘××•×¤×Ÿ ××œ×—×•×˜×™ ×‘×©×™×˜×ª N Back Go.
× ×¡××Ÿ ×‘-X ××ª ×¡×¤×¨×ª ×”×‘×™×§×•×¨×ª ×©×œ ×”×ª.×–. ×©×œ×š. ×× ×©× ×™ ×©×•×ª×¤×™× ××’×™×©×™× ××ª ×”×ª×¨×’×™×œ ×™×—×“, X ×”×•× ×¡×¤×¨×ª
×”×‘×™×§×•×¨×ª ×‘×¢×œ×ª ×”×¢×¨×š ×”× ××•×š ×™×•×ª×¨ ××‘×™×Ÿ ×”×©×ª×™×™×.
×§×¦×‘ ×”×ª×§×©×•×¨×ª ×”×•× 8Gbps, ×•×’×•×“×œ ×›×œ ×—×‘×™×œ×” ×”×•× KByte*X. ×’×“×œ×™ ×”-headers ×•×” -Acks ×–× ×™×—×™×.
ï¿½ğ‘’ğ‘ ï¿½/ï¿½ï¿½ 8 , ×•×”××¨×—×§ ×‘×™×Ÿ ×”×ª×—× ×•×ª ×”×•× 1Km. ×§×¦×‘ ×”×”×ª×¤×©×˜×•×ª ×”×•× 10 â‹… 2
×–××Ÿ ×¢×™×‘×•×“ ×”× ×ª×•× ×™× ×‘×ª×—× ×•×ª ×–× ×™×—.
××£ ×—×‘×™×œ×” ×•××£ Ack ×œ× ×”×•×œ×›×™× ×œ××™×‘×•×“.
â— ××”×• X ×©×œ×š?
â— ××” ×¦×¨×™×š ×œ×”×™×•×ª ×’×•×“×œ ×—×œ×•×Ÿ ×”××©×œ×•×— ×›×“×™ ×œ×”×‘×˜×™×— ×ª×¤×•×§×” ××§×¡×™××œ×™×ª?
 Communication Networks Course
Page | 9
Bonus â€“ Improving the Reliable UDP â€“ 15 points
Note: This part isnâ€™t mandatory and is a bonus only!
In this part, youâ€™ll improve your RUDP implementation by adding the concepts of flow
control and congestion control from TCP. Youâ€™re free to choose which algorithms to
implement, as long as you explain in your PDF which algorithms youâ€™ve used. Youâ€™ll probably
need to make changes in the original design of the RUDP. Changes only need to be to the API
itself, ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„.
Points distribution:
â€¢ Flow control improvement â€“ 7 Points
â€¢ Congestion control improvement â€“ 8 points.
Guidance:
â€¢ For flow control, you must use one of the Sliding window techniques: stop-and-wait
ARQ, Go-Back-N or Selective repeat.
â€¢ List of known TCP congestion control algorithms, which you can use any one of them
for this bonus task, or makeup your own:
Figure 2 â€“ List of known TCP congestion control algorithms, Wikipedia
 Communication Networks Course
Page | 10
Appendix A â€“ Linux local packet loss tool
To simulate a packet loss in a local network, we'll use a Linux tool that's called Linux Traffic
Control (ğ‘¡ğ‘). This requires a full Linux installation, so working with WSL won't work.
If the tool isn't installed in your machine, you can install it by using the following commands:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’
If the installation didn't work, you can use the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’2
To create a packet loss scenario, type the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘ğ‘‘ğ‘‘ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
After creating a packet loss scenario, you can change the percentage by typing the following
command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘â„ğ‘ğ‘›ğ‘”ğ‘’ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
To remove the packet loss scenario, write the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘‘ğ‘’ğ‘™ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š
 Communication Networks Course
Page | 11
Appendix B â€“ ğ’ğ’‚ğ’(ğŸ) system calls
This appendixâ€™s purpose is to give you a better understanding of socket handling in C.
A recommended reference is Beejâ€™s Guide to Network Programming, by Brian â€œBeej
Jorgensenâ€ Hall, which gives a lot of information about sockets in C and functions.
Functions and documentation links:
â€¢ ğ’”ğ’ğ’„ğ’Œğ’†ğ’•(ğŸ) â€“ A Factory method system call that creates a socket with the given
parameters.
â€¢ ğ’ƒğ’Šğ’ğ’…(ğŸ) â€“ Whenever we create a new socket, we need to bind it to a specific port in
our machine, â€œto catch a portâ€. The port number is managed and used by the kernel
to link incoming packets to the corresponding application socket. The port numbers
are usually fixed. The ğ‘ğ‘‘ğ‘‘ğ‘Ÿ parameter must match the current socket that is used.
â€¢ ğ’ğ’Šğ’”ğ’•ğ’†ğ’(ğŸ) â€“ The ğ‘™ğ‘–ğ‘ ğ‘¡ğ‘’ğ‘›(2) system call doesn't do anything in the mean of
communication but only memory allocation (malloc) for stream sockets only. If we
won't allocate memory, any incoming connection will fail.
â€¢ ğ’„ğ’ğ’ğ’ğ’†ğ’„ğ’•(ğŸ) â€“ The ğ‘ğ‘œğ‘›ğ‘›ğ‘’ğ‘ğ‘¡(2) system call starts the link between a client and a
specific IP address and port number. The connection would complete when the
other side will call the ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call.
â€¢ ğ’‚ğ’„ğ’„ğ’†ğ’‘ğ’•(ğŸ) â€“ The ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call accepts the incoming stream connection
request from the other side, by the listening socket. This system call completes the
three-way handshake of stream socket (like TCP) and opens a new socket that has a
direct communication channel only with the other party in the handshake.
â€¢ ğ’”ğ’†ğ’ğ’…(ğŸ) and ğ’”ğ’†ğ’ğ’…ğ’•ğ’(ğŸ) â€“ The ğ‘ ğ‘’ğ‘›ğ‘‘(2) and ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system calls are an analogy
for the ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’(2) system call, specifcly for sockets, with flags set to 0. Those system
calls return the number of bytes that were sent through the socket itself, as the
number of bytes can vary. The ğ‘ ğ‘’ğ‘›ğ‘‘(2)system call designed for stream sockets (like
TCP), while the ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system call designed for datagram connection-less
sockets (like UDP). When the ğ‘ ğ‘’ğ‘›ğ‘‘(2) system call returns 0, it means that the other
party closed the connection.
â€¢ ğ’“ğ’†ğ’„ğ’—(ğŸ) and ğ’“ğ’†ğ’„ğ’—ğ’‡ğ’“ğ’ğ’(ğŸ) â€“ The ğ‘Ÿğ‘’ğ‘ğ‘£(2) and ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system calls are an
analogy for the ğ‘Ÿğ‘’ğ‘ğ‘‘(2) system call, specifically for sockets, with flags set to 0.
Those system calls return the number of bytes that were received through the socket
itself, as the number of bytes can vary. The ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call designed for stream
sockets (like TCP), while the ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system call designed for datagram
connection-less sockets (like UDP). When the ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call returns 0, it means
that the other party closed the connection.
â€¢ ğ’„ğ’ğ’ğ’”ğ’†(ğŸ) and ğ’”ğ’‰ğ’–ğ’•ğ’…ğ’ğ’˜ğ’(ğŸ) â€“ The ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) and ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2) system calls close
the socket. While ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) system call closes the whole socket, the ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2)
system call partially closes the socket for read/write.
 Communication Networks Course
Page | 12
Appendix C â€“ Random data generator
The data that you are going to send in this assignment is randomly generated. You can use
your own file with appropriate size or use the following function (or a function of your own)
to generate the data:
/*
* @brief A random data generator function based on srand() and rand().
* @param size The size of the data to generate (up to 2^32 bytes).
* @return A pointer to the buffer.
*/
char *util_generate_random_data(unsigned int size) {
 char *buffer = NULL;
 // Argument check.
 if (size == 0)
 return NULL;
 buffer = (char *)calloc(size, sizeof(char));
 // Error checking.
 if (buffer == NULL)
 return NULL;
 // Randomize the seed of the random number generator.
 srand(time(NULL));
 for (unsigned int i = 0; i < size; i++)
 *(buffer + i) = ((unsigned int)rand() % 256);
 return buffer;
}
 Communication Networks Course
Page | 13
Appendix D â€“ Checksum function
A checksum is a small-sized block of data derived from another block of digital data for the
purpose of detecting errors that may have been introduced during its transmission or
storage. By themselves, checksums are often used to verify data integrity but are not relied
upon to verify data authenticity.
Below is a simple yet efficient implementation of the checksum function, you can use it for
the assignment, but you can implement your own checksum function.
/*
* @brief A checksum function that returns 16 bit checksum for data.
* @param data The data to do the checksum for.
* @param bytes The length of the data in bytes.
* @return The checksum itself as 16 bit unsigned number.
* @note This function is taken from RFC1071, can be found here:
* @note https://tools.ietf.org/html/rfc1071
* @note It is the simplest way to calculate a checksum and is not very strong.
* However, it is good enough for this assignment.
* @note You are free to use any other checksum function as well.
* You can also use this function as such without any change.
*/
unsigned short int calculate_checksum(void *data, unsigned int bytes) {
 unsigned short int *data_pointer = (unsigned short int *)data;
 unsigned int total_sum = 0;
 // Main summing loop
 while (bytes > 1) {
 total_sum += *data_pointer++;
 bytes -= 2;
 }
 // Add left-over byte, if any
 if (bytes > 0)
 total_sum += *((unsigned char *)data_pointer);
 // Fold 32-bit sum to 16 bits
 while (total_sum >> 16)
 total_sum = (total_sum & 0xFFFF) + (total_sum >> 16);
 return (~((unsigned short int)total_sum));
} Communication Networks Course
Page | 1
Assignment 3 â€“ Transport Layer
Assignment Notes and Instructions
This assignment is to be done in pairs only. You must upload all the necessary files in a ZIP
file named after both of the studentâ€™s ID. For example: ğŸğŸğŸ‘ğŸ’ğŸ“ğŸ”ğŸ•ğŸ–ğŸ—_ğŸ—ğŸ–ğŸ•ğŸ”ğŸ“ğŸ’ğŸ‘ğŸğŸ. ğ’›ğ’Šğ’‘.
1) The assignment must be submitted by the date specified in the submission box.
2) All the assignment files (Code, Wireshark pcap files, PDF) must be submitted in a ZIP file. The
PDF must contain all the necessary screenshots with a description for each one of them.
3) The assignment must be done in pairs only. In exceptional cases, you should send an email to
the course coordinator.
4) You can use any reference material available through the course Moodle website or any
material passed during the exercises.
5) You can use any reference from the web, but copying codes from websites is forbidden; this
includes codes from other GitHub repositories. A student who gets caught in the act will
automatically fail this assignment (score 0). Any website youâ€™ve used to solve the
assignment, every website you used to solve the assignment must be noted in the PDF.
6) No delays in submission without special permission. Lateness without approval will result in
failure of the assignment (score 0).
7) All submissions will be submitted via the course's Moodle website. Email submissions will not
be accepted, resulting in a failure in the assignment.
8) The order and design of the code must be carefully considered. Make sure that the program
output is as clear as possible, comments in the code, and meaningful variable names. You
must also submit a makefile that compiles all the programs.
9) The assignment code must be written in C only.
10) The assignment is personal for each pair, and you should not accept help from other people,
whether outside the university or inside it. You can contact the course staff during reception
hours for help or raise a question in the course forum. Do not transfer code sections
between students, upload solutions or parts of solutions to websites on the Internet or in
various communication groups.
11) Students who copy a solution will receive a 0 in all assignments in the course and a report will
be made to the institutional disciplinary committee.
12) All code files of the assignment are required to both compile and run properly on the Ubuntu
22.04 LTS operating system. This is the operating system where the submissions will be
tested. You mustnâ€™t code it in Windows, as it uses different API for sockets. WSL wonâ€™t work,
as the task needs a tool that works only in a fully Linux environment.
Good Luck!
 Communication Networks Course
Page | 2
Part A â€“ Transmission Control Protocol (TCP) â€“ 30 points
In this part, youâ€™ll write two program files: ğ‘»ğ‘ªğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and ğ‘»ğ‘ªğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
The Sender will send a randomly generated file and the Receiver will receive it and measure
the time it took for his program to receive the file. The file size should be at least 2MB.
When running the Sender and Receiver, they both should support two standard congestion
control algorithms: TCP Reno and TCP Cubic.
Notes:
â€¢ The main goal of this part is to get familiar with the TCP concept of sending
messages between two endpoints.
â€¢ For approaching this part of the assignment, please be sure that you are familiar
with the congestion control algorithms and how to change them using the correct
method in C (see Appendix B for more information).
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). You've
learned that TCP is reliable by design, so you can assume that all the data have been
passed correctly, and thus, no need to recheck.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
Usage:
â€¢ Receiver:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
â€¢ Sender:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port of the Receiver.
â€¢ ğ‘¨ğ‘³ğ‘®ğ‘¶ â€“ The TCP congestion control algorithm that will be used by the party
member (either ğ’“ğ’†ğ’ğ’ for TCP Reno or ğ’„ğ’–ğ’ƒğ’Šğ’„ for TCP Cubic).
 Communication Networks Course
Page | 3
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a TCP socket between the Sender and the
Receiver.
3) Send the file.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a TCP connection between the Receiver and
the Sender.
2) Get a connection from the sender.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./TCP_Receiver -p 1234 -algo reno
Starting Receiver...
Waiting for TCP connection...
Sender connected, beginning to receive file...
File transfer completed.
Waiting for Sender response...
Sender sent exit message.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 4
Part B â€“ Reliable User Datagram Protocol (Reliable UDP or RUDP) â€“ 40 points
Youâ€™ve learned that while TCP is reliable, it lacks speed and has an overhead data of 20 bytes,
compering to UDP that needs only 8 bytes of overhead data.
Reliable UDP or RUDP, is a protocol that uses the UDP protocol for a faster transmission of
data, while adding a reliability layer to it, but without adding too much overhead data like
TCP.
A simple sketch for a RUDP connection would look something like this:
Your task in this part is to implement a Reliable protocol using UDP only. For simplicity, your
implementation should only support a handshake, closing scheme, error checking,
acknowledgment of received packets, and retransmission of lost packets.
Guidance:
â€¢ You can use ğ‘ ğ‘’ğ‘¡ğ‘ ğ‘œğ‘ğ‘˜ğ‘œğ‘ğ‘¡(2) for detecting a timeout.
â€¢ You need to build your own protocol, as Reliable UDP isnâ€™t a standard protocol (see a
draft of RUDP in this link), and no official header is provided. You can use this sketch
for a header, but you can come up with your own protocol, as long as it works.
Where:
o ğ‘³ğ’†ğ’ğ’ˆğ’•ğ’‰ is the length of the data itself, without the RUDP header.
o ğ‘ªğ’‰ğ’†ğ’„ğ’Œğ’”ğ’–ğ’ is a 16bit number that validates the correctness of the data.
o ğ‘­ğ’ğ’‚ğ’ˆğ’” is a special byte where we classify the packet itself (SYN, ACK, etc.).
â€¢ In your PDF, you must explain how your implementation of RUDP works â€“ How does
it detect a timeout to do retransmissions, how does the handshake work, what is the
header overhead, etc.
â€¢ For this part, youâ€™ll write three files: ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¨ğ‘·ğ‘°. ğ’„, ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and
ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
Reliable UDP Header proposed sketch
Byte 0 Byte 1 Byte 2 Byte 3
Length (2 Bytes) Checksum (2 Bytes)
Flags (1 Byte)
Figure 1 - RUDP Protocol Architecture, Geeksforgeeks
 Communication Networks Course
Page | 5
Notes:
â€¢ The Sender will send a random generated file and the Receiver will receive it and
measure the time it took for his program to receive the file. The file size should be at
least 2MB.
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). But, as the
RUDP is based on UDP, itâ€™s not reliable. You must use some form of error checking
(like checksum) to ensure that the packet wasnâ€™t alerted during the transfer.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
â€¢ The RUDP needs support only 1 sender and 1 receiver, for simplicity purposes.
Usage:
â€¢ Receiver:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
â€¢ Sender:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port that both the Sender and the Receiver will use.
The ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„ file will contain all the implementations of the RUDP API functions (That is, to
prevent reusing the same chuck of code both in the Sender and the Receiver.).
The API should support at the bare minimum the following functions (you decide what
parameters to implement, and what are the names of the functions, as long as the API is
explained in the PDF):
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘œğ‘ğ‘˜ğ‘’ğ‘¡() â€“ Creating a RUDP socket and creating a handshake between two
peers.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘’ğ‘›ğ‘‘() â€“ Sending data to the peer. The function should wait for an
acknowledgment packet, and if it didnâ€™t receive any, retransmits the data.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘Ÿğ‘’ğ‘ğ‘£() â€“ Receive data from a peer.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ğ‘™ğ‘œğ‘ ğ‘’() â€“ Closes a connection between peers.
 Communication Networks Course
Page | 6
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a UDP socket between the Sender and the
Receiver.
3) Send the file via the RUDP protocol.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a UDP connection between the Receiver and
the Sender.
2) Get a connection from the sender, by the custom
RUDP protocol youâ€™ve built.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./RUDP_Receiver -p 1234
Starting Receiver...
Waiting for RUDP connection...
Connection request received, sending ACK.
Sender connected, beginning to receive file...
File transfer completed.
ACK sent.
Waiting for Sender response...
Sender sent exit message.
ACK sent.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 7
Part C â€“ Research â€“ 30 points
In this part, youâ€™ll conduct research about your implementations of part A and part B.
In the research itself, each one of the versions (TCP version and UDP version) will be run at
least 5 times (meaning that the file transfer will occur at least 5 times) by the following
conditions:
â€¢ For TCP, youâ€™ll run it in TCP Reno and TCP Cubic, alternating each time, for each
scenario, meaning that you run 5 times with TCP Reno in both Sender and Receiver,
and 5 times with TCP Cubic in both Sender and Receiver.
Bonus (5 points): Create a very large data set â€“ 5 times with TCP Reno in both Sender
and Receiver, 5 times with TCP Reno in Sender and TCP Cubic in Receiver, 5 times
with TCP Cubic in Sender and TCP Reno in Receiver, and 5 times with TCP Cubic in
both Sender and Receiver. This will give you a data set large enough, which allows
you to work with, compare with and to reach a definite conclusion.
â€¢ For RUDP, you will run it 5 times for each scenario.
â€¢ For both TCP and RUDP, you will run them on those scenarios of packet loss:
o 0% packet loss â€“ Control group, simulating perfect connection.
o 2% packet loss â€“ Simulating unstable connection that commonly occur.
o 5% packet loss â€“ Simulating bad connection.
o 10% packet loss â€“ Simulating extremely poor connection.
For each scenario, you must provide a filtered PCAP file and relevant screenshots that
explain each one of the steps in the process. (10 points)
After youâ€™ve gathered the data set for both TCP and Reliable UDP, answer the following
questions:
1) In TCP, which congestion control algorithm gave better results overall? TCP Reno or
TCP Cubic? Which one gave better results on high packet loss? Explain how you came
to this conclusion based on the data set youâ€™ve gathered. (5 points)
2) How did your implementation of Reliable UDP perform overall compared to regular
TCP? Which one is better for high packet loss? (5 points)
3) According to the data youâ€™ve gathered, in which scenarios and applications would we
prefer to use TCP and in which situations would we prefer to use reliable UDP?
Explain your answer. (5 points)
 Communication Networks Course
Page | 8
×¢× ×• ×¢×œ ×”×©××œ×•×ª ×”×‘××•×ª )5 × ×§×•×“×•×ª(:
â— ×‘"×¨×©×ª ×××™× ×”" ×”×›×•×•× ×” ×”×™× ×œ×¨×©×ª ×©×‘×” ××¢×˜ ×××•×“ ×—×‘×™×œ×•×ª ×”×•×œ×›×•×ª ×œ××™×‘×•×“. ×‘"×§×©×¨ ××¨×•×š" ×”×›×•×•× ×” ×”×™×
×œ×§×©×¨ TCP ×©×™×© ×‘×• ×”×¨×‘×” ×××•×“ ××™×“×¢ ×œ×©×œ×•×—. ××•×¦×¢ ×œ×”×’×“×™×œ ×‘ -TCP ××ª SSThreshold ×‘×ª×—×™×œ×ª ×”×§×©×¨.
×‘××™×–×” ××”××§×¨×™× ×”×‘××™× ×”×©×™× ×•×™ ×”×–×” ×¢×©×•×™ ×œ×”×•×¢×™×œ ×‘××™×“×” ×”××™×¨×‘×™×ª? × ××§.
.1 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
.2 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.3 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.4 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.5 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.6 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.7 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.8 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
â— A ×©×•×œ×— ×œ -B ×—×‘×™×œ×•×ª ××™×“×¢ ×‘×××¦×¢×•×ª ×§×©×¨ TCP. × ×ª×•×Ÿ ×›×™ ×”×§×©×¨ ××ª×—×™×œ ×¢× ×—×œ×•×Ÿ ×‘×’×•×“×œ 1MSS. ×”×§×©×¨
××¡×ª×™×™× ×‘×¤×¢× ×”×¨××©×•× ×” ×©×”×•× ××’×™×¢ ×œ -SSthresh. ×‘××”×œ×š ×”×§×©×¨ ×œ× ××•×‘×“×•×ª ×—×‘×™×œ×•×ª. × ×¡××Ÿ ×‘×§×™×¦×•×¨:
.SSthresh=S*MSS
× ×ª×•×Ÿ ×›×™ ×œ××•×¨×š ×›×œ ×”×§×©×¨ rwnd < MSS*S.
××”×™ ×”×ª×¤×•×§×” ×©×œ ×”×§×©×¨ ×-A ×œ-B( ×‘ -sec / Bytes )×‘×–××Ÿ ×”× "×œ? × ××§×™.
]S*MSS / [lg (S) * RTT*2 ×‘×¢×¨×š .1
]S*MSS / [S^0.5 * RTT*2 ×‘×¢×¨×š .2
S*MSS / RTT ×‘×¢×¨×š .3
S^2)*MSS / RTT( ×‘×¢×¨×š .4
â— ×©×ª×™ ×ª×—× ×•×ª ××ª×§×©×¨×•×ª ×‘××•×¤×Ÿ ××œ×—×•×˜×™ ×‘×©×™×˜×ª N Back Go.
× ×¡××Ÿ ×‘-X ××ª ×¡×¤×¨×ª ×”×‘×™×§×•×¨×ª ×©×œ ×”×ª.×–. ×©×œ×š. ×× ×©× ×™ ×©×•×ª×¤×™× ××’×™×©×™× ××ª ×”×ª×¨×’×™×œ ×™×—×“, X ×”×•× ×¡×¤×¨×ª
×”×‘×™×§×•×¨×ª ×‘×¢×œ×ª ×”×¢×¨×š ×”× ××•×š ×™×•×ª×¨ ××‘×™×Ÿ ×”×©×ª×™×™×.
×§×¦×‘ ×”×ª×§×©×•×¨×ª ×”×•× 8Gbps, ×•×’×•×“×œ ×›×œ ×—×‘×™×œ×” ×”×•× KByte*X. ×’×“×œ×™ ×”-headers ×•×” -Acks ×–× ×™×—×™×.
ï¿½ğ‘’ğ‘ ï¿½/ï¿½ï¿½ 8 , ×•×”××¨×—×§ ×‘×™×Ÿ ×”×ª×—× ×•×ª ×”×•× 1Km. ×§×¦×‘ ×”×”×ª×¤×©×˜×•×ª ×”×•× 10 â‹… 2
×–××Ÿ ×¢×™×‘×•×“ ×”× ×ª×•× ×™× ×‘×ª×—× ×•×ª ×–× ×™×—.
××£ ×—×‘×™×œ×” ×•××£ Ack ×œ× ×”×•×œ×›×™× ×œ××™×‘×•×“.
â— ××”×• X ×©×œ×š?
â— ××” ×¦×¨×™×š ×œ×”×™×•×ª ×’×•×“×œ ×—×œ×•×Ÿ ×”××©×œ×•×— ×›×“×™ ×œ×”×‘×˜×™×— ×ª×¤×•×§×” ××§×¡×™××œ×™×ª?
 Communication Networks Course
Page | 9
Bonus â€“ Improving the Reliable UDP â€“ 15 points
Note: This part isnâ€™t mandatory and is a bonus only!
In this part, youâ€™ll improve your RUDP implementation by adding the concepts of flow
control and congestion control from TCP. Youâ€™re free to choose which algorithms to
implement, as long as you explain in your PDF which algorithms youâ€™ve used. Youâ€™ll probably
need to make changes in the original design of the RUDP. Changes only need to be to the API
itself, ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„.
Points distribution:
â€¢ Flow control improvement â€“ 7 Points
â€¢ Congestion control improvement â€“ 8 points.
Guidance:
â€¢ For flow control, you must use one of the Sliding window techniques: stop-and-wait
ARQ, Go-Back-N or Selective repeat.
â€¢ List of known TCP congestion control algorithms, which you can use any one of them
for this bonus task, or makeup your own:
Figure 2 â€“ List of known TCP congestion control algorithms, Wikipedia
 Communication Networks Course
Page | 10
Appendix A â€“ Linux local packet loss tool
To simulate a packet loss in a local network, we'll use a Linux tool that's called Linux Traffic
Control (ğ‘¡ğ‘). This requires a full Linux installation, so working with WSL won't work.
If the tool isn't installed in your machine, you can install it by using the following commands:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’
If the installation didn't work, you can use the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’2
To create a packet loss scenario, type the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘ğ‘‘ğ‘‘ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
After creating a packet loss scenario, you can change the percentage by typing the following
command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘â„ğ‘ğ‘›ğ‘”ğ‘’ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
To remove the packet loss scenario, write the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘‘ğ‘’ğ‘™ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š
 Communication Networks Course
Page | 11
Appendix B â€“ ğ’ğ’‚ğ’(ğŸ) system calls
This appendixâ€™s purpose is to give you a better understanding of socket handling in C.
A recommended reference is Beejâ€™s Guide to Network Programming, by Brian â€œBeej
Jorgensenâ€ Hall, which gives a lot of information about sockets in C and functions.
Functions and documentation links:
â€¢ ğ’”ğ’ğ’„ğ’Œğ’†ğ’•(ğŸ) â€“ A Factory method system call that creates a socket with the given
parameters.
â€¢ ğ’ƒğ’Šğ’ğ’…(ğŸ) â€“ Whenever we create a new socket, we need to bind it to a specific port in
our machine, â€œto catch a portâ€. The port number is managed and used by the kernel
to link incoming packets to the corresponding application socket. The port numbers
are usually fixed. The ğ‘ğ‘‘ğ‘‘ğ‘Ÿ parameter must match the current socket that is used.
â€¢ ğ’ğ’Šğ’”ğ’•ğ’†ğ’(ğŸ) â€“ The ğ‘™ğ‘–ğ‘ ğ‘¡ğ‘’ğ‘›(2) system call doesn't do anything in the mean of
communication but only memory allocation (malloc) for stream sockets only. If we
won't allocate memory, any incoming connection will fail.
â€¢ ğ’„ğ’ğ’ğ’ğ’†ğ’„ğ’•(ğŸ) â€“ The ğ‘ğ‘œğ‘›ğ‘›ğ‘’ğ‘ğ‘¡(2) system call starts the link between a client and a
specific IP address and port number. The connection would complete when the
other side will call the ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call.
â€¢ ğ’‚ğ’„ğ’„ğ’†ğ’‘ğ’•(ğŸ) â€“ The ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call accepts the incoming stream connection
request from the other side, by the listening socket. This system call completes the
three-way handshake of stream socket (like TCP) and opens a new socket that has a
direct communication channel only with the other party in the handshake.
â€¢ ğ’”ğ’†ğ’ğ’…(ğŸ) and ğ’”ğ’†ğ’ğ’…ğ’•ğ’(ğŸ) â€“ The ğ‘ ğ‘’ğ‘›ğ‘‘(2) and ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system calls are an analogy
for the ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’(2) system call, specifcly for sockets, with flags set to 0. Those system
calls return the number of bytes that were sent through the socket itself, as the
number of bytes can vary. The ğ‘ ğ‘’ğ‘›ğ‘‘(2)system call designed for stream sockets (like
TCP), while the ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system call designed for datagram connection-less
sockets (like UDP). When the ğ‘ ğ‘’ğ‘›ğ‘‘(2) system call returns 0, it means that the other
party closed the connection.
â€¢ ğ’“ğ’†ğ’„ğ’—(ğŸ) and ğ’“ğ’†ğ’„ğ’—ğ’‡ğ’“ğ’ğ’(ğŸ) â€“ The ğ‘Ÿğ‘’ğ‘ğ‘£(2) and ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system calls are an
analogy for the ğ‘Ÿğ‘’ğ‘ğ‘‘(2) system call, specifically for sockets, with flags set to 0.
Those system calls return the number of bytes that were received through the socket
itself, as the number of bytes can vary. The ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call designed for stream
sockets (like TCP), while the ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system call designed for datagram
connection-less sockets (like UDP). When the ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call returns 0, it means
that the other party closed the connection.
â€¢ ğ’„ğ’ğ’ğ’”ğ’†(ğŸ) and ğ’”ğ’‰ğ’–ğ’•ğ’…ğ’ğ’˜ğ’(ğŸ) â€“ The ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) and ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2) system calls close
the socket. While ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) system call closes the whole socket, the ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2)
system call partially closes the socket for read/write.
 Communication Networks Course
Page | 12
Appendix C â€“ Random data generator
The data that you are going to send in this assignment is randomly generated. You can use
your own file with appropriate size or use the following function (or a function of your own)
to generate the data:
/*
* @brief A random data generator function based on srand() and rand().
* @param size The size of the data to generate (up to 2^32 bytes).
* @return A pointer to the buffer.
*/
char *util_generate_random_data(unsigned int size) {
 char *buffer = NULL;
 // Argument check.
 if (size == 0)
 return NULL;
 buffer = (char *)calloc(size, sizeof(char));
 // Error checking.
 if (buffer == NULL)
 return NULL;
 // Randomize the seed of the random number generator.
 srand(time(NULL));
 for (unsigned int i = 0; i < size; i++)
 *(buffer + i) = ((unsigned int)rand() % 256);
 return buffer;
}
 Communication Networks Course
Page | 13
Appendix D â€“ Checksum function
A checksum is a small-sized block of data derived from another block of digital data for the
purpose of detecting errors that may have been introduced during its transmission or
storage. By themselves, checksums are often used to verify data integrity but are not relied
upon to verify data authenticity.
Below is a simple yet efficient implementation of the checksum function, you can use it for
the assignment, but you can implement your own checksum function.
/*
* @brief A checksum function that returns 16 bit checksum for data.
* @param data The data to do the checksum for.
* @param bytes The length of the data in bytes.
* @return The checksum itself as 16 bit unsigned number.
* @note This function is taken from RFC1071, can be found here:
* @note https://tools.ietf.org/html/rfc1071
* @note It is the simplest way to calculate a checksum and is not very strong.
* However, it is good enough for this assignment.
* @note You are free to use any other checksum function as well.
* You can also use this function as such without any change.
*/
unsigned short int calculate_checksum(void *data, unsigned int bytes) {
 unsigned short int *data_pointer = (unsigned short int *)data;
 unsigned int total_sum = 0;
 // Main summing loop
 while (bytes > 1) {
 total_sum += *data_pointer++;
 bytes -= 2;
 }
 // Add left-over byte, if any
 if (bytes > 0)
 total_sum += *((unsigned char *)data_pointer);
 // Fold 32-bit sum to 16 bits
 while (total_sum >> 16)
 total_sum = (total_sum & 0xFFFF) + (total_sum >> 16);
 return (~((unsigned short int)total_sum));
} Communication Networks Course
Page | 1
Assignment 3 â€“ Transport Layer
Assignment Notes and Instructions
This assignment is to be done in pairs only. You must upload all the necessary files in a ZIP
file named after both of the studentâ€™s ID. For example: ğŸğŸğŸ‘ğŸ’ğŸ“ğŸ”ğŸ•ğŸ–ğŸ—_ğŸ—ğŸ–ğŸ•ğŸ”ğŸ“ğŸ’ğŸ‘ğŸğŸ. ğ’›ğ’Šğ’‘.
1) The assignment must be submitted by the date specified in the submission box.
2) All the assignment files (Code, Wireshark pcap files, PDF) must be submitted in a ZIP file. The
PDF must contain all the necessary screenshots with a description for each one of them.
3) The assignment must be done in pairs only. In exceptional cases, you should send an email to
the course coordinator.
4) You can use any reference material available through the course Moodle website or any
material passed during the exercises.
5) You can use any reference from the web, but copying codes from websites is forbidden; this
includes codes from other GitHub repositories. A student who gets caught in the act will
automatically fail this assignment (score 0). Any website youâ€™ve used to solve the
assignment, every website you used to solve the assignment must be noted in the PDF.
6) No delays in submission without special permission. Lateness without approval will result in
failure of the assignment (score 0).
7) All submissions will be submitted via the course's Moodle website. Email submissions will not
be accepted, resulting in a failure in the assignment.
8) The order and design of the code must be carefully considered. Make sure that the program
output is as clear as possible, comments in the code, and meaningful variable names. You
must also submit a makefile that compiles all the programs.
9) The assignment code must be written in C only.
10) The assignment is personal for each pair, and you should not accept help from other people,
whether outside the university or inside it. You can contact the course staff during reception
hours for help or raise a question in the course forum. Do not transfer code sections
between students, upload solutions or parts of solutions to websites on the Internet or in
various communication groups.
11) Students who copy a solution will receive a 0 in all assignments in the course and a report will
be made to the institutional disciplinary committee.
12) All code files of the assignment are required to both compile and run properly on the Ubuntu
22.04 LTS operating system. This is the operating system where the submissions will be
tested. You mustnâ€™t code it in Windows, as it uses different API for sockets. WSL wonâ€™t work,
as the task needs a tool that works only in a fully Linux environment.
Good Luck!
 Communication Networks Course
Page | 2
Part A â€“ Transmission Control Protocol (TCP) â€“ 30 points
In this part, youâ€™ll write two program files: ğ‘»ğ‘ªğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and ğ‘»ğ‘ªğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
The Sender will send a randomly generated file and the Receiver will receive it and measure
the time it took for his program to receive the file. The file size should be at least 2MB.
When running the Sender and Receiver, they both should support two standard congestion
control algorithms: TCP Reno and TCP Cubic.
Notes:
â€¢ The main goal of this part is to get familiar with the TCP concept of sending
messages between two endpoints.
â€¢ For approaching this part of the assignment, please be sure that you are familiar
with the congestion control algorithms and how to change them using the correct
method in C (see Appendix B for more information).
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). You've
learned that TCP is reliable by design, so you can assume that all the data have been
passed correctly, and thus, no need to recheck.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
Usage:
â€¢ Receiver:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
â€¢ Sender:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port of the Receiver.
â€¢ ğ‘¨ğ‘³ğ‘®ğ‘¶ â€“ The TCP congestion control algorithm that will be used by the party
member (either ğ’“ğ’†ğ’ğ’ for TCP Reno or ğ’„ğ’–ğ’ƒğ’Šğ’„ for TCP Cubic).
 Communication Networks Course
Page | 3
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a TCP socket between the Sender and the
Receiver.
3) Send the file.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a TCP connection between the Receiver and
the Sender.
2) Get a connection from the sender.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./TCP_Receiver -p 1234 -algo reno
Starting Receiver...
Waiting for TCP connection...
Sender connected, beginning to receive file...
File transfer completed.
Waiting for Sender response...
Sender sent exit message.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 4
Part B â€“ Reliable User Datagram Protocol (Reliable UDP or RUDP) â€“ 40 points
Youâ€™ve learned that while TCP is reliable, it lacks speed and has an overhead data of 20 bytes,
compering to UDP that needs only 8 bytes of overhead data.
Reliable UDP or RUDP, is a protocol that uses the UDP protocol for a faster transmission of
data, while adding a reliability layer to it, but without adding too much overhead data like
TCP.
A simple sketch for a RUDP connection would look something like this:
Your task in this part is to implement a Reliable protocol using UDP only. For simplicity, your
implementation should only support a handshake, closing scheme, error checking,
acknowledgment of received packets, and retransmission of lost packets.
Guidance:
â€¢ You can use ğ‘ ğ‘’ğ‘¡ğ‘ ğ‘œğ‘ğ‘˜ğ‘œğ‘ğ‘¡(2) for detecting a timeout.
â€¢ You need to build your own protocol, as Reliable UDP isnâ€™t a standard protocol (see a
draft of RUDP in this link), and no official header is provided. You can use this sketch
for a header, but you can come up with your own protocol, as long as it works.
Where:
o ğ‘³ğ’†ğ’ğ’ˆğ’•ğ’‰ is the length of the data itself, without the RUDP header.
o ğ‘ªğ’‰ğ’†ğ’„ğ’Œğ’”ğ’–ğ’ is a 16bit number that validates the correctness of the data.
o ğ‘­ğ’ğ’‚ğ’ˆğ’” is a special byte where we classify the packet itself (SYN, ACK, etc.).
â€¢ In your PDF, you must explain how your implementation of RUDP works â€“ How does
it detect a timeout to do retransmissions, how does the handshake work, what is the
header overhead, etc.
â€¢ For this part, youâ€™ll write three files: ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¨ğ‘·ğ‘°. ğ’„, ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and
ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
Reliable UDP Header proposed sketch
Byte 0 Byte 1 Byte 2 Byte 3
Length (2 Bytes) Checksum (2 Bytes)
Flags (1 Byte)
Figure 1 - RUDP Protocol Architecture, Geeksforgeeks
 Communication Networks Course
Page | 5
Notes:
â€¢ The Sender will send a random generated file and the Receiver will receive it and
measure the time it took for his program to receive the file. The file size should be at
least 2MB.
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). But, as the
RUDP is based on UDP, itâ€™s not reliable. You must use some form of error checking
(like checksum) to ensure that the packet wasnâ€™t alerted during the transfer.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
â€¢ The RUDP needs support only 1 sender and 1 receiver, for simplicity purposes.
Usage:
â€¢ Receiver:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
â€¢ Sender:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port that both the Sender and the Receiver will use.
The ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„ file will contain all the implementations of the RUDP API functions (That is, to
prevent reusing the same chuck of code both in the Sender and the Receiver.).
The API should support at the bare minimum the following functions (you decide what
parameters to implement, and what are the names of the functions, as long as the API is
explained in the PDF):
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘œğ‘ğ‘˜ğ‘’ğ‘¡() â€“ Creating a RUDP socket and creating a handshake between two
peers.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘’ğ‘›ğ‘‘() â€“ Sending data to the peer. The function should wait for an
acknowledgment packet, and if it didnâ€™t receive any, retransmits the data.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘Ÿğ‘’ğ‘ğ‘£() â€“ Receive data from a peer.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ğ‘™ğ‘œğ‘ ğ‘’() â€“ Closes a connection between peers.
 Communication Networks Course
Page | 6
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a UDP socket between the Sender and the
Receiver.
3) Send the file via the RUDP protocol.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a UDP connection between the Receiver and
the Sender.
2) Get a connection from the sender, by the custom
RUDP protocol youâ€™ve built.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./RUDP_Receiver -p 1234
Starting Receiver...
Waiting for RUDP connection...
Connection request received, sending ACK.
Sender connected, beginning to receive file...
File transfer completed.
ACK sent.
Waiting for Sender response...
Sender sent exit message.
ACK sent.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 7
Part C â€“ Research â€“ 30 points
In this part, youâ€™ll conduct research about your implementations of part A and part B.
In the research itself, each one of the versions (TCP version and UDP version) will be run at
least 5 times (meaning that the file transfer will occur at least 5 times) by the following
conditions:
â€¢ For TCP, youâ€™ll run it in TCP Reno and TCP Cubic, alternating each time, for each
scenario, meaning that you run 5 times with TCP Reno in both Sender and Receiver,
and 5 times with TCP Cubic in both Sender and Receiver.
Bonus (5 points): Create a very large data set â€“ 5 times with TCP Reno in both Sender
and Receiver, 5 times with TCP Reno in Sender and TCP Cubic in Receiver, 5 times
with TCP Cubic in Sender and TCP Reno in Receiver, and 5 times with TCP Cubic in
both Sender and Receiver. This will give you a data set large enough, which allows
you to work with, compare with and to reach a definite conclusion.
â€¢ For RUDP, you will run it 5 times for each scenario.
â€¢ For both TCP and RUDP, you will run them on those scenarios of packet loss:
o 0% packet loss â€“ Control group, simulating perfect connection.
o 2% packet loss â€“ Simulating unstable connection that commonly occur.
o 5% packet loss â€“ Simulating bad connection.
o 10% packet loss â€“ Simulating extremely poor connection.
For each scenario, you must provide a filtered PCAP file and relevant screenshots that
explain each one of the steps in the process. (10 points)
After youâ€™ve gathered the data set for both TCP and Reliable UDP, answer the following
questions:
1) In TCP, which congestion control algorithm gave better results overall? TCP Reno or
TCP Cubic? Which one gave better results on high packet loss? Explain how you came
to this conclusion based on the data set youâ€™ve gathered. (5 points)
2) How did your implementation of Reliable UDP perform overall compared to regular
TCP? Which one is better for high packet loss? (5 points)
3) According to the data youâ€™ve gathered, in which scenarios and applications would we
prefer to use TCP and in which situations would we prefer to use reliable UDP?
Explain your answer. (5 points)
 Communication Networks Course
Page | 8
×¢× ×• ×¢×œ ×”×©××œ×•×ª ×”×‘××•×ª )5 × ×§×•×“×•×ª(:
â— ×‘"×¨×©×ª ×××™× ×”" ×”×›×•×•× ×” ×”×™× ×œ×¨×©×ª ×©×‘×” ××¢×˜ ×××•×“ ×—×‘×™×œ×•×ª ×”×•×œ×›×•×ª ×œ××™×‘×•×“. ×‘"×§×©×¨ ××¨×•×š" ×”×›×•×•× ×” ×”×™×
×œ×§×©×¨ TCP ×©×™×© ×‘×• ×”×¨×‘×” ×××•×“ ××™×“×¢ ×œ×©×œ×•×—. ××•×¦×¢ ×œ×”×’×“×™×œ ×‘ -TCP ××ª SSThreshold ×‘×ª×—×™×œ×ª ×”×§×©×¨.
×‘××™×–×” ××”××§×¨×™× ×”×‘××™× ×”×©×™× ×•×™ ×”×–×” ×¢×©×•×™ ×œ×”×•×¢×™×œ ×‘××™×“×” ×”××™×¨×‘×™×ª? × ××§.
.1 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
.2 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.3 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.4 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.5 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.6 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.7 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.8 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
â— A ×©×•×œ×— ×œ -B ×—×‘×™×œ×•×ª ××™×“×¢ ×‘×××¦×¢×•×ª ×§×©×¨ TCP. × ×ª×•×Ÿ ×›×™ ×”×§×©×¨ ××ª×—×™×œ ×¢× ×—×œ×•×Ÿ ×‘×’×•×“×œ 1MSS. ×”×§×©×¨
××¡×ª×™×™× ×‘×¤×¢× ×”×¨××©×•× ×” ×©×”×•× ××’×™×¢ ×œ -SSthresh. ×‘××”×œ×š ×”×§×©×¨ ×œ× ××•×‘×“×•×ª ×—×‘×™×œ×•×ª. × ×¡××Ÿ ×‘×§×™×¦×•×¨:
.SSthresh=S*MSS
× ×ª×•×Ÿ ×›×™ ×œ××•×¨×š ×›×œ ×”×§×©×¨ rwnd < MSS*S.
××”×™ ×”×ª×¤×•×§×” ×©×œ ×”×§×©×¨ ×-A ×œ-B( ×‘ -sec / Bytes )×‘×–××Ÿ ×”× "×œ? × ××§×™.
]S*MSS / [lg (S) * RTT*2 ×‘×¢×¨×š .1
]S*MSS / [S^0.5 * RTT*2 ×‘×¢×¨×š .2
S*MSS / RTT ×‘×¢×¨×š .3
S^2)*MSS / RTT( ×‘×¢×¨×š .4
â— ×©×ª×™ ×ª×—× ×•×ª ××ª×§×©×¨×•×ª ×‘××•×¤×Ÿ ××œ×—×•×˜×™ ×‘×©×™×˜×ª N Back Go.
× ×¡××Ÿ ×‘-X ××ª ×¡×¤×¨×ª ×”×‘×™×§×•×¨×ª ×©×œ ×”×ª.×–. ×©×œ×š. ×× ×©× ×™ ×©×•×ª×¤×™× ××’×™×©×™× ××ª ×”×ª×¨×’×™×œ ×™×—×“, X ×”×•× ×¡×¤×¨×ª
×”×‘×™×§×•×¨×ª ×‘×¢×œ×ª ×”×¢×¨×š ×”× ××•×š ×™×•×ª×¨ ××‘×™×Ÿ ×”×©×ª×™×™×.
×§×¦×‘ ×”×ª×§×©×•×¨×ª ×”×•× 8Gbps, ×•×’×•×“×œ ×›×œ ×—×‘×™×œ×” ×”×•× KByte*X. ×’×“×œ×™ ×”-headers ×•×” -Acks ×–× ×™×—×™×.
ï¿½ğ‘’ğ‘ ï¿½/ï¿½ï¿½ 8 , ×•×”××¨×—×§ ×‘×™×Ÿ ×”×ª×—× ×•×ª ×”×•× 1Km. ×§×¦×‘ ×”×”×ª×¤×©×˜×•×ª ×”×•× 10 â‹… 2
×–××Ÿ ×¢×™×‘×•×“ ×”× ×ª×•× ×™× ×‘×ª×—× ×•×ª ×–× ×™×—.
××£ ×—×‘×™×œ×” ×•××£ Ack ×œ× ×”×•×œ×›×™× ×œ××™×‘×•×“.
â— ××”×• X ×©×œ×š?
â— ××” ×¦×¨×™×š ×œ×”×™×•×ª ×’×•×“×œ ×—×œ×•×Ÿ ×”××©×œ×•×— ×›×“×™ ×œ×”×‘×˜×™×— ×ª×¤×•×§×” ××§×¡×™××œ×™×ª?
 Communication Networks Course
Page | 9
Bonus â€“ Improving the Reliable UDP â€“ 15 points
Note: This part isnâ€™t mandatory and is a bonus only!
In this part, youâ€™ll improve your RUDP implementation by adding the concepts of flow
control and congestion control from TCP. Youâ€™re free to choose which algorithms to
implement, as long as you explain in your PDF which algorithms youâ€™ve used. Youâ€™ll probably
need to make changes in the original design of the RUDP. Changes only need to be to the API
itself, ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„.
Points distribution:
â€¢ Flow control improvement â€“ 7 Points
â€¢ Congestion control improvement â€“ 8 points.
Guidance:
â€¢ For flow control, you must use one of the Sliding window techniques: stop-and-wait
ARQ, Go-Back-N or Selective repeat.
â€¢ List of known TCP congestion control algorithms, which you can use any one of them
for this bonus task, or makeup your own:
Figure 2 â€“ List of known TCP congestion control algorithms, Wikipedia
 Communication Networks Course
Page | 10
Appendix A â€“ Linux local packet loss tool
To simulate a packet loss in a local network, we'll use a Linux tool that's called Linux Traffic
Control (ğ‘¡ğ‘). This requires a full Linux installation, so working with WSL won't work.
If the tool isn't installed in your machine, you can install it by using the following commands:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’
If the installation didn't work, you can use the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’2
To create a packet loss scenario, type the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘ğ‘‘ğ‘‘ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
After creating a packet loss scenario, you can change the percentage by typing the following
command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘â„ğ‘ğ‘›ğ‘”ğ‘’ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
To remove the packet loss scenario, write the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘‘ğ‘’ğ‘™ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š
 Communication Networks Course
Page | 11
Appendix B â€“ ğ’ğ’‚ğ’(ğŸ) system calls
This appendixâ€™s purpose is to give you a better understanding of socket handling in C.
A recommended reference is Beejâ€™s Guide to Network Programming, by Brian â€œBeej
Jorgensenâ€ Hall, which gives a lot of information about sockets in C and functions.
Functions and documentation links:
â€¢ ğ’”ğ’ğ’„ğ’Œğ’†ğ’•(ğŸ) â€“ A Factory method system call that creates a socket with the given
parameters.
â€¢ ğ’ƒğ’Šğ’ğ’…(ğŸ) â€“ Whenever we create a new socket, we need to bind it to a specific port in
our machine, â€œto catch a portâ€. The port number is managed and used by the kernel
to link incoming packets to the corresponding application socket. The port numbers
are usually fixed. The ğ‘ğ‘‘ğ‘‘ğ‘Ÿ parameter must match the current socket that is used.
â€¢ ğ’ğ’Šğ’”ğ’•ğ’†ğ’(ğŸ) â€“ The ğ‘™ğ‘–ğ‘ ğ‘¡ğ‘’ğ‘›(2) system call doesn't do anything in the mean of
communication but only memory allocation (malloc) for stream sockets only. If we
won't allocate memory, any incoming connection will fail.
â€¢ ğ’„ğ’ğ’ğ’ğ’†ğ’„ğ’•(ğŸ) â€“ The ğ‘ğ‘œğ‘›ğ‘›ğ‘’ğ‘ğ‘¡(2) system call starts the link between a client and a
specific IP address and port number. The connection would complete when the
other side will call the ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call.
â€¢ ğ’‚ğ’„ğ’„ğ’†ğ’‘ğ’•(ğŸ) â€“ The ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call accepts the incoming stream connection
request from the other side, by the listening socket. This system call completes the
three-way handshake of stream socket (like TCP) and opens a new socket that has a
direct communication channel only with the other party in the handshake.
â€¢ ğ’”ğ’†ğ’ğ’…(ğŸ) and ğ’”ğ’†ğ’ğ’…ğ’•ğ’(ğŸ) â€“ The ğ‘ ğ‘’ğ‘›ğ‘‘(2) and ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system calls are an analogy
for the ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’(2) system call, specifcly for sockets, with flags set to 0. Those system
calls return the number of bytes that were sent through the socket itself, as the
number of bytes can vary. The ğ‘ ğ‘’ğ‘›ğ‘‘(2)system call designed for stream sockets (like
TCP), while the ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system call designed for datagram connection-less
sockets (like UDP). When the ğ‘ ğ‘’ğ‘›ğ‘‘(2) system call returns 0, it means that the other
party closed the connection.
â€¢ ğ’“ğ’†ğ’„ğ’—(ğŸ) and ğ’“ğ’†ğ’„ğ’—ğ’‡ğ’“ğ’ğ’(ğŸ) â€“ The ğ‘Ÿğ‘’ğ‘ğ‘£(2) and ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system calls are an
analogy for the ğ‘Ÿğ‘’ğ‘ğ‘‘(2) system call, specifically for sockets, with flags set to 0.
Those system calls return the number of bytes that were received through the socket
itself, as the number of bytes can vary. The ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call designed for stream
sockets (like TCP), while the ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system call designed for datagram
connection-less sockets (like UDP). When the ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call returns 0, it means
that the other party closed the connection.
â€¢ ğ’„ğ’ğ’ğ’”ğ’†(ğŸ) and ğ’”ğ’‰ğ’–ğ’•ğ’…ğ’ğ’˜ğ’(ğŸ) â€“ The ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) and ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2) system calls close
the socket. While ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) system call closes the whole socket, the ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2)
system call partially closes the socket for read/write.
 Communication Networks Course
Page | 12
Appendix C â€“ Random data generator
The data that you are going to send in this assignment is randomly generated. You can use
your own file with appropriate size or use the following function (or a function of your own)
to generate the data:
/*
* @brief A random data generator function based on srand() and rand().
* @param size The size of the data to generate (up to 2^32 bytes).
* @return A pointer to the buffer.
*/
char *util_generate_random_data(unsigned int size) {
 char *buffer = NULL;
 // Argument check.
 if (size == 0)
 return NULL;
 buffer = (char *)calloc(size, sizeof(char));
 // Error checking.
 if (buffer == NULL)
 return NULL;
 // Randomize the seed of the random number generator.
 srand(time(NULL));
 for (unsigned int i = 0; i < size; i++)
 *(buffer + i) = ((unsigned int)rand() % 256);
 return buffer;
}
 Communication Networks Course
Page | 13
Appendix D â€“ Checksum function
A checksum is a small-sized block of data derived from another block of digital data for the
purpose of detecting errors that may have been introduced during its transmission or
storage. By themselves, checksums are often used to verify data integrity but are not relied
upon to verify data authenticity.
Below is a simple yet efficient implementation of the checksum function, you can use it for
the assignment, but you can implement your own checksum function.
/*
* @brief A checksum function that returns 16 bit checksum for data.
* @param data The data to do the checksum for.
* @param bytes The length of the data in bytes.
* @return The checksum itself as 16 bit unsigned number.
* @note This function is taken from RFC1071, can be found here:
* @note https://tools.ietf.org/html/rfc1071
* @note It is the simplest way to calculate a checksum and is not very strong.
* However, it is good enough for this assignment.
* @note You are free to use any other checksum function as well.
* You can also use this function as such without any change.
*/
unsigned short int calculate_checksum(void *data, unsigned int bytes) {
 unsigned short int *data_pointer = (unsigned short int *)data;
 unsigned int total_sum = 0;
 // Main summing loop
 while (bytes > 1) {
 total_sum += *data_pointer++;
 bytes -= 2;
 }
 // Add left-over byte, if any
 if (bytes > 0)
 total_sum += *((unsigned char *)data_pointer);
 // Fold 32-bit sum to 16 bits
 while (total_sum >> 16)
 total_sum = (total_sum & 0xFFFF) + (total_sum >> 16);
 return (~((unsigned short int)total_sum));
} Communication Networks Course
Page | 1
Assignment 3 â€“ Transport Layer
Assignment Notes and Instructions
This assignment is to be done in pairs only. You must upload all the necessary files in a ZIP
file named after both of the studentâ€™s ID. For example: ğŸğŸğŸ‘ğŸ’ğŸ“ğŸ”ğŸ•ğŸ–ğŸ—_ğŸ—ğŸ–ğŸ•ğŸ”ğŸ“ğŸ’ğŸ‘ğŸğŸ. ğ’›ğ’Šğ’‘.
1) The assignment must be submitted by the date specified in the submission box.
2) All the assignment files (Code, Wireshark pcap files, PDF) must be submitted in a ZIP file. The
PDF must contain all the necessary screenshots with a description for each one of them.
3) The assignment must be done in pairs only. In exceptional cases, you should send an email to
the course coordinator.
4) You can use any reference material available through the course Moodle website or any
material passed during the exercises.
5) You can use any reference from the web, but copying codes from websites is forbidden; this
includes codes from other GitHub repositories. A student who gets caught in the act will
automatically fail this assignment (score 0). Any website youâ€™ve used to solve the
assignment, every website you used to solve the assignment must be noted in the PDF.
6) No delays in submission without special permission. Lateness without approval will result in
failure of the assignment (score 0).
7) All submissions will be submitted via the course's Moodle website. Email submissions will not
be accepted, resulting in a failure in the assignment.
8) The order and design of the code must be carefully considered. Make sure that the program
output is as clear as possible, comments in the code, and meaningful variable names. You
must also submit a makefile that compiles all the programs.
9) The assignment code must be written in C only.
10) The assignment is personal for each pair, and you should not accept help from other people,
whether outside the university or inside it. You can contact the course staff during reception
hours for help or raise a question in the course forum. Do not transfer code sections
between students, upload solutions or parts of solutions to websites on the Internet or in
various communication groups.
11) Students who copy a solution will receive a 0 in all assignments in the course and a report will
be made to the institutional disciplinary committee.
12) All code files of the assignment are required to both compile and run properly on the Ubuntu
22.04 LTS operating system. This is the operating system where the submissions will be
tested. You mustnâ€™t code it in Windows, as it uses different API for sockets. WSL wonâ€™t work,
as the task needs a tool that works only in a fully Linux environment.
Good Luck!
 Communication Networks Course
Page | 2
Part A â€“ Transmission Control Protocol (TCP) â€“ 30 points
In this part, youâ€™ll write two program files: ğ‘»ğ‘ªğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and ğ‘»ğ‘ªğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
The Sender will send a randomly generated file and the Receiver will receive it and measure
the time it took for his program to receive the file. The file size should be at least 2MB.
When running the Sender and Receiver, they both should support two standard congestion
control algorithms: TCP Reno and TCP Cubic.
Notes:
â€¢ The main goal of this part is to get familiar with the TCP concept of sending
messages between two endpoints.
â€¢ For approaching this part of the assignment, please be sure that you are familiar
with the congestion control algorithms and how to change them using the correct
method in C (see Appendix B for more information).
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). You've
learned that TCP is reliable by design, so you can assume that all the data have been
passed correctly, and thus, no need to recheck.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
Usage:
â€¢ Receiver:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
â€¢ Sender:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port of the Receiver.
â€¢ ğ‘¨ğ‘³ğ‘®ğ‘¶ â€“ The TCP congestion control algorithm that will be used by the party
member (either ğ’“ğ’†ğ’ğ’ for TCP Reno or ğ’„ğ’–ğ’ƒğ’Šğ’„ for TCP Cubic).
 Communication Networks Course
Page | 3
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a TCP socket between the Sender and the
Receiver.
3) Send the file.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a TCP connection between the Receiver and
the Sender.
2) Get a connection from the sender.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./TCP_Receiver -p 1234 -algo reno
Starting Receiver...
Waiting for TCP connection...
Sender connected, beginning to receive file...
File transfer completed.
Waiting for Sender response...
Sender sent exit message.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 4
Part B â€“ Reliable User Datagram Protocol (Reliable UDP or RUDP) â€“ 40 points
Youâ€™ve learned that while TCP is reliable, it lacks speed and has an overhead data of 20 bytes,
compering to UDP that needs only 8 bytes of overhead data.
Reliable UDP or RUDP, is a protocol that uses the UDP protocol for a faster transmission of
data, while adding a reliability layer to it, but without adding too much overhead data like
TCP.
A simple sketch for a RUDP connection would look something like this:
Your task in this part is to implement a Reliable protocol using UDP only. For simplicity, your
implementation should only support a handshake, closing scheme, error checking,
acknowledgment of received packets, and retransmission of lost packets.
Guidance:
â€¢ You can use ğ‘ ğ‘’ğ‘¡ğ‘ ğ‘œğ‘ğ‘˜ğ‘œğ‘ğ‘¡(2) for detecting a timeout.
â€¢ You need to build your own protocol, as Reliable UDP isnâ€™t a standard protocol (see a
draft of RUDP in this link), and no official header is provided. You can use this sketch
for a header, but you can come up with your own protocol, as long as it works.
Where:
o ğ‘³ğ’†ğ’ğ’ˆğ’•ğ’‰ is the length of the data itself, without the RUDP header.
o ğ‘ªğ’‰ğ’†ğ’„ğ’Œğ’”ğ’–ğ’ is a 16bit number that validates the correctness of the data.
o ğ‘­ğ’ğ’‚ğ’ˆğ’” is a special byte where we classify the packet itself (SYN, ACK, etc.).
â€¢ In your PDF, you must explain how your implementation of RUDP works â€“ How does
it detect a timeout to do retransmissions, how does the handshake work, what is the
header overhead, etc.
â€¢ For this part, youâ€™ll write three files: ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¨ğ‘·ğ‘°. ğ’„, ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and
ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
Reliable UDP Header proposed sketch
Byte 0 Byte 1 Byte 2 Byte 3
Length (2 Bytes) Checksum (2 Bytes)
Flags (1 Byte)
Figure 1 - RUDP Protocol Architecture, Geeksforgeeks
 Communication Networks Course
Page | 5
Notes:
â€¢ The Sender will send a random generated file and the Receiver will receive it and
measure the time it took for his program to receive the file. The file size should be at
least 2MB.
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). But, as the
RUDP is based on UDP, itâ€™s not reliable. You must use some form of error checking
(like checksum) to ensure that the packet wasnâ€™t alerted during the transfer.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
â€¢ The RUDP needs support only 1 sender and 1 receiver, for simplicity purposes.
Usage:
â€¢ Receiver:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
â€¢ Sender:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port that both the Sender and the Receiver will use.
The ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„ file will contain all the implementations of the RUDP API functions (That is, to
prevent reusing the same chuck of code both in the Sender and the Receiver.).
The API should support at the bare minimum the following functions (you decide what
parameters to implement, and what are the names of the functions, as long as the API is
explained in the PDF):
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘œğ‘ğ‘˜ğ‘’ğ‘¡() â€“ Creating a RUDP socket and creating a handshake between two
peers.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘’ğ‘›ğ‘‘() â€“ Sending data to the peer. The function should wait for an
acknowledgment packet, and if it didnâ€™t receive any, retransmits the data.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘Ÿğ‘’ğ‘ğ‘£() â€“ Receive data from a peer.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ğ‘™ğ‘œğ‘ ğ‘’() â€“ Closes a connection between peers.
 Communication Networks Course
Page | 6
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a UDP socket between the Sender and the
Receiver.
3) Send the file via the RUDP protocol.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a UDP connection between the Receiver and
the Sender.
2) Get a connection from the sender, by the custom
RUDP protocol youâ€™ve built.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./RUDP_Receiver -p 1234
Starting Receiver...
Waiting for RUDP connection...
Connection request received, sending ACK.
Sender connected, beginning to receive file...
File transfer completed.
ACK sent.
Waiting for Sender response...
Sender sent exit message.
ACK sent.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 7
Part C â€“ Research â€“ 30 points
In this part, youâ€™ll conduct research about your implementations of part A and part B.
In the research itself, each one of the versions (TCP version and UDP version) will be run at
least 5 times (meaning that the file transfer will occur at least 5 times) by the following
conditions:
â€¢ For TCP, youâ€™ll run it in TCP Reno and TCP Cubic, alternating each time, for each
scenario, meaning that you run 5 times with TCP Reno in both Sender and Receiver,
and 5 times with TCP Cubic in both Sender and Receiver.
Bonus (5 points): Create a very large data set â€“ 5 times with TCP Reno in both Sender
and Receiver, 5 times with TCP Reno in Sender and TCP Cubic in Receiver, 5 times
with TCP Cubic in Sender and TCP Reno in Receiver, and 5 times with TCP Cubic in
both Sender and Receiver. This will give you a data set large enough, which allows
you to work with, compare with and to reach a definite conclusion.
â€¢ For RUDP, you will run it 5 times for each scenario.
â€¢ For both TCP and RUDP, you will run them on those scenarios of packet loss:
o 0% packet loss â€“ Control group, simulating perfect connection.
o 2% packet loss â€“ Simulating unstable connection that commonly occur.
o 5% packet loss â€“ Simulating bad connection.
o 10% packet loss â€“ Simulating extremely poor connection.
For each scenario, you must provide a filtered PCAP file and relevant screenshots that
explain each one of the steps in the process. (10 points)
After youâ€™ve gathered the data set for both TCP and Reliable UDP, answer the following
questions:
1) In TCP, which congestion control algorithm gave better results overall? TCP Reno or
TCP Cubic? Which one gave better results on high packet loss? Explain how you came
to this conclusion based on the data set youâ€™ve gathered. (5 points)
2) How did your implementation of Reliable UDP perform overall compared to regular
TCP? Which one is better for high packet loss? (5 points)
3) According to the data youâ€™ve gathered, in which scenarios and applications would we
prefer to use TCP and in which situations would we prefer to use reliable UDP?
Explain your answer. (5 points)
 Communication Networks Course
Page | 8
×¢× ×• ×¢×œ ×”×©××œ×•×ª ×”×‘××•×ª )5 × ×§×•×“×•×ª(:
â— ×‘"×¨×©×ª ×××™× ×”" ×”×›×•×•× ×” ×”×™× ×œ×¨×©×ª ×©×‘×” ××¢×˜ ×××•×“ ×—×‘×™×œ×•×ª ×”×•×œ×›×•×ª ×œ××™×‘×•×“. ×‘"×§×©×¨ ××¨×•×š" ×”×›×•×•× ×” ×”×™×
×œ×§×©×¨ TCP ×©×™×© ×‘×• ×”×¨×‘×” ×××•×“ ××™×“×¢ ×œ×©×œ×•×—. ××•×¦×¢ ×œ×”×’×“×™×œ ×‘ -TCP ××ª SSThreshold ×‘×ª×—×™×œ×ª ×”×§×©×¨.
×‘××™×–×” ××”××§×¨×™× ×”×‘××™× ×”×©×™× ×•×™ ×”×–×” ×¢×©×•×™ ×œ×”×•×¢×™×œ ×‘××™×“×” ×”××™×¨×‘×™×ª? × ××§.
.1 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
.2 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.3 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.4 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.5 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.6 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.7 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.8 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
â— A ×©×•×œ×— ×œ -B ×—×‘×™×œ×•×ª ××™×“×¢ ×‘×××¦×¢×•×ª ×§×©×¨ TCP. × ×ª×•×Ÿ ×›×™ ×”×§×©×¨ ××ª×—×™×œ ×¢× ×—×œ×•×Ÿ ×‘×’×•×“×œ 1MSS. ×”×§×©×¨
××¡×ª×™×™× ×‘×¤×¢× ×”×¨××©×•× ×” ×©×”×•× ××’×™×¢ ×œ -SSthresh. ×‘××”×œ×š ×”×§×©×¨ ×œ× ××•×‘×“×•×ª ×—×‘×™×œ×•×ª. × ×¡××Ÿ ×‘×§×™×¦×•×¨:
.SSthresh=S*MSS
× ×ª×•×Ÿ ×›×™ ×œ××•×¨×š ×›×œ ×”×§×©×¨ rwnd < MSS*S.
××”×™ ×”×ª×¤×•×§×” ×©×œ ×”×§×©×¨ ×-A ×œ-B( ×‘ -sec / Bytes )×‘×–××Ÿ ×”× "×œ? × ××§×™.
]S*MSS / [lg (S) * RTT*2 ×‘×¢×¨×š .1
]S*MSS / [S^0.5 * RTT*2 ×‘×¢×¨×š .2
S*MSS / RTT ×‘×¢×¨×š .3
S^2)*MSS / RTT( ×‘×¢×¨×š .4
â— ×©×ª×™ ×ª×—× ×•×ª ××ª×§×©×¨×•×ª ×‘××•×¤×Ÿ ××œ×—×•×˜×™ ×‘×©×™×˜×ª N Back Go.
× ×¡××Ÿ ×‘-X ××ª ×¡×¤×¨×ª ×”×‘×™×§×•×¨×ª ×©×œ ×”×ª.×–. ×©×œ×š. ×× ×©× ×™ ×©×•×ª×¤×™× ××’×™×©×™× ××ª ×”×ª×¨×’×™×œ ×™×—×“, X ×”×•× ×¡×¤×¨×ª
×”×‘×™×§×•×¨×ª ×‘×¢×œ×ª ×”×¢×¨×š ×”× ××•×š ×™×•×ª×¨ ××‘×™×Ÿ ×”×©×ª×™×™×.
×§×¦×‘ ×”×ª×§×©×•×¨×ª ×”×•× 8Gbps, ×•×’×•×“×œ ×›×œ ×—×‘×™×œ×” ×”×•× KByte*X. ×’×“×œ×™ ×”-headers ×•×” -Acks ×–× ×™×—×™×.
ï¿½ğ‘’ğ‘ ï¿½/ï¿½ï¿½ 8 , ×•×”××¨×—×§ ×‘×™×Ÿ ×”×ª×—× ×•×ª ×”×•× 1Km. ×§×¦×‘ ×”×”×ª×¤×©×˜×•×ª ×”×•× 10 â‹… 2
×–××Ÿ ×¢×™×‘×•×“ ×”× ×ª×•× ×™× ×‘×ª×—× ×•×ª ×–× ×™×—.
××£ ×—×‘×™×œ×” ×•××£ Ack ×œ× ×”×•×œ×›×™× ×œ××™×‘×•×“.
â— ××”×• X ×©×œ×š?
â— ××” ×¦×¨×™×š ×œ×”×™×•×ª ×’×•×“×œ ×—×œ×•×Ÿ ×”××©×œ×•×— ×›×“×™ ×œ×”×‘×˜×™×— ×ª×¤×•×§×” ××§×¡×™××œ×™×ª?
 Communication Networks Course
Page | 9
Bonus â€“ Improving the Reliable UDP â€“ 15 points
Note: This part isnâ€™t mandatory and is a bonus only!
In this part, youâ€™ll improve your RUDP implementation by adding the concepts of flow
control and congestion control from TCP. Youâ€™re free to choose which algorithms to
implement, as long as you explain in your PDF which algorithms youâ€™ve used. Youâ€™ll probably
need to make changes in the original design of the RUDP. Changes only need to be to the API
itself, ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„.
Points distribution:
â€¢ Flow control improvement â€“ 7 Points
â€¢ Congestion control improvement â€“ 8 points.
Guidance:
â€¢ For flow control, you must use one of the Sliding window techniques: stop-and-wait
ARQ, Go-Back-N or Selective repeat.
â€¢ List of known TCP congestion control algorithms, which you can use any one of them
for this bonus task, or makeup your own:
Figure 2 â€“ List of known TCP congestion control algorithms, Wikipedia
 Communication Networks Course
Page | 10
Appendix A â€“ Linux local packet loss tool
To simulate a packet loss in a local network, we'll use a Linux tool that's called Linux Traffic
Control (ğ‘¡ğ‘). This requires a full Linux installation, so working with WSL won't work.
If the tool isn't installed in your machine, you can install it by using the following commands:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’
If the installation didn't work, you can use the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’2
To create a packet loss scenario, type the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘ğ‘‘ğ‘‘ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
After creating a packet loss scenario, you can change the percentage by typing the following
command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘â„ğ‘ğ‘›ğ‘”ğ‘’ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
To remove the packet loss scenario, write the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘‘ğ‘’ğ‘™ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š
 Communication Networks Course
Page | 11
Appendix B â€“ ğ’ğ’‚ğ’(ğŸ) system calls
This appendixâ€™s purpose is to give you a better understanding of socket handling in C.
A recommended reference is Beejâ€™s Guide to Network Programming, by Brian â€œBeej
Jorgensenâ€ Hall, which gives a lot of information about sockets in C and functions.
Functions and documentation links:
â€¢ ğ’”ğ’ğ’„ğ’Œğ’†ğ’•(ğŸ) â€“ A Factory method system call that creates a socket with the given
parameters.
â€¢ ğ’ƒğ’Šğ’ğ’…(ğŸ) â€“ Whenever we create a new socket, we need to bind it to a specific port in
our machine, â€œto catch a portâ€. The port number is managed and used by the kernel
to link incoming packets to the corresponding application socket. The port numbers
are usually fixed. The ğ‘ğ‘‘ğ‘‘ğ‘Ÿ parameter must match the current socket that is used.
â€¢ ğ’ğ’Šğ’”ğ’•ğ’†ğ’(ğŸ) â€“ The ğ‘™ğ‘–ğ‘ ğ‘¡ğ‘’ğ‘›(2) system call doesn't do anything in the mean of
communication but only memory allocation (malloc) for stream sockets only. If we
won't allocate memory, any incoming connection will fail.
â€¢ ğ’„ğ’ğ’ğ’ğ’†ğ’„ğ’•(ğŸ) â€“ The ğ‘ğ‘œğ‘›ğ‘›ğ‘’ğ‘ğ‘¡(2) system call starts the link between a client and a
specific IP address and port number. The connection would complete when the
other side will call the ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call.
â€¢ ğ’‚ğ’„ğ’„ğ’†ğ’‘ğ’•(ğŸ) â€“ The ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call accepts the incoming stream connection
request from the other side, by the listening socket. This system call completes the
three-way handshake of stream socket (like TCP) and opens a new socket that has a
direct communication channel only with the other party in the handshake.
â€¢ ğ’”ğ’†ğ’ğ’…(ğŸ) and ğ’”ğ’†ğ’ğ’…ğ’•ğ’(ğŸ) â€“ The ğ‘ ğ‘’ğ‘›ğ‘‘(2) and ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system calls are an analogy
for the ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’(2) system call, specifcly for sockets, with flags set to 0. Those system
calls return the number of bytes that were sent through the socket itself, as the
number of bytes can vary. The ğ‘ ğ‘’ğ‘›ğ‘‘(2)system call designed for stream sockets (like
TCP), while the ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system call designed for datagram connection-less
sockets (like UDP). When the ğ‘ ğ‘’ğ‘›ğ‘‘(2) system call returns 0, it means that the other
party closed the connection.
â€¢ ğ’“ğ’†ğ’„ğ’—(ğŸ) and ğ’“ğ’†ğ’„ğ’—ğ’‡ğ’“ğ’ğ’(ğŸ) â€“ The ğ‘Ÿğ‘’ğ‘ğ‘£(2) and ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system calls are an
analogy for the ğ‘Ÿğ‘’ğ‘ğ‘‘(2) system call, specifically for sockets, with flags set to 0.
Those system calls return the number of bytes that were received through the socket
itself, as the number of bytes can vary. The ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call designed for stream
sockets (like TCP), while the ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system call designed for datagram
connection-less sockets (like UDP). When the ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call returns 0, it means
that the other party closed the connection.
â€¢ ğ’„ğ’ğ’ğ’”ğ’†(ğŸ) and ğ’”ğ’‰ğ’–ğ’•ğ’…ğ’ğ’˜ğ’(ğŸ) â€“ The ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) and ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2) system calls close
the socket. While ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) system call closes the whole socket, the ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2)
system call partially closes the socket for read/write.
 Communication Networks Course
Page | 12
Appendix C â€“ Random data generator
The data that you are going to send in this assignment is randomly generated. You can use
your own file with appropriate size or use the following function (or a function of your own)
to generate the data:
/*
* @brief A random data generator function based on srand() and rand().
* @param size The size of the data to generate (up to 2^32 bytes).
* @return A pointer to the buffer.
*/
char *util_generate_random_data(unsigned int size) {
 char *buffer = NULL;
 // Argument check.
 if (size == 0)
 return NULL;
 buffer = (char *)calloc(size, sizeof(char));
 // Error checking.
 if (buffer == NULL)
 return NULL;
 // Randomize the seed of the random number generator.
 srand(time(NULL));
 for (unsigned int i = 0; i < size; i++)
 *(buffer + i) = ((unsigned int)rand() % 256);
 return buffer;
}
 Communication Networks Course
Page | 13
Appendix D â€“ Checksum function
A checksum is a small-sized block of data derived from another block of digital data for the
purpose of detecting errors that may have been introduced during its transmission or
storage. By themselves, checksums are often used to verify data integrity but are not relied
upon to verify data authenticity.
Below is a simple yet efficient implementation of the checksum function, you can use it for
the assignment, but you can implement your own checksum function.
/*
* @brief A checksum function that returns 16 bit checksum for data.
* @param data The data to do the checksum for.
* @param bytes The length of the data in bytes.
* @return The checksum itself as 16 bit unsigned number.
* @note This function is taken from RFC1071, can be found here:
* @note https://tools.ietf.org/html/rfc1071
* @note It is the simplest way to calculate a checksum and is not very strong.
* However, it is good enough for this assignment.
* @note You are free to use any other checksum function as well.
* You can also use this function as such without any change.
*/
unsigned short int calculate_checksum(void *data, unsigned int bytes) {
 unsigned short int *data_pointer = (unsigned short int *)data;
 unsigned int total_sum = 0;
 // Main summing loop
 while (bytes > 1) {
 total_sum += *data_pointer++;
 bytes -= 2;
 }
 // Add left-over byte, if any
 if (bytes > 0)
 total_sum += *((unsigned char *)data_pointer);
 // Fold 32-bit sum to 16 bits
 while (total_sum >> 16)
 total_sum = (total_sum & 0xFFFF) + (total_sum >> 16);
 return (~((unsigned short int)total_sum));
} Communication Networks Course
Page | 1
Assignment 3 â€“ Transport Layer
Assignment Notes and Instructions
This assignment is to be done in pairs only. You must upload all the necessary files in a ZIP
file named after both of the studentâ€™s ID. For example: ğŸğŸğŸ‘ğŸ’ğŸ“ğŸ”ğŸ•ğŸ–ğŸ—_ğŸ—ğŸ–ğŸ•ğŸ”ğŸ“ğŸ’ğŸ‘ğŸğŸ. ğ’›ğ’Šğ’‘.
1) The assignment must be submitted by the date specified in the submission box.
2) All the assignment files (Code, Wireshark pcap files, PDF) must be submitted in a ZIP file. The
PDF must contain all the necessary screenshots with a description for each one of them.
3) The assignment must be done in pairs only. In exceptional cases, you should send an email to
the course coordinator.
4) You can use any reference material available through the course Moodle website or any
material passed during the exercises.
5) You can use any reference from the web, but copying codes from websites is forbidden; this
includes codes from other GitHub repositories. A student who gets caught in the act will
automatically fail this assignment (score 0). Any website youâ€™ve used to solve the
assignment, every website you used to solve the assignment must be noted in the PDF.
6) No delays in submission without special permission. Lateness without approval will result in
failure of the assignment (score 0).
7) All submissions will be submitted via the course's Moodle website. Email submissions will not
be accepted, resulting in a failure in the assignment.
8) The order and design of the code must be carefully considered. Make sure that the program
output is as clear as possible, comments in the code, and meaningful variable names. You
must also submit a makefile that compiles all the programs.
9) The assignment code must be written in C only.
10) The assignment is personal for each pair, and you should not accept help from other people,
whether outside the university or inside it. You can contact the course staff during reception
hours for help or raise a question in the course forum. Do not transfer code sections
between students, upload solutions or parts of solutions to websites on the Internet or in
various communication groups.
11) Students who copy a solution will receive a 0 in all assignments in the course and a report will
be made to the institutional disciplinary committee.
12) All code files of the assignment are required to both compile and run properly on the Ubuntu
22.04 LTS operating system. This is the operating system where the submissions will be
tested. You mustnâ€™t code it in Windows, as it uses different API for sockets. WSL wonâ€™t work,
as the task needs a tool that works only in a fully Linux environment.
Good Luck!
 Communication Networks Course
Page | 2
Part A â€“ Transmission Control Protocol (TCP) â€“ 30 points
In this part, youâ€™ll write two program files: ğ‘»ğ‘ªğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and ğ‘»ğ‘ªğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
The Sender will send a randomly generated file and the Receiver will receive it and measure
the time it took for his program to receive the file. The file size should be at least 2MB.
When running the Sender and Receiver, they both should support two standard congestion
control algorithms: TCP Reno and TCP Cubic.
Notes:
â€¢ The main goal of this part is to get familiar with the TCP concept of sending
messages between two endpoints.
â€¢ For approaching this part of the assignment, please be sure that you are familiar
with the congestion control algorithms and how to change them using the correct
method in C (see Appendix B for more information).
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). You've
learned that TCP is reliable by design, so you can assume that all the data have been
passed correctly, and thus, no need to recheck.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
Usage:
â€¢ Receiver:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
â€¢ Sender:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port of the Receiver.
â€¢ ğ‘¨ğ‘³ğ‘®ğ‘¶ â€“ The TCP congestion control algorithm that will be used by the party
member (either ğ’“ğ’†ğ’ğ’ for TCP Reno or ğ’„ğ’–ğ’ƒğ’Šğ’„ for TCP Cubic).
 Communication Networks Course
Page | 3
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a TCP socket between the Sender and the
Receiver.
3) Send the file.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a TCP connection between the Receiver and
the Sender.
2) Get a connection from the sender.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./TCP_Receiver -p 1234 -algo reno
Starting Receiver...
Waiting for TCP connection...
Sender connected, beginning to receive file...
File transfer completed.
Waiting for Sender response...
Sender sent exit message.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 4
Part B â€“ Reliable User Datagram Protocol (Reliable UDP or RUDP) â€“ 40 points
Youâ€™ve learned that while TCP is reliable, it lacks speed and has an overhead data of 20 bytes,
compering to UDP that needs only 8 bytes of overhead data.
Reliable UDP or RUDP, is a protocol that uses the UDP protocol for a faster transmission of
data, while adding a reliability layer to it, but without adding too much overhead data like
TCP.
A simple sketch for a RUDP connection would look something like this:
Your task in this part is to implement a Reliable protocol using UDP only. For simplicity, your
implementation should only support a handshake, closing scheme, error checking,
acknowledgment of received packets, and retransmission of lost packets.
Guidance:
â€¢ You can use ğ‘ ğ‘’ğ‘¡ğ‘ ğ‘œğ‘ğ‘˜ğ‘œğ‘ğ‘¡(2) for detecting a timeout.
â€¢ You need to build your own protocol, as Reliable UDP isnâ€™t a standard protocol (see a
draft of RUDP in this link), and no official header is provided. You can use this sketch
for a header, but you can come up with your own protocol, as long as it works.
Where:
o ğ‘³ğ’†ğ’ğ’ˆğ’•ğ’‰ is the length of the data itself, without the RUDP header.
o ğ‘ªğ’‰ğ’†ğ’„ğ’Œğ’”ğ’–ğ’ is a 16bit number that validates the correctness of the data.
o ğ‘­ğ’ğ’‚ğ’ˆğ’” is a special byte where we classify the packet itself (SYN, ACK, etc.).
â€¢ In your PDF, you must explain how your implementation of RUDP works â€“ How does
it detect a timeout to do retransmissions, how does the handshake work, what is the
header overhead, etc.
â€¢ For this part, youâ€™ll write three files: ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¨ğ‘·ğ‘°. ğ’„, ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and
ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
Reliable UDP Header proposed sketch
Byte 0 Byte 1 Byte 2 Byte 3
Length (2 Bytes) Checksum (2 Bytes)
Flags (1 Byte)
Figure 1 - RUDP Protocol Architecture, Geeksforgeeks
 Communication Networks Course
Page | 5
Notes:
â€¢ The Sender will send a random generated file and the Receiver will receive it and
measure the time it took for his program to receive the file. The file size should be at
least 2MB.
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). But, as the
RUDP is based on UDP, itâ€™s not reliable. You must use some form of error checking
(like checksum) to ensure that the packet wasnâ€™t alerted during the transfer.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
â€¢ The RUDP needs support only 1 sender and 1 receiver, for simplicity purposes.
Usage:
â€¢ Receiver:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
â€¢ Sender:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port that both the Sender and the Receiver will use.
The ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„ file will contain all the implementations of the RUDP API functions (That is, to
prevent reusing the same chuck of code both in the Sender and the Receiver.).
The API should support at the bare minimum the following functions (you decide what
parameters to implement, and what are the names of the functions, as long as the API is
explained in the PDF):
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘œğ‘ğ‘˜ğ‘’ğ‘¡() â€“ Creating a RUDP socket and creating a handshake between two
peers.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘’ğ‘›ğ‘‘() â€“ Sending data to the peer. The function should wait for an
acknowledgment packet, and if it didnâ€™t receive any, retransmits the data.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘Ÿğ‘’ğ‘ğ‘£() â€“ Receive data from a peer.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ğ‘™ğ‘œğ‘ ğ‘’() â€“ Closes a connection between peers.
 Communication Networks Course
Page | 6
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a UDP socket between the Sender and the
Receiver.
3) Send the file via the RUDP protocol.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a UDP connection between the Receiver and
the Sender.
2) Get a connection from the sender, by the custom
RUDP protocol youâ€™ve built.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./RUDP_Receiver -p 1234
Starting Receiver...
Waiting for RUDP connection...
Connection request received, sending ACK.
Sender connected, beginning to receive file...
File transfer completed.
ACK sent.
Waiting for Sender response...
Sender sent exit message.
ACK sent.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 7
Part C â€“ Research â€“ 30 points
In this part, youâ€™ll conduct research about your implementations of part A and part B.
In the research itself, each one of the versions (TCP version and UDP version) will be run at
least 5 times (meaning that the file transfer will occur at least 5 times) by the following
conditions:
â€¢ For TCP, youâ€™ll run it in TCP Reno and TCP Cubic, alternating each time, for each
scenario, meaning that you run 5 times with TCP Reno in both Sender and Receiver,
and 5 times with TCP Cubic in both Sender and Receiver.
Bonus (5 points): Create a very large data set â€“ 5 times with TCP Reno in both Sender
and Receiver, 5 times with TCP Reno in Sender and TCP Cubic in Receiver, 5 times
with TCP Cubic in Sender and TCP Reno in Receiver, and 5 times with TCP Cubic in
both Sender and Receiver. This will give you a data set large enough, which allows
you to work with, compare with and to reach a definite conclusion.
â€¢ For RUDP, you will run it 5 times for each scenario.
â€¢ For both TCP and RUDP, you will run them on those scenarios of packet loss:
o 0% packet loss â€“ Control group, simulating perfect connection.
o 2% packet loss â€“ Simulating unstable connection that commonly occur.
o 5% packet loss â€“ Simulating bad connection.
o 10% packet loss â€“ Simulating extremely poor connection.
For each scenario, you must provide a filtered PCAP file and relevant screenshots that
explain each one of the steps in the process. (10 points)
After youâ€™ve gathered the data set for both TCP and Reliable UDP, answer the following
questions:
1) In TCP, which congestion control algorithm gave better results overall? TCP Reno or
TCP Cubic? Which one gave better results on high packet loss? Explain how you came
to this conclusion based on the data set youâ€™ve gathered. (5 points)
2) How did your implementation of Reliable UDP perform overall compared to regular
TCP? Which one is better for high packet loss? (5 points)
3) According to the data youâ€™ve gathered, in which scenarios and applications would we
prefer to use TCP and in which situations would we prefer to use reliable UDP?
Explain your answer. (5 points)
 Communication Networks Course
Page | 8
×¢× ×• ×¢×œ ×”×©××œ×•×ª ×”×‘××•×ª )5 × ×§×•×“×•×ª(:
â— ×‘"×¨×©×ª ×××™× ×”" ×”×›×•×•× ×” ×”×™× ×œ×¨×©×ª ×©×‘×” ××¢×˜ ×××•×“ ×—×‘×™×œ×•×ª ×”×•×œ×›×•×ª ×œ××™×‘×•×“. ×‘"×§×©×¨ ××¨×•×š" ×”×›×•×•× ×” ×”×™×
×œ×§×©×¨ TCP ×©×™×© ×‘×• ×”×¨×‘×” ×××•×“ ××™×“×¢ ×œ×©×œ×•×—. ××•×¦×¢ ×œ×”×’×“×™×œ ×‘ -TCP ××ª SSThreshold ×‘×ª×—×™×œ×ª ×”×§×©×¨.
×‘××™×–×” ××”××§×¨×™× ×”×‘××™× ×”×©×™× ×•×™ ×”×–×” ×¢×©×•×™ ×œ×”×•×¢×™×œ ×‘××™×“×” ×”××™×¨×‘×™×ª? × ××§.
.1 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
.2 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.3 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.4 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.5 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.6 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.7 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.8 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
â— A ×©×•×œ×— ×œ -B ×—×‘×™×œ×•×ª ××™×“×¢ ×‘×××¦×¢×•×ª ×§×©×¨ TCP. × ×ª×•×Ÿ ×›×™ ×”×§×©×¨ ××ª×—×™×œ ×¢× ×—×œ×•×Ÿ ×‘×’×•×“×œ 1MSS. ×”×§×©×¨
××¡×ª×™×™× ×‘×¤×¢× ×”×¨××©×•× ×” ×©×”×•× ××’×™×¢ ×œ -SSthresh. ×‘××”×œ×š ×”×§×©×¨ ×œ× ××•×‘×“×•×ª ×—×‘×™×œ×•×ª. × ×¡××Ÿ ×‘×§×™×¦×•×¨:
.SSthresh=S*MSS
× ×ª×•×Ÿ ×›×™ ×œ××•×¨×š ×›×œ ×”×§×©×¨ rwnd < MSS*S.
××”×™ ×”×ª×¤×•×§×” ×©×œ ×”×§×©×¨ ×-A ×œ-B( ×‘ -sec / Bytes )×‘×–××Ÿ ×”× "×œ? × ××§×™.
]S*MSS / [lg (S) * RTT*2 ×‘×¢×¨×š .1
]S*MSS / [S^0.5 * RTT*2 ×‘×¢×¨×š .2
S*MSS / RTT ×‘×¢×¨×š .3
S^2)*MSS / RTT( ×‘×¢×¨×š .4
â— ×©×ª×™ ×ª×—× ×•×ª ××ª×§×©×¨×•×ª ×‘××•×¤×Ÿ ××œ×—×•×˜×™ ×‘×©×™×˜×ª N Back Go.
× ×¡××Ÿ ×‘-X ××ª ×¡×¤×¨×ª ×”×‘×™×§×•×¨×ª ×©×œ ×”×ª.×–. ×©×œ×š. ×× ×©× ×™ ×©×•×ª×¤×™× ××’×™×©×™× ××ª ×”×ª×¨×’×™×œ ×™×—×“, X ×”×•× ×¡×¤×¨×ª
×”×‘×™×§×•×¨×ª ×‘×¢×œ×ª ×”×¢×¨×š ×”× ××•×š ×™×•×ª×¨ ××‘×™×Ÿ ×”×©×ª×™×™×.
×§×¦×‘ ×”×ª×§×©×•×¨×ª ×”×•× 8Gbps, ×•×’×•×“×œ ×›×œ ×—×‘×™×œ×” ×”×•× KByte*X. ×’×“×œ×™ ×”-headers ×•×” -Acks ×–× ×™×—×™×.
ï¿½ğ‘’ğ‘ ï¿½/ï¿½ï¿½ 8 , ×•×”××¨×—×§ ×‘×™×Ÿ ×”×ª×—× ×•×ª ×”×•× 1Km. ×§×¦×‘ ×”×”×ª×¤×©×˜×•×ª ×”×•× 10 â‹… 2
×–××Ÿ ×¢×™×‘×•×“ ×”× ×ª×•× ×™× ×‘×ª×—× ×•×ª ×–× ×™×—.
××£ ×—×‘×™×œ×” ×•××£ Ack ×œ× ×”×•×œ×›×™× ×œ××™×‘×•×“.
â— ××”×• X ×©×œ×š?
â— ××” ×¦×¨×™×š ×œ×”×™×•×ª ×’×•×“×œ ×—×œ×•×Ÿ ×”××©×œ×•×— ×›×“×™ ×œ×”×‘×˜×™×— ×ª×¤×•×§×” ××§×¡×™××œ×™×ª?
 Communication Networks Course
Page | 9
Bonus â€“ Improving the Reliable UDP â€“ 15 points
Note: This part isnâ€™t mandatory and is a bonus only!
In this part, youâ€™ll improve your RUDP implementation by adding the concepts of flow
control and congestion control from TCP. Youâ€™re free to choose which algorithms to
implement, as long as you explain in your PDF which algorithms youâ€™ve used. Youâ€™ll probably
need to make changes in the original design of the RUDP. Changes only need to be to the API
itself, ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„.
Points distribution:
â€¢ Flow control improvement â€“ 7 Points
â€¢ Congestion control improvement â€“ 8 points.
Guidance:
â€¢ For flow control, you must use one of the Sliding window techniques: stop-and-wait
ARQ, Go-Back-N or Selective repeat.
â€¢ List of known TCP congestion control algorithms, which you can use any one of them
for this bonus task, or makeup your own:
Figure 2 â€“ List of known TCP congestion control algorithms, Wikipedia
 Communication Networks Course
Page | 10
Appendix A â€“ Linux local packet loss tool
To simulate a packet loss in a local network, we'll use a Linux tool that's called Linux Traffic
Control (ğ‘¡ğ‘). This requires a full Linux installation, so working with WSL won't work.
If the tool isn't installed in your machine, you can install it by using the following commands:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’
If the installation didn't work, you can use the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’2
To create a packet loss scenario, type the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘ğ‘‘ğ‘‘ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
After creating a packet loss scenario, you can change the percentage by typing the following
command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘â„ğ‘ğ‘›ğ‘”ğ‘’ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
To remove the packet loss scenario, write the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘‘ğ‘’ğ‘™ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š
 Communication Networks Course
Page | 11
Appendix B â€“ ğ’ğ’‚ğ’(ğŸ) system calls
This appendixâ€™s purpose is to give you a better understanding of socket handling in C.
A recommended reference is Beejâ€™s Guide to Network Programming, by Brian â€œBeej
Jorgensenâ€ Hall, which gives a lot of information about sockets in C and functions.
Functions and documentation links:
â€¢ ğ’”ğ’ğ’„ğ’Œğ’†ğ’•(ğŸ) â€“ A Factory method system call that creates a socket with the given
parameters.
â€¢ ğ’ƒğ’Šğ’ğ’…(ğŸ) â€“ Whenever we create a new socket, we need to bind it to a specific port in
our machine, â€œto catch a portâ€. The port number is managed and used by the kernel
to link incoming packets to the corresponding application socket. The port numbers
are usually fixed. The ğ‘ğ‘‘ğ‘‘ğ‘Ÿ parameter must match the current socket that is used.
â€¢ ğ’ğ’Šğ’”ğ’•ğ’†ğ’(ğŸ) â€“ The ğ‘™ğ‘–ğ‘ ğ‘¡ğ‘’ğ‘›(2) system call doesn't do anything in the mean of
communication but only memory allocation (malloc) for stream sockets only. If we
won't allocate memory, any incoming connection will fail.
â€¢ ğ’„ğ’ğ’ğ’ğ’†ğ’„ğ’•(ğŸ) â€“ The ğ‘ğ‘œğ‘›ğ‘›ğ‘’ğ‘ğ‘¡(2) system call starts the link between a client and a
specific IP address and port number. The connection would complete when the
other side will call the ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call.
â€¢ ğ’‚ğ’„ğ’„ğ’†ğ’‘ğ’•(ğŸ) â€“ The ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call accepts the incoming stream connection
request from the other side, by the listening socket. This system call completes the
three-way handshake of stream socket (like TCP) and opens a new socket that has a
direct communication channel only with the other party in the handshake.
â€¢ ğ’”ğ’†ğ’ğ’…(ğŸ) and ğ’”ğ’†ğ’ğ’…ğ’•ğ’(ğŸ) â€“ The ğ‘ ğ‘’ğ‘›ğ‘‘(2) and ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system calls are an analogy
for the ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’(2) system call, specifcly for sockets, with flags set to 0. Those system
calls return the number of bytes that were sent through the socket itself, as the
number of bytes can vary. The ğ‘ ğ‘’ğ‘›ğ‘‘(2)system call designed for stream sockets (like
TCP), while the ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system call designed for datagram connection-less
sockets (like UDP). When the ğ‘ ğ‘’ğ‘›ğ‘‘(2) system call returns 0, it means that the other
party closed the connection.
â€¢ ğ’“ğ’†ğ’„ğ’—(ğŸ) and ğ’“ğ’†ğ’„ğ’—ğ’‡ğ’“ğ’ğ’(ğŸ) â€“ The ğ‘Ÿğ‘’ğ‘ğ‘£(2) and ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system calls are an
analogy for the ğ‘Ÿğ‘’ğ‘ğ‘‘(2) system call, specifically for sockets, with flags set to 0.
Those system calls return the number of bytes that were received through the socket
itself, as the number of bytes can vary. The ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call designed for stream
sockets (like TCP), while the ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system call designed for datagram
connection-less sockets (like UDP). When the ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call returns 0, it means
that the other party closed the connection.
â€¢ ğ’„ğ’ğ’ğ’”ğ’†(ğŸ) and ğ’”ğ’‰ğ’–ğ’•ğ’…ğ’ğ’˜ğ’(ğŸ) â€“ The ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) and ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2) system calls close
the socket. While ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) system call closes the whole socket, the ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2)
system call partially closes the socket for read/write.
 Communication Networks Course
Page | 12
Appendix C â€“ Random data generator
The data that you are going to send in this assignment is randomly generated. You can use
your own file with appropriate size or use the following function (or a function of your own)
to generate the data:
/*
* @brief A random data generator function based on srand() and rand().
* @param size The size of the data to generate (up to 2^32 bytes).
* @return A pointer to the buffer.
*/
char *util_generate_random_data(unsigned int size) {
 char *buffer = NULL;
 // Argument check.
 if (size == 0)
 return NULL;
 buffer = (char *)calloc(size, sizeof(char));
 // Error checking.
 if (buffer == NULL)
 return NULL;
 // Randomize the seed of the random number generator.
 srand(time(NULL));
 for (unsigned int i = 0; i < size; i++)
 *(buffer + i) = ((unsigned int)rand() % 256);
 return buffer;
}
 Communication Networks Course
Page | 13
Appendix D â€“ Checksum function
A checksum is a small-sized block of data derived from another block of digital data for the
purpose of detecting errors that may have been introduced during its transmission or
storage. By themselves, checksums are often used to verify data integrity but are not relied
upon to verify data authenticity.
Below is a simple yet efficient implementation of the checksum function, you can use it for
the assignment, but you can implement your own checksum function.
/*
* @brief A checksum function that returns 16 bit checksum for data.
* @param data The data to do the checksum for.
* @param bytes The length of the data in bytes.
* @return The checksum itself as 16 bit unsigned number.
* @note This function is taken from RFC1071, can be found here:
* @note https://tools.ietf.org/html/rfc1071
* @note It is the simplest way to calculate a checksum and is not very strong.
* However, it is good enough for this assignment.
* @note You are free to use any other checksum function as well.
* You can also use this function as such without any change.
*/
unsigned short int calculate_checksum(void *data, unsigned int bytes) {
 unsigned short int *data_pointer = (unsigned short int *)data;
 unsigned int total_sum = 0;
 // Main summing loop
 while (bytes > 1) {
 total_sum += *data_pointer++;
 bytes -= 2;
 }
 // Add left-over byte, if any
 if (bytes > 0)
 total_sum += *((unsigned char *)data_pointer);
 // Fold 32-bit sum to 16 bits
 while (total_sum >> 16)
 total_sum = (total_sum & 0xFFFF) + (total_sum >> 16);
 return (~((unsigned short int)total_sum));
} Communication Networks Course
Page | 1
Assignment 3 â€“ Transport Layer
Assignment Notes and Instructions
This assignment is to be done in pairs only. You must upload all the necessary files in a ZIP
file named after both of the studentâ€™s ID. For example: ğŸğŸğŸ‘ğŸ’ğŸ“ğŸ”ğŸ•ğŸ–ğŸ—_ğŸ—ğŸ–ğŸ•ğŸ”ğŸ“ğŸ’ğŸ‘ğŸğŸ. ğ’›ğ’Šğ’‘.
1) The assignment must be submitted by the date specified in the submission box.
2) All the assignment files (Code, Wireshark pcap files, PDF) must be submitted in a ZIP file. The
PDF must contain all the necessary screenshots with a description for each one of them.
3) The assignment must be done in pairs only. In exceptional cases, you should send an email to
the course coordinator.
4) You can use any reference material available through the course Moodle website or any
material passed during the exercises.
5) You can use any reference from the web, but copying codes from websites is forbidden; this
includes codes from other GitHub repositories. A student who gets caught in the act will
automatically fail this assignment (score 0). Any website youâ€™ve used to solve the
assignment, every website you used to solve the assignment must be noted in the PDF.
6) No delays in submission without special permission. Lateness without approval will result in
failure of the assignment (score 0).
7) All submissions will be submitted via the course's Moodle website. Email submissions will not
be accepted, resulting in a failure in the assignment.
8) The order and design of the code must be carefully considered. Make sure that the program
output is as clear as possible, comments in the code, and meaningful variable names. You
must also submit a makefile that compiles all the programs.
9) The assignment code must be written in C only.
10) The assignment is personal for each pair, and you should not accept help from other people,
whether outside the university or inside it. You can contact the course staff during reception
hours for help or raise a question in the course forum. Do not transfer code sections
between students, upload solutions or parts of solutions to websites on the Internet or in
various communication groups.
11) Students who copy a solution will receive a 0 in all assignments in the course and a report will
be made to the institutional disciplinary committee.
12) All code files of the assignment are required to both compile and run properly on the Ubuntu
22.04 LTS operating system. This is the operating system where the submissions will be
tested. You mustnâ€™t code it in Windows, as it uses different API for sockets. WSL wonâ€™t work,
as the task needs a tool that works only in a fully Linux environment.
Good Luck!
 Communication Networks Course
Page | 2
Part A â€“ Transmission Control Protocol (TCP) â€“ 30 points
In this part, youâ€™ll write two program files: ğ‘»ğ‘ªğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and ğ‘»ğ‘ªğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
The Sender will send a randomly generated file and the Receiver will receive it and measure
the time it took for his program to receive the file. The file size should be at least 2MB.
When running the Sender and Receiver, they both should support two standard congestion
control algorithms: TCP Reno and TCP Cubic.
Notes:
â€¢ The main goal of this part is to get familiar with the TCP concept of sending
messages between two endpoints.
â€¢ For approaching this part of the assignment, please be sure that you are familiar
with the congestion control algorithms and how to change them using the correct
method in C (see Appendix B for more information).
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). You've
learned that TCP is reliable by design, so you can assume that all the data have been
passed correctly, and thus, no need to recheck.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
Usage:
â€¢ Receiver:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
â€¢ Sender:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port of the Receiver.
â€¢ ğ‘¨ğ‘³ğ‘®ğ‘¶ â€“ The TCP congestion control algorithm that will be used by the party
member (either ğ’“ğ’†ğ’ğ’ for TCP Reno or ğ’„ğ’–ğ’ƒğ’Šğ’„ for TCP Cubic).
 Communication Networks Course
Page | 3
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a TCP socket between the Sender and the
Receiver.
3) Send the file.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a TCP connection between the Receiver and
the Sender.
2) Get a connection from the sender.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./TCP_Receiver -p 1234 -algo reno
Starting Receiver...
Waiting for TCP connection...
Sender connected, beginning to receive file...
File transfer completed.
Waiting for Sender response...
Sender sent exit message.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 4
Part B â€“ Reliable User Datagram Protocol (Reliable UDP or RUDP) â€“ 40 points
Youâ€™ve learned that while TCP is reliable, it lacks speed and has an overhead data of 20 bytes,
compering to UDP that needs only 8 bytes of overhead data.
Reliable UDP or RUDP, is a protocol that uses the UDP protocol for a faster transmission of
data, while adding a reliability layer to it, but without adding too much overhead data like
TCP.
A simple sketch for a RUDP connection would look something like this:
Your task in this part is to implement a Reliable protocol using UDP only. For simplicity, your
implementation should only support a handshake, closing scheme, error checking,
acknowledgment of received packets, and retransmission of lost packets.
Guidance:
â€¢ You can use ğ‘ ğ‘’ğ‘¡ğ‘ ğ‘œğ‘ğ‘˜ğ‘œğ‘ğ‘¡(2) for detecting a timeout.
â€¢ You need to build your own protocol, as Reliable UDP isnâ€™t a standard protocol (see a
draft of RUDP in this link), and no official header is provided. You can use this sketch
for a header, but you can come up with your own protocol, as long as it works.
Where:
o ğ‘³ğ’†ğ’ğ’ˆğ’•ğ’‰ is the length of the data itself, without the RUDP header.
o ğ‘ªğ’‰ğ’†ğ’„ğ’Œğ’”ğ’–ğ’ is a 16bit number that validates the correctness of the data.
o ğ‘­ğ’ğ’‚ğ’ˆğ’” is a special byte where we classify the packet itself (SYN, ACK, etc.).
â€¢ In your PDF, you must explain how your implementation of RUDP works â€“ How does
it detect a timeout to do retransmissions, how does the handshake work, what is the
header overhead, etc.
â€¢ For this part, youâ€™ll write three files: ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¨ğ‘·ğ‘°. ğ’„, ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and
ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
Reliable UDP Header proposed sketch
Byte 0 Byte 1 Byte 2 Byte 3
Length (2 Bytes) Checksum (2 Bytes)
Flags (1 Byte)
Figure 1 - RUDP Protocol Architecture, Geeksforgeeks
 Communication Networks Course
Page | 5
Notes:
â€¢ The Sender will send a random generated file and the Receiver will receive it and
measure the time it took for his program to receive the file. The file size should be at
least 2MB.
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). But, as the
RUDP is based on UDP, itâ€™s not reliable. You must use some form of error checking
(like checksum) to ensure that the packet wasnâ€™t alerted during the transfer.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
â€¢ The RUDP needs support only 1 sender and 1 receiver, for simplicity purposes.
Usage:
â€¢ Receiver:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
â€¢ Sender:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port that both the Sender and the Receiver will use.
The ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„ file will contain all the implementations of the RUDP API functions (That is, to
prevent reusing the same chuck of code both in the Sender and the Receiver.).
The API should support at the bare minimum the following functions (you decide what
parameters to implement, and what are the names of the functions, as long as the API is
explained in the PDF):
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘œğ‘ğ‘˜ğ‘’ğ‘¡() â€“ Creating a RUDP socket and creating a handshake between two
peers.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘’ğ‘›ğ‘‘() â€“ Sending data to the peer. The function should wait for an
acknowledgment packet, and if it didnâ€™t receive any, retransmits the data.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘Ÿğ‘’ğ‘ğ‘£() â€“ Receive data from a peer.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ğ‘™ğ‘œğ‘ ğ‘’() â€“ Closes a connection between peers.
 Communication Networks Course
Page | 6
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a UDP socket between the Sender and the
Receiver.
3) Send the file via the RUDP protocol.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a UDP connection between the Receiver and
the Sender.
2) Get a connection from the sender, by the custom
RUDP protocol youâ€™ve built.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./RUDP_Receiver -p 1234
Starting Receiver...
Waiting for RUDP connection...
Connection request received, sending ACK.
Sender connected, beginning to receive file...
File transfer completed.
ACK sent.
Waiting for Sender response...
Sender sent exit message.
ACK sent.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 7
Part C â€“ Research â€“ 30 points
In this part, youâ€™ll conduct research about your implementations of part A and part B.
In the research itself, each one of the versions (TCP version and UDP version) will be run at
least 5 times (meaning that the file transfer will occur at least 5 times) by the following
conditions:
â€¢ For TCP, youâ€™ll run it in TCP Reno and TCP Cubic, alternating each time, for each
scenario, meaning that you run 5 times with TCP Reno in both Sender and Receiver,
and 5 times with TCP Cubic in both Sender and Receiver.
Bonus (5 points): Create a very large data set â€“ 5 times with TCP Reno in both Sender
and Receiver, 5 times with TCP Reno in Sender and TCP Cubic in Receiver, 5 times
with TCP Cubic in Sender and TCP Reno in Receiver, and 5 times with TCP Cubic in
both Sender and Receiver. This will give you a data set large enough, which allows
you to work with, compare with and to reach a definite conclusion.
â€¢ For RUDP, you will run it 5 times for each scenario.
â€¢ For both TCP and RUDP, you will run them on those scenarios of packet loss:
o 0% packet loss â€“ Control group, simulating perfect connection.
o 2% packet loss â€“ Simulating unstable connection that commonly occur.
o 5% packet loss â€“ Simulating bad connection.
o 10% packet loss â€“ Simulating extremely poor connection.
For each scenario, you must provide a filtered PCAP file and relevant screenshots that
explain each one of the steps in the process. (10 points)
After youâ€™ve gathered the data set for both TCP and Reliable UDP, answer the following
questions:
1) In TCP, which congestion control algorithm gave better results overall? TCP Reno or
TCP Cubic? Which one gave better results on high packet loss? Explain how you came
to this conclusion based on the data set youâ€™ve gathered. (5 points)
2) How did your implementation of Reliable UDP perform overall compared to regular
TCP? Which one is better for high packet loss? (5 points)
3) According to the data youâ€™ve gathered, in which scenarios and applications would we
prefer to use TCP and in which situations would we prefer to use reliable UDP?
Explain your answer. (5 points)
 Communication Networks Course
Page | 8
×¢× ×• ×¢×œ ×”×©××œ×•×ª ×”×‘××•×ª )5 × ×§×•×“×•×ª(:
â— ×‘"×¨×©×ª ×××™× ×”" ×”×›×•×•× ×” ×”×™× ×œ×¨×©×ª ×©×‘×” ××¢×˜ ×××•×“ ×—×‘×™×œ×•×ª ×”×•×œ×›×•×ª ×œ××™×‘×•×“. ×‘"×§×©×¨ ××¨×•×š" ×”×›×•×•× ×” ×”×™×
×œ×§×©×¨ TCP ×©×™×© ×‘×• ×”×¨×‘×” ×××•×“ ××™×“×¢ ×œ×©×œ×•×—. ××•×¦×¢ ×œ×”×’×“×™×œ ×‘ -TCP ××ª SSThreshold ×‘×ª×—×™×œ×ª ×”×§×©×¨.
×‘××™×–×” ××”××§×¨×™× ×”×‘××™× ×”×©×™× ×•×™ ×”×–×” ×¢×©×•×™ ×œ×”×•×¢×™×œ ×‘××™×“×” ×”××™×¨×‘×™×ª? × ××§.
.1 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
.2 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.3 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.4 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.5 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.6 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.7 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.8 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
â— A ×©×•×œ×— ×œ -B ×—×‘×™×œ×•×ª ××™×“×¢ ×‘×××¦×¢×•×ª ×§×©×¨ TCP. × ×ª×•×Ÿ ×›×™ ×”×§×©×¨ ××ª×—×™×œ ×¢× ×—×œ×•×Ÿ ×‘×’×•×“×œ 1MSS. ×”×§×©×¨
××¡×ª×™×™× ×‘×¤×¢× ×”×¨××©×•× ×” ×©×”×•× ××’×™×¢ ×œ -SSthresh. ×‘××”×œ×š ×”×§×©×¨ ×œ× ××•×‘×“×•×ª ×—×‘×™×œ×•×ª. × ×¡××Ÿ ×‘×§×™×¦×•×¨:
.SSthresh=S*MSS
× ×ª×•×Ÿ ×›×™ ×œ××•×¨×š ×›×œ ×”×§×©×¨ rwnd < MSS*S.
××”×™ ×”×ª×¤×•×§×” ×©×œ ×”×§×©×¨ ×-A ×œ-B( ×‘ -sec / Bytes )×‘×–××Ÿ ×”× "×œ? × ××§×™.
]S*MSS / [lg (S) * RTT*2 ×‘×¢×¨×š .1
]S*MSS / [S^0.5 * RTT*2 ×‘×¢×¨×š .2
S*MSS / RTT ×‘×¢×¨×š .3
S^2)*MSS / RTT( ×‘×¢×¨×š .4
â— ×©×ª×™ ×ª×—× ×•×ª ××ª×§×©×¨×•×ª ×‘××•×¤×Ÿ ××œ×—×•×˜×™ ×‘×©×™×˜×ª N Back Go.
× ×¡××Ÿ ×‘-X ××ª ×¡×¤×¨×ª ×”×‘×™×§×•×¨×ª ×©×œ ×”×ª.×–. ×©×œ×š. ×× ×©× ×™ ×©×•×ª×¤×™× ××’×™×©×™× ××ª ×”×ª×¨×’×™×œ ×™×—×“, X ×”×•× ×¡×¤×¨×ª
×”×‘×™×§×•×¨×ª ×‘×¢×œ×ª ×”×¢×¨×š ×”× ××•×š ×™×•×ª×¨ ××‘×™×Ÿ ×”×©×ª×™×™×.
×§×¦×‘ ×”×ª×§×©×•×¨×ª ×”×•× 8Gbps, ×•×’×•×“×œ ×›×œ ×—×‘×™×œ×” ×”×•× KByte*X. ×’×“×œ×™ ×”-headers ×•×” -Acks ×–× ×™×—×™×.
ï¿½ğ‘’ğ‘ ï¿½/ï¿½ï¿½ 8 , ×•×”××¨×—×§ ×‘×™×Ÿ ×”×ª×—× ×•×ª ×”×•× 1Km. ×§×¦×‘ ×”×”×ª×¤×©×˜×•×ª ×”×•× 10 â‹… 2
×–××Ÿ ×¢×™×‘×•×“ ×”× ×ª×•× ×™× ×‘×ª×—× ×•×ª ×–× ×™×—.
××£ ×—×‘×™×œ×” ×•××£ Ack ×œ× ×”×•×œ×›×™× ×œ××™×‘×•×“.
â— ××”×• X ×©×œ×š?
â— ××” ×¦×¨×™×š ×œ×”×™×•×ª ×’×•×“×œ ×—×œ×•×Ÿ ×”××©×œ×•×— ×›×“×™ ×œ×”×‘×˜×™×— ×ª×¤×•×§×” ××§×¡×™××œ×™×ª?
 Communication Networks Course
Page | 9
Bonus â€“ Improving the Reliable UDP â€“ 15 points
Note: This part isnâ€™t mandatory and is a bonus only!
In this part, youâ€™ll improve your RUDP implementation by adding the concepts of flow
control and congestion control from TCP. Youâ€™re free to choose which algorithms to
implement, as long as you explain in your PDF which algorithms youâ€™ve used. Youâ€™ll probably
need to make changes in the original design of the RUDP. Changes only need to be to the API
itself, ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„.
Points distribution:
â€¢ Flow control improvement â€“ 7 Points
â€¢ Congestion control improvement â€“ 8 points.
Guidance:
â€¢ For flow control, you must use one of the Sliding window techniques: stop-and-wait
ARQ, Go-Back-N or Selective repeat.
â€¢ List of known TCP congestion control algorithms, which you can use any one of them
for this bonus task, or makeup your own:
Figure 2 â€“ List of known TCP congestion control algorithms, Wikipedia
 Communication Networks Course
Page | 10
Appendix A â€“ Linux local packet loss tool
To simulate a packet loss in a local network, we'll use a Linux tool that's called Linux Traffic
Control (ğ‘¡ğ‘). This requires a full Linux installation, so working with WSL won't work.
If the tool isn't installed in your machine, you can install it by using the following commands:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’
If the installation didn't work, you can use the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’2
To create a packet loss scenario, type the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘ğ‘‘ğ‘‘ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
After creating a packet loss scenario, you can change the percentage by typing the following
command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘â„ğ‘ğ‘›ğ‘”ğ‘’ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
To remove the packet loss scenario, write the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘‘ğ‘’ğ‘™ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š
 Communication Networks Course
Page | 11
Appendix B â€“ ğ’ğ’‚ğ’(ğŸ) system calls
This appendixâ€™s purpose is to give you a better understanding of socket handling in C.
A recommended reference is Beejâ€™s Guide to Network Programming, by Brian â€œBeej
Jorgensenâ€ Hall, which gives a lot of information about sockets in C and functions.
Functions and documentation links:
â€¢ ğ’”ğ’ğ’„ğ’Œğ’†ğ’•(ğŸ) â€“ A Factory method system call that creates a socket with the given
parameters.
â€¢ ğ’ƒğ’Šğ’ğ’…(ğŸ) â€“ Whenever we create a new socket, we need to bind it to a specific port in
our machine, â€œto catch a portâ€. The port number is managed and used by the kernel
to link incoming packets to the corresponding application socket. The port numbers
are usually fixed. The ğ‘ğ‘‘ğ‘‘ğ‘Ÿ parameter must match the current socket that is used.
â€¢ ğ’ğ’Šğ’”ğ’•ğ’†ğ’(ğŸ) â€“ The ğ‘™ğ‘–ğ‘ ğ‘¡ğ‘’ğ‘›(2) system call doesn't do anything in the mean of
communication but only memory allocation (malloc) for stream sockets only. If we
won't allocate memory, any incoming connection will fail.
â€¢ ğ’„ğ’ğ’ğ’ğ’†ğ’„ğ’•(ğŸ) â€“ The ğ‘ğ‘œğ‘›ğ‘›ğ‘’ğ‘ğ‘¡(2) system call starts the link between a client and a
specific IP address and port number. The connection would complete when the
other side will call the ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call.
â€¢ ğ’‚ğ’„ğ’„ğ’†ğ’‘ğ’•(ğŸ) â€“ The ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call accepts the incoming stream connection
request from the other side, by the listening socket. This system call completes the
three-way handshake of stream socket (like TCP) and opens a new socket that has a
direct communication channel only with the other party in the handshake.
â€¢ ğ’”ğ’†ğ’ğ’…(ğŸ) and ğ’”ğ’†ğ’ğ’…ğ’•ğ’(ğŸ) â€“ The ğ‘ ğ‘’ğ‘›ğ‘‘(2) and ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system calls are an analogy
for the ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’(2) system call, specifcly for sockets, with flags set to 0. Those system
calls return the number of bytes that were sent through the socket itself, as the
number of bytes can vary. The ğ‘ ğ‘’ğ‘›ğ‘‘(2)system call designed for stream sockets (like
TCP), while the ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system call designed for datagram connection-less
sockets (like UDP). When the ğ‘ ğ‘’ğ‘›ğ‘‘(2) system call returns 0, it means that the other
party closed the connection.
â€¢ ğ’“ğ’†ğ’„ğ’—(ğŸ) and ğ’“ğ’†ğ’„ğ’—ğ’‡ğ’“ğ’ğ’(ğŸ) â€“ The ğ‘Ÿğ‘’ğ‘ğ‘£(2) and ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system calls are an
analogy for the ğ‘Ÿğ‘’ğ‘ğ‘‘(2) system call, specifically for sockets, with flags set to 0.
Those system calls return the number of bytes that were received through the socket
itself, as the number of bytes can vary. The ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call designed for stream
sockets (like TCP), while the ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system call designed for datagram
connection-less sockets (like UDP). When the ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call returns 0, it means
that the other party closed the connection.
â€¢ ğ’„ğ’ğ’ğ’”ğ’†(ğŸ) and ğ’”ğ’‰ğ’–ğ’•ğ’…ğ’ğ’˜ğ’(ğŸ) â€“ The ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) and ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2) system calls close
the socket. While ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) system call closes the whole socket, the ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2)
system call partially closes the socket for read/write.
 Communication Networks Course
Page | 12
Appendix C â€“ Random data generator
The data that you are going to send in this assignment is randomly generated. You can use
your own file with appropriate size or use the following function (or a function of your own)
to generate the data:
/*
* @brief A random data generator function based on srand() and rand().
* @param size The size of the data to generate (up to 2^32 bytes).
* @return A pointer to the buffer.
*/
char *util_generate_random_data(unsigned int size) {
 char *buffer = NULL;
 // Argument check.
 if (size == 0)
 return NULL;
 buffer = (char *)calloc(size, sizeof(char));
 // Error checking.
 if (buffer == NULL)
 return NULL;
 // Randomize the seed of the random number generator.
 srand(time(NULL));
 for (unsigned int i = 0; i < size; i++)
 *(buffer + i) = ((unsigned int)rand() % 256);
 return buffer;
}
 Communication Networks Course
Page | 13
Appendix D â€“ Checksum function
A checksum is a small-sized block of data derived from another block of digital data for the
purpose of detecting errors that may have been introduced during its transmission or
storage. By themselves, checksums are often used to verify data integrity but are not relied
upon to verify data authenticity.
Below is a simple yet efficient implementation of the checksum function, you can use it for
the assignment, but you can implement your own checksum function.
/*
* @brief A checksum function that returns 16 bit checksum for data.
* @param data The data to do the checksum for.
* @param bytes The length of the data in bytes.
* @return The checksum itself as 16 bit unsigned number.
* @note This function is taken from RFC1071, can be found here:
* @note https://tools.ietf.org/html/rfc1071
* @note It is the simplest way to calculate a checksum and is not very strong.
* However, it is good enough for this assignment.
* @note You are free to use any other checksum function as well.
* You can also use this function as such without any change.
*/
unsigned short int calculate_checksum(void *data, unsigned int bytes) {
 unsigned short int *data_pointer = (unsigned short int *)data;
 unsigned int total_sum = 0;
 // Main summing loop
 while (bytes > 1) {
 total_sum += *data_pointer++;
 bytes -= 2;
 }
 // Add left-over byte, if any
 if (bytes > 0)
 total_sum += *((unsigned char *)data_pointer);
 // Fold 32-bit sum to 16 bits
 while (total_sum >> 16)
 total_sum = (total_sum & 0xFFFF) + (total_sum >> 16);
 return (~((unsigned short int)total_sum));
} Communication Networks Course
Page | 1
Assignment 3 â€“ Transport Layer
Assignment Notes and Instructions
This assignment is to be done in pairs only. You must upload all the necessary files in a ZIP
file named after both of the studentâ€™s ID. For example: ğŸğŸğŸ‘ğŸ’ğŸ“ğŸ”ğŸ•ğŸ–ğŸ—_ğŸ—ğŸ–ğŸ•ğŸ”ğŸ“ğŸ’ğŸ‘ğŸğŸ. ğ’›ğ’Šğ’‘.
1) The assignment must be submitted by the date specified in the submission box.
2) All the assignment files (Code, Wireshark pcap files, PDF) must be submitted in a ZIP file. The
PDF must contain all the necessary screenshots with a description for each one of them.
3) The assignment must be done in pairs only. In exceptional cases, you should send an email to
the course coordinator.
4) You can use any reference material available through the course Moodle website or any
material passed during the exercises.
5) You can use any reference from the web, but copying codes from websites is forbidden; this
includes codes from other GitHub repositories. A student who gets caught in the act will
automatically fail this assignment (score 0). Any website youâ€™ve used to solve the
assignment, every website you used to solve the assignment must be noted in the PDF.
6) No delays in submission without special permission. Lateness without approval will result in
failure of the assignment (score 0).
7) All submissions will be submitted via the course's Moodle website. Email submissions will not
be accepted, resulting in a failure in the assignment.
8) The order and design of the code must be carefully considered. Make sure that the program
output is as clear as possible, comments in the code, and meaningful variable names. You
must also submit a makefile that compiles all the programs.
9) The assignment code must be written in C only.
10) The assignment is personal for each pair, and you should not accept help from other people,
whether outside the university or inside it. You can contact the course staff during reception
hours for help or raise a question in the course forum. Do not transfer code sections
between students, upload solutions or parts of solutions to websites on the Internet or in
various communication groups.
11) Students who copy a solution will receive a 0 in all assignments in the course and a report will
be made to the institutional disciplinary committee.
12) All code files of the assignment are required to both compile and run properly on the Ubuntu
22.04 LTS operating system. This is the operating system where the submissions will be
tested. You mustnâ€™t code it in Windows, as it uses different API for sockets. WSL wonâ€™t work,
as the task needs a tool that works only in a fully Linux environment.
Good Luck!
 Communication Networks Course
Page | 2
Part A â€“ Transmission Control Protocol (TCP) â€“ 30 points
In this part, youâ€™ll write two program files: ğ‘»ğ‘ªğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and ğ‘»ğ‘ªğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
The Sender will send a randomly generated file and the Receiver will receive it and measure
the time it took for his program to receive the file. The file size should be at least 2MB.
When running the Sender and Receiver, they both should support two standard congestion
control algorithms: TCP Reno and TCP Cubic.
Notes:
â€¢ The main goal of this part is to get familiar with the TCP concept of sending
messages between two endpoints.
â€¢ For approaching this part of the assignment, please be sure that you are familiar
with the congestion control algorithms and how to change them using the correct
method in C (see Appendix B for more information).
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). You've
learned that TCP is reliable by design, so you can assume that all the data have been
passed correctly, and thus, no need to recheck.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
Usage:
â€¢ Receiver:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
â€¢ Sender:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port of the Receiver.
â€¢ ğ‘¨ğ‘³ğ‘®ğ‘¶ â€“ The TCP congestion control algorithm that will be used by the party
member (either ğ’“ğ’†ğ’ğ’ for TCP Reno or ğ’„ğ’–ğ’ƒğ’Šğ’„ for TCP Cubic).
 Communication Networks Course
Page | 3
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a TCP socket between the Sender and the
Receiver.
3) Send the file.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a TCP connection between the Receiver and
the Sender.
2) Get a connection from the sender.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./TCP_Receiver -p 1234 -algo reno
Starting Receiver...
Waiting for TCP connection...
Sender connected, beginning to receive file...
File transfer completed.
Waiting for Sender response...
Sender sent exit message.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 4
Part B â€“ Reliable User Datagram Protocol (Reliable UDP or RUDP) â€“ 40 points
Youâ€™ve learned that while TCP is reliable, it lacks speed and has an overhead data of 20 bytes,
compering to UDP that needs only 8 bytes of overhead data.
Reliable UDP or RUDP, is a protocol that uses the UDP protocol for a faster transmission of
data, while adding a reliability layer to it, but without adding too much overhead data like
TCP.
A simple sketch for a RUDP connection would look something like this:
Your task in this part is to implement a Reliable protocol using UDP only. For simplicity, your
implementation should only support a handshake, closing scheme, error checking,
acknowledgment of received packets, and retransmission of lost packets.
Guidance:
â€¢ You can use ğ‘ ğ‘’ğ‘¡ğ‘ ğ‘œğ‘ğ‘˜ğ‘œğ‘ğ‘¡(2) for detecting a timeout.
â€¢ You need to build your own protocol, as Reliable UDP isnâ€™t a standard protocol (see a
draft of RUDP in this link), and no official header is provided. You can use this sketch
for a header, but you can come up with your own protocol, as long as it works.
Where:
o ğ‘³ğ’†ğ’ğ’ˆğ’•ğ’‰ is the length of the data itself, without the RUDP header.
o ğ‘ªğ’‰ğ’†ğ’„ğ’Œğ’”ğ’–ğ’ is a 16bit number that validates the correctness of the data.
o ğ‘­ğ’ğ’‚ğ’ˆğ’” is a special byte where we classify the packet itself (SYN, ACK, etc.).
â€¢ In your PDF, you must explain how your implementation of RUDP works â€“ How does
it detect a timeout to do retransmissions, how does the handshake work, what is the
header overhead, etc.
â€¢ For this part, youâ€™ll write three files: ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¨ğ‘·ğ‘°. ğ’„, ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and
ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
Reliable UDP Header proposed sketch
Byte 0 Byte 1 Byte 2 Byte 3
Length (2 Bytes) Checksum (2 Bytes)
Flags (1 Byte)
Figure 1 - RUDP Protocol Architecture, Geeksforgeeks
 Communication Networks Course
Page | 5
Notes:
â€¢ The Sender will send a random generated file and the Receiver will receive it and
measure the time it took for his program to receive the file. The file size should be at
least 2MB.
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). But, as the
RUDP is based on UDP, itâ€™s not reliable. You must use some form of error checking
(like checksum) to ensure that the packet wasnâ€™t alerted during the transfer.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
â€¢ The RUDP needs support only 1 sender and 1 receiver, for simplicity purposes.
Usage:
â€¢ Receiver:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
â€¢ Sender:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port that both the Sender and the Receiver will use.
The ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„ file will contain all the implementations of the RUDP API functions (That is, to
prevent reusing the same chuck of code both in the Sender and the Receiver.).
The API should support at the bare minimum the following functions (you decide what
parameters to implement, and what are the names of the functions, as long as the API is
explained in the PDF):
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘œğ‘ğ‘˜ğ‘’ğ‘¡() â€“ Creating a RUDP socket and creating a handshake between two
peers.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘’ğ‘›ğ‘‘() â€“ Sending data to the peer. The function should wait for an
acknowledgment packet, and if it didnâ€™t receive any, retransmits the data.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘Ÿğ‘’ğ‘ğ‘£() â€“ Receive data from a peer.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ğ‘™ğ‘œğ‘ ğ‘’() â€“ Closes a connection between peers.
 Communication Networks Course
Page | 6
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a UDP socket between the Sender and the
Receiver.
3) Send the file via the RUDP protocol.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a UDP connection between the Receiver and
the Sender.
2) Get a connection from the sender, by the custom
RUDP protocol youâ€™ve built.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./RUDP_Receiver -p 1234
Starting Receiver...
Waiting for RUDP connection...
Connection request received, sending ACK.
Sender connected, beginning to receive file...
File transfer completed.
ACK sent.
Waiting for Sender response...
Sender sent exit message.
ACK sent.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 7
Part C â€“ Research â€“ 30 points
In this part, youâ€™ll conduct research about your implementations of part A and part B.
In the research itself, each one of the versions (TCP version and UDP version) will be run at
least 5 times (meaning that the file transfer will occur at least 5 times) by the following
conditions:
â€¢ For TCP, youâ€™ll run it in TCP Reno and TCP Cubic, alternating each time, for each
scenario, meaning that you run 5 times with TCP Reno in both Sender and Receiver,
and 5 times with TCP Cubic in both Sender and Receiver.
Bonus (5 points): Create a very large data set â€“ 5 times with TCP Reno in both Sender
and Receiver, 5 times with TCP Reno in Sender and TCP Cubic in Receiver, 5 times
with TCP Cubic in Sender and TCP Reno in Receiver, and 5 times with TCP Cubic in
both Sender and Receiver. This will give you a data set large enough, which allows
you to work with, compare with and to reach a definite conclusion.
â€¢ For RUDP, you will run it 5 times for each scenario.
â€¢ For both TCP and RUDP, you will run them on those scenarios of packet loss:
o 0% packet loss â€“ Control group, simulating perfect connection.
o 2% packet loss â€“ Simulating unstable connection that commonly occur.
o 5% packet loss â€“ Simulating bad connection.
o 10% packet loss â€“ Simulating extremely poor connection.
For each scenario, you must provide a filtered PCAP file and relevant screenshots that
explain each one of the steps in the process. (10 points)
After youâ€™ve gathered the data set for both TCP and Reliable UDP, answer the following
questions:
1) In TCP, which congestion control algorithm gave better results overall? TCP Reno or
TCP Cubic? Which one gave better results on high packet loss? Explain how you came
to this conclusion based on the data set youâ€™ve gathered. (5 points)
2) How did your implementation of Reliable UDP perform overall compared to regular
TCP? Which one is better for high packet loss? (5 points)
3) According to the data youâ€™ve gathered, in which scenarios and applications would we
prefer to use TCP and in which situations would we prefer to use reliable UDP?
Explain your answer. (5 points)
 Communication Networks Course
Page | 8
×¢× ×• ×¢×œ ×”×©××œ×•×ª ×”×‘××•×ª )5 × ×§×•×“×•×ª(:
â— ×‘"×¨×©×ª ×××™× ×”" ×”×›×•×•× ×” ×”×™× ×œ×¨×©×ª ×©×‘×” ××¢×˜ ×××•×“ ×—×‘×™×œ×•×ª ×”×•×œ×›×•×ª ×œ××™×‘×•×“. ×‘"×§×©×¨ ××¨×•×š" ×”×›×•×•× ×” ×”×™×
×œ×§×©×¨ TCP ×©×™×© ×‘×• ×”×¨×‘×” ×××•×“ ××™×“×¢ ×œ×©×œ×•×—. ××•×¦×¢ ×œ×”×’×“×™×œ ×‘ -TCP ××ª SSThreshold ×‘×ª×—×™×œ×ª ×”×§×©×¨.
×‘××™×–×” ××”××§×¨×™× ×”×‘××™× ×”×©×™× ×•×™ ×”×–×” ×¢×©×•×™ ×œ×”×•×¢×™×œ ×‘××™×“×” ×”××™×¨×‘×™×ª? × ××§.
.1 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
.2 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.3 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.4 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.5 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.6 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.7 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.8 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
â— A ×©×•×œ×— ×œ -B ×—×‘×™×œ×•×ª ××™×“×¢ ×‘×××¦×¢×•×ª ×§×©×¨ TCP. × ×ª×•×Ÿ ×›×™ ×”×§×©×¨ ××ª×—×™×œ ×¢× ×—×œ×•×Ÿ ×‘×’×•×“×œ 1MSS. ×”×§×©×¨
××¡×ª×™×™× ×‘×¤×¢× ×”×¨××©×•× ×” ×©×”×•× ××’×™×¢ ×œ -SSthresh. ×‘××”×œ×š ×”×§×©×¨ ×œ× ××•×‘×“×•×ª ×—×‘×™×œ×•×ª. × ×¡××Ÿ ×‘×§×™×¦×•×¨:
.SSthresh=S*MSS
× ×ª×•×Ÿ ×›×™ ×œ××•×¨×š ×›×œ ×”×§×©×¨ rwnd < MSS*S.
××”×™ ×”×ª×¤×•×§×” ×©×œ ×”×§×©×¨ ×-A ×œ-B( ×‘ -sec / Bytes )×‘×–××Ÿ ×”× "×œ? × ××§×™.
]S*MSS / [lg (S) * RTT*2 ×‘×¢×¨×š .1
]S*MSS / [S^0.5 * RTT*2 ×‘×¢×¨×š .2
S*MSS / RTT ×‘×¢×¨×š .3
S^2)*MSS / RTT( ×‘×¢×¨×š .4
â— ×©×ª×™ ×ª×—× ×•×ª ××ª×§×©×¨×•×ª ×‘××•×¤×Ÿ ××œ×—×•×˜×™ ×‘×©×™×˜×ª N Back Go.
× ×¡××Ÿ ×‘-X ××ª ×¡×¤×¨×ª ×”×‘×™×§×•×¨×ª ×©×œ ×”×ª.×–. ×©×œ×š. ×× ×©× ×™ ×©×•×ª×¤×™× ××’×™×©×™× ××ª ×”×ª×¨×’×™×œ ×™×—×“, X ×”×•× ×¡×¤×¨×ª
×”×‘×™×§×•×¨×ª ×‘×¢×œ×ª ×”×¢×¨×š ×”× ××•×š ×™×•×ª×¨ ××‘×™×Ÿ ×”×©×ª×™×™×.
×§×¦×‘ ×”×ª×§×©×•×¨×ª ×”×•× 8Gbps, ×•×’×•×“×œ ×›×œ ×—×‘×™×œ×” ×”×•× KByte*X. ×’×“×œ×™ ×”-headers ×•×” -Acks ×–× ×™×—×™×.
ï¿½ğ‘’ğ‘ ï¿½/ï¿½ï¿½ 8 , ×•×”××¨×—×§ ×‘×™×Ÿ ×”×ª×—× ×•×ª ×”×•× 1Km. ×§×¦×‘ ×”×”×ª×¤×©×˜×•×ª ×”×•× 10 â‹… 2
×–××Ÿ ×¢×™×‘×•×“ ×”× ×ª×•× ×™× ×‘×ª×—× ×•×ª ×–× ×™×—.
××£ ×—×‘×™×œ×” ×•××£ Ack ×œ× ×”×•×œ×›×™× ×œ××™×‘×•×“.
â— ××”×• X ×©×œ×š?
â— ××” ×¦×¨×™×š ×œ×”×™×•×ª ×’×•×“×œ ×—×œ×•×Ÿ ×”××©×œ×•×— ×›×“×™ ×œ×”×‘×˜×™×— ×ª×¤×•×§×” ××§×¡×™××œ×™×ª?
 Communication Networks Course
Page | 9
Bonus â€“ Improving the Reliable UDP â€“ 15 points
Note: This part isnâ€™t mandatory and is a bonus only!
In this part, youâ€™ll improve your RUDP implementation by adding the concepts of flow
control and congestion control from TCP. Youâ€™re free to choose which algorithms to
implement, as long as you explain in your PDF which algorithms youâ€™ve used. Youâ€™ll probably
need to make changes in the original design of the RUDP. Changes only need to be to the API
itself, ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„.
Points distribution:
â€¢ Flow control improvement â€“ 7 Points
â€¢ Congestion control improvement â€“ 8 points.
Guidance:
â€¢ For flow control, you must use one of the Sliding window techniques: stop-and-wait
ARQ, Go-Back-N or Selective repeat.
â€¢ List of known TCP congestion control algorithms, which you can use any one of them
for this bonus task, or makeup your own:
Figure 2 â€“ List of known TCP congestion control algorithms, Wikipedia
 Communication Networks Course
Page | 10
Appendix A â€“ Linux local packet loss tool
To simulate a packet loss in a local network, we'll use a Linux tool that's called Linux Traffic
Control (ğ‘¡ğ‘). This requires a full Linux installation, so working with WSL won't work.
If the tool isn't installed in your machine, you can install it by using the following commands:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’
If the installation didn't work, you can use the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’2
To create a packet loss scenario, type the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘ğ‘‘ğ‘‘ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
After creating a packet loss scenario, you can change the percentage by typing the following
command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘â„ğ‘ğ‘›ğ‘”ğ‘’ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
To remove the packet loss scenario, write the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘‘ğ‘’ğ‘™ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š
 Communication Networks Course
Page | 11
Appendix B â€“ ğ’ğ’‚ğ’(ğŸ) system calls
This appendixâ€™s purpose is to give you a better understanding of socket handling in C.
A recommended reference is Beejâ€™s Guide to Network Programming, by Brian â€œBeej
Jorgensenâ€ Hall, which gives a lot of information about sockets in C and functions.
Functions and documentation links:
â€¢ ğ’”ğ’ğ’„ğ’Œğ’†ğ’•(ğŸ) â€“ A Factory method system call that creates a socket with the given
parameters.
â€¢ ğ’ƒğ’Šğ’ğ’…(ğŸ) â€“ Whenever we create a new socket, we need to bind it to a specific port in
our machine, â€œto catch a portâ€. The port number is managed and used by the kernel
to link incoming packets to the corresponding application socket. The port numbers
are usually fixed. The ğ‘ğ‘‘ğ‘‘ğ‘Ÿ parameter must match the current socket that is used.
â€¢ ğ’ğ’Šğ’”ğ’•ğ’†ğ’(ğŸ) â€“ The ğ‘™ğ‘–ğ‘ ğ‘¡ğ‘’ğ‘›(2) system call doesn't do anything in the mean of
communication but only memory allocation (malloc) for stream sockets only. If we
won't allocate memory, any incoming connection will fail.
â€¢ ğ’„ğ’ğ’ğ’ğ’†ğ’„ğ’•(ğŸ) â€“ The ğ‘ğ‘œğ‘›ğ‘›ğ‘’ğ‘ğ‘¡(2) system call starts the link between a client and a
specific IP address and port number. The connection would complete when the
other side will call the ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call.
â€¢ ğ’‚ğ’„ğ’„ğ’†ğ’‘ğ’•(ğŸ) â€“ The ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call accepts the incoming stream connection
request from the other side, by the listening socket. This system call completes the
three-way handshake of stream socket (like TCP) and opens a new socket that has a
direct communication channel only with the other party in the handshake.
â€¢ ğ’”ğ’†ğ’ğ’…(ğŸ) and ğ’”ğ’†ğ’ğ’…ğ’•ğ’(ğŸ) â€“ The ğ‘ ğ‘’ğ‘›ğ‘‘(2) and ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system calls are an analogy
for the ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’(2) system call, specifcly for sockets, with flags set to 0. Those system
calls return the number of bytes that were sent through the socket itself, as the
number of bytes can vary. The ğ‘ ğ‘’ğ‘›ğ‘‘(2)system call designed for stream sockets (like
TCP), while the ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system call designed for datagram connection-less
sockets (like UDP). When the ğ‘ ğ‘’ğ‘›ğ‘‘(2) system call returns 0, it means that the other
party closed the connection.
â€¢ ğ’“ğ’†ğ’„ğ’—(ğŸ) and ğ’“ğ’†ğ’„ğ’—ğ’‡ğ’“ğ’ğ’(ğŸ) â€“ The ğ‘Ÿğ‘’ğ‘ğ‘£(2) and ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system calls are an
analogy for the ğ‘Ÿğ‘’ğ‘ğ‘‘(2) system call, specifically for sockets, with flags set to 0.
Those system calls return the number of bytes that were received through the socket
itself, as the number of bytes can vary. The ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call designed for stream
sockets (like TCP), while the ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system call designed for datagram
connection-less sockets (like UDP). When the ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call returns 0, it means
that the other party closed the connection.
â€¢ ğ’„ğ’ğ’ğ’”ğ’†(ğŸ) and ğ’”ğ’‰ğ’–ğ’•ğ’…ğ’ğ’˜ğ’(ğŸ) â€“ The ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) and ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2) system calls close
the socket. While ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) system call closes the whole socket, the ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2)
system call partially closes the socket for read/write.
 Communication Networks Course
Page | 12
Appendix C â€“ Random data generator
The data that you are going to send in this assignment is randomly generated. You can use
your own file with appropriate size or use the following function (or a function of your own)
to generate the data:
/*
* @brief A random data generator function based on srand() and rand().
* @param size The size of the data to generate (up to 2^32 bytes).
* @return A pointer to the buffer.
*/
char *util_generate_random_data(unsigned int size) {
 char *buffer = NULL;
 // Argument check.
 if (size == 0)
 return NULL;
 buffer = (char *)calloc(size, sizeof(char));
 // Error checking.
 if (buffer == NULL)
 return NULL;
 // Randomize the seed of the random number generator.
 srand(time(NULL));
 for (unsigned int i = 0; i < size; i++)
 *(buffer + i) = ((unsigned int)rand() % 256);
 return buffer;
}
 Communication Networks Course
Page | 13
Appendix D â€“ Checksum function
A checksum is a small-sized block of data derived from another block of digital data for the
purpose of detecting errors that may have been introduced during its transmission or
storage. By themselves, checksums are often used to verify data integrity but are not relied
upon to verify data authenticity.
Below is a simple yet efficient implementation of the checksum function, you can use it for
the assignment, but you can implement your own checksum function.
/*
* @brief A checksum function that returns 16 bit checksum for data.
* @param data The data to do the checksum for.
* @param bytes The length of the data in bytes.
* @return The checksum itself as 16 bit unsigned number.
* @note This function is taken from RFC1071, can be found here:
* @note https://tools.ietf.org/html/rfc1071
* @note It is the simplest way to calculate a checksum and is not very strong.
* However, it is good enough for this assignment.
* @note You are free to use any other checksum function as well.
* You can also use this function as such without any change.
*/
unsigned short int calculate_checksum(void *data, unsigned int bytes) {
 unsigned short int *data_pointer = (unsigned short int *)data;
 unsigned int total_sum = 0;
 // Main summing loop
 while (bytes > 1) {
 total_sum += *data_pointer++;
 bytes -= 2;
 }
 // Add left-over byte, if any
 if (bytes > 0)
 total_sum += *((unsigned char *)data_pointer);
 // Fold 32-bit sum to 16 bits
 while (total_sum >> 16)
 total_sum = (total_sum & 0xFFFF) + (total_sum >> 16);
 return (~((unsigned short int)total_sum));
} Communication Networks Course
Page | 1
Assignment 3 â€“ Transport Layer
Assignment Notes and Instructions
This assignment is to be done in pairs only. You must upload all the necessary files in a ZIP
file named after both of the studentâ€™s ID. For example: ğŸğŸğŸ‘ğŸ’ğŸ“ğŸ”ğŸ•ğŸ–ğŸ—_ğŸ—ğŸ–ğŸ•ğŸ”ğŸ“ğŸ’ğŸ‘ğŸğŸ. ğ’›ğ’Šğ’‘.
1) The assignment must be submitted by the date specified in the submission box.
2) All the assignment files (Code, Wireshark pcap files, PDF) must be submitted in a ZIP file. The
PDF must contain all the necessary screenshots with a description for each one of them.
3) The assignment must be done in pairs only. In exceptional cases, you should send an email to
the course coordinator.
4) You can use any reference material available through the course Moodle website or any
material passed during the exercises.
5) You can use any reference from the web, but copying codes from websites is forbidden; this
includes codes from other GitHub repositories. A student who gets caught in the act will
automatically fail this assignment (score 0). Any website youâ€™ve used to solve the
assignment, every website you used to solve the assignment must be noted in the PDF.
6) No delays in submission without special permission. Lateness without approval will result in
failure of the assignment (score 0).
7) All submissions will be submitted via the course's Moodle website. Email submissions will not
be accepted, resulting in a failure in the assignment.
8) The order and design of the code must be carefully considered. Make sure that the program
output is as clear as possible, comments in the code, and meaningful variable names. You
must also submit a makefile that compiles all the programs.
9) The assignment code must be written in C only.
10) The assignment is personal for each pair, and you should not accept help from other people,
whether outside the university or inside it. You can contact the course staff during reception
hours for help or raise a question in the course forum. Do not transfer code sections
between students, upload solutions or parts of solutions to websites on the Internet or in
various communication groups.
11) Students who copy a solution will receive a 0 in all assignments in the course and a report will
be made to the institutional disciplinary committee.
12) All code files of the assignment are required to both compile and run properly on the Ubuntu
22.04 LTS operating system. This is the operating system where the submissions will be
tested. You mustnâ€™t code it in Windows, as it uses different API for sockets. WSL wonâ€™t work,
as the task needs a tool that works only in a fully Linux environment.
Good Luck!
 Communication Networks Course
Page | 2
Part A â€“ Transmission Control Protocol (TCP) â€“ 30 points
In this part, youâ€™ll write two program files: ğ‘»ğ‘ªğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and ğ‘»ğ‘ªğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
The Sender will send a randomly generated file and the Receiver will receive it and measure
the time it took for his program to receive the file. The file size should be at least 2MB.
When running the Sender and Receiver, they both should support two standard congestion
control algorithms: TCP Reno and TCP Cubic.
Notes:
â€¢ The main goal of this part is to get familiar with the TCP concept of sending
messages between two endpoints.
â€¢ For approaching this part of the assignment, please be sure that you are familiar
with the congestion control algorithms and how to change them using the correct
method in C (see Appendix B for more information).
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). You've
learned that TCP is reliable by design, so you can assume that all the data have been
passed correctly, and thus, no need to recheck.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
Usage:
â€¢ Receiver:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
â€¢ Sender:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port of the Receiver.
â€¢ ğ‘¨ğ‘³ğ‘®ğ‘¶ â€“ The TCP congestion control algorithm that will be used by the party
member (either ğ’“ğ’†ğ’ğ’ for TCP Reno or ğ’„ğ’–ğ’ƒğ’Šğ’„ for TCP Cubic).
 Communication Networks Course
Page | 3
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a TCP socket between the Sender and the
Receiver.
3) Send the file.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a TCP connection between the Receiver and
the Sender.
2) Get a connection from the sender.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./TCP_Receiver -p 1234 -algo reno
Starting Receiver...
Waiting for TCP connection...
Sender connected, beginning to receive file...
File transfer completed.
Waiting for Sender response...
Sender sent exit message.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 4
Part B â€“ Reliable User Datagram Protocol (Reliable UDP or RUDP) â€“ 40 points
Youâ€™ve learned that while TCP is reliable, it lacks speed and has an overhead data of 20 bytes,
compering to UDP that needs only 8 bytes of overhead data.
Reliable UDP or RUDP, is a protocol that uses the UDP protocol for a faster transmission of
data, while adding a reliability layer to it, but without adding too much overhead data like
TCP.
A simple sketch for a RUDP connection would look something like this:
Your task in this part is to implement a Reliable protocol using UDP only. For simplicity, your
implementation should only support a handshake, closing scheme, error checking,
acknowledgment of received packets, and retransmission of lost packets.
Guidance:
â€¢ You can use ğ‘ ğ‘’ğ‘¡ğ‘ ğ‘œğ‘ğ‘˜ğ‘œğ‘ğ‘¡(2) for detecting a timeout.
â€¢ You need to build your own protocol, as Reliable UDP isnâ€™t a standard protocol (see a
draft of RUDP in this link), and no official header is provided. You can use this sketch
for a header, but you can come up with your own protocol, as long as it works.
Where:
o ğ‘³ğ’†ğ’ğ’ˆğ’•ğ’‰ is the length of the data itself, without the RUDP header.
o ğ‘ªğ’‰ğ’†ğ’„ğ’Œğ’”ğ’–ğ’ is a 16bit number that validates the correctness of the data.
o ğ‘­ğ’ğ’‚ğ’ˆğ’” is a special byte where we classify the packet itself (SYN, ACK, etc.).
â€¢ In your PDF, you must explain how your implementation of RUDP works â€“ How does
it detect a timeout to do retransmissions, how does the handshake work, what is the
header overhead, etc.
â€¢ For this part, youâ€™ll write three files: ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¨ğ‘·ğ‘°. ğ’„, ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and
ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
Reliable UDP Header proposed sketch
Byte 0 Byte 1 Byte 2 Byte 3
Length (2 Bytes) Checksum (2 Bytes)
Flags (1 Byte)
Figure 1 - RUDP Protocol Architecture, Geeksforgeeks
 Communication Networks Course
Page | 5
Notes:
â€¢ The Sender will send a random generated file and the Receiver will receive it and
measure the time it took for his program to receive the file. The file size should be at
least 2MB.
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). But, as the
RUDP is based on UDP, itâ€™s not reliable. You must use some form of error checking
(like checksum) to ensure that the packet wasnâ€™t alerted during the transfer.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
â€¢ The RUDP needs support only 1 sender and 1 receiver, for simplicity purposes.
Usage:
â€¢ Receiver:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
â€¢ Sender:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port that both the Sender and the Receiver will use.
The ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„ file will contain all the implementations of the RUDP API functions (That is, to
prevent reusing the same chuck of code both in the Sender and the Receiver.).
The API should support at the bare minimum the following functions (you decide what
parameters to implement, and what are the names of the functions, as long as the API is
explained in the PDF):
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘œğ‘ğ‘˜ğ‘’ğ‘¡() â€“ Creating a RUDP socket and creating a handshake between two
peers.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘’ğ‘›ğ‘‘() â€“ Sending data to the peer. The function should wait for an
acknowledgment packet, and if it didnâ€™t receive any, retransmits the data.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘Ÿğ‘’ğ‘ğ‘£() â€“ Receive data from a peer.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ğ‘™ğ‘œğ‘ ğ‘’() â€“ Closes a connection between peers.
 Communication Networks Course
Page | 6
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a UDP socket between the Sender and the
Receiver.
3) Send the file via the RUDP protocol.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a UDP connection between the Receiver and
the Sender.
2) Get a connection from the sender, by the custom
RUDP protocol youâ€™ve built.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./RUDP_Receiver -p 1234
Starting Receiver...
Waiting for RUDP connection...
Connection request received, sending ACK.
Sender connected, beginning to receive file...
File transfer completed.
ACK sent.
Waiting for Sender response...
Sender sent exit message.
ACK sent.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 7
Part C â€“ Research â€“ 30 points
In this part, youâ€™ll conduct research about your implementations of part A and part B.
In the research itself, each one of the versions (TCP version and UDP version) will be run at
least 5 times (meaning that the file transfer will occur at least 5 times) by the following
conditions:
â€¢ For TCP, youâ€™ll run it in TCP Reno and TCP Cubic, alternating each time, for each
scenario, meaning that you run 5 times with TCP Reno in both Sender and Receiver,
and 5 times with TCP Cubic in both Sender and Receiver.
Bonus (5 points): Create a very large data set â€“ 5 times with TCP Reno in both Sender
and Receiver, 5 times with TCP Reno in Sender and TCP Cubic in Receiver, 5 times
with TCP Cubic in Sender and TCP Reno in Receiver, and 5 times with TCP Cubic in
both Sender and Receiver. This will give you a data set large enough, which allows
you to work with, compare with and to reach a definite conclusion.
â€¢ For RUDP, you will run it 5 times for each scenario.
â€¢ For both TCP and RUDP, you will run them on those scenarios of packet loss:
o 0% packet loss â€“ Control group, simulating perfect connection.
o 2% packet loss â€“ Simulating unstable connection that commonly occur.
o 5% packet loss â€“ Simulating bad connection.
o 10% packet loss â€“ Simulating extremely poor connection.
For each scenario, you must provide a filtered PCAP file and relevant screenshots that
explain each one of the steps in the process. (10 points)
After youâ€™ve gathered the data set for both TCP and Reliable UDP, answer the following
questions:
1) In TCP, which congestion control algorithm gave better results overall? TCP Reno or
TCP Cubic? Which one gave better results on high packet loss? Explain how you came
to this conclusion based on the data set youâ€™ve gathered. (5 points)
2) How did your implementation of Reliable UDP perform overall compared to regular
TCP? Which one is better for high packet loss? (5 points)
3) According to the data youâ€™ve gathered, in which scenarios and applications would we
prefer to use TCP and in which situations would we prefer to use reliable UDP?
Explain your answer. (5 points)
 Communication Networks Course
Page | 8
×¢× ×• ×¢×œ ×”×©××œ×•×ª ×”×‘××•×ª )5 × ×§×•×“×•×ª(:
â— ×‘"×¨×©×ª ×××™× ×”" ×”×›×•×•× ×” ×”×™× ×œ×¨×©×ª ×©×‘×” ××¢×˜ ×××•×“ ×—×‘×™×œ×•×ª ×”×•×œ×›×•×ª ×œ××™×‘×•×“. ×‘"×§×©×¨ ××¨×•×š" ×”×›×•×•× ×” ×”×™×
×œ×§×©×¨ TCP ×©×™×© ×‘×• ×”×¨×‘×” ×××•×“ ××™×“×¢ ×œ×©×œ×•×—. ××•×¦×¢ ×œ×”×’×“×™×œ ×‘ -TCP ××ª SSThreshold ×‘×ª×—×™×œ×ª ×”×§×©×¨.
×‘××™×–×” ××”××§×¨×™× ×”×‘××™× ×”×©×™× ×•×™ ×”×–×” ×¢×©×•×™ ×œ×”×•×¢×™×œ ×‘××™×“×” ×”××™×¨×‘×™×ª? × ××§.
.1 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
.2 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.3 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.4 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.5 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.6 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.7 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.8 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
â— A ×©×•×œ×— ×œ -B ×—×‘×™×œ×•×ª ××™×“×¢ ×‘×××¦×¢×•×ª ×§×©×¨ TCP. × ×ª×•×Ÿ ×›×™ ×”×§×©×¨ ××ª×—×™×œ ×¢× ×—×œ×•×Ÿ ×‘×’×•×“×œ 1MSS. ×”×§×©×¨
××¡×ª×™×™× ×‘×¤×¢× ×”×¨××©×•× ×” ×©×”×•× ××’×™×¢ ×œ -SSthresh. ×‘××”×œ×š ×”×§×©×¨ ×œ× ××•×‘×“×•×ª ×—×‘×™×œ×•×ª. × ×¡××Ÿ ×‘×§×™×¦×•×¨:
.SSthresh=S*MSS
× ×ª×•×Ÿ ×›×™ ×œ××•×¨×š ×›×œ ×”×§×©×¨ rwnd < MSS*S.
××”×™ ×”×ª×¤×•×§×” ×©×œ ×”×§×©×¨ ×-A ×œ-B( ×‘ -sec / Bytes )×‘×–××Ÿ ×”× "×œ? × ××§×™.
]S*MSS / [lg (S) * RTT*2 ×‘×¢×¨×š .1
]S*MSS / [S^0.5 * RTT*2 ×‘×¢×¨×š .2
S*MSS / RTT ×‘×¢×¨×š .3
S^2)*MSS / RTT( ×‘×¢×¨×š .4
â— ×©×ª×™ ×ª×—× ×•×ª ××ª×§×©×¨×•×ª ×‘××•×¤×Ÿ ××œ×—×•×˜×™ ×‘×©×™×˜×ª N Back Go.
× ×¡××Ÿ ×‘-X ××ª ×¡×¤×¨×ª ×”×‘×™×§×•×¨×ª ×©×œ ×”×ª.×–. ×©×œ×š. ×× ×©× ×™ ×©×•×ª×¤×™× ××’×™×©×™× ××ª ×”×ª×¨×’×™×œ ×™×—×“, X ×”×•× ×¡×¤×¨×ª
×”×‘×™×§×•×¨×ª ×‘×¢×œ×ª ×”×¢×¨×š ×”× ××•×š ×™×•×ª×¨ ××‘×™×Ÿ ×”×©×ª×™×™×.
×§×¦×‘ ×”×ª×§×©×•×¨×ª ×”×•× 8Gbps, ×•×’×•×“×œ ×›×œ ×—×‘×™×œ×” ×”×•× KByte*X. ×’×“×œ×™ ×”-headers ×•×” -Acks ×–× ×™×—×™×.
ï¿½ğ‘’ğ‘ ï¿½/ï¿½ï¿½ 8 , ×•×”××¨×—×§ ×‘×™×Ÿ ×”×ª×—× ×•×ª ×”×•× 1Km. ×§×¦×‘ ×”×”×ª×¤×©×˜×•×ª ×”×•× 10 â‹… 2
×–××Ÿ ×¢×™×‘×•×“ ×”× ×ª×•× ×™× ×‘×ª×—× ×•×ª ×–× ×™×—.
××£ ×—×‘×™×œ×” ×•××£ Ack ×œ× ×”×•×œ×›×™× ×œ××™×‘×•×“.
â— ××”×• X ×©×œ×š?
â— ××” ×¦×¨×™×š ×œ×”×™×•×ª ×’×•×“×œ ×—×œ×•×Ÿ ×”××©×œ×•×— ×›×“×™ ×œ×”×‘×˜×™×— ×ª×¤×•×§×” ××§×¡×™××œ×™×ª?
 Communication Networks Course
Page | 9
Bonus â€“ Improving the Reliable UDP â€“ 15 points
Note: This part isnâ€™t mandatory and is a bonus only!
In this part, youâ€™ll improve your RUDP implementation by adding the concepts of flow
control and congestion control from TCP. Youâ€™re free to choose which algorithms to
implement, as long as you explain in your PDF which algorithms youâ€™ve used. Youâ€™ll probably
need to make changes in the original design of the RUDP. Changes only need to be to the API
itself, ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„.
Points distribution:
â€¢ Flow control improvement â€“ 7 Points
â€¢ Congestion control improvement â€“ 8 points.
Guidance:
â€¢ For flow control, you must use one of the Sliding window techniques: stop-and-wait
ARQ, Go-Back-N or Selective repeat.
â€¢ List of known TCP congestion control algorithms, which you can use any one of them
for this bonus task, or makeup your own:
Figure 2 â€“ List of known TCP congestion control algorithms, Wikipedia
 Communication Networks Course
Page | 10
Appendix A â€“ Linux local packet loss tool
To simulate a packet loss in a local network, we'll use a Linux tool that's called Linux Traffic
Control (ğ‘¡ğ‘). This requires a full Linux installation, so working with WSL won't work.
If the tool isn't installed in your machine, you can install it by using the following commands:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’
If the installation didn't work, you can use the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’2
To create a packet loss scenario, type the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘ğ‘‘ğ‘‘ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
After creating a packet loss scenario, you can change the percentage by typing the following
command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘â„ğ‘ğ‘›ğ‘”ğ‘’ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
To remove the packet loss scenario, write the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘‘ğ‘’ğ‘™ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š
 Communication Networks Course
Page | 11
Appendix B â€“ ğ’ğ’‚ğ’(ğŸ) system calls
This appendixâ€™s purpose is to give you a better understanding of socket handling in C.
A recommended reference is Beejâ€™s Guide to Network Programming, by Brian â€œBeej
Jorgensenâ€ Hall, which gives a lot of information about sockets in C and functions.
Functions and documentation links:
â€¢ ğ’”ğ’ğ’„ğ’Œğ’†ğ’•(ğŸ) â€“ A Factory method system call that creates a socket with the given
parameters.
â€¢ ğ’ƒğ’Šğ’ğ’…(ğŸ) â€“ Whenever we create a new socket, we need to bind it to a specific port in
our machine, â€œto catch a portâ€. The port number is managed and used by the kernel
to link incoming packets to the corresponding application socket. The port numbers
are usually fixed. The ğ‘ğ‘‘ğ‘‘ğ‘Ÿ parameter must match the current socket that is used.
â€¢ ğ’ğ’Šğ’”ğ’•ğ’†ğ’(ğŸ) â€“ The ğ‘™ğ‘–ğ‘ ğ‘¡ğ‘’ğ‘›(2) system call doesn't do anything in the mean of
communication but only memory allocation (malloc) for stream sockets only. If we
won't allocate memory, any incoming connection will fail.
â€¢ ğ’„ğ’ğ’ğ’ğ’†ğ’„ğ’•(ğŸ) â€“ The ğ‘ğ‘œğ‘›ğ‘›ğ‘’ğ‘ğ‘¡(2) system call starts the link between a client and a
specific IP address and port number. The connection would complete when the
other side will call the ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call.
â€¢ ğ’‚ğ’„ğ’„ğ’†ğ’‘ğ’•(ğŸ) â€“ The ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call accepts the incoming stream connection
request from the other side, by the listening socket. This system call completes the
three-way handshake of stream socket (like TCP) and opens a new socket that has a
direct communication channel only with the other party in the handshake.
â€¢ ğ’”ğ’†ğ’ğ’…(ğŸ) and ğ’”ğ’†ğ’ğ’…ğ’•ğ’(ğŸ) â€“ The ğ‘ ğ‘’ğ‘›ğ‘‘(2) and ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system calls are an analogy
for the ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’(2) system call, specifcly for sockets, with flags set to 0. Those system
calls return the number of bytes that were sent through the socket itself, as the
number of bytes can vary. The ğ‘ ğ‘’ğ‘›ğ‘‘(2)system call designed for stream sockets (like
TCP), while the ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system call designed for datagram connection-less
sockets (like UDP). When the ğ‘ ğ‘’ğ‘›ğ‘‘(2) system call returns 0, it means that the other
party closed the connection.
â€¢ ğ’“ğ’†ğ’„ğ’—(ğŸ) and ğ’“ğ’†ğ’„ğ’—ğ’‡ğ’“ğ’ğ’(ğŸ) â€“ The ğ‘Ÿğ‘’ğ‘ğ‘£(2) and ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system calls are an
analogy for the ğ‘Ÿğ‘’ğ‘ğ‘‘(2) system call, specifically for sockets, with flags set to 0.
Those system calls return the number of bytes that were received through the socket
itself, as the number of bytes can vary. The ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call designed for stream
sockets (like TCP), while the ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system call designed for datagram
connection-less sockets (like UDP). When the ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call returns 0, it means
that the other party closed the connection.
â€¢ ğ’„ğ’ğ’ğ’”ğ’†(ğŸ) and ğ’”ğ’‰ğ’–ğ’•ğ’…ğ’ğ’˜ğ’(ğŸ) â€“ The ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) and ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2) system calls close
the socket. While ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) system call closes the whole socket, the ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2)
system call partially closes the socket for read/write.
 Communication Networks Course
Page | 12
Appendix C â€“ Random data generator
The data that you are going to send in this assignment is randomly generated. You can use
your own file with appropriate size or use the following function (or a function of your own)
to generate the data:
/*
* @brief A random data generator function based on srand() and rand().
* @param size The size of the data to generate (up to 2^32 bytes).
* @return A pointer to the buffer.
*/
char *util_generate_random_data(unsigned int size) {
 char *buffer = NULL;
 // Argument check.
 if (size == 0)
 return NULL;
 buffer = (char *)calloc(size, sizeof(char));
 // Error checking.
 if (buffer == NULL)
 return NULL;
 // Randomize the seed of the random number generator.
 srand(time(NULL));
 for (unsigned int i = 0; i < size; i++)
 *(buffer + i) = ((unsigned int)rand() % 256);
 return buffer;
}
 Communication Networks Course
Page | 13
Appendix D â€“ Checksum function
A checksum is a small-sized block of data derived from another block of digital data for the
purpose of detecting errors that may have been introduced during its transmission or
storage. By themselves, checksums are often used to verify data integrity but are not relied
upon to verify data authenticity.
Below is a simple yet efficient implementation of the checksum function, you can use it for
the assignment, but you can implement your own checksum function.
/*
* @brief A checksum function that returns 16 bit checksum for data.
* @param data The data to do the checksum for.
* @param bytes The length of the data in bytes.
* @return The checksum itself as 16 bit unsigned number.
* @note This function is taken from RFC1071, can be found here:
* @note https://tools.ietf.org/html/rfc1071
* @note It is the simplest way to calculate a checksum and is not very strong.
* However, it is good enough for this assignment.
* @note You are free to use any other checksum function as well.
* You can also use this function as such without any change.
*/
unsigned short int calculate_checksum(void *data, unsigned int bytes) {
 unsigned short int *data_pointer = (unsigned short int *)data;
 unsigned int total_sum = 0;
 // Main summing loop
 while (bytes > 1) {
 total_sum += *data_pointer++;
 bytes -= 2;
 }
 // Add left-over byte, if any
 if (bytes > 0)
 total_sum += *((unsigned char *)data_pointer);
 // Fold 32-bit sum to 16 bits
 while (total_sum >> 16)
 total_sum = (total_sum & 0xFFFF) + (total_sum >> 16);
 return (~((unsigned short int)total_sum));
} Communication Networks Course
Page | 1
Assignment 3 â€“ Transport Layer
Assignment Notes and Instructions
This assignment is to be done in pairs only. You must upload all the necessary files in a ZIP
file named after both of the studentâ€™s ID. For example: ğŸğŸğŸ‘ğŸ’ğŸ“ğŸ”ğŸ•ğŸ–ğŸ—_ğŸ—ğŸ–ğŸ•ğŸ”ğŸ“ğŸ’ğŸ‘ğŸğŸ. ğ’›ğ’Šğ’‘.
1) The assignment must be submitted by the date specified in the submission box.
2) All the assignment files (Code, Wireshark pcap files, PDF) must be submitted in a ZIP file. The
PDF must contain all the necessary screenshots with a description for each one of them.
3) The assignment must be done in pairs only. In exceptional cases, you should send an email to
the course coordinator.
4) You can use any reference material available through the course Moodle website or any
material passed during the exercises.
5) You can use any reference from the web, but copying codes from websites is forbidden; this
includes codes from other GitHub repositories. A student who gets caught in the act will
automatically fail this assignment (score 0). Any website youâ€™ve used to solve the
assignment, every website you used to solve the assignment must be noted in the PDF.
6) No delays in submission without special permission. Lateness without approval will result in
failure of the assignment (score 0).
7) All submissions will be submitted via the course's Moodle website. Email submissions will not
be accepted, resulting in a failure in the assignment.
8) The order and design of the code must be carefully considered. Make sure that the program
output is as clear as possible, comments in the code, and meaningful variable names. You
must also submit a makefile that compiles all the programs.
9) The assignment code must be written in C only.
10) The assignment is personal for each pair, and you should not accept help from other people,
whether outside the university or inside it. You can contact the course staff during reception
hours for help or raise a question in the course forum. Do not transfer code sections
between students, upload solutions or parts of solutions to websites on the Internet or in
various communication groups.
11) Students who copy a solution will receive a 0 in all assignments in the course and a report will
be made to the institutional disciplinary committee.
12) All code files of the assignment are required to both compile and run properly on the Ubuntu
22.04 LTS operating system. This is the operating system where the submissions will be
tested. You mustnâ€™t code it in Windows, as it uses different API for sockets. WSL wonâ€™t work,
as the task needs a tool that works only in a fully Linux environment.
Good Luck!
 Communication Networks Course
Page | 2
Part A â€“ Transmission Control Protocol (TCP) â€“ 30 points
In this part, youâ€™ll write two program files: ğ‘»ğ‘ªğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and ğ‘»ğ‘ªğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
The Sender will send a randomly generated file and the Receiver will receive it and measure
the time it took for his program to receive the file. The file size should be at least 2MB.
When running the Sender and Receiver, they both should support two standard congestion
control algorithms: TCP Reno and TCP Cubic.
Notes:
â€¢ The main goal of this part is to get familiar with the TCP concept of sending
messages between two endpoints.
â€¢ For approaching this part of the assignment, please be sure that you are familiar
with the congestion control algorithms and how to change them using the correct
method in C (see Appendix B for more information).
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). You've
learned that TCP is reliable by design, so you can assume that all the data have been
passed correctly, and thus, no need to recheck.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
Usage:
â€¢ Receiver:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
â€¢ Sender:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port of the Receiver.
â€¢ ğ‘¨ğ‘³ğ‘®ğ‘¶ â€“ The TCP congestion control algorithm that will be used by the party
member (either ğ’“ğ’†ğ’ğ’ for TCP Reno or ğ’„ğ’–ğ’ƒğ’Šğ’„ for TCP Cubic).
 Communication Networks Course
Page | 3
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a TCP socket between the Sender and the
Receiver.
3) Send the file.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a TCP connection between the Receiver and
the Sender.
2) Get a connection from the sender.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./TCP_Receiver -p 1234 -algo reno
Starting Receiver...
Waiting for TCP connection...
Sender connected, beginning to receive file...
File transfer completed.
Waiting for Sender response...
Sender sent exit message.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 4
Part B â€“ Reliable User Datagram Protocol (Reliable UDP or RUDP) â€“ 40 points
Youâ€™ve learned that while TCP is reliable, it lacks speed and has an overhead data of 20 bytes,
compering to UDP that needs only 8 bytes of overhead data.
Reliable UDP or RUDP, is a protocol that uses the UDP protocol for a faster transmission of
data, while adding a reliability layer to it, but without adding too much overhead data like
TCP.
A simple sketch for a RUDP connection would look something like this:
Your task in this part is to implement a Reliable protocol using UDP only. For simplicity, your
implementation should only support a handshake, closing scheme, error checking,
acknowledgment of received packets, and retransmission of lost packets.
Guidance:
â€¢ You can use ğ‘ ğ‘’ğ‘¡ğ‘ ğ‘œğ‘ğ‘˜ğ‘œğ‘ğ‘¡(2) for detecting a timeout.
â€¢ You need to build your own protocol, as Reliable UDP isnâ€™t a standard protocol (see a
draft of RUDP in this link), and no official header is provided. You can use this sketch
for a header, but you can come up with your own protocol, as long as it works.
Where:
o ğ‘³ğ’†ğ’ğ’ˆğ’•ğ’‰ is the length of the data itself, without the RUDP header.
o ğ‘ªğ’‰ğ’†ğ’„ğ’Œğ’”ğ’–ğ’ is a 16bit number that validates the correctness of the data.
o ğ‘­ğ’ğ’‚ğ’ˆğ’” is a special byte where we classify the packet itself (SYN, ACK, etc.).
â€¢ In your PDF, you must explain how your implementation of RUDP works â€“ How does
it detect a timeout to do retransmissions, how does the handshake work, what is the
header overhead, etc.
â€¢ For this part, youâ€™ll write three files: ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¨ğ‘·ğ‘°. ğ’„, ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and
ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
Reliable UDP Header proposed sketch
Byte 0 Byte 1 Byte 2 Byte 3
Length (2 Bytes) Checksum (2 Bytes)
Flags (1 Byte)
Figure 1 - RUDP Protocol Architecture, Geeksforgeeks
 Communication Networks Course
Page | 5
Notes:
â€¢ The Sender will send a random generated file and the Receiver will receive it and
measure the time it took for his program to receive the file. The file size should be at
least 2MB.
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). But, as the
RUDP is based on UDP, itâ€™s not reliable. You must use some form of error checking
(like checksum) to ensure that the packet wasnâ€™t alerted during the transfer.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
â€¢ The RUDP needs support only 1 sender and 1 receiver, for simplicity purposes.
Usage:
â€¢ Receiver:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
â€¢ Sender:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port that both the Sender and the Receiver will use.
The ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„ file will contain all the implementations of the RUDP API functions (That is, to
prevent reusing the same chuck of code both in the Sender and the Receiver.).
The API should support at the bare minimum the following functions (you decide what
parameters to implement, and what are the names of the functions, as long as the API is
explained in the PDF):
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘œğ‘ğ‘˜ğ‘’ğ‘¡() â€“ Creating a RUDP socket and creating a handshake between two
peers.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘’ğ‘›ğ‘‘() â€“ Sending data to the peer. The function should wait for an
acknowledgment packet, and if it didnâ€™t receive any, retransmits the data.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘Ÿğ‘’ğ‘ğ‘£() â€“ Receive data from a peer.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ğ‘™ğ‘œğ‘ ğ‘’() â€“ Closes a connection between peers.
 Communication Networks Course
Page | 6
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a UDP socket between the Sender and the
Receiver.
3) Send the file via the RUDP protocol.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a UDP connection between the Receiver and
the Sender.
2) Get a connection from the sender, by the custom
RUDP protocol youâ€™ve built.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./RUDP_Receiver -p 1234
Starting Receiver...
Waiting for RUDP connection...
Connection request received, sending ACK.
Sender connected, beginning to receive file...
File transfer completed.
ACK sent.
Waiting for Sender response...
Sender sent exit message.
ACK sent.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 7
Part C â€“ Research â€“ 30 points
In this part, youâ€™ll conduct research about your implementations of part A and part B.
In the research itself, each one of the versions (TCP version and UDP version) will be run at
least 5 times (meaning that the file transfer will occur at least 5 times) by the following
conditions:
â€¢ For TCP, youâ€™ll run it in TCP Reno and TCP Cubic, alternating each time, for each
scenario, meaning that you run 5 times with TCP Reno in both Sender and Receiver,
and 5 times with TCP Cubic in both Sender and Receiver.
Bonus (5 points): Create a very large data set â€“ 5 times with TCP Reno in both Sender
and Receiver, 5 times with TCP Reno in Sender and TCP Cubic in Receiver, 5 times
with TCP Cubic in Sender and TCP Reno in Receiver, and 5 times with TCP Cubic in
both Sender and Receiver. This will give you a data set large enough, which allows
you to work with, compare with and to reach a definite conclusion.
â€¢ For RUDP, you will run it 5 times for each scenario.
â€¢ For both TCP and RUDP, you will run them on those scenarios of packet loss:
o 0% packet loss â€“ Control group, simulating perfect connection.
o 2% packet loss â€“ Simulating unstable connection that commonly occur.
o 5% packet loss â€“ Simulating bad connection.
o 10% packet loss â€“ Simulating extremely poor connection.
For each scenario, you must provide a filtered PCAP file and relevant screenshots that
explain each one of the steps in the process. (10 points)
After youâ€™ve gathered the data set for both TCP and Reliable UDP, answer the following
questions:
1) In TCP, which congestion control algorithm gave better results overall? TCP Reno or
TCP Cubic? Which one gave better results on high packet loss? Explain how you came
to this conclusion based on the data set youâ€™ve gathered. (5 points)
2) How did your implementation of Reliable UDP perform overall compared to regular
TCP? Which one is better for high packet loss? (5 points)
3) According to the data youâ€™ve gathered, in which scenarios and applications would we
prefer to use TCP and in which situations would we prefer to use reliable UDP?
Explain your answer. (5 points)
 Communication Networks Course
Page | 8
×¢× ×• ×¢×œ ×”×©××œ×•×ª ×”×‘××•×ª )5 × ×§×•×“×•×ª(:
â— ×‘"×¨×©×ª ×××™× ×”" ×”×›×•×•× ×” ×”×™× ×œ×¨×©×ª ×©×‘×” ××¢×˜ ×××•×“ ×—×‘×™×œ×•×ª ×”×•×œ×›×•×ª ×œ××™×‘×•×“. ×‘"×§×©×¨ ××¨×•×š" ×”×›×•×•× ×” ×”×™×
×œ×§×©×¨ TCP ×©×™×© ×‘×• ×”×¨×‘×” ×××•×“ ××™×“×¢ ×œ×©×œ×•×—. ××•×¦×¢ ×œ×”×’×“×™×œ ×‘ -TCP ××ª SSThreshold ×‘×ª×—×™×œ×ª ×”×§×©×¨.
×‘××™×–×” ××”××§×¨×™× ×”×‘××™× ×”×©×™× ×•×™ ×”×–×” ×¢×©×•×™ ×œ×”×•×¢×™×œ ×‘××™×“×” ×”××™×¨×‘×™×ª? × ××§.
.1 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
.2 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.3 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.4 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.5 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.6 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.7 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.8 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
â— A ×©×•×œ×— ×œ -B ×—×‘×™×œ×•×ª ××™×“×¢ ×‘×××¦×¢×•×ª ×§×©×¨ TCP. × ×ª×•×Ÿ ×›×™ ×”×§×©×¨ ××ª×—×™×œ ×¢× ×—×œ×•×Ÿ ×‘×’×•×“×œ 1MSS. ×”×§×©×¨
××¡×ª×™×™× ×‘×¤×¢× ×”×¨××©×•× ×” ×©×”×•× ××’×™×¢ ×œ -SSthresh. ×‘××”×œ×š ×”×§×©×¨ ×œ× ××•×‘×“×•×ª ×—×‘×™×œ×•×ª. × ×¡××Ÿ ×‘×§×™×¦×•×¨:
.SSthresh=S*MSS
× ×ª×•×Ÿ ×›×™ ×œ××•×¨×š ×›×œ ×”×§×©×¨ rwnd < MSS*S.
××”×™ ×”×ª×¤×•×§×” ×©×œ ×”×§×©×¨ ×-A ×œ-B( ×‘ -sec / Bytes )×‘×–××Ÿ ×”× "×œ? × ××§×™.
]S*MSS / [lg (S) * RTT*2 ×‘×¢×¨×š .1
]S*MSS / [S^0.5 * RTT*2 ×‘×¢×¨×š .2
S*MSS / RTT ×‘×¢×¨×š .3
S^2)*MSS / RTT( ×‘×¢×¨×š .4
â— ×©×ª×™ ×ª×—× ×•×ª ××ª×§×©×¨×•×ª ×‘××•×¤×Ÿ ××œ×—×•×˜×™ ×‘×©×™×˜×ª N Back Go.
× ×¡××Ÿ ×‘-X ××ª ×¡×¤×¨×ª ×”×‘×™×§×•×¨×ª ×©×œ ×”×ª.×–. ×©×œ×š. ×× ×©× ×™ ×©×•×ª×¤×™× ××’×™×©×™× ××ª ×”×ª×¨×’×™×œ ×™×—×“, X ×”×•× ×¡×¤×¨×ª
×”×‘×™×§×•×¨×ª ×‘×¢×œ×ª ×”×¢×¨×š ×”× ××•×š ×™×•×ª×¨ ××‘×™×Ÿ ×”×©×ª×™×™×.
×§×¦×‘ ×”×ª×§×©×•×¨×ª ×”×•× 8Gbps, ×•×’×•×“×œ ×›×œ ×—×‘×™×œ×” ×”×•× KByte*X. ×’×“×œ×™ ×”-headers ×•×” -Acks ×–× ×™×—×™×.
ï¿½ğ‘’ğ‘ ï¿½/ï¿½ï¿½ 8 , ×•×”××¨×—×§ ×‘×™×Ÿ ×”×ª×—× ×•×ª ×”×•× 1Km. ×§×¦×‘ ×”×”×ª×¤×©×˜×•×ª ×”×•× 10 â‹… 2
×–××Ÿ ×¢×™×‘×•×“ ×”× ×ª×•× ×™× ×‘×ª×—× ×•×ª ×–× ×™×—.
××£ ×—×‘×™×œ×” ×•××£ Ack ×œ× ×”×•×œ×›×™× ×œ××™×‘×•×“.
â— ××”×• X ×©×œ×š?
â— ××” ×¦×¨×™×š ×œ×”×™×•×ª ×’×•×“×œ ×—×œ×•×Ÿ ×”××©×œ×•×— ×›×“×™ ×œ×”×‘×˜×™×— ×ª×¤×•×§×” ××§×¡×™××œ×™×ª?
 Communication Networks Course
Page | 9
Bonus â€“ Improving the Reliable UDP â€“ 15 points
Note: This part isnâ€™t mandatory and is a bonus only!
In this part, youâ€™ll improve your RUDP implementation by adding the concepts of flow
control and congestion control from TCP. Youâ€™re free to choose which algorithms to
implement, as long as you explain in your PDF which algorithms youâ€™ve used. Youâ€™ll probably
need to make changes in the original design of the RUDP. Changes only need to be to the API
itself, ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„.
Points distribution:
â€¢ Flow control improvement â€“ 7 Points
â€¢ Congestion control improvement â€“ 8 points.
Guidance:
â€¢ For flow control, you must use one of the Sliding window techniques: stop-and-wait
ARQ, Go-Back-N or Selective repeat.
â€¢ List of known TCP congestion control algorithms, which you can use any one of them
for this bonus task, or makeup your own:
Figure 2 â€“ List of known TCP congestion control algorithms, Wikipedia
 Communication Networks Course
Page | 10
Appendix A â€“ Linux local packet loss tool
To simulate a packet loss in a local network, we'll use a Linux tool that's called Linux Traffic
Control (ğ‘¡ğ‘). This requires a full Linux installation, so working with WSL won't work.
If the tool isn't installed in your machine, you can install it by using the following commands:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’
If the installation didn't work, you can use the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’2
To create a packet loss scenario, type the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘ğ‘‘ğ‘‘ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
After creating a packet loss scenario, you can change the percentage by typing the following
command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘â„ğ‘ğ‘›ğ‘”ğ‘’ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
To remove the packet loss scenario, write the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘‘ğ‘’ğ‘™ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š
 Communication Networks Course
Page | 11
Appendix B â€“ ğ’ğ’‚ğ’(ğŸ) system calls
This appendixâ€™s purpose is to give you a better understanding of socket handling in C.
A recommended reference is Beejâ€™s Guide to Network Programming, by Brian â€œBeej
Jorgensenâ€ Hall, which gives a lot of information about sockets in C and functions.
Functions and documentation links:
â€¢ ğ’”ğ’ğ’„ğ’Œğ’†ğ’•(ğŸ) â€“ A Factory method system call that creates a socket with the given
parameters.
â€¢ ğ’ƒğ’Šğ’ğ’…(ğŸ) â€“ Whenever we create a new socket, we need to bind it to a specific port in
our machine, â€œto catch a portâ€. The port number is managed and used by the kernel
to link incoming packets to the corresponding application socket. The port numbers
are usually fixed. The ğ‘ğ‘‘ğ‘‘ğ‘Ÿ parameter must match the current socket that is used.
â€¢ ğ’ğ’Šğ’”ğ’•ğ’†ğ’(ğŸ) â€“ The ğ‘™ğ‘–ğ‘ ğ‘¡ğ‘’ğ‘›(2) system call doesn't do anything in the mean of
communication but only memory allocation (malloc) for stream sockets only. If we
won't allocate memory, any incoming connection will fail.
â€¢ ğ’„ğ’ğ’ğ’ğ’†ğ’„ğ’•(ğŸ) â€“ The ğ‘ğ‘œğ‘›ğ‘›ğ‘’ğ‘ğ‘¡(2) system call starts the link between a client and a
specific IP address and port number. The connection would complete when the
other side will call the ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call.
â€¢ ğ’‚ğ’„ğ’„ğ’†ğ’‘ğ’•(ğŸ) â€“ The ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call accepts the incoming stream connection
request from the other side, by the listening socket. This system call completes the
three-way handshake of stream socket (like TCP) and opens a new socket that has a
direct communication channel only with the other party in the handshake.
â€¢ ğ’”ğ’†ğ’ğ’…(ğŸ) and ğ’”ğ’†ğ’ğ’…ğ’•ğ’(ğŸ) â€“ The ğ‘ ğ‘’ğ‘›ğ‘‘(2) and ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system calls are an analogy
for the ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’(2) system call, specifcly for sockets, with flags set to 0. Those system
calls return the number of bytes that were sent through the socket itself, as the
number of bytes can vary. The ğ‘ ğ‘’ğ‘›ğ‘‘(2)system call designed for stream sockets (like
TCP), while the ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system call designed for datagram connection-less
sockets (like UDP). When the ğ‘ ğ‘’ğ‘›ğ‘‘(2) system call returns 0, it means that the other
party closed the connection.
â€¢ ğ’“ğ’†ğ’„ğ’—(ğŸ) and ğ’“ğ’†ğ’„ğ’—ğ’‡ğ’“ğ’ğ’(ğŸ) â€“ The ğ‘Ÿğ‘’ğ‘ğ‘£(2) and ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system calls are an
analogy for the ğ‘Ÿğ‘’ğ‘ğ‘‘(2) system call, specifically for sockets, with flags set to 0.
Those system calls return the number of bytes that were received through the socket
itself, as the number of bytes can vary. The ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call designed for stream
sockets (like TCP), while the ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system call designed for datagram
connection-less sockets (like UDP). When the ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call returns 0, it means
that the other party closed the connection.
â€¢ ğ’„ğ’ğ’ğ’”ğ’†(ğŸ) and ğ’”ğ’‰ğ’–ğ’•ğ’…ğ’ğ’˜ğ’(ğŸ) â€“ The ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) and ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2) system calls close
the socket. While ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) system call closes the whole socket, the ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2)
system call partially closes the socket for read/write.
 Communication Networks Course
Page | 12
Appendix C â€“ Random data generator
The data that you are going to send in this assignment is randomly generated. You can use
your own file with appropriate size or use the following function (or a function of your own)
to generate the data:
/*
* @brief A random data generator function based on srand() and rand().
* @param size The size of the data to generate (up to 2^32 bytes).
* @return A pointer to the buffer.
*/
char *util_generate_random_data(unsigned int size) {
 char *buffer = NULL;
 // Argument check.
 if (size == 0)
 return NULL;
 buffer = (char *)calloc(size, sizeof(char));
 // Error checking.
 if (buffer == NULL)
 return NULL;
 // Randomize the seed of the random number generator.
 srand(time(NULL));
 for (unsigned int i = 0; i < size; i++)
 *(buffer + i) = ((unsigned int)rand() % 256);
 return buffer;
}
 Communication Networks Course
Page | 13
Appendix D â€“ Checksum function
A checksum is a small-sized block of data derived from another block of digital data for the
purpose of detecting errors that may have been introduced during its transmission or
storage. By themselves, checksums are often used to verify data integrity but are not relied
upon to verify data authenticity.
Below is a simple yet efficient implementation of the checksum function, you can use it for
the assignment, but you can implement your own checksum function.
/*
* @brief A checksum function that returns 16 bit checksum for data.
* @param data The data to do the checksum for.
* @param bytes The length of the data in bytes.
* @return The checksum itself as 16 bit unsigned number.
* @note This function is taken from RFC1071, can be found here:
* @note https://tools.ietf.org/html/rfc1071
* @note It is the simplest way to calculate a checksum and is not very strong.
* However, it is good enough for this assignment.
* @note You are free to use any other checksum function as well.
* You can also use this function as such without any change.
*/
unsigned short int calculate_checksum(void *data, unsigned int bytes) {
 unsigned short int *data_pointer = (unsigned short int *)data;
 unsigned int total_sum = 0;
 // Main summing loop
 while (bytes > 1) {
 total_sum += *data_pointer++;
 bytes -= 2;
 }
 // Add left-over byte, if any
 if (bytes > 0)
 total_sum += *((unsigned char *)data_pointer);
 // Fold 32-bit sum to 16 bits
 while (total_sum >> 16)
 total_sum = (total_sum & 0xFFFF) + (total_sum >> 16);
 return (~((unsigned short int)total_sum));
} Communication Networks Course
Page | 1
Assignment 3 â€“ Transport Layer
Assignment Notes and Instructions
This assignment is to be done in pairs only. You must upload all the necessary files in a ZIP
file named after both of the studentâ€™s ID. For example: ğŸğŸğŸ‘ğŸ’ğŸ“ğŸ”ğŸ•ğŸ–ğŸ—_ğŸ—ğŸ–ğŸ•ğŸ”ğŸ“ğŸ’ğŸ‘ğŸğŸ. ğ’›ğ’Šğ’‘.
1) The assignment must be submitted by the date specified in the submission box.
2) All the assignment files (Code, Wireshark pcap files, PDF) must be submitted in a ZIP file. The
PDF must contain all the necessary screenshots with a description for each one of them.
3) The assignment must be done in pairs only. In exceptional cases, you should send an email to
the course coordinator.
4) You can use any reference material available through the course Moodle website or any
material passed during the exercises.
5) You can use any reference from the web, but copying codes from websites is forbidden; this
includes codes from other GitHub repositories. A student who gets caught in the act will
automatically fail this assignment (score 0). Any website youâ€™ve used to solve the
assignment, every website you used to solve the assignment must be noted in the PDF.
6) No delays in submission without special permission. Lateness without approval will result in
failure of the assignment (score 0).
7) All submissions will be submitted via the course's Moodle website. Email submissions will not
be accepted, resulting in a failure in the assignment.
8) The order and design of the code must be carefully considered. Make sure that the program
output is as clear as possible, comments in the code, and meaningful variable names. You
must also submit a makefile that compiles all the programs.
9) The assignment code must be written in C only.
10) The assignment is personal for each pair, and you should not accept help from other people,
whether outside the university or inside it. You can contact the course staff during reception
hours for help or raise a question in the course forum. Do not transfer code sections
between students, upload solutions or parts of solutions to websites on the Internet or in
various communication groups.
11) Students who copy a solution will receive a 0 in all assignments in the course and a report will
be made to the institutional disciplinary committee.
12) All code files of the assignment are required to both compile and run properly on the Ubuntu
22.04 LTS operating system. This is the operating system where the submissions will be
tested. You mustnâ€™t code it in Windows, as it uses different API for sockets. WSL wonâ€™t work,
as the task needs a tool that works only in a fully Linux environment.
Good Luck!
 Communication Networks Course
Page | 2
Part A â€“ Transmission Control Protocol (TCP) â€“ 30 points
In this part, youâ€™ll write two program files: ğ‘»ğ‘ªğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and ğ‘»ğ‘ªğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
The Sender will send a randomly generated file and the Receiver will receive it and measure
the time it took for his program to receive the file. The file size should be at least 2MB.
When running the Sender and Receiver, they both should support two standard congestion
control algorithms: TCP Reno and TCP Cubic.
Notes:
â€¢ The main goal of this part is to get familiar with the TCP concept of sending
messages between two endpoints.
â€¢ For approaching this part of the assignment, please be sure that you are familiar
with the congestion control algorithms and how to change them using the correct
method in C (see Appendix B for more information).
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). You've
learned that TCP is reliable by design, so you can assume that all the data have been
passed correctly, and thus, no need to recheck.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
Usage:
â€¢ Receiver:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
â€¢ Sender:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port of the Receiver.
â€¢ ğ‘¨ğ‘³ğ‘®ğ‘¶ â€“ The TCP congestion control algorithm that will be used by the party
member (either ğ’“ğ’†ğ’ğ’ for TCP Reno or ğ’„ğ’–ğ’ƒğ’Šğ’„ for TCP Cubic).
 Communication Networks Course
Page | 3
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a TCP socket between the Sender and the
Receiver.
3) Send the file.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a TCP connection between the Receiver and
the Sender.
2) Get a connection from the sender.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./TCP_Receiver -p 1234 -algo reno
Starting Receiver...
Waiting for TCP connection...
Sender connected, beginning to receive file...
File transfer completed.
Waiting for Sender response...
Sender sent exit message.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 4
Part B â€“ Reliable User Datagram Protocol (Reliable UDP or RUDP) â€“ 40 points
Youâ€™ve learned that while TCP is reliable, it lacks speed and has an overhead data of 20 bytes,
compering to UDP that needs only 8 bytes of overhead data.
Reliable UDP or RUDP, is a protocol that uses the UDP protocol for a faster transmission of
data, while adding a reliability layer to it, but without adding too much overhead data like
TCP.
A simple sketch for a RUDP connection would look something like this:
Your task in this part is to implement a Reliable protocol using UDP only. For simplicity, your
implementation should only support a handshake, closing scheme, error checking,
acknowledgment of received packets, and retransmission of lost packets.
Guidance:
â€¢ You can use ğ‘ ğ‘’ğ‘¡ğ‘ ğ‘œğ‘ğ‘˜ğ‘œğ‘ğ‘¡(2) for detecting a timeout.
â€¢ You need to build your own protocol, as Reliable UDP isnâ€™t a standard protocol (see a
draft of RUDP in this link), and no official header is provided. You can use this sketch
for a header, but you can come up with your own protocol, as long as it works.
Where:
o ğ‘³ğ’†ğ’ğ’ˆğ’•ğ’‰ is the length of the data itself, without the RUDP header.
o ğ‘ªğ’‰ğ’†ğ’„ğ’Œğ’”ğ’–ğ’ is a 16bit number that validates the correctness of the data.
o ğ‘­ğ’ğ’‚ğ’ˆğ’” is a special byte where we classify the packet itself (SYN, ACK, etc.).
â€¢ In your PDF, you must explain how your implementation of RUDP works â€“ How does
it detect a timeout to do retransmissions, how does the handshake work, what is the
header overhead, etc.
â€¢ For this part, youâ€™ll write three files: ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¨ğ‘·ğ‘°. ğ’„, ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and
ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
Reliable UDP Header proposed sketch
Byte 0 Byte 1 Byte 2 Byte 3
Length (2 Bytes) Checksum (2 Bytes)
Flags (1 Byte)
Figure 1 - RUDP Protocol Architecture, Geeksforgeeks
 Communication Networks Course
Page | 5
Notes:
â€¢ The Sender will send a random generated file and the Receiver will receive it and
measure the time it took for his program to receive the file. The file size should be at
least 2MB.
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). But, as the
RUDP is based on UDP, itâ€™s not reliable. You must use some form of error checking
(like checksum) to ensure that the packet wasnâ€™t alerted during the transfer.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
â€¢ The RUDP needs support only 1 sender and 1 receiver, for simplicity purposes.
Usage:
â€¢ Receiver:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
â€¢ Sender:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port that both the Sender and the Receiver will use.
The ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„ file will contain all the implementations of the RUDP API functions (That is, to
prevent reusing the same chuck of code both in the Sender and the Receiver.).
The API should support at the bare minimum the following functions (you decide what
parameters to implement, and what are the names of the functions, as long as the API is
explained in the PDF):
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘œğ‘ğ‘˜ğ‘’ğ‘¡() â€“ Creating a RUDP socket and creating a handshake between two
peers.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘’ğ‘›ğ‘‘() â€“ Sending data to the peer. The function should wait for an
acknowledgment packet, and if it didnâ€™t receive any, retransmits the data.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘Ÿğ‘’ğ‘ğ‘£() â€“ Receive data from a peer.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ğ‘™ğ‘œğ‘ ğ‘’() â€“ Closes a connection between peers.
 Communication Networks Course
Page | 6
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a UDP socket between the Sender and the
Receiver.
3) Send the file via the RUDP protocol.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a UDP connection between the Receiver and
the Sender.
2) Get a connection from the sender, by the custom
RUDP protocol youâ€™ve built.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./RUDP_Receiver -p 1234
Starting Receiver...
Waiting for RUDP connection...
Connection request received, sending ACK.
Sender connected, beginning to receive file...
File transfer completed.
ACK sent.
Waiting for Sender response...
Sender sent exit message.
ACK sent.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 7
Part C â€“ Research â€“ 30 points
In this part, youâ€™ll conduct research about your implementations of part A and part B.
In the research itself, each one of the versions (TCP version and UDP version) will be run at
least 5 times (meaning that the file transfer will occur at least 5 times) by the following
conditions:
â€¢ For TCP, youâ€™ll run it in TCP Reno and TCP Cubic, alternating each time, for each
scenario, meaning that you run 5 times with TCP Reno in both Sender and Receiver,
and 5 times with TCP Cubic in both Sender and Receiver.
Bonus (5 points): Create a very large data set â€“ 5 times with TCP Reno in both Sender
and Receiver, 5 times with TCP Reno in Sender and TCP Cubic in Receiver, 5 times
with TCP Cubic in Sender and TCP Reno in Receiver, and 5 times with TCP Cubic in
both Sender and Receiver. This will give you a data set large enough, which allows
you to work with, compare with and to reach a definite conclusion.
â€¢ For RUDP, you will run it 5 times for each scenario.
â€¢ For both TCP and RUDP, you will run them on those scenarios of packet loss:
o 0% packet loss â€“ Control group, simulating perfect connection.
o 2% packet loss â€“ Simulating unstable connection that commonly occur.
o 5% packet loss â€“ Simulating bad connection.
o 10% packet loss â€“ Simulating extremely poor connection.
For each scenario, you must provide a filtered PCAP file and relevant screenshots that
explain each one of the steps in the process. (10 points)
After youâ€™ve gathered the data set for both TCP and Reliable UDP, answer the following
questions:
1) In TCP, which congestion control algorithm gave better results overall? TCP Reno or
TCP Cubic? Which one gave better results on high packet loss? Explain how you came
to this conclusion based on the data set youâ€™ve gathered. (5 points)
2) How did your implementation of Reliable UDP perform overall compared to regular
TCP? Which one is better for high packet loss? (5 points)
3) According to the data youâ€™ve gathered, in which scenarios and applications would we
prefer to use TCP and in which situations would we prefer to use reliable UDP?
Explain your answer. (5 points)
 Communication Networks Course
Page | 8
×¢× ×• ×¢×œ ×”×©××œ×•×ª ×”×‘××•×ª )5 × ×§×•×“×•×ª(:
â— ×‘"×¨×©×ª ×××™× ×”" ×”×›×•×•× ×” ×”×™× ×œ×¨×©×ª ×©×‘×” ××¢×˜ ×××•×“ ×—×‘×™×œ×•×ª ×”×•×œ×›×•×ª ×œ××™×‘×•×“. ×‘"×§×©×¨ ××¨×•×š" ×”×›×•×•× ×” ×”×™×
×œ×§×©×¨ TCP ×©×™×© ×‘×• ×”×¨×‘×” ×××•×“ ××™×“×¢ ×œ×©×œ×•×—. ××•×¦×¢ ×œ×”×’×“×™×œ ×‘ -TCP ××ª SSThreshold ×‘×ª×—×™×œ×ª ×”×§×©×¨.
×‘××™×–×” ××”××§×¨×™× ×”×‘××™× ×”×©×™× ×•×™ ×”×–×” ×¢×©×•×™ ×œ×”×•×¢×™×œ ×‘××™×“×” ×”××™×¨×‘×™×ª? × ××§.
.1 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
.2 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.3 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.4 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.5 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.6 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.7 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.8 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
â— A ×©×•×œ×— ×œ -B ×—×‘×™×œ×•×ª ××™×“×¢ ×‘×××¦×¢×•×ª ×§×©×¨ TCP. × ×ª×•×Ÿ ×›×™ ×”×§×©×¨ ××ª×—×™×œ ×¢× ×—×œ×•×Ÿ ×‘×’×•×“×œ 1MSS. ×”×§×©×¨
××¡×ª×™×™× ×‘×¤×¢× ×”×¨××©×•× ×” ×©×”×•× ××’×™×¢ ×œ -SSthresh. ×‘××”×œ×š ×”×§×©×¨ ×œ× ××•×‘×“×•×ª ×—×‘×™×œ×•×ª. × ×¡××Ÿ ×‘×§×™×¦×•×¨:
.SSthresh=S*MSS
× ×ª×•×Ÿ ×›×™ ×œ××•×¨×š ×›×œ ×”×§×©×¨ rwnd < MSS*S.
××”×™ ×”×ª×¤×•×§×” ×©×œ ×”×§×©×¨ ×-A ×œ-B( ×‘ -sec / Bytes )×‘×–××Ÿ ×”× "×œ? × ××§×™.
]S*MSS / [lg (S) * RTT*2 ×‘×¢×¨×š .1
]S*MSS / [S^0.5 * RTT*2 ×‘×¢×¨×š .2
S*MSS / RTT ×‘×¢×¨×š .3
S^2)*MSS / RTT( ×‘×¢×¨×š .4
â— ×©×ª×™ ×ª×—× ×•×ª ××ª×§×©×¨×•×ª ×‘××•×¤×Ÿ ××œ×—×•×˜×™ ×‘×©×™×˜×ª N Back Go.
× ×¡××Ÿ ×‘-X ××ª ×¡×¤×¨×ª ×”×‘×™×§×•×¨×ª ×©×œ ×”×ª.×–. ×©×œ×š. ×× ×©× ×™ ×©×•×ª×¤×™× ××’×™×©×™× ××ª ×”×ª×¨×’×™×œ ×™×—×“, X ×”×•× ×¡×¤×¨×ª
×”×‘×™×§×•×¨×ª ×‘×¢×œ×ª ×”×¢×¨×š ×”× ××•×š ×™×•×ª×¨ ××‘×™×Ÿ ×”×©×ª×™×™×.
×§×¦×‘ ×”×ª×§×©×•×¨×ª ×”×•× 8Gbps, ×•×’×•×“×œ ×›×œ ×—×‘×™×œ×” ×”×•× KByte*X. ×’×“×œ×™ ×”-headers ×•×” -Acks ×–× ×™×—×™×.
ï¿½ğ‘’ğ‘ ï¿½/ï¿½ï¿½ 8 , ×•×”××¨×—×§ ×‘×™×Ÿ ×”×ª×—× ×•×ª ×”×•× 1Km. ×§×¦×‘ ×”×”×ª×¤×©×˜×•×ª ×”×•× 10 â‹… 2
×–××Ÿ ×¢×™×‘×•×“ ×”× ×ª×•× ×™× ×‘×ª×—× ×•×ª ×–× ×™×—.
××£ ×—×‘×™×œ×” ×•××£ Ack ×œ× ×”×•×œ×›×™× ×œ××™×‘×•×“.
â— ××”×• X ×©×œ×š?
â— ××” ×¦×¨×™×š ×œ×”×™×•×ª ×’×•×“×œ ×—×œ×•×Ÿ ×”××©×œ×•×— ×›×“×™ ×œ×”×‘×˜×™×— ×ª×¤×•×§×” ××§×¡×™××œ×™×ª?
 Communication Networks Course
Page | 9
Bonus â€“ Improving the Reliable UDP â€“ 15 points
Note: This part isnâ€™t mandatory and is a bonus only!
In this part, youâ€™ll improve your RUDP implementation by adding the concepts of flow
control and congestion control from TCP. Youâ€™re free to choose which algorithms to
implement, as long as you explain in your PDF which algorithms youâ€™ve used. Youâ€™ll probably
need to make changes in the original design of the RUDP. Changes only need to be to the API
itself, ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„.
Points distribution:
â€¢ Flow control improvement â€“ 7 Points
â€¢ Congestion control improvement â€“ 8 points.
Guidance:
â€¢ For flow control, you must use one of the Sliding window techniques: stop-and-wait
ARQ, Go-Back-N or Selective repeat.
â€¢ List of known TCP congestion control algorithms, which you can use any one of them
for this bonus task, or makeup your own:
Figure 2 â€“ List of known TCP congestion control algorithms, Wikipedia
 Communication Networks Course
Page | 10
Appendix A â€“ Linux local packet loss tool
To simulate a packet loss in a local network, we'll use a Linux tool that's called Linux Traffic
Control (ğ‘¡ğ‘). This requires a full Linux installation, so working with WSL won't work.
If the tool isn't installed in your machine, you can install it by using the following commands:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’
If the installation didn't work, you can use the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’2
To create a packet loss scenario, type the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘ğ‘‘ğ‘‘ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
After creating a packet loss scenario, you can change the percentage by typing the following
command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘â„ğ‘ğ‘›ğ‘”ğ‘’ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
To remove the packet loss scenario, write the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘‘ğ‘’ğ‘™ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š
 Communication Networks Course
Page | 11
Appendix B â€“ ğ’ğ’‚ğ’(ğŸ) system calls
This appendixâ€™s purpose is to give you a better understanding of socket handling in C.
A recommended reference is Beejâ€™s Guide to Network Programming, by Brian â€œBeej
Jorgensenâ€ Hall, which gives a lot of information about sockets in C and functions.
Functions and documentation links:
â€¢ ğ’”ğ’ğ’„ğ’Œğ’†ğ’•(ğŸ) â€“ A Factory method system call that creates a socket with the given
parameters.
â€¢ ğ’ƒğ’Šğ’ğ’…(ğŸ) â€“ Whenever we create a new socket, we need to bind it to a specific port in
our machine, â€œto catch a portâ€. The port number is managed and used by the kernel
to link incoming packets to the corresponding application socket. The port numbers
are usually fixed. The ğ‘ğ‘‘ğ‘‘ğ‘Ÿ parameter must match the current socket that is used.
â€¢ ğ’ğ’Šğ’”ğ’•ğ’†ğ’(ğŸ) â€“ The ğ‘™ğ‘–ğ‘ ğ‘¡ğ‘’ğ‘›(2) system call doesn't do anything in the mean of
communication but only memory allocation (malloc) for stream sockets only. If we
won't allocate memory, any incoming connection will fail.
â€¢ ğ’„ğ’ğ’ğ’ğ’†ğ’„ğ’•(ğŸ) â€“ The ğ‘ğ‘œğ‘›ğ‘›ğ‘’ğ‘ğ‘¡(2) system call starts the link between a client and a
specific IP address and port number. The connection would complete when the
other side will call the ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call.
â€¢ ğ’‚ğ’„ğ’„ğ’†ğ’‘ğ’•(ğŸ) â€“ The ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call accepts the incoming stream connection
request from the other side, by the listening socket. This system call completes the
three-way handshake of stream socket (like TCP) and opens a new socket that has a
direct communication channel only with the other party in the handshake.
â€¢ ğ’”ğ’†ğ’ğ’…(ğŸ) and ğ’”ğ’†ğ’ğ’…ğ’•ğ’(ğŸ) â€“ The ğ‘ ğ‘’ğ‘›ğ‘‘(2) and ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system calls are an analogy
for the ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’(2) system call, specifcly for sockets, with flags set to 0. Those system
calls return the number of bytes that were sent through the socket itself, as the
number of bytes can vary. The ğ‘ ğ‘’ğ‘›ğ‘‘(2)system call designed for stream sockets (like
TCP), while the ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system call designed for datagram connection-less
sockets (like UDP). When the ğ‘ ğ‘’ğ‘›ğ‘‘(2) system call returns 0, it means that the other
party closed the connection.
â€¢ ğ’“ğ’†ğ’„ğ’—(ğŸ) and ğ’“ğ’†ğ’„ğ’—ğ’‡ğ’“ğ’ğ’(ğŸ) â€“ The ğ‘Ÿğ‘’ğ‘ğ‘£(2) and ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system calls are an
analogy for the ğ‘Ÿğ‘’ğ‘ğ‘‘(2) system call, specifically for sockets, with flags set to 0.
Those system calls return the number of bytes that were received through the socket
itself, as the number of bytes can vary. The ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call designed for stream
sockets (like TCP), while the ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system call designed for datagram
connection-less sockets (like UDP). When the ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call returns 0, it means
that the other party closed the connection.
â€¢ ğ’„ğ’ğ’ğ’”ğ’†(ğŸ) and ğ’”ğ’‰ğ’–ğ’•ğ’…ğ’ğ’˜ğ’(ğŸ) â€“ The ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) and ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2) system calls close
the socket. While ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) system call closes the whole socket, the ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2)
system call partially closes the socket for read/write.
 Communication Networks Course
Page | 12
Appendix C â€“ Random data generator
The data that you are going to send in this assignment is randomly generated. You can use
your own file with appropriate size or use the following function (or a function of your own)
to generate the data:
/*
* @brief A random data generator function based on srand() and rand().
* @param size The size of the data to generate (up to 2^32 bytes).
* @return A pointer to the buffer.
*/
char *util_generate_random_data(unsigned int size) {
 char *buffer = NULL;
 // Argument check.
 if (size == 0)
 return NULL;
 buffer = (char *)calloc(size, sizeof(char));
 // Error checking.
 if (buffer == NULL)
 return NULL;
 // Randomize the seed of the random number generator.
 srand(time(NULL));
 for (unsigned int i = 0; i < size; i++)
 *(buffer + i) = ((unsigned int)rand() % 256);
 return buffer;
}
 Communication Networks Course
Page | 13
Appendix D â€“ Checksum function
A checksum is a small-sized block of data derived from another block of digital data for the
purpose of detecting errors that may have been introduced during its transmission or
storage. By themselves, checksums are often used to verify data integrity but are not relied
upon to verify data authenticity.
Below is a simple yet efficient implementation of the checksum function, you can use it for
the assignment, but you can implement your own checksum function.
/*
* @brief A checksum function that returns 16 bit checksum for data.
* @param data The data to do the checksum for.
* @param bytes The length of the data in bytes.
* @return The checksum itself as 16 bit unsigned number.
* @note This function is taken from RFC1071, can be found here:
* @note https://tools.ietf.org/html/rfc1071
* @note It is the simplest way to calculate a checksum and is not very strong.
* However, it is good enough for this assignment.
* @note You are free to use any other checksum function as well.
* You can also use this function as such without any change.
*/
unsigned short int calculate_checksum(void *data, unsigned int bytes) {
 unsigned short int *data_pointer = (unsigned short int *)data;
 unsigned int total_sum = 0;
 // Main summing loop
 while (bytes > 1) {
 total_sum += *data_pointer++;
 bytes -= 2;
 }
 // Add left-over byte, if any
 if (bytes > 0)
 total_sum += *((unsigned char *)data_pointer);
 // Fold 32-bit sum to 16 bits
 while (total_sum >> 16)
 total_sum = (total_sum & 0xFFFF) + (total_sum >> 16);
 return (~((unsigned short int)total_sum));
} Communication Networks Course
Page | 1
Assignment 3 â€“ Transport Layer
Assignment Notes and Instructions
This assignment is to be done in pairs only. You must upload all the necessary files in a ZIP
file named after both of the studentâ€™s ID. For example: ğŸğŸğŸ‘ğŸ’ğŸ“ğŸ”ğŸ•ğŸ–ğŸ—_ğŸ—ğŸ–ğŸ•ğŸ”ğŸ“ğŸ’ğŸ‘ğŸğŸ. ğ’›ğ’Šğ’‘.
1) The assignment must be submitted by the date specified in the submission box.
2) All the assignment files (Code, Wireshark pcap files, PDF) must be submitted in a ZIP file. The
PDF must contain all the necessary screenshots with a description for each one of them.
3) The assignment must be done in pairs only. In exceptional cases, you should send an email to
the course coordinator.
4) You can use any reference material available through the course Moodle website or any
material passed during the exercises.
5) You can use any reference from the web, but copying codes from websites is forbidden; this
includes codes from other GitHub repositories. A student who gets caught in the act will
automatically fail this assignment (score 0). Any website youâ€™ve used to solve the
assignment, every website you used to solve the assignment must be noted in the PDF.
6) No delays in submission without special permission. Lateness without approval will result in
failure of the assignment (score 0).
7) All submissions will be submitted via the course's Moodle website. Email submissions will not
be accepted, resulting in a failure in the assignment.
8) The order and design of the code must be carefully considered. Make sure that the program
output is as clear as possible, comments in the code, and meaningful variable names. You
must also submit a makefile that compiles all the programs.
9) The assignment code must be written in C only.
10) The assignment is personal for each pair, and you should not accept help from other people,
whether outside the university or inside it. You can contact the course staff during reception
hours for help or raise a question in the course forum. Do not transfer code sections
between students, upload solutions or parts of solutions to websites on the Internet or in
various communication groups.
11) Students who copy a solution will receive a 0 in all assignments in the course and a report will
be made to the institutional disciplinary committee.
12) All code files of the assignment are required to both compile and run properly on the Ubuntu
22.04 LTS operating system. This is the operating system where the submissions will be
tested. You mustnâ€™t code it in Windows, as it uses different API for sockets. WSL wonâ€™t work,
as the task needs a tool that works only in a fully Linux environment.
Good Luck!
 Communication Networks Course
Page | 2
Part A â€“ Transmission Control Protocol (TCP) â€“ 30 points
In this part, youâ€™ll write two program files: ğ‘»ğ‘ªğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and ğ‘»ğ‘ªğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
The Sender will send a randomly generated file and the Receiver will receive it and measure
the time it took for his program to receive the file. The file size should be at least 2MB.
When running the Sender and Receiver, they both should support two standard congestion
control algorithms: TCP Reno and TCP Cubic.
Notes:
â€¢ The main goal of this part is to get familiar with the TCP concept of sending
messages between two endpoints.
â€¢ For approaching this part of the assignment, please be sure that you are familiar
with the congestion control algorithms and how to change them using the correct
method in C (see Appendix B for more information).
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). You've
learned that TCP is reliable by design, so you can assume that all the data have been
passed correctly, and thus, no need to recheck.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
Usage:
â€¢ Receiver:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
â€¢ Sender:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port of the Receiver.
â€¢ ğ‘¨ğ‘³ğ‘®ğ‘¶ â€“ The TCP congestion control algorithm that will be used by the party
member (either ğ’“ğ’†ğ’ğ’ for TCP Reno or ğ’„ğ’–ğ’ƒğ’Šğ’„ for TCP Cubic).
 Communication Networks Course
Page | 3
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a TCP socket between the Sender and the
Receiver.
3) Send the file.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a TCP connection between the Receiver and
the Sender.
2) Get a connection from the sender.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./TCP_Receiver -p 1234 -algo reno
Starting Receiver...
Waiting for TCP connection...
Sender connected, beginning to receive file...
File transfer completed.
Waiting for Sender response...
Sender sent exit message.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 4
Part B â€“ Reliable User Datagram Protocol (Reliable UDP or RUDP) â€“ 40 points
Youâ€™ve learned that while TCP is reliable, it lacks speed and has an overhead data of 20 bytes,
compering to UDP that needs only 8 bytes of overhead data.
Reliable UDP or RUDP, is a protocol that uses the UDP protocol for a faster transmission of
data, while adding a reliability layer to it, but without adding too much overhead data like
TCP.
A simple sketch for a RUDP connection would look something like this:
Your task in this part is to implement a Reliable protocol using UDP only. For simplicity, your
implementation should only support a handshake, closing scheme, error checking,
acknowledgment of received packets, and retransmission of lost packets.
Guidance:
â€¢ You can use ğ‘ ğ‘’ğ‘¡ğ‘ ğ‘œğ‘ğ‘˜ğ‘œğ‘ğ‘¡(2) for detecting a timeout.
â€¢ You need to build your own protocol, as Reliable UDP isnâ€™t a standard protocol (see a
draft of RUDP in this link), and no official header is provided. You can use this sketch
for a header, but you can come up with your own protocol, as long as it works.
Where:
o ğ‘³ğ’†ğ’ğ’ˆğ’•ğ’‰ is the length of the data itself, without the RUDP header.
o ğ‘ªğ’‰ğ’†ğ’„ğ’Œğ’”ğ’–ğ’ is a 16bit number that validates the correctness of the data.
o ğ‘­ğ’ğ’‚ğ’ˆğ’” is a special byte where we classify the packet itself (SYN, ACK, etc.).
â€¢ In your PDF, you must explain how your implementation of RUDP works â€“ How does
it detect a timeout to do retransmissions, how does the handshake work, what is the
header overhead, etc.
â€¢ For this part, youâ€™ll write three files: ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¨ğ‘·ğ‘°. ğ’„, ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and
ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
Reliable UDP Header proposed sketch
Byte 0 Byte 1 Byte 2 Byte 3
Length (2 Bytes) Checksum (2 Bytes)
Flags (1 Byte)
Figure 1 - RUDP Protocol Architecture, Geeksforgeeks
 Communication Networks Course
Page | 5
Notes:
â€¢ The Sender will send a random generated file and the Receiver will receive it and
measure the time it took for his program to receive the file. The file size should be at
least 2MB.
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). But, as the
RUDP is based on UDP, itâ€™s not reliable. You must use some form of error checking
(like checksum) to ensure that the packet wasnâ€™t alerted during the transfer.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
â€¢ The RUDP needs support only 1 sender and 1 receiver, for simplicity purposes.
Usage:
â€¢ Receiver:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
â€¢ Sender:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port that both the Sender and the Receiver will use.
The ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„ file will contain all the implementations of the RUDP API functions (That is, to
prevent reusing the same chuck of code both in the Sender and the Receiver.).
The API should support at the bare minimum the following functions (you decide what
parameters to implement, and what are the names of the functions, as long as the API is
explained in the PDF):
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘œğ‘ğ‘˜ğ‘’ğ‘¡() â€“ Creating a RUDP socket and creating a handshake between two
peers.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘’ğ‘›ğ‘‘() â€“ Sending data to the peer. The function should wait for an
acknowledgment packet, and if it didnâ€™t receive any, retransmits the data.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘Ÿğ‘’ğ‘ğ‘£() â€“ Receive data from a peer.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ğ‘™ğ‘œğ‘ ğ‘’() â€“ Closes a connection between peers.
 Communication Networks Course
Page | 6
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a UDP socket between the Sender and the
Receiver.
3) Send the file via the RUDP protocol.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a UDP connection between the Receiver and
the Sender.
2) Get a connection from the sender, by the custom
RUDP protocol youâ€™ve built.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./RUDP_Receiver -p 1234
Starting Receiver...
Waiting for RUDP connection...
Connection request received, sending ACK.
Sender connected, beginning to receive file...
File transfer completed.
ACK sent.
Waiting for Sender response...
Sender sent exit message.
ACK sent.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 7
Part C â€“ Research â€“ 30 points
In this part, youâ€™ll conduct research about your implementations of part A and part B.
In the research itself, each one of the versions (TCP version and UDP version) will be run at
least 5 times (meaning that the file transfer will occur at least 5 times) by the following
conditions:
â€¢ For TCP, youâ€™ll run it in TCP Reno and TCP Cubic, alternating each time, for each
scenario, meaning that you run 5 times with TCP Reno in both Sender and Receiver,
and 5 times with TCP Cubic in both Sender and Receiver.
Bonus (5 points): Create a very large data set â€“ 5 times with TCP Reno in both Sender
and Receiver, 5 times with TCP Reno in Sender and TCP Cubic in Receiver, 5 times
with TCP Cubic in Sender and TCP Reno in Receiver, and 5 times with TCP Cubic in
both Sender and Receiver. This will give you a data set large enough, which allows
you to work with, compare with and to reach a definite conclusion.
â€¢ For RUDP, you will run it 5 times for each scenario.
â€¢ For both TCP and RUDP, you will run them on those scenarios of packet loss:
o 0% packet loss â€“ Control group, simulating perfect connection.
o 2% packet loss â€“ Simulating unstable connection that commonly occur.
o 5% packet loss â€“ Simulating bad connection.
o 10% packet loss â€“ Simulating extremely poor connection.
For each scenario, you must provide a filtered PCAP file and relevant screenshots that
explain each one of the steps in the process. (10 points)
After youâ€™ve gathered the data set for both TCP and Reliable UDP, answer the following
questions:
1) In TCP, which congestion control algorithm gave better results overall? TCP Reno or
TCP Cubic? Which one gave better results on high packet loss? Explain how you came
to this conclusion based on the data set youâ€™ve gathered. (5 points)
2) How did your implementation of Reliable UDP perform overall compared to regular
TCP? Which one is better for high packet loss? (5 points)
3) According to the data youâ€™ve gathered, in which scenarios and applications would we
prefer to use TCP and in which situations would we prefer to use reliable UDP?
Explain your answer. (5 points)
 Communication Networks Course
Page | 8
×¢× ×• ×¢×œ ×”×©××œ×•×ª ×”×‘××•×ª )5 × ×§×•×“×•×ª(:
â— ×‘"×¨×©×ª ×××™× ×”" ×”×›×•×•× ×” ×”×™× ×œ×¨×©×ª ×©×‘×” ××¢×˜ ×××•×“ ×—×‘×™×œ×•×ª ×”×•×œ×›×•×ª ×œ××™×‘×•×“. ×‘"×§×©×¨ ××¨×•×š" ×”×›×•×•× ×” ×”×™×
×œ×§×©×¨ TCP ×©×™×© ×‘×• ×”×¨×‘×” ×××•×“ ××™×“×¢ ×œ×©×œ×•×—. ××•×¦×¢ ×œ×”×’×“×™×œ ×‘ -TCP ××ª SSThreshold ×‘×ª×—×™×œ×ª ×”×§×©×¨.
×‘××™×–×” ××”××§×¨×™× ×”×‘××™× ×”×©×™× ×•×™ ×”×–×” ×¢×©×•×™ ×œ×”×•×¢×™×œ ×‘××™×“×” ×”××™×¨×‘×™×ª? × ××§.
.1 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
.2 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.3 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.4 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.5 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.6 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.7 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.8 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
â— A ×©×•×œ×— ×œ -B ×—×‘×™×œ×•×ª ××™×“×¢ ×‘×××¦×¢×•×ª ×§×©×¨ TCP. × ×ª×•×Ÿ ×›×™ ×”×§×©×¨ ××ª×—×™×œ ×¢× ×—×œ×•×Ÿ ×‘×’×•×“×œ 1MSS. ×”×§×©×¨
××¡×ª×™×™× ×‘×¤×¢× ×”×¨××©×•× ×” ×©×”×•× ××’×™×¢ ×œ -SSthresh. ×‘××”×œ×š ×”×§×©×¨ ×œ× ××•×‘×“×•×ª ×—×‘×™×œ×•×ª. × ×¡××Ÿ ×‘×§×™×¦×•×¨:
.SSthresh=S*MSS
× ×ª×•×Ÿ ×›×™ ×œ××•×¨×š ×›×œ ×”×§×©×¨ rwnd < MSS*S.
××”×™ ×”×ª×¤×•×§×” ×©×œ ×”×§×©×¨ ×-A ×œ-B( ×‘ -sec / Bytes )×‘×–××Ÿ ×”× "×œ? × ××§×™.
]S*MSS / [lg (S) * RTT*2 ×‘×¢×¨×š .1
]S*MSS / [S^0.5 * RTT*2 ×‘×¢×¨×š .2
S*MSS / RTT ×‘×¢×¨×š .3
S^2)*MSS / RTT( ×‘×¢×¨×š .4
â— ×©×ª×™ ×ª×—× ×•×ª ××ª×§×©×¨×•×ª ×‘××•×¤×Ÿ ××œ×—×•×˜×™ ×‘×©×™×˜×ª N Back Go.
× ×¡××Ÿ ×‘-X ××ª ×¡×¤×¨×ª ×”×‘×™×§×•×¨×ª ×©×œ ×”×ª.×–. ×©×œ×š. ×× ×©× ×™ ×©×•×ª×¤×™× ××’×™×©×™× ××ª ×”×ª×¨×’×™×œ ×™×—×“, X ×”×•× ×¡×¤×¨×ª
×”×‘×™×§×•×¨×ª ×‘×¢×œ×ª ×”×¢×¨×š ×”× ××•×š ×™×•×ª×¨ ××‘×™×Ÿ ×”×©×ª×™×™×.
×§×¦×‘ ×”×ª×§×©×•×¨×ª ×”×•× 8Gbps, ×•×’×•×“×œ ×›×œ ×—×‘×™×œ×” ×”×•× KByte*X. ×’×“×œ×™ ×”-headers ×•×” -Acks ×–× ×™×—×™×.
ï¿½ğ‘’ğ‘ ï¿½/ï¿½ï¿½ 8 , ×•×”××¨×—×§ ×‘×™×Ÿ ×”×ª×—× ×•×ª ×”×•× 1Km. ×§×¦×‘ ×”×”×ª×¤×©×˜×•×ª ×”×•× 10 â‹… 2
×–××Ÿ ×¢×™×‘×•×“ ×”× ×ª×•× ×™× ×‘×ª×—× ×•×ª ×–× ×™×—.
××£ ×—×‘×™×œ×” ×•××£ Ack ×œ× ×”×•×œ×›×™× ×œ××™×‘×•×“.
â— ××”×• X ×©×œ×š?
â— ××” ×¦×¨×™×š ×œ×”×™×•×ª ×’×•×“×œ ×—×œ×•×Ÿ ×”××©×œ×•×— ×›×“×™ ×œ×”×‘×˜×™×— ×ª×¤×•×§×” ××§×¡×™××œ×™×ª?
 Communication Networks Course
Page | 9
Bonus â€“ Improving the Reliable UDP â€“ 15 points
Note: This part isnâ€™t mandatory and is a bonus only!
In this part, youâ€™ll improve your RUDP implementation by adding the concepts of flow
control and congestion control from TCP. Youâ€™re free to choose which algorithms to
implement, as long as you explain in your PDF which algorithms youâ€™ve used. Youâ€™ll probably
need to make changes in the original design of the RUDP. Changes only need to be to the API
itself, ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„.
Points distribution:
â€¢ Flow control improvement â€“ 7 Points
â€¢ Congestion control improvement â€“ 8 points.
Guidance:
â€¢ For flow control, you must use one of the Sliding window techniques: stop-and-wait
ARQ, Go-Back-N or Selective repeat.
â€¢ List of known TCP congestion control algorithms, which you can use any one of them
for this bonus task, or makeup your own:
Figure 2 â€“ List of known TCP congestion control algorithms, Wikipedia
 Communication Networks Course
Page | 10
Appendix A â€“ Linux local packet loss tool
To simulate a packet loss in a local network, we'll use a Linux tool that's called Linux Traffic
Control (ğ‘¡ğ‘). This requires a full Linux installation, so working with WSL won't work.
If the tool isn't installed in your machine, you can install it by using the following commands:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’
If the installation didn't work, you can use the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’2
To create a packet loss scenario, type the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘ğ‘‘ğ‘‘ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
After creating a packet loss scenario, you can change the percentage by typing the following
command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘â„ğ‘ğ‘›ğ‘”ğ‘’ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
To remove the packet loss scenario, write the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘‘ğ‘’ğ‘™ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š
 Communication Networks Course
Page | 11
Appendix B â€“ ğ’ğ’‚ğ’(ğŸ) system calls
This appendixâ€™s purpose is to give you a better understanding of socket handling in C.
A recommended reference is Beejâ€™s Guide to Network Programming, by Brian â€œBeej
Jorgensenâ€ Hall, which gives a lot of information about sockets in C and functions.
Functions and documentation links:
â€¢ ğ’”ğ’ğ’„ğ’Œğ’†ğ’•(ğŸ) â€“ A Factory method system call that creates a socket with the given
parameters.
â€¢ ğ’ƒğ’Šğ’ğ’…(ğŸ) â€“ Whenever we create a new socket, we need to bind it to a specific port in
our machine, â€œto catch a portâ€. The port number is managed and used by the kernel
to link incoming packets to the corresponding application socket. The port numbers
are usually fixed. The ğ‘ğ‘‘ğ‘‘ğ‘Ÿ parameter must match the current socket that is used.
â€¢ ğ’ğ’Šğ’”ğ’•ğ’†ğ’(ğŸ) â€“ The ğ‘™ğ‘–ğ‘ ğ‘¡ğ‘’ğ‘›(2) system call doesn't do anything in the mean of
communication but only memory allocation (malloc) for stream sockets only. If we
won't allocate memory, any incoming connection will fail.
â€¢ ğ’„ğ’ğ’ğ’ğ’†ğ’„ğ’•(ğŸ) â€“ The ğ‘ğ‘œğ‘›ğ‘›ğ‘’ğ‘ğ‘¡(2) system call starts the link between a client and a
specific IP address and port number. The connection would complete when the
other side will call the ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call.
â€¢ ğ’‚ğ’„ğ’„ğ’†ğ’‘ğ’•(ğŸ) â€“ The ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call accepts the incoming stream connection
request from the other side, by the listening socket. This system call completes the
three-way handshake of stream socket (like TCP) and opens a new socket that has a
direct communication channel only with the other party in the handshake.
â€¢ ğ’”ğ’†ğ’ğ’…(ğŸ) and ğ’”ğ’†ğ’ğ’…ğ’•ğ’(ğŸ) â€“ The ğ‘ ğ‘’ğ‘›ğ‘‘(2) and ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system calls are an analogy
for the ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’(2) system call, specifcly for sockets, with flags set to 0. Those system
calls return the number of bytes that were sent through the socket itself, as the
number of bytes can vary. The ğ‘ ğ‘’ğ‘›ğ‘‘(2)system call designed for stream sockets (like
TCP), while the ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system call designed for datagram connection-less
sockets (like UDP). When the ğ‘ ğ‘’ğ‘›ğ‘‘(2) system call returns 0, it means that the other
party closed the connection.
â€¢ ğ’“ğ’†ğ’„ğ’—(ğŸ) and ğ’“ğ’†ğ’„ğ’—ğ’‡ğ’“ğ’ğ’(ğŸ) â€“ The ğ‘Ÿğ‘’ğ‘ğ‘£(2) and ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system calls are an
analogy for the ğ‘Ÿğ‘’ğ‘ğ‘‘(2) system call, specifically for sockets, with flags set to 0.
Those system calls return the number of bytes that were received through the socket
itself, as the number of bytes can vary. The ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call designed for stream
sockets (like TCP), while the ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system call designed for datagram
connection-less sockets (like UDP). When the ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call returns 0, it means
that the other party closed the connection.
â€¢ ğ’„ğ’ğ’ğ’”ğ’†(ğŸ) and ğ’”ğ’‰ğ’–ğ’•ğ’…ğ’ğ’˜ğ’(ğŸ) â€“ The ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) and ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2) system calls close
the socket. While ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) system call closes the whole socket, the ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2)
system call partially closes the socket for read/write.
 Communication Networks Course
Page | 12
Appendix C â€“ Random data generator
The data that you are going to send in this assignment is randomly generated. You can use
your own file with appropriate size or use the following function (or a function of your own)
to generate the data:
/*
* @brief A random data generator function based on srand() and rand().
* @param size The size of the data to generate (up to 2^32 bytes).
* @return A pointer to the buffer.
*/
char *util_generate_random_data(unsigned int size) {
 char *buffer = NULL;
 // Argument check.
 if (size == 0)
 return NULL;
 buffer = (char *)calloc(size, sizeof(char));
 // Error checking.
 if (buffer == NULL)
 return NULL;
 // Randomize the seed of the random number generator.
 srand(time(NULL));
 for (unsigned int i = 0; i < size; i++)
 *(buffer + i) = ((unsigned int)rand() % 256);
 return buffer;
}
 Communication Networks Course
Page | 13
Appendix D â€“ Checksum function
A checksum is a small-sized block of data derived from another block of digital data for the
purpose of detecting errors that may have been introduced during its transmission or
storage. By themselves, checksums are often used to verify data integrity but are not relied
upon to verify data authenticity.
Below is a simple yet efficient implementation of the checksum function, you can use it for
the assignment, but you can implement your own checksum function.
/*
* @brief A checksum function that returns 16 bit checksum for data.
* @param data The data to do the checksum for.
* @param bytes The length of the data in bytes.
* @return The checksum itself as 16 bit unsigned number.
* @note This function is taken from RFC1071, can be found here:
* @note https://tools.ietf.org/html/rfc1071
* @note It is the simplest way to calculate a checksum and is not very strong.
* However, it is good enough for this assignment.
* @note You are free to use any other checksum function as well.
* You can also use this function as such without any change.
*/
unsigned short int calculate_checksum(void *data, unsigned int bytes) {
 unsigned short int *data_pointer = (unsigned short int *)data;
 unsigned int total_sum = 0;
 // Main summing loop
 while (bytes > 1) {
 total_sum += *data_pointer++;
 bytes -= 2;
 }
 // Add left-over byte, if any
 if (bytes > 0)
 total_sum += *((unsigned char *)data_pointer);
 // Fold 32-bit sum to 16 bits
 while (total_sum >> 16)
 total_sum = (total_sum & 0xFFFF) + (total_sum >> 16);
 return (~((unsigned short int)total_sum));
} Communication Networks Course
Page | 1
Assignment 3 â€“ Transport Layer
Assignment Notes and Instructions
This assignment is to be done in pairs only. You must upload all the necessary files in a ZIP
file named after both of the studentâ€™s ID. For example: ğŸğŸğŸ‘ğŸ’ğŸ“ğŸ”ğŸ•ğŸ–ğŸ—_ğŸ—ğŸ–ğŸ•ğŸ”ğŸ“ğŸ’ğŸ‘ğŸğŸ. ğ’›ğ’Šğ’‘.
1) The assignment must be submitted by the date specified in the submission box.
2) All the assignment files (Code, Wireshark pcap files, PDF) must be submitted in a ZIP file. The
PDF must contain all the necessary screenshots with a description for each one of them.
3) The assignment must be done in pairs only. In exceptional cases, you should send an email to
the course coordinator.
4) You can use any reference material available through the course Moodle website or any
material passed during the exercises.
5) You can use any reference from the web, but copying codes from websites is forbidden; this
includes codes from other GitHub repositories. A student who gets caught in the act will
automatically fail this assignment (score 0). Any website youâ€™ve used to solve the
assignment, every website you used to solve the assignment must be noted in the PDF.
6) No delays in submission without special permission. Lateness without approval will result in
failure of the assignment (score 0).
7) All submissions will be submitted via the course's Moodle website. Email submissions will not
be accepted, resulting in a failure in the assignment.
8) The order and design of the code must be carefully considered. Make sure that the program
output is as clear as possible, comments in the code, and meaningful variable names. You
must also submit a makefile that compiles all the programs.
9) The assignment code must be written in C only.
10) The assignment is personal for each pair, and you should not accept help from other people,
whether outside the university or inside it. You can contact the course staff during reception
hours for help or raise a question in the course forum. Do not transfer code sections
between students, upload solutions or parts of solutions to websites on the Internet or in
various communication groups.
11) Students who copy a solution will receive a 0 in all assignments in the course and a report will
be made to the institutional disciplinary committee.
12) All code files of the assignment are required to both compile and run properly on the Ubuntu
22.04 LTS operating system. This is the operating system where the submissions will be
tested. You mustnâ€™t code it in Windows, as it uses different API for sockets. WSL wonâ€™t work,
as the task needs a tool that works only in a fully Linux environment.
Good Luck!
 Communication Networks Course
Page | 2
Part A â€“ Transmission Control Protocol (TCP) â€“ 30 points
In this part, youâ€™ll write two program files: ğ‘»ğ‘ªğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and ğ‘»ğ‘ªğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
The Sender will send a randomly generated file and the Receiver will receive it and measure
the time it took for his program to receive the file. The file size should be at least 2MB.
When running the Sender and Receiver, they both should support two standard congestion
control algorithms: TCP Reno and TCP Cubic.
Notes:
â€¢ The main goal of this part is to get familiar with the TCP concept of sending
messages between two endpoints.
â€¢ For approaching this part of the assignment, please be sure that you are familiar
with the congestion control algorithms and how to change them using the correct
method in C (see Appendix B for more information).
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). You've
learned that TCP is reliable by design, so you can assume that all the data have been
passed correctly, and thus, no need to recheck.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
Usage:
â€¢ Receiver:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
â€¢ Sender:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port of the Receiver.
â€¢ ğ‘¨ğ‘³ğ‘®ğ‘¶ â€“ The TCP congestion control algorithm that will be used by the party
member (either ğ’“ğ’†ğ’ğ’ for TCP Reno or ğ’„ğ’–ğ’ƒğ’Šğ’„ for TCP Cubic).
 Communication Networks Course
Page | 3
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a TCP socket between the Sender and the
Receiver.
3) Send the file.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a TCP connection between the Receiver and
the Sender.
2) Get a connection from the sender.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./TCP_Receiver -p 1234 -algo reno
Starting Receiver...
Waiting for TCP connection...
Sender connected, beginning to receive file...
File transfer completed.
Waiting for Sender response...
Sender sent exit message.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 4
Part B â€“ Reliable User Datagram Protocol (Reliable UDP or RUDP) â€“ 40 points
Youâ€™ve learned that while TCP is reliable, it lacks speed and has an overhead data of 20 bytes,
compering to UDP that needs only 8 bytes of overhead data.
Reliable UDP or RUDP, is a protocol that uses the UDP protocol for a faster transmission of
data, while adding a reliability layer to it, but without adding too much overhead data like
TCP.
A simple sketch for a RUDP connection would look something like this:
Your task in this part is to implement a Reliable protocol using UDP only. For simplicity, your
implementation should only support a handshake, closing scheme, error checking,
acknowledgment of received packets, and retransmission of lost packets.
Guidance:
â€¢ You can use ğ‘ ğ‘’ğ‘¡ğ‘ ğ‘œğ‘ğ‘˜ğ‘œğ‘ğ‘¡(2) for detecting a timeout.
â€¢ You need to build your own protocol, as Reliable UDP isnâ€™t a standard protocol (see a
draft of RUDP in this link), and no official header is provided. You can use this sketch
for a header, but you can come up with your own protocol, as long as it works.
Where:
o ğ‘³ğ’†ğ’ğ’ˆğ’•ğ’‰ is the length of the data itself, without the RUDP header.
o ğ‘ªğ’‰ğ’†ğ’„ğ’Œğ’”ğ’–ğ’ is a 16bit number that validates the correctness of the data.
o ğ‘­ğ’ğ’‚ğ’ˆğ’” is a special byte where we classify the packet itself (SYN, ACK, etc.).
â€¢ In your PDF, you must explain how your implementation of RUDP works â€“ How does
it detect a timeout to do retransmissions, how does the handshake work, what is the
header overhead, etc.
â€¢ For this part, youâ€™ll write three files: ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¨ğ‘·ğ‘°. ğ’„, ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and
ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
Reliable UDP Header proposed sketch
Byte 0 Byte 1 Byte 2 Byte 3
Length (2 Bytes) Checksum (2 Bytes)
Flags (1 Byte)
Figure 1 - RUDP Protocol Architecture, Geeksforgeeks
 Communication Networks Course
Page | 5
Notes:
â€¢ The Sender will send a random generated file and the Receiver will receive it and
measure the time it took for his program to receive the file. The file size should be at
least 2MB.
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). But, as the
RUDP is based on UDP, itâ€™s not reliable. You must use some form of error checking
(like checksum) to ensure that the packet wasnâ€™t alerted during the transfer.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
â€¢ The RUDP needs support only 1 sender and 1 receiver, for simplicity purposes.
Usage:
â€¢ Receiver:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
â€¢ Sender:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port that both the Sender and the Receiver will use.
The ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„ file will contain all the implementations of the RUDP API functions (That is, to
prevent reusing the same chuck of code both in the Sender and the Receiver.).
The API should support at the bare minimum the following functions (you decide what
parameters to implement, and what are the names of the functions, as long as the API is
explained in the PDF):
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘œğ‘ğ‘˜ğ‘’ğ‘¡() â€“ Creating a RUDP socket and creating a handshake between two
peers.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘’ğ‘›ğ‘‘() â€“ Sending data to the peer. The function should wait for an
acknowledgment packet, and if it didnâ€™t receive any, retransmits the data.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘Ÿğ‘’ğ‘ğ‘£() â€“ Receive data from a peer.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ğ‘™ğ‘œğ‘ ğ‘’() â€“ Closes a connection between peers.
 Communication Networks Course
Page | 6
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a UDP socket between the Sender and the
Receiver.
3) Send the file via the RUDP protocol.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a UDP connection between the Receiver and
the Sender.
2) Get a connection from the sender, by the custom
RUDP protocol youâ€™ve built.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./RUDP_Receiver -p 1234
Starting Receiver...
Waiting for RUDP connection...
Connection request received, sending ACK.
Sender connected, beginning to receive file...
File transfer completed.
ACK sent.
Waiting for Sender response...
Sender sent exit message.
ACK sent.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 7
Part C â€“ Research â€“ 30 points
In this part, youâ€™ll conduct research about your implementations of part A and part B.
In the research itself, each one of the versions (TCP version and UDP version) will be run at
least 5 times (meaning that the file transfer will occur at least 5 times) by the following
conditions:
â€¢ For TCP, youâ€™ll run it in TCP Reno and TCP Cubic, alternating each time, for each
scenario, meaning that you run 5 times with TCP Reno in both Sender and Receiver,
and 5 times with TCP Cubic in both Sender and Receiver.
Bonus (5 points): Create a very large data set â€“ 5 times with TCP Reno in both Sender
and Receiver, 5 times with TCP Reno in Sender and TCP Cubic in Receiver, 5 times
with TCP Cubic in Sender and TCP Reno in Receiver, and 5 times with TCP Cubic in
both Sender and Receiver. This will give you a data set large enough, which allows
you to work with, compare with and to reach a definite conclusion.
â€¢ For RUDP, you will run it 5 times for each scenario.
â€¢ For both TCP and RUDP, you will run them on those scenarios of packet loss:
o 0% packet loss â€“ Control group, simulating perfect connection.
o 2% packet loss â€“ Simulating unstable connection that commonly occur.
o 5% packet loss â€“ Simulating bad connection.
o 10% packet loss â€“ Simulating extremely poor connection.
For each scenario, you must provide a filtered PCAP file and relevant screenshots that
explain each one of the steps in the process. (10 points)
After youâ€™ve gathered the data set for both TCP and Reliable UDP, answer the following
questions:
1) In TCP, which congestion control algorithm gave better results overall? TCP Reno or
TCP Cubic? Which one gave better results on high packet loss? Explain how you came
to this conclusion based on the data set youâ€™ve gathered. (5 points)
2) How did your implementation of Reliable UDP perform overall compared to regular
TCP? Which one is better for high packet loss? (5 points)
3) According to the data youâ€™ve gathered, in which scenarios and applications would we
prefer to use TCP and in which situations would we prefer to use reliable UDP?
Explain your answer. (5 points)
 Communication Networks Course
Page | 8
×¢× ×• ×¢×œ ×”×©××œ×•×ª ×”×‘××•×ª )5 × ×§×•×“×•×ª(:
â— ×‘"×¨×©×ª ×××™× ×”" ×”×›×•×•× ×” ×”×™× ×œ×¨×©×ª ×©×‘×” ××¢×˜ ×××•×“ ×—×‘×™×œ×•×ª ×”×•×œ×›×•×ª ×œ××™×‘×•×“. ×‘"×§×©×¨ ××¨×•×š" ×”×›×•×•× ×” ×”×™×
×œ×§×©×¨ TCP ×©×™×© ×‘×• ×”×¨×‘×” ×××•×“ ××™×“×¢ ×œ×©×œ×•×—. ××•×¦×¢ ×œ×”×’×“×™×œ ×‘ -TCP ××ª SSThreshold ×‘×ª×—×™×œ×ª ×”×§×©×¨.
×‘××™×–×” ××”××§×¨×™× ×”×‘××™× ×”×©×™× ×•×™ ×”×–×” ×¢×©×•×™ ×œ×”×•×¢×™×œ ×‘××™×“×” ×”××™×¨×‘×™×ª? × ××§.
.1 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
.2 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.3 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.4 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.5 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.6 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.7 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.8 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
â— A ×©×•×œ×— ×œ -B ×—×‘×™×œ×•×ª ××™×“×¢ ×‘×××¦×¢×•×ª ×§×©×¨ TCP. × ×ª×•×Ÿ ×›×™ ×”×§×©×¨ ××ª×—×™×œ ×¢× ×—×œ×•×Ÿ ×‘×’×•×“×œ 1MSS. ×”×§×©×¨
××¡×ª×™×™× ×‘×¤×¢× ×”×¨××©×•× ×” ×©×”×•× ××’×™×¢ ×œ -SSthresh. ×‘××”×œ×š ×”×§×©×¨ ×œ× ××•×‘×“×•×ª ×—×‘×™×œ×•×ª. × ×¡××Ÿ ×‘×§×™×¦×•×¨:
.SSthresh=S*MSS
× ×ª×•×Ÿ ×›×™ ×œ××•×¨×š ×›×œ ×”×§×©×¨ rwnd < MSS*S.
××”×™ ×”×ª×¤×•×§×” ×©×œ ×”×§×©×¨ ×-A ×œ-B( ×‘ -sec / Bytes )×‘×–××Ÿ ×”× "×œ? × ××§×™.
]S*MSS / [lg (S) * RTT*2 ×‘×¢×¨×š .1
]S*MSS / [S^0.5 * RTT*2 ×‘×¢×¨×š .2
S*MSS / RTT ×‘×¢×¨×š .3
S^2)*MSS / RTT( ×‘×¢×¨×š .4
â— ×©×ª×™ ×ª×—× ×•×ª ××ª×§×©×¨×•×ª ×‘××•×¤×Ÿ ××œ×—×•×˜×™ ×‘×©×™×˜×ª N Back Go.
× ×¡××Ÿ ×‘-X ××ª ×¡×¤×¨×ª ×”×‘×™×§×•×¨×ª ×©×œ ×”×ª.×–. ×©×œ×š. ×× ×©× ×™ ×©×•×ª×¤×™× ××’×™×©×™× ××ª ×”×ª×¨×’×™×œ ×™×—×“, X ×”×•× ×¡×¤×¨×ª
×”×‘×™×§×•×¨×ª ×‘×¢×œ×ª ×”×¢×¨×š ×”× ××•×š ×™×•×ª×¨ ××‘×™×Ÿ ×”×©×ª×™×™×.
×§×¦×‘ ×”×ª×§×©×•×¨×ª ×”×•× 8Gbps, ×•×’×•×“×œ ×›×œ ×—×‘×™×œ×” ×”×•× KByte*X. ×’×“×œ×™ ×”-headers ×•×” -Acks ×–× ×™×—×™×.
ï¿½ğ‘’ğ‘ ï¿½/ï¿½ï¿½ 8 , ×•×”××¨×—×§ ×‘×™×Ÿ ×”×ª×—× ×•×ª ×”×•× 1Km. ×§×¦×‘ ×”×”×ª×¤×©×˜×•×ª ×”×•× 10 â‹… 2
×–××Ÿ ×¢×™×‘×•×“ ×”× ×ª×•× ×™× ×‘×ª×—× ×•×ª ×–× ×™×—.
××£ ×—×‘×™×œ×” ×•××£ Ack ×œ× ×”×•×œ×›×™× ×œ××™×‘×•×“.
â— ××”×• X ×©×œ×š?
â— ××” ×¦×¨×™×š ×œ×”×™×•×ª ×’×•×“×œ ×—×œ×•×Ÿ ×”××©×œ×•×— ×›×“×™ ×œ×”×‘×˜×™×— ×ª×¤×•×§×” ××§×¡×™××œ×™×ª?
 Communication Networks Course
Page | 9
Bonus â€“ Improving the Reliable UDP â€“ 15 points
Note: This part isnâ€™t mandatory and is a bonus only!
In this part, youâ€™ll improve your RUDP implementation by adding the concepts of flow
control and congestion control from TCP. Youâ€™re free to choose which algorithms to
implement, as long as you explain in your PDF which algorithms youâ€™ve used. Youâ€™ll probably
need to make changes in the original design of the RUDP. Changes only need to be to the API
itself, ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„.
Points distribution:
â€¢ Flow control improvement â€“ 7 Points
â€¢ Congestion control improvement â€“ 8 points.
Guidance:
â€¢ For flow control, you must use one of the Sliding window techniques: stop-and-wait
ARQ, Go-Back-N or Selective repeat.
â€¢ List of known TCP congestion control algorithms, which you can use any one of them
for this bonus task, or makeup your own:
Figure 2 â€“ List of known TCP congestion control algorithms, Wikipedia
 Communication Networks Course
Page | 10
Appendix A â€“ Linux local packet loss tool
To simulate a packet loss in a local network, we'll use a Linux tool that's called Linux Traffic
Control (ğ‘¡ğ‘). This requires a full Linux installation, so working with WSL won't work.
If the tool isn't installed in your machine, you can install it by using the following commands:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’
If the installation didn't work, you can use the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’2
To create a packet loss scenario, type the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘ğ‘‘ğ‘‘ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
After creating a packet loss scenario, you can change the percentage by typing the following
command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘â„ğ‘ğ‘›ğ‘”ğ‘’ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
To remove the packet loss scenario, write the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘‘ğ‘’ğ‘™ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š
 Communication Networks Course
Page | 11
Appendix B â€“ ğ’ğ’‚ğ’(ğŸ) system calls
This appendixâ€™s purpose is to give you a better understanding of socket handling in C.
A recommended reference is Beejâ€™s Guide to Network Programming, by Brian â€œBeej
Jorgensenâ€ Hall, which gives a lot of information about sockets in C and functions.
Functions and documentation links:
â€¢ ğ’”ğ’ğ’„ğ’Œğ’†ğ’•(ğŸ) â€“ A Factory method system call that creates a socket with the given
parameters.
â€¢ ğ’ƒğ’Šğ’ğ’…(ğŸ) â€“ Whenever we create a new socket, we need to bind it to a specific port in
our machine, â€œto catch a portâ€. The port number is managed and used by the kernel
to link incoming packets to the corresponding application socket. The port numbers
are usually fixed. The ğ‘ğ‘‘ğ‘‘ğ‘Ÿ parameter must match the current socket that is used.
â€¢ ğ’ğ’Šğ’”ğ’•ğ’†ğ’(ğŸ) â€“ The ğ‘™ğ‘–ğ‘ ğ‘¡ğ‘’ğ‘›(2) system call doesn't do anything in the mean of
communication but only memory allocation (malloc) for stream sockets only. If we
won't allocate memory, any incoming connection will fail.
â€¢ ğ’„ğ’ğ’ğ’ğ’†ğ’„ğ’•(ğŸ) â€“ The ğ‘ğ‘œğ‘›ğ‘›ğ‘’ğ‘ğ‘¡(2) system call starts the link between a client and a
specific IP address and port number. The connection would complete when the
other side will call the ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call.
â€¢ ğ’‚ğ’„ğ’„ğ’†ğ’‘ğ’•(ğŸ) â€“ The ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call accepts the incoming stream connection
request from the other side, by the listening socket. This system call completes the
three-way handshake of stream socket (like TCP) and opens a new socket that has a
direct communication channel only with the other party in the handshake.
â€¢ ğ’”ğ’†ğ’ğ’…(ğŸ) and ğ’”ğ’†ğ’ğ’…ğ’•ğ’(ğŸ) â€“ The ğ‘ ğ‘’ğ‘›ğ‘‘(2) and ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system calls are an analogy
for the ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’(2) system call, specifcly for sockets, with flags set to 0. Those system
calls return the number of bytes that were sent through the socket itself, as the
number of bytes can vary. The ğ‘ ğ‘’ğ‘›ğ‘‘(2)system call designed for stream sockets (like
TCP), while the ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system call designed for datagram connection-less
sockets (like UDP). When the ğ‘ ğ‘’ğ‘›ğ‘‘(2) system call returns 0, it means that the other
party closed the connection.
â€¢ ğ’“ğ’†ğ’„ğ’—(ğŸ) and ğ’“ğ’†ğ’„ğ’—ğ’‡ğ’“ğ’ğ’(ğŸ) â€“ The ğ‘Ÿğ‘’ğ‘ğ‘£(2) and ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system calls are an
analogy for the ğ‘Ÿğ‘’ğ‘ğ‘‘(2) system call, specifically for sockets, with flags set to 0.
Those system calls return the number of bytes that were received through the socket
itself, as the number of bytes can vary. The ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call designed for stream
sockets (like TCP), while the ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system call designed for datagram
connection-less sockets (like UDP). When the ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call returns 0, it means
that the other party closed the connection.
â€¢ ğ’„ğ’ğ’ğ’”ğ’†(ğŸ) and ğ’”ğ’‰ğ’–ğ’•ğ’…ğ’ğ’˜ğ’(ğŸ) â€“ The ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) and ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2) system calls close
the socket. While ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) system call closes the whole socket, the ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2)
system call partially closes the socket for read/write.
 Communication Networks Course
Page | 12
Appendix C â€“ Random data generator
The data that you are going to send in this assignment is randomly generated. You can use
your own file with appropriate size or use the following function (or a function of your own)
to generate the data:
/*
* @brief A random data generator function based on srand() and rand().
* @param size The size of the data to generate (up to 2^32 bytes).
* @return A pointer to the buffer.
*/
char *util_generate_random_data(unsigned int size) {
 char *buffer = NULL;
 // Argument check.
 if (size == 0)
 return NULL;
 buffer = (char *)calloc(size, sizeof(char));
 // Error checking.
 if (buffer == NULL)
 return NULL;
 // Randomize the seed of the random number generator.
 srand(time(NULL));
 for (unsigned int i = 0; i < size; i++)
 *(buffer + i) = ((unsigned int)rand() % 256);
 return buffer;
}
 Communication Networks Course
Page | 13
Appendix D â€“ Checksum function
A checksum is a small-sized block of data derived from another block of digital data for the
purpose of detecting errors that may have been introduced during its transmission or
storage. By themselves, checksums are often used to verify data integrity but are not relied
upon to verify data authenticity.
Below is a simple yet efficient implementation of the checksum function, you can use it for
the assignment, but you can implement your own checksum function.
/*
* @brief A checksum function that returns 16 bit checksum for data.
* @param data The data to do the checksum for.
* @param bytes The length of the data in bytes.
* @return The checksum itself as 16 bit unsigned number.
* @note This function is taken from RFC1071, can be found here:
* @note https://tools.ietf.org/html/rfc1071
* @note It is the simplest way to calculate a checksum and is not very strong.
* However, it is good enough for this assignment.
* @note You are free to use any other checksum function as well.
* You can also use this function as such without any change.
*/
unsigned short int calculate_checksum(void *data, unsigned int bytes) {
 unsigned short int *data_pointer = (unsigned short int *)data;
 unsigned int total_sum = 0;
 // Main summing loop
 while (bytes > 1) {
 total_sum += *data_pointer++;
 bytes -= 2;
 }
 // Add left-over byte, if any
 if (bytes > 0)
 total_sum += *((unsigned char *)data_pointer);
 // Fold 32-bit sum to 16 bits
 while (total_sum >> 16)
 total_sum = (total_sum & 0xFFFF) + (total_sum >> 16);
 return (~((unsigned short int)total_sum));
} Communication Networks Course
Page | 1
Assignment 3 â€“ Transport Layer
Assignment Notes and Instructions
This assignment is to be done in pairs only. You must upload all the necessary files in a ZIP
file named after both of the studentâ€™s ID. For example: ğŸğŸğŸ‘ğŸ’ğŸ“ğŸ”ğŸ•ğŸ–ğŸ—_ğŸ—ğŸ–ğŸ•ğŸ”ğŸ“ğŸ’ğŸ‘ğŸğŸ. ğ’›ğ’Šğ’‘.
1) The assignment must be submitted by the date specified in the submission box.
2) All the assignment files (Code, Wireshark pcap files, PDF) must be submitted in a ZIP file. The
PDF must contain all the necessary screenshots with a description for each one of them.
3) The assignment must be done in pairs only. In exceptional cases, you should send an email to
the course coordinator.
4) You can use any reference material available through the course Moodle website or any
material passed during the exercises.
5) You can use any reference from the web, but copying codes from websites is forbidden; this
includes codes from other GitHub repositories. A student who gets caught in the act will
automatically fail this assignment (score 0). Any website youâ€™ve used to solve the
assignment, every website you used to solve the assignment must be noted in the PDF.
6) No delays in submission without special permission. Lateness without approval will result in
failure of the assignment (score 0).
7) All submissions will be submitted via the course's Moodle website. Email submissions will not
be accepted, resulting in a failure in the assignment.
8) The order and design of the code must be carefully considered. Make sure that the program
output is as clear as possible, comments in the code, and meaningful variable names. You
must also submit a makefile that compiles all the programs.
9) The assignment code must be written in C only.
10) The assignment is personal for each pair, and you should not accept help from other people,
whether outside the university or inside it. You can contact the course staff during reception
hours for help or raise a question in the course forum. Do not transfer code sections
between students, upload solutions or parts of solutions to websites on the Internet or in
various communication groups.
11) Students who copy a solution will receive a 0 in all assignments in the course and a report will
be made to the institutional disciplinary committee.
12) All code files of the assignment are required to both compile and run properly on the Ubuntu
22.04 LTS operating system. This is the operating system where the submissions will be
tested. You mustnâ€™t code it in Windows, as it uses different API for sockets. WSL wonâ€™t work,
as the task needs a tool that works only in a fully Linux environment.
Good Luck!
 Communication Networks Course
Page | 2
Part A â€“ Transmission Control Protocol (TCP) â€“ 30 points
In this part, youâ€™ll write two program files: ğ‘»ğ‘ªğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and ğ‘»ğ‘ªğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
The Sender will send a randomly generated file and the Receiver will receive it and measure
the time it took for his program to receive the file. The file size should be at least 2MB.
When running the Sender and Receiver, they both should support two standard congestion
control algorithms: TCP Reno and TCP Cubic.
Notes:
â€¢ The main goal of this part is to get familiar with the TCP concept of sending
messages between two endpoints.
â€¢ For approaching this part of the assignment, please be sure that you are familiar
with the congestion control algorithms and how to change them using the correct
method in C (see Appendix B for more information).
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). You've
learned that TCP is reliable by design, so you can assume that all the data have been
passed correctly, and thus, no need to recheck.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
Usage:
â€¢ Receiver:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
â€¢ Sender:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port of the Receiver.
â€¢ ğ‘¨ğ‘³ğ‘®ğ‘¶ â€“ The TCP congestion control algorithm that will be used by the party
member (either ğ’“ğ’†ğ’ğ’ for TCP Reno or ğ’„ğ’–ğ’ƒğ’Šğ’„ for TCP Cubic).
 Communication Networks Course
Page | 3
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a TCP socket between the Sender and the
Receiver.
3) Send the file.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a TCP connection between the Receiver and
the Sender.
2) Get a connection from the sender.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./TCP_Receiver -p 1234 -algo reno
Starting Receiver...
Waiting for TCP connection...
Sender connected, beginning to receive file...
File transfer completed.
Waiting for Sender response...
Sender sent exit message.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 4
Part B â€“ Reliable User Datagram Protocol (Reliable UDP or RUDP) â€“ 40 points
Youâ€™ve learned that while TCP is reliable, it lacks speed and has an overhead data of 20 bytes,
compering to UDP that needs only 8 bytes of overhead data.
Reliable UDP or RUDP, is a protocol that uses the UDP protocol for a faster transmission of
data, while adding a reliability layer to it, but without adding too much overhead data like
TCP.
A simple sketch for a RUDP connection would look something like this:
Your task in this part is to implement a Reliable protocol using UDP only. For simplicity, your
implementation should only support a handshake, closing scheme, error checking,
acknowledgment of received packets, and retransmission of lost packets.
Guidance:
â€¢ You can use ğ‘ ğ‘’ğ‘¡ğ‘ ğ‘œğ‘ğ‘˜ğ‘œğ‘ğ‘¡(2) for detecting a timeout.
â€¢ You need to build your own protocol, as Reliable UDP isnâ€™t a standard protocol (see a
draft of RUDP in this link), and no official header is provided. You can use this sketch
for a header, but you can come up with your own protocol, as long as it works.
Where:
o ğ‘³ğ’†ğ’ğ’ˆğ’•ğ’‰ is the length of the data itself, without the RUDP header.
o ğ‘ªğ’‰ğ’†ğ’„ğ’Œğ’”ğ’–ğ’ is a 16bit number that validates the correctness of the data.
o ğ‘­ğ’ğ’‚ğ’ˆğ’” is a special byte where we classify the packet itself (SYN, ACK, etc.).
â€¢ In your PDF, you must explain how your implementation of RUDP works â€“ How does
it detect a timeout to do retransmissions, how does the handshake work, what is the
header overhead, etc.
â€¢ For this part, youâ€™ll write three files: ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¨ğ‘·ğ‘°. ğ’„, ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and
ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
Reliable UDP Header proposed sketch
Byte 0 Byte 1 Byte 2 Byte 3
Length (2 Bytes) Checksum (2 Bytes)
Flags (1 Byte)
Figure 1 - RUDP Protocol Architecture, Geeksforgeeks
 Communication Networks Course
Page | 5
Notes:
â€¢ The Sender will send a random generated file and the Receiver will receive it and
measure the time it took for his program to receive the file. The file size should be at
least 2MB.
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). But, as the
RUDP is based on UDP, itâ€™s not reliable. You must use some form of error checking
(like checksum) to ensure that the packet wasnâ€™t alerted during the transfer.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
â€¢ The RUDP needs support only 1 sender and 1 receiver, for simplicity purposes.
Usage:
â€¢ Receiver:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
â€¢ Sender:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port that both the Sender and the Receiver will use.
The ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„ file will contain all the implementations of the RUDP API functions (That is, to
prevent reusing the same chuck of code both in the Sender and the Receiver.).
The API should support at the bare minimum the following functions (you decide what
parameters to implement, and what are the names of the functions, as long as the API is
explained in the PDF):
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘œğ‘ğ‘˜ğ‘’ğ‘¡() â€“ Creating a RUDP socket and creating a handshake between two
peers.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘’ğ‘›ğ‘‘() â€“ Sending data to the peer. The function should wait for an
acknowledgment packet, and if it didnâ€™t receive any, retransmits the data.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘Ÿğ‘’ğ‘ğ‘£() â€“ Receive data from a peer.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ğ‘™ğ‘œğ‘ ğ‘’() â€“ Closes a connection between peers.
 Communication Networks Course
Page | 6
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a UDP socket between the Sender and the
Receiver.
3) Send the file via the RUDP protocol.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a UDP connection between the Receiver and
the Sender.
2) Get a connection from the sender, by the custom
RUDP protocol youâ€™ve built.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./RUDP_Receiver -p 1234
Starting Receiver...
Waiting for RUDP connection...
Connection request received, sending ACK.
Sender connected, beginning to receive file...
File transfer completed.
ACK sent.
Waiting for Sender response...
Sender sent exit message.
ACK sent.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 7
Part C â€“ Research â€“ 30 points
In this part, youâ€™ll conduct research about your implementations of part A and part B.
In the research itself, each one of the versions (TCP version and UDP version) will be run at
least 5 times (meaning that the file transfer will occur at least 5 times) by the following
conditions:
â€¢ For TCP, youâ€™ll run it in TCP Reno and TCP Cubic, alternating each time, for each
scenario, meaning that you run 5 times with TCP Reno in both Sender and Receiver,
and 5 times with TCP Cubic in both Sender and Receiver.
Bonus (5 points): Create a very large data set â€“ 5 times with TCP Reno in both Sender
and Receiver, 5 times with TCP Reno in Sender and TCP Cubic in Receiver, 5 times
with TCP Cubic in Sender and TCP Reno in Receiver, and 5 times with TCP Cubic in
both Sender and Receiver. This will give you a data set large enough, which allows
you to work with, compare with and to reach a definite conclusion.
â€¢ For RUDP, you will run it 5 times for each scenario.
â€¢ For both TCP and RUDP, you will run them on those scenarios of packet loss:
o 0% packet loss â€“ Control group, simulating perfect connection.
o 2% packet loss â€“ Simulating unstable connection that commonly occur.
o 5% packet loss â€“ Simulating bad connection.
o 10% packet loss â€“ Simulating extremely poor connection.
For each scenario, you must provide a filtered PCAP file and relevant screenshots that
explain each one of the steps in the process. (10 points)
After youâ€™ve gathered the data set for both TCP and Reliable UDP, answer the following
questions:
1) In TCP, which congestion control algorithm gave better results overall? TCP Reno or
TCP Cubic? Which one gave better results on high packet loss? Explain how you came
to this conclusion based on the data set youâ€™ve gathered. (5 points)
2) How did your implementation of Reliable UDP perform overall compared to regular
TCP? Which one is better for high packet loss? (5 points)
3) According to the data youâ€™ve gathered, in which scenarios and applications would we
prefer to use TCP and in which situations would we prefer to use reliable UDP?
Explain your answer. (5 points)
 Communication Networks Course
Page | 8
×¢× ×• ×¢×œ ×”×©××œ×•×ª ×”×‘××•×ª )5 × ×§×•×“×•×ª(:
â— ×‘"×¨×©×ª ×××™× ×”" ×”×›×•×•× ×” ×”×™× ×œ×¨×©×ª ×©×‘×” ××¢×˜ ×××•×“ ×—×‘×™×œ×•×ª ×”×•×œ×›×•×ª ×œ××™×‘×•×“. ×‘"×§×©×¨ ××¨×•×š" ×”×›×•×•× ×” ×”×™×
×œ×§×©×¨ TCP ×©×™×© ×‘×• ×”×¨×‘×” ×××•×“ ××™×“×¢ ×œ×©×œ×•×—. ××•×¦×¢ ×œ×”×’×“×™×œ ×‘ -TCP ××ª SSThreshold ×‘×ª×—×™×œ×ª ×”×§×©×¨.
×‘××™×–×” ××”××§×¨×™× ×”×‘××™× ×”×©×™× ×•×™ ×”×–×” ×¢×©×•×™ ×œ×”×•×¢×™×œ ×‘××™×“×” ×”××™×¨×‘×™×ª? × ××§.
.1 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
.2 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.3 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.4 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.5 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.6 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.7 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.8 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
â— A ×©×•×œ×— ×œ -B ×—×‘×™×œ×•×ª ××™×“×¢ ×‘×××¦×¢×•×ª ×§×©×¨ TCP. × ×ª×•×Ÿ ×›×™ ×”×§×©×¨ ××ª×—×™×œ ×¢× ×—×œ×•×Ÿ ×‘×’×•×“×œ 1MSS. ×”×§×©×¨
××¡×ª×™×™× ×‘×¤×¢× ×”×¨××©×•× ×” ×©×”×•× ××’×™×¢ ×œ -SSthresh. ×‘××”×œ×š ×”×§×©×¨ ×œ× ××•×‘×“×•×ª ×—×‘×™×œ×•×ª. × ×¡××Ÿ ×‘×§×™×¦×•×¨:
.SSthresh=S*MSS
× ×ª×•×Ÿ ×›×™ ×œ××•×¨×š ×›×œ ×”×§×©×¨ rwnd < MSS*S.
××”×™ ×”×ª×¤×•×§×” ×©×œ ×”×§×©×¨ ×-A ×œ-B( ×‘ -sec / Bytes )×‘×–××Ÿ ×”× "×œ? × ××§×™.
]S*MSS / [lg (S) * RTT*2 ×‘×¢×¨×š .1
]S*MSS / [S^0.5 * RTT*2 ×‘×¢×¨×š .2
S*MSS / RTT ×‘×¢×¨×š .3
S^2)*MSS / RTT( ×‘×¢×¨×š .4
â— ×©×ª×™ ×ª×—× ×•×ª ××ª×§×©×¨×•×ª ×‘××•×¤×Ÿ ××œ×—×•×˜×™ ×‘×©×™×˜×ª N Back Go.
× ×¡××Ÿ ×‘-X ××ª ×¡×¤×¨×ª ×”×‘×™×§×•×¨×ª ×©×œ ×”×ª.×–. ×©×œ×š. ×× ×©× ×™ ×©×•×ª×¤×™× ××’×™×©×™× ××ª ×”×ª×¨×’×™×œ ×™×—×“, X ×”×•× ×¡×¤×¨×ª
×”×‘×™×§×•×¨×ª ×‘×¢×œ×ª ×”×¢×¨×š ×”× ××•×š ×™×•×ª×¨ ××‘×™×Ÿ ×”×©×ª×™×™×.
×§×¦×‘ ×”×ª×§×©×•×¨×ª ×”×•× 8Gbps, ×•×’×•×“×œ ×›×œ ×—×‘×™×œ×” ×”×•× KByte*X. ×’×“×œ×™ ×”-headers ×•×” -Acks ×–× ×™×—×™×.
ï¿½ğ‘’ğ‘ ï¿½/ï¿½ï¿½ 8 , ×•×”××¨×—×§ ×‘×™×Ÿ ×”×ª×—× ×•×ª ×”×•× 1Km. ×§×¦×‘ ×”×”×ª×¤×©×˜×•×ª ×”×•× 10 â‹… 2
×–××Ÿ ×¢×™×‘×•×“ ×”× ×ª×•× ×™× ×‘×ª×—× ×•×ª ×–× ×™×—.
××£ ×—×‘×™×œ×” ×•××£ Ack ×œ× ×”×•×œ×›×™× ×œ××™×‘×•×“.
â— ××”×• X ×©×œ×š?
â— ××” ×¦×¨×™×š ×œ×”×™×•×ª ×’×•×“×œ ×—×œ×•×Ÿ ×”××©×œ×•×— ×›×“×™ ×œ×”×‘×˜×™×— ×ª×¤×•×§×” ××§×¡×™××œ×™×ª?
 Communication Networks Course
Page | 9
Bonus â€“ Improving the Reliable UDP â€“ 15 points
Note: This part isnâ€™t mandatory and is a bonus only!
In this part, youâ€™ll improve your RUDP implementation by adding the concepts of flow
control and congestion control from TCP. Youâ€™re free to choose which algorithms to
implement, as long as you explain in your PDF which algorithms youâ€™ve used. Youâ€™ll probably
need to make changes in the original design of the RUDP. Changes only need to be to the API
itself, ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„.
Points distribution:
â€¢ Flow control improvement â€“ 7 Points
â€¢ Congestion control improvement â€“ 8 points.
Guidance:
â€¢ For flow control, you must use one of the Sliding window techniques: stop-and-wait
ARQ, Go-Back-N or Selective repeat.
â€¢ List of known TCP congestion control algorithms, which you can use any one of them
for this bonus task, or makeup your own:
Figure 2 â€“ List of known TCP congestion control algorithms, Wikipedia
 Communication Networks Course
Page | 10
Appendix A â€“ Linux local packet loss tool
To simulate a packet loss in a local network, we'll use a Linux tool that's called Linux Traffic
Control (ğ‘¡ğ‘). This requires a full Linux installation, so working with WSL won't work.
If the tool isn't installed in your machine, you can install it by using the following commands:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’
If the installation didn't work, you can use the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’2
To create a packet loss scenario, type the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘ğ‘‘ğ‘‘ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
After creating a packet loss scenario, you can change the percentage by typing the following
command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘â„ğ‘ğ‘›ğ‘”ğ‘’ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
To remove the packet loss scenario, write the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘‘ğ‘’ğ‘™ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š
 Communication Networks Course
Page | 11
Appendix B â€“ ğ’ğ’‚ğ’(ğŸ) system calls
This appendixâ€™s purpose is to give you a better understanding of socket handling in C.
A recommended reference is Beejâ€™s Guide to Network Programming, by Brian â€œBeej
Jorgensenâ€ Hall, which gives a lot of information about sockets in C and functions.
Functions and documentation links:
â€¢ ğ’”ğ’ğ’„ğ’Œğ’†ğ’•(ğŸ) â€“ A Factory method system call that creates a socket with the given
parameters.
â€¢ ğ’ƒğ’Šğ’ğ’…(ğŸ) â€“ Whenever we create a new socket, we need to bind it to a specific port in
our machine, â€œto catch a portâ€. The port number is managed and used by the kernel
to link incoming packets to the corresponding application socket. The port numbers
are usually fixed. The ğ‘ğ‘‘ğ‘‘ğ‘Ÿ parameter must match the current socket that is used.
â€¢ ğ’ğ’Šğ’”ğ’•ğ’†ğ’(ğŸ) â€“ The ğ‘™ğ‘–ğ‘ ğ‘¡ğ‘’ğ‘›(2) system call doesn't do anything in the mean of
communication but only memory allocation (malloc) for stream sockets only. If we
won't allocate memory, any incoming connection will fail.
â€¢ ğ’„ğ’ğ’ğ’ğ’†ğ’„ğ’•(ğŸ) â€“ The ğ‘ğ‘œğ‘›ğ‘›ğ‘’ğ‘ğ‘¡(2) system call starts the link between a client and a
specific IP address and port number. The connection would complete when the
other side will call the ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call.
â€¢ ğ’‚ğ’„ğ’„ğ’†ğ’‘ğ’•(ğŸ) â€“ The ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call accepts the incoming stream connection
request from the other side, by the listening socket. This system call completes the
three-way handshake of stream socket (like TCP) and opens a new socket that has a
direct communication channel only with the other party in the handshake.
â€¢ ğ’”ğ’†ğ’ğ’…(ğŸ) and ğ’”ğ’†ğ’ğ’…ğ’•ğ’(ğŸ) â€“ The ğ‘ ğ‘’ğ‘›ğ‘‘(2) and ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system calls are an analogy
for the ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’(2) system call, specifcly for sockets, with flags set to 0. Those system
calls return the number of bytes that were sent through the socket itself, as the
number of bytes can vary. The ğ‘ ğ‘’ğ‘›ğ‘‘(2)system call designed for stream sockets (like
TCP), while the ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system call designed for datagram connection-less
sockets (like UDP). When the ğ‘ ğ‘’ğ‘›ğ‘‘(2) system call returns 0, it means that the other
party closed the connection.
â€¢ ğ’“ğ’†ğ’„ğ’—(ğŸ) and ğ’“ğ’†ğ’„ğ’—ğ’‡ğ’“ğ’ğ’(ğŸ) â€“ The ğ‘Ÿğ‘’ğ‘ğ‘£(2) and ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system calls are an
analogy for the ğ‘Ÿğ‘’ğ‘ğ‘‘(2) system call, specifically for sockets, with flags set to 0.
Those system calls return the number of bytes that were received through the socket
itself, as the number of bytes can vary. The ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call designed for stream
sockets (like TCP), while the ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system call designed for datagram
connection-less sockets (like UDP). When the ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call returns 0, it means
that the other party closed the connection.
â€¢ ğ’„ğ’ğ’ğ’”ğ’†(ğŸ) and ğ’”ğ’‰ğ’–ğ’•ğ’…ğ’ğ’˜ğ’(ğŸ) â€“ The ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) and ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2) system calls close
the socket. While ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) system call closes the whole socket, the ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2)
system call partially closes the socket for read/write.
 Communication Networks Course
Page | 12
Appendix C â€“ Random data generator
The data that you are going to send in this assignment is randomly generated. You can use
your own file with appropriate size or use the following function (or a function of your own)
to generate the data:
/*
* @brief A random data generator function based on srand() and rand().
* @param size The size of the data to generate (up to 2^32 bytes).
* @return A pointer to the buffer.
*/
char *util_generate_random_data(unsigned int size) {
 char *buffer = NULL;
 // Argument check.
 if (size == 0)
 return NULL;
 buffer = (char *)calloc(size, sizeof(char));
 // Error checking.
 if (buffer == NULL)
 return NULL;
 // Randomize the seed of the random number generator.
 srand(time(NULL));
 for (unsigned int i = 0; i < size; i++)
 *(buffer + i) = ((unsigned int)rand() % 256);
 return buffer;
}
 Communication Networks Course
Page | 13
Appendix D â€“ Checksum function
A checksum is a small-sized block of data derived from another block of digital data for the
purpose of detecting errors that may have been introduced during its transmission or
storage. By themselves, checksums are often used to verify data integrity but are not relied
upon to verify data authenticity.
Below is a simple yet efficient implementation of the checksum function, you can use it for
the assignment, but you can implement your own checksum function.
/*
* @brief A checksum function that returns 16 bit checksum for data.
* @param data The data to do the checksum for.
* @param bytes The length of the data in bytes.
* @return The checksum itself as 16 bit unsigned number.
* @note This function is taken from RFC1071, can be found here:
* @note https://tools.ietf.org/html/rfc1071
* @note It is the simplest way to calculate a checksum and is not very strong.
* However, it is good enough for this assignment.
* @note You are free to use any other checksum function as well.
* You can also use this function as such without any change.
*/
unsigned short int calculate_checksum(void *data, unsigned int bytes) {
 unsigned short int *data_pointer = (unsigned short int *)data;
 unsigned int total_sum = 0;
 // Main summing loop
 while (bytes > 1) {
 total_sum += *data_pointer++;
 bytes -= 2;
 }
 // Add left-over byte, if any
 if (bytes > 0)
 total_sum += *((unsigned char *)data_pointer);
 // Fold 32-bit sum to 16 bits
 while (total_sum >> 16)
 total_sum = (total_sum & 0xFFFF) + (total_sum >> 16);
 return (~((unsigned short int)total_sum));
} Communication Networks Course
Page | 1
Assignment 3 â€“ Transport Layer
Assignment Notes and Instructions
This assignment is to be done in pairs only. You must upload all the necessary files in a ZIP
file named after both of the studentâ€™s ID. For example: ğŸğŸğŸ‘ğŸ’ğŸ“ğŸ”ğŸ•ğŸ–ğŸ—_ğŸ—ğŸ–ğŸ•ğŸ”ğŸ“ğŸ’ğŸ‘ğŸğŸ. ğ’›ğ’Šğ’‘.
1) The assignment must be submitted by the date specified in the submission box.
2) All the assignment files (Code, Wireshark pcap files, PDF) must be submitted in a ZIP file. The
PDF must contain all the necessary screenshots with a description for each one of them.
3) The assignment must be done in pairs only. In exceptional cases, you should send an email to
the course coordinator.
4) You can use any reference material available through the course Moodle website or any
material passed during the exercises.
5) You can use any reference from the web, but copying codes from websites is forbidden; this
includes codes from other GitHub repositories. A student who gets caught in the act will
automatically fail this assignment (score 0). Any website youâ€™ve used to solve the
assignment, every website you used to solve the assignment must be noted in the PDF.
6) No delays in submission without special permission. Lateness without approval will result in
failure of the assignment (score 0).
7) All submissions will be submitted via the course's Moodle website. Email submissions will not
be accepted, resulting in a failure in the assignment.
8) The order and design of the code must be carefully considered. Make sure that the program
output is as clear as possible, comments in the code, and meaningful variable names. You
must also submit a makefile that compiles all the programs.
9) The assignment code must be written in C only.
10) The assignment is personal for each pair, and you should not accept help from other people,
whether outside the university or inside it. You can contact the course staff during reception
hours for help or raise a question in the course forum. Do not transfer code sections
between students, upload solutions or parts of solutions to websites on the Internet or in
various communication groups.
11) Students who copy a solution will receive a 0 in all assignments in the course and a report will
be made to the institutional disciplinary committee.
12) All code files of the assignment are required to both compile and run properly on the Ubuntu
22.04 LTS operating system. This is the operating system where the submissions will be
tested. You mustnâ€™t code it in Windows, as it uses different API for sockets. WSL wonâ€™t work,
as the task needs a tool that works only in a fully Linux environment.
Good Luck!
 Communication Networks Course
Page | 2
Part A â€“ Transmission Control Protocol (TCP) â€“ 30 points
In this part, youâ€™ll write two program files: ğ‘»ğ‘ªğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and ğ‘»ğ‘ªğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
The Sender will send a randomly generated file and the Receiver will receive it and measure
the time it took for his program to receive the file. The file size should be at least 2MB.
When running the Sender and Receiver, they both should support two standard congestion
control algorithms: TCP Reno and TCP Cubic.
Notes:
â€¢ The main goal of this part is to get familiar with the TCP concept of sending
messages between two endpoints.
â€¢ For approaching this part of the assignment, please be sure that you are familiar
with the congestion control algorithms and how to change them using the correct
method in C (see Appendix B for more information).
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). You've
learned that TCP is reliable by design, so you can assume that all the data have been
passed correctly, and thus, no need to recheck.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
Usage:
â€¢ Receiver:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
â€¢ Sender:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port of the Receiver.
â€¢ ğ‘¨ğ‘³ğ‘®ğ‘¶ â€“ The TCP congestion control algorithm that will be used by the party
member (either ğ’“ğ’†ğ’ğ’ for TCP Reno or ğ’„ğ’–ğ’ƒğ’Šğ’„ for TCP Cubic).
 Communication Networks Course
Page | 3
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a TCP socket between the Sender and the
Receiver.
3) Send the file.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a TCP connection between the Receiver and
the Sender.
2) Get a connection from the sender.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./TCP_Receiver -p 1234 -algo reno
Starting Receiver...
Waiting for TCP connection...
Sender connected, beginning to receive file...
File transfer completed.
Waiting for Sender response...
Sender sent exit message.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 4
Part B â€“ Reliable User Datagram Protocol (Reliable UDP or RUDP) â€“ 40 points
Youâ€™ve learned that while TCP is reliable, it lacks speed and has an overhead data of 20 bytes,
compering to UDP that needs only 8 bytes of overhead data.
Reliable UDP or RUDP, is a protocol that uses the UDP protocol for a faster transmission of
data, while adding a reliability layer to it, but without adding too much overhead data like
TCP.
A simple sketch for a RUDP connection would look something like this:
Your task in this part is to implement a Reliable protocol using UDP only. For simplicity, your
implementation should only support a handshake, closing scheme, error checking,
acknowledgment of received packets, and retransmission of lost packets.
Guidance:
â€¢ You can use ğ‘ ğ‘’ğ‘¡ğ‘ ğ‘œğ‘ğ‘˜ğ‘œğ‘ğ‘¡(2) for detecting a timeout.
â€¢ You need to build your own protocol, as Reliable UDP isnâ€™t a standard protocol (see a
draft of RUDP in this link), and no official header is provided. You can use this sketch
for a header, but you can come up with your own protocol, as long as it works.
Where:
o ğ‘³ğ’†ğ’ğ’ˆğ’•ğ’‰ is the length of the data itself, without the RUDP header.
o ğ‘ªğ’‰ğ’†ğ’„ğ’Œğ’”ğ’–ğ’ is a 16bit number that validates the correctness of the data.
o ğ‘­ğ’ğ’‚ğ’ˆğ’” is a special byte where we classify the packet itself (SYN, ACK, etc.).
â€¢ In your PDF, you must explain how your implementation of RUDP works â€“ How does
it detect a timeout to do retransmissions, how does the handshake work, what is the
header overhead, etc.
â€¢ For this part, youâ€™ll write three files: ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¨ğ‘·ğ‘°. ğ’„, ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and
ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
Reliable UDP Header proposed sketch
Byte 0 Byte 1 Byte 2 Byte 3
Length (2 Bytes) Checksum (2 Bytes)
Flags (1 Byte)
Figure 1 - RUDP Protocol Architecture, Geeksforgeeks
 Communication Networks Course
Page | 5
Notes:
â€¢ The Sender will send a random generated file and the Receiver will receive it and
measure the time it took for his program to receive the file. The file size should be at
least 2MB.
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). But, as the
RUDP is based on UDP, itâ€™s not reliable. You must use some form of error checking
(like checksum) to ensure that the packet wasnâ€™t alerted during the transfer.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
â€¢ The RUDP needs support only 1 sender and 1 receiver, for simplicity purposes.
Usage:
â€¢ Receiver:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
â€¢ Sender:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port that both the Sender and the Receiver will use.
The ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„ file will contain all the implementations of the RUDP API functions (That is, to
prevent reusing the same chuck of code both in the Sender and the Receiver.).
The API should support at the bare minimum the following functions (you decide what
parameters to implement, and what are the names of the functions, as long as the API is
explained in the PDF):
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘œğ‘ğ‘˜ğ‘’ğ‘¡() â€“ Creating a RUDP socket and creating a handshake between two
peers.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘’ğ‘›ğ‘‘() â€“ Sending data to the peer. The function should wait for an
acknowledgment packet, and if it didnâ€™t receive any, retransmits the data.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘Ÿğ‘’ğ‘ğ‘£() â€“ Receive data from a peer.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ğ‘™ğ‘œğ‘ ğ‘’() â€“ Closes a connection between peers.
 Communication Networks Course
Page | 6
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a UDP socket between the Sender and the
Receiver.
3) Send the file via the RUDP protocol.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a UDP connection between the Receiver and
the Sender.
2) Get a connection from the sender, by the custom
RUDP protocol youâ€™ve built.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./RUDP_Receiver -p 1234
Starting Receiver...
Waiting for RUDP connection...
Connection request received, sending ACK.
Sender connected, beginning to receive file...
File transfer completed.
ACK sent.
Waiting for Sender response...
Sender sent exit message.
ACK sent.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 7
Part C â€“ Research â€“ 30 points
In this part, youâ€™ll conduct research about your implementations of part A and part B.
In the research itself, each one of the versions (TCP version and UDP version) will be run at
least 5 times (meaning that the file transfer will occur at least 5 times) by the following
conditions:
â€¢ For TCP, youâ€™ll run it in TCP Reno and TCP Cubic, alternating each time, for each
scenario, meaning that you run 5 times with TCP Reno in both Sender and Receiver,
and 5 times with TCP Cubic in both Sender and Receiver.
Bonus (5 points): Create a very large data set â€“ 5 times with TCP Reno in both Sender
and Receiver, 5 times with TCP Reno in Sender and TCP Cubic in Receiver, 5 times
with TCP Cubic in Sender and TCP Reno in Receiver, and 5 times with TCP Cubic in
both Sender and Receiver. This will give you a data set large enough, which allows
you to work with, compare with and to reach a definite conclusion.
â€¢ For RUDP, you will run it 5 times for each scenario.
â€¢ For both TCP and RUDP, you will run them on those scenarios of packet loss:
o 0% packet loss â€“ Control group, simulating perfect connection.
o 2% packet loss â€“ Simulating unstable connection that commonly occur.
o 5% packet loss â€“ Simulating bad connection.
o 10% packet loss â€“ Simulating extremely poor connection.
For each scenario, you must provide a filtered PCAP file and relevant screenshots that
explain each one of the steps in the process. (10 points)
After youâ€™ve gathered the data set for both TCP and Reliable UDP, answer the following
questions:
1) In TCP, which congestion control algorithm gave better results overall? TCP Reno or
TCP Cubic? Which one gave better results on high packet loss? Explain how you came
to this conclusion based on the data set youâ€™ve gathered. (5 points)
2) How did your implementation of Reliable UDP perform overall compared to regular
TCP? Which one is better for high packet loss? (5 points)
3) According to the data youâ€™ve gathered, in which scenarios and applications would we
prefer to use TCP and in which situations would we prefer to use reliable UDP?
Explain your answer. (5 points)
 Communication Networks Course
Page | 8
×¢× ×• ×¢×œ ×”×©××œ×•×ª ×”×‘××•×ª )5 × ×§×•×“×•×ª(:
â— ×‘"×¨×©×ª ×××™× ×”" ×”×›×•×•× ×” ×”×™× ×œ×¨×©×ª ×©×‘×” ××¢×˜ ×××•×“ ×—×‘×™×œ×•×ª ×”×•×œ×›×•×ª ×œ××™×‘×•×“. ×‘"×§×©×¨ ××¨×•×š" ×”×›×•×•× ×” ×”×™×
×œ×§×©×¨ TCP ×©×™×© ×‘×• ×”×¨×‘×” ×××•×“ ××™×“×¢ ×œ×©×œ×•×—. ××•×¦×¢ ×œ×”×’×“×™×œ ×‘ -TCP ××ª SSThreshold ×‘×ª×—×™×œ×ª ×”×§×©×¨.
×‘××™×–×” ××”××§×¨×™× ×”×‘××™× ×”×©×™× ×•×™ ×”×–×” ×¢×©×•×™ ×œ×”×•×¢×™×œ ×‘××™×“×” ×”××™×¨×‘×™×ª? × ××§.
.1 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
.2 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.3 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.4 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.5 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.6 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.7 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.8 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
â— A ×©×•×œ×— ×œ -B ×—×‘×™×œ×•×ª ××™×“×¢ ×‘×××¦×¢×•×ª ×§×©×¨ TCP. × ×ª×•×Ÿ ×›×™ ×”×§×©×¨ ××ª×—×™×œ ×¢× ×—×œ×•×Ÿ ×‘×’×•×“×œ 1MSS. ×”×§×©×¨
××¡×ª×™×™× ×‘×¤×¢× ×”×¨××©×•× ×” ×©×”×•× ××’×™×¢ ×œ -SSthresh. ×‘××”×œ×š ×”×§×©×¨ ×œ× ××•×‘×“×•×ª ×—×‘×™×œ×•×ª. × ×¡××Ÿ ×‘×§×™×¦×•×¨:
.SSthresh=S*MSS
× ×ª×•×Ÿ ×›×™ ×œ××•×¨×š ×›×œ ×”×§×©×¨ rwnd < MSS*S.
××”×™ ×”×ª×¤×•×§×” ×©×œ ×”×§×©×¨ ×-A ×œ-B( ×‘ -sec / Bytes )×‘×–××Ÿ ×”× "×œ? × ××§×™.
]S*MSS / [lg (S) * RTT*2 ×‘×¢×¨×š .1
]S*MSS / [S^0.5 * RTT*2 ×‘×¢×¨×š .2
S*MSS / RTT ×‘×¢×¨×š .3
S^2)*MSS / RTT( ×‘×¢×¨×š .4
â— ×©×ª×™ ×ª×—× ×•×ª ××ª×§×©×¨×•×ª ×‘××•×¤×Ÿ ××œ×—×•×˜×™ ×‘×©×™×˜×ª N Back Go.
× ×¡××Ÿ ×‘-X ××ª ×¡×¤×¨×ª ×”×‘×™×§×•×¨×ª ×©×œ ×”×ª.×–. ×©×œ×š. ×× ×©× ×™ ×©×•×ª×¤×™× ××’×™×©×™× ××ª ×”×ª×¨×’×™×œ ×™×—×“, X ×”×•× ×¡×¤×¨×ª
×”×‘×™×§×•×¨×ª ×‘×¢×œ×ª ×”×¢×¨×š ×”× ××•×š ×™×•×ª×¨ ××‘×™×Ÿ ×”×©×ª×™×™×.
×§×¦×‘ ×”×ª×§×©×•×¨×ª ×”×•× 8Gbps, ×•×’×•×“×œ ×›×œ ×—×‘×™×œ×” ×”×•× KByte*X. ×’×“×œ×™ ×”-headers ×•×” -Acks ×–× ×™×—×™×.
ï¿½ğ‘’ğ‘ ï¿½/ï¿½ï¿½ 8 , ×•×”××¨×—×§ ×‘×™×Ÿ ×”×ª×—× ×•×ª ×”×•× 1Km. ×§×¦×‘ ×”×”×ª×¤×©×˜×•×ª ×”×•× 10 â‹… 2
×–××Ÿ ×¢×™×‘×•×“ ×”× ×ª×•× ×™× ×‘×ª×—× ×•×ª ×–× ×™×—.
××£ ×—×‘×™×œ×” ×•××£ Ack ×œ× ×”×•×œ×›×™× ×œ××™×‘×•×“.
â— ××”×• X ×©×œ×š?
â— ××” ×¦×¨×™×š ×œ×”×™×•×ª ×’×•×“×œ ×—×œ×•×Ÿ ×”××©×œ×•×— ×›×“×™ ×œ×”×‘×˜×™×— ×ª×¤×•×§×” ××§×¡×™××œ×™×ª?
 Communication Networks Course
Page | 9
Bonus â€“ Improving the Reliable UDP â€“ 15 points
Note: This part isnâ€™t mandatory and is a bonus only!
In this part, youâ€™ll improve your RUDP implementation by adding the concepts of flow
control and congestion control from TCP. Youâ€™re free to choose which algorithms to
implement, as long as you explain in your PDF which algorithms youâ€™ve used. Youâ€™ll probably
need to make changes in the original design of the RUDP. Changes only need to be to the API
itself, ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„.
Points distribution:
â€¢ Flow control improvement â€“ 7 Points
â€¢ Congestion control improvement â€“ 8 points.
Guidance:
â€¢ For flow control, you must use one of the Sliding window techniques: stop-and-wait
ARQ, Go-Back-N or Selective repeat.
â€¢ List of known TCP congestion control algorithms, which you can use any one of them
for this bonus task, or makeup your own:
Figure 2 â€“ List of known TCP congestion control algorithms, Wikipedia
 Communication Networks Course
Page | 10
Appendix A â€“ Linux local packet loss tool
To simulate a packet loss in a local network, we'll use a Linux tool that's called Linux Traffic
Control (ğ‘¡ğ‘). This requires a full Linux installation, so working with WSL won't work.
If the tool isn't installed in your machine, you can install it by using the following commands:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’
If the installation didn't work, you can use the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’2
To create a packet loss scenario, type the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘ğ‘‘ğ‘‘ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
After creating a packet loss scenario, you can change the percentage by typing the following
command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘â„ğ‘ğ‘›ğ‘”ğ‘’ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
To remove the packet loss scenario, write the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘‘ğ‘’ğ‘™ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š
 Communication Networks Course
Page | 11
Appendix B â€“ ğ’ğ’‚ğ’(ğŸ) system calls
This appendixâ€™s purpose is to give you a better understanding of socket handling in C.
A recommended reference is Beejâ€™s Guide to Network Programming, by Brian â€œBeej
Jorgensenâ€ Hall, which gives a lot of information about sockets in C and functions.
Functions and documentation links:
â€¢ ğ’”ğ’ğ’„ğ’Œğ’†ğ’•(ğŸ) â€“ A Factory method system call that creates a socket with the given
parameters.
â€¢ ğ’ƒğ’Šğ’ğ’…(ğŸ) â€“ Whenever we create a new socket, we need to bind it to a specific port in
our machine, â€œto catch a portâ€. The port number is managed and used by the kernel
to link incoming packets to the corresponding application socket. The port numbers
are usually fixed. The ğ‘ğ‘‘ğ‘‘ğ‘Ÿ parameter must match the current socket that is used.
â€¢ ğ’ğ’Šğ’”ğ’•ğ’†ğ’(ğŸ) â€“ The ğ‘™ğ‘–ğ‘ ğ‘¡ğ‘’ğ‘›(2) system call doesn't do anything in the mean of
communication but only memory allocation (malloc) for stream sockets only. If we
won't allocate memory, any incoming connection will fail.
â€¢ ğ’„ğ’ğ’ğ’ğ’†ğ’„ğ’•(ğŸ) â€“ The ğ‘ğ‘œğ‘›ğ‘›ğ‘’ğ‘ğ‘¡(2) system call starts the link between a client and a
specific IP address and port number. The connection would complete when the
other side will call the ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call.
â€¢ ğ’‚ğ’„ğ’„ğ’†ğ’‘ğ’•(ğŸ) â€“ The ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call accepts the incoming stream connection
request from the other side, by the listening socket. This system call completes the
three-way handshake of stream socket (like TCP) and opens a new socket that has a
direct communication channel only with the other party in the handshake.
â€¢ ğ’”ğ’†ğ’ğ’…(ğŸ) and ğ’”ğ’†ğ’ğ’…ğ’•ğ’(ğŸ) â€“ The ğ‘ ğ‘’ğ‘›ğ‘‘(2) and ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system calls are an analogy
for the ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’(2) system call, specifcly for sockets, with flags set to 0. Those system
calls return the number of bytes that were sent through the socket itself, as the
number of bytes can vary. The ğ‘ ğ‘’ğ‘›ğ‘‘(2)system call designed for stream sockets (like
TCP), while the ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system call designed for datagram connection-less
sockets (like UDP). When the ğ‘ ğ‘’ğ‘›ğ‘‘(2) system call returns 0, it means that the other
party closed the connection.
â€¢ ğ’“ğ’†ğ’„ğ’—(ğŸ) and ğ’“ğ’†ğ’„ğ’—ğ’‡ğ’“ğ’ğ’(ğŸ) â€“ The ğ‘Ÿğ‘’ğ‘ğ‘£(2) and ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system calls are an
analogy for the ğ‘Ÿğ‘’ğ‘ğ‘‘(2) system call, specifically for sockets, with flags set to 0.
Those system calls return the number of bytes that were received through the socket
itself, as the number of bytes can vary. The ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call designed for stream
sockets (like TCP), while the ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system call designed for datagram
connection-less sockets (like UDP). When the ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call returns 0, it means
that the other party closed the connection.
â€¢ ğ’„ğ’ğ’ğ’”ğ’†(ğŸ) and ğ’”ğ’‰ğ’–ğ’•ğ’…ğ’ğ’˜ğ’(ğŸ) â€“ The ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) and ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2) system calls close
the socket. While ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) system call closes the whole socket, the ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2)
system call partially closes the socket for read/write.
 Communication Networks Course
Page | 12
Appendix C â€“ Random data generator
The data that you are going to send in this assignment is randomly generated. You can use
your own file with appropriate size or use the following function (or a function of your own)
to generate the data:
/*
* @brief A random data generator function based on srand() and rand().
* @param size The size of the data to generate (up to 2^32 bytes).
* @return A pointer to the buffer.
*/
char *util_generate_random_data(unsigned int size) {
 char *buffer = NULL;
 // Argument check.
 if (size == 0)
 return NULL;
 buffer = (char *)calloc(size, sizeof(char));
 // Error checking.
 if (buffer == NULL)
 return NULL;
 // Randomize the seed of the random number generator.
 srand(time(NULL));
 for (unsigned int i = 0; i < size; i++)
 *(buffer + i) = ((unsigned int)rand() % 256);
 return buffer;
}
 Communication Networks Course
Page | 13
Appendix D â€“ Checksum function
A checksum is a small-sized block of data derived from another block of digital data for the
purpose of detecting errors that may have been introduced during its transmission or
storage. By themselves, checksums are often used to verify data integrity but are not relied
upon to verify data authenticity.
Below is a simple yet efficient implementation of the checksum function, you can use it for
the assignment, but you can implement your own checksum function.
/*
* @brief A checksum function that returns 16 bit checksum for data.
* @param data The data to do the checksum for.
* @param bytes The length of the data in bytes.
* @return The checksum itself as 16 bit unsigned number.
* @note This function is taken from RFC1071, can be found here:
* @note https://tools.ietf.org/html/rfc1071
* @note It is the simplest way to calculate a checksum and is not very strong.
* However, it is good enough for this assignment.
* @note You are free to use any other checksum function as well.
* You can also use this function as such without any change.
*/
unsigned short int calculate_checksum(void *data, unsigned int bytes) {
 unsigned short int *data_pointer = (unsigned short int *)data;
 unsigned int total_sum = 0;
 // Main summing loop
 while (bytes > 1) {
 total_sum += *data_pointer++;
 bytes -= 2;
 }
 // Add left-over byte, if any
 if (bytes > 0)
 total_sum += *((unsigned char *)data_pointer);
 // Fold 32-bit sum to 16 bits
 while (total_sum >> 16)
 total_sum = (total_sum & 0xFFFF) + (total_sum >> 16);
 return (~((unsigned short int)total_sum));
} Communication Networks Course
Page | 1
Assignment 3 â€“ Transport Layer
Assignment Notes and Instructions
This assignment is to be done in pairs only. You must upload all the necessary files in a ZIP
file named after both of the studentâ€™s ID. For example: ğŸğŸğŸ‘ğŸ’ğŸ“ğŸ”ğŸ•ğŸ–ğŸ—_ğŸ—ğŸ–ğŸ•ğŸ”ğŸ“ğŸ’ğŸ‘ğŸğŸ. ğ’›ğ’Šğ’‘.
1) The assignment must be submitted by the date specified in the submission box.
2) All the assignment files (Code, Wireshark pcap files, PDF) must be submitted in a ZIP file. The
PDF must contain all the necessary screenshots with a description for each one of them.
3) The assignment must be done in pairs only. In exceptional cases, you should send an email to
the course coordinator.
4) You can use any reference material available through the course Moodle website or any
material passed during the exercises.
5) You can use any reference from the web, but copying codes from websites is forbidden; this
includes codes from other GitHub repositories. A student who gets caught in the act will
automatically fail this assignment (score 0). Any website youâ€™ve used to solve the
assignment, every website you used to solve the assignment must be noted in the PDF.
6) No delays in submission without special permission. Lateness without approval will result in
failure of the assignment (score 0).
7) All submissions will be submitted via the course's Moodle website. Email submissions will not
be accepted, resulting in a failure in the assignment.
8) The order and design of the code must be carefully considered. Make sure that the program
output is as clear as possible, comments in the code, and meaningful variable names. You
must also submit a makefile that compiles all the programs.
9) The assignment code must be written in C only.
10) The assignment is personal for each pair, and you should not accept help from other people,
whether outside the university or inside it. You can contact the course staff during reception
hours for help or raise a question in the course forum. Do not transfer code sections
between students, upload solutions or parts of solutions to websites on the Internet or in
various communication groups.
11) Students who copy a solution will receive a 0 in all assignments in the course and a report will
be made to the institutional disciplinary committee.
12) All code files of the assignment are required to both compile and run properly on the Ubuntu
22.04 LTS operating system. This is the operating system where the submissions will be
tested. You mustnâ€™t code it in Windows, as it uses different API for sockets. WSL wonâ€™t work,
as the task needs a tool that works only in a fully Linux environment.
Good Luck!
 Communication Networks Course
Page | 2
Part A â€“ Transmission Control Protocol (TCP) â€“ 30 points
In this part, youâ€™ll write two program files: ğ‘»ğ‘ªğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and ğ‘»ğ‘ªğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
The Sender will send a randomly generated file and the Receiver will receive it and measure
the time it took for his program to receive the file. The file size should be at least 2MB.
When running the Sender and Receiver, they both should support two standard congestion
control algorithms: TCP Reno and TCP Cubic.
Notes:
â€¢ The main goal of this part is to get familiar with the TCP concept of sending
messages between two endpoints.
â€¢ For approaching this part of the assignment, please be sure that you are familiar
with the congestion control algorithms and how to change them using the correct
method in C (see Appendix B for more information).
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). You've
learned that TCP is reliable by design, so you can assume that all the data have been
passed correctly, and thus, no need to recheck.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
Usage:
â€¢ Receiver:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
â€¢ Sender:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port of the Receiver.
â€¢ ğ‘¨ğ‘³ğ‘®ğ‘¶ â€“ The TCP congestion control algorithm that will be used by the party
member (either ğ’“ğ’†ğ’ğ’ for TCP Reno or ğ’„ğ’–ğ’ƒğ’Šğ’„ for TCP Cubic).
 Communication Networks Course
Page | 3
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a TCP socket between the Sender and the
Receiver.
3) Send the file.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a TCP connection between the Receiver and
the Sender.
2) Get a connection from the sender.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./TCP_Receiver -p 1234 -algo reno
Starting Receiver...
Waiting for TCP connection...
Sender connected, beginning to receive file...
File transfer completed.
Waiting for Sender response...
Sender sent exit message.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 4
Part B â€“ Reliable User Datagram Protocol (Reliable UDP or RUDP) â€“ 40 points
Youâ€™ve learned that while TCP is reliable, it lacks speed and has an overhead data of 20 bytes,
compering to UDP that needs only 8 bytes of overhead data.
Reliable UDP or RUDP, is a protocol that uses the UDP protocol for a faster transmission of
data, while adding a reliability layer to it, but without adding too much overhead data like
TCP.
A simple sketch for a RUDP connection would look something like this:
Your task in this part is to implement a Reliable protocol using UDP only. For simplicity, your
implementation should only support a handshake, closing scheme, error checking,
acknowledgment of received packets, and retransmission of lost packets.
Guidance:
â€¢ You can use ğ‘ ğ‘’ğ‘¡ğ‘ ğ‘œğ‘ğ‘˜ğ‘œğ‘ğ‘¡(2) for detecting a timeout.
â€¢ You need to build your own protocol, as Reliable UDP isnâ€™t a standard protocol (see a
draft of RUDP in this link), and no official header is provided. You can use this sketch
for a header, but you can come up with your own protocol, as long as it works.
Where:
o ğ‘³ğ’†ğ’ğ’ˆğ’•ğ’‰ is the length of the data itself, without the RUDP header.
o ğ‘ªğ’‰ğ’†ğ’„ğ’Œğ’”ğ’–ğ’ is a 16bit number that validates the correctness of the data.
o ğ‘­ğ’ğ’‚ğ’ˆğ’” is a special byte where we classify the packet itself (SYN, ACK, etc.).
â€¢ In your PDF, you must explain how your implementation of RUDP works â€“ How does
it detect a timeout to do retransmissions, how does the handshake work, what is the
header overhead, etc.
â€¢ For this part, youâ€™ll write three files: ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¨ğ‘·ğ‘°. ğ’„, ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and
ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
Reliable UDP Header proposed sketch
Byte 0 Byte 1 Byte 2 Byte 3
Length (2 Bytes) Checksum (2 Bytes)
Flags (1 Byte)
Figure 1 - RUDP Protocol Architecture, Geeksforgeeks
 Communication Networks Course
Page | 5
Notes:
â€¢ The Sender will send a random generated file and the Receiver will receive it and
measure the time it took for his program to receive the file. The file size should be at
least 2MB.
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). But, as the
RUDP is based on UDP, itâ€™s not reliable. You must use some form of error checking
(like checksum) to ensure that the packet wasnâ€™t alerted during the transfer.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
â€¢ The RUDP needs support only 1 sender and 1 receiver, for simplicity purposes.
Usage:
â€¢ Receiver:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
â€¢ Sender:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port that both the Sender and the Receiver will use.
The ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„ file will contain all the implementations of the RUDP API functions (That is, to
prevent reusing the same chuck of code both in the Sender and the Receiver.).
The API should support at the bare minimum the following functions (you decide what
parameters to implement, and what are the names of the functions, as long as the API is
explained in the PDF):
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘œğ‘ğ‘˜ğ‘’ğ‘¡() â€“ Creating a RUDP socket and creating a handshake between two
peers.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘’ğ‘›ğ‘‘() â€“ Sending data to the peer. The function should wait for an
acknowledgment packet, and if it didnâ€™t receive any, retransmits the data.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘Ÿğ‘’ğ‘ğ‘£() â€“ Receive data from a peer.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ğ‘™ğ‘œğ‘ ğ‘’() â€“ Closes a connection between peers.
 Communication Networks Course
Page | 6
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a UDP socket between the Sender and the
Receiver.
3) Send the file via the RUDP protocol.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a UDP connection between the Receiver and
the Sender.
2) Get a connection from the sender, by the custom
RUDP protocol youâ€™ve built.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./RUDP_Receiver -p 1234
Starting Receiver...
Waiting for RUDP connection...
Connection request received, sending ACK.
Sender connected, beginning to receive file...
File transfer completed.
ACK sent.
Waiting for Sender response...
Sender sent exit message.
ACK sent.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 7
Part C â€“ Research â€“ 30 points
In this part, youâ€™ll conduct research about your implementations of part A and part B.
In the research itself, each one of the versions (TCP version and UDP version) will be run at
least 5 times (meaning that the file transfer will occur at least 5 times) by the following
conditions:
â€¢ For TCP, youâ€™ll run it in TCP Reno and TCP Cubic, alternating each time, for each
scenario, meaning that you run 5 times with TCP Reno in both Sender and Receiver,
and 5 times with TCP Cubic in both Sender and Receiver.
Bonus (5 points): Create a very large data set â€“ 5 times with TCP Reno in both Sender
and Receiver, 5 times with TCP Reno in Sender and TCP Cubic in Receiver, 5 times
with TCP Cubic in Sender and TCP Reno in Receiver, and 5 times with TCP Cubic in
both Sender and Receiver. This will give you a data set large enough, which allows
you to work with, compare with and to reach a definite conclusion.
â€¢ For RUDP, you will run it 5 times for each scenario.
â€¢ For both TCP and RUDP, you will run them on those scenarios of packet loss:
o 0% packet loss â€“ Control group, simulating perfect connection.
o 2% packet loss â€“ Simulating unstable connection that commonly occur.
o 5% packet loss â€“ Simulating bad connection.
o 10% packet loss â€“ Simulating extremely poor connection.
For each scenario, you must provide a filtered PCAP file and relevant screenshots that
explain each one of the steps in the process. (10 points)
After youâ€™ve gathered the data set for both TCP and Reliable UDP, answer the following
questions:
1) In TCP, which congestion control algorithm gave better results overall? TCP Reno or
TCP Cubic? Which one gave better results on high packet loss? Explain how you came
to this conclusion based on the data set youâ€™ve gathered. (5 points)
2) How did your implementation of Reliable UDP perform overall compared to regular
TCP? Which one is better for high packet loss? (5 points)
3) According to the data youâ€™ve gathered, in which scenarios and applications would we
prefer to use TCP and in which situations would we prefer to use reliable UDP?
Explain your answer. (5 points)
 Communication Networks Course
Page | 8
×¢× ×• ×¢×œ ×”×©××œ×•×ª ×”×‘××•×ª )5 × ×§×•×“×•×ª(:
â— ×‘"×¨×©×ª ×××™× ×”" ×”×›×•×•× ×” ×”×™× ×œ×¨×©×ª ×©×‘×” ××¢×˜ ×××•×“ ×—×‘×™×œ×•×ª ×”×•×œ×›×•×ª ×œ××™×‘×•×“. ×‘"×§×©×¨ ××¨×•×š" ×”×›×•×•× ×” ×”×™×
×œ×§×©×¨ TCP ×©×™×© ×‘×• ×”×¨×‘×” ×××•×“ ××™×“×¢ ×œ×©×œ×•×—. ××•×¦×¢ ×œ×”×’×“×™×œ ×‘ -TCP ××ª SSThreshold ×‘×ª×—×™×œ×ª ×”×§×©×¨.
×‘××™×–×” ××”××§×¨×™× ×”×‘××™× ×”×©×™× ×•×™ ×”×–×” ×¢×©×•×™ ×œ×”×•×¢×™×œ ×‘××™×“×” ×”××™×¨×‘×™×ª? × ××§.
.1 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
.2 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.3 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.4 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.5 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.6 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.7 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.8 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
â— A ×©×•×œ×— ×œ -B ×—×‘×™×œ×•×ª ××™×“×¢ ×‘×××¦×¢×•×ª ×§×©×¨ TCP. × ×ª×•×Ÿ ×›×™ ×”×§×©×¨ ××ª×—×™×œ ×¢× ×—×œ×•×Ÿ ×‘×’×•×“×œ 1MSS. ×”×§×©×¨
××¡×ª×™×™× ×‘×¤×¢× ×”×¨××©×•× ×” ×©×”×•× ××’×™×¢ ×œ -SSthresh. ×‘××”×œ×š ×”×§×©×¨ ×œ× ××•×‘×“×•×ª ×—×‘×™×œ×•×ª. × ×¡××Ÿ ×‘×§×™×¦×•×¨:
.SSthresh=S*MSS
× ×ª×•×Ÿ ×›×™ ×œ××•×¨×š ×›×œ ×”×§×©×¨ rwnd < MSS*S.
××”×™ ×”×ª×¤×•×§×” ×©×œ ×”×§×©×¨ ×-A ×œ-B( ×‘ -sec / Bytes )×‘×–××Ÿ ×”× "×œ? × ××§×™.
]S*MSS / [lg (S) * RTT*2 ×‘×¢×¨×š .1
]S*MSS / [S^0.5 * RTT*2 ×‘×¢×¨×š .2
S*MSS / RTT ×‘×¢×¨×š .3
S^2)*MSS / RTT( ×‘×¢×¨×š .4
â— ×©×ª×™ ×ª×—× ×•×ª ××ª×§×©×¨×•×ª ×‘××•×¤×Ÿ ××œ×—×•×˜×™ ×‘×©×™×˜×ª N Back Go.
× ×¡××Ÿ ×‘-X ××ª ×¡×¤×¨×ª ×”×‘×™×§×•×¨×ª ×©×œ ×”×ª.×–. ×©×œ×š. ×× ×©× ×™ ×©×•×ª×¤×™× ××’×™×©×™× ××ª ×”×ª×¨×’×™×œ ×™×—×“, X ×”×•× ×¡×¤×¨×ª
×”×‘×™×§×•×¨×ª ×‘×¢×œ×ª ×”×¢×¨×š ×”× ××•×š ×™×•×ª×¨ ××‘×™×Ÿ ×”×©×ª×™×™×.
×§×¦×‘ ×”×ª×§×©×•×¨×ª ×”×•× 8Gbps, ×•×’×•×“×œ ×›×œ ×—×‘×™×œ×” ×”×•× KByte*X. ×’×“×œ×™ ×”-headers ×•×” -Acks ×–× ×™×—×™×.
ï¿½ğ‘’ğ‘ ï¿½/ï¿½ï¿½ 8 , ×•×”××¨×—×§ ×‘×™×Ÿ ×”×ª×—× ×•×ª ×”×•× 1Km. ×§×¦×‘ ×”×”×ª×¤×©×˜×•×ª ×”×•× 10 â‹… 2
×–××Ÿ ×¢×™×‘×•×“ ×”× ×ª×•× ×™× ×‘×ª×—× ×•×ª ×–× ×™×—.
××£ ×—×‘×™×œ×” ×•××£ Ack ×œ× ×”×•×œ×›×™× ×œ××™×‘×•×“.
â— ××”×• X ×©×œ×š?
â— ××” ×¦×¨×™×š ×œ×”×™×•×ª ×’×•×“×œ ×—×œ×•×Ÿ ×”××©×œ×•×— ×›×“×™ ×œ×”×‘×˜×™×— ×ª×¤×•×§×” ××§×¡×™××œ×™×ª?
 Communication Networks Course
Page | 9
Bonus â€“ Improving the Reliable UDP â€“ 15 points
Note: This part isnâ€™t mandatory and is a bonus only!
In this part, youâ€™ll improve your RUDP implementation by adding the concepts of flow
control and congestion control from TCP. Youâ€™re free to choose which algorithms to
implement, as long as you explain in your PDF which algorithms youâ€™ve used. Youâ€™ll probably
need to make changes in the original design of the RUDP. Changes only need to be to the API
itself, ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„.
Points distribution:
â€¢ Flow control improvement â€“ 7 Points
â€¢ Congestion control improvement â€“ 8 points.
Guidance:
â€¢ For flow control, you must use one of the Sliding window techniques: stop-and-wait
ARQ, Go-Back-N or Selective repeat.
â€¢ List of known TCP congestion control algorithms, which you can use any one of them
for this bonus task, or makeup your own:
Figure 2 â€“ List of known TCP congestion control algorithms, Wikipedia
 Communication Networks Course
Page | 10
Appendix A â€“ Linux local packet loss tool
To simulate a packet loss in a local network, we'll use a Linux tool that's called Linux Traffic
Control (ğ‘¡ğ‘). This requires a full Linux installation, so working with WSL won't work.
If the tool isn't installed in your machine, you can install it by using the following commands:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’
If the installation didn't work, you can use the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’2
To create a packet loss scenario, type the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘ğ‘‘ğ‘‘ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
After creating a packet loss scenario, you can change the percentage by typing the following
command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘â„ğ‘ğ‘›ğ‘”ğ‘’ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
To remove the packet loss scenario, write the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘‘ğ‘’ğ‘™ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š
 Communication Networks Course
Page | 11
Appendix B â€“ ğ’ğ’‚ğ’(ğŸ) system calls
This appendixâ€™s purpose is to give you a better understanding of socket handling in C.
A recommended reference is Beejâ€™s Guide to Network Programming, by Brian â€œBeej
Jorgensenâ€ Hall, which gives a lot of information about sockets in C and functions.
Functions and documentation links:
â€¢ ğ’”ğ’ğ’„ğ’Œğ’†ğ’•(ğŸ) â€“ A Factory method system call that creates a socket with the given
parameters.
â€¢ ğ’ƒğ’Šğ’ğ’…(ğŸ) â€“ Whenever we create a new socket, we need to bind it to a specific port in
our machine, â€œto catch a portâ€. The port number is managed and used by the kernel
to link incoming packets to the corresponding application socket. The port numbers
are usually fixed. The ğ‘ğ‘‘ğ‘‘ğ‘Ÿ parameter must match the current socket that is used.
â€¢ ğ’ğ’Šğ’”ğ’•ğ’†ğ’(ğŸ) â€“ The ğ‘™ğ‘–ğ‘ ğ‘¡ğ‘’ğ‘›(2) system call doesn't do anything in the mean of
communication but only memory allocation (malloc) for stream sockets only. If we
won't allocate memory, any incoming connection will fail.
â€¢ ğ’„ğ’ğ’ğ’ğ’†ğ’„ğ’•(ğŸ) â€“ The ğ‘ğ‘œğ‘›ğ‘›ğ‘’ğ‘ğ‘¡(2) system call starts the link between a client and a
specific IP address and port number. The connection would complete when the
other side will call the ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call.
â€¢ ğ’‚ğ’„ğ’„ğ’†ğ’‘ğ’•(ğŸ) â€“ The ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call accepts the incoming stream connection
request from the other side, by the listening socket. This system call completes the
three-way handshake of stream socket (like TCP) and opens a new socket that has a
direct communication channel only with the other party in the handshake.
â€¢ ğ’”ğ’†ğ’ğ’…(ğŸ) and ğ’”ğ’†ğ’ğ’…ğ’•ğ’(ğŸ) â€“ The ğ‘ ğ‘’ğ‘›ğ‘‘(2) and ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system calls are an analogy
for the ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’(2) system call, specifcly for sockets, with flags set to 0. Those system
calls return the number of bytes that were sent through the socket itself, as the
number of bytes can vary. The ğ‘ ğ‘’ğ‘›ğ‘‘(2)system call designed for stream sockets (like
TCP), while the ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system call designed for datagram connection-less
sockets (like UDP). When the ğ‘ ğ‘’ğ‘›ğ‘‘(2) system call returns 0, it means that the other
party closed the connection.
â€¢ ğ’“ğ’†ğ’„ğ’—(ğŸ) and ğ’“ğ’†ğ’„ğ’—ğ’‡ğ’“ğ’ğ’(ğŸ) â€“ The ğ‘Ÿğ‘’ğ‘ğ‘£(2) and ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system calls are an
analogy for the ğ‘Ÿğ‘’ğ‘ğ‘‘(2) system call, specifically for sockets, with flags set to 0.
Those system calls return the number of bytes that were received through the socket
itself, as the number of bytes can vary. The ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call designed for stream
sockets (like TCP), while the ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system call designed for datagram
connection-less sockets (like UDP). When the ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call returns 0, it means
that the other party closed the connection.
â€¢ ğ’„ğ’ğ’ğ’”ğ’†(ğŸ) and ğ’”ğ’‰ğ’–ğ’•ğ’…ğ’ğ’˜ğ’(ğŸ) â€“ The ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) and ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2) system calls close
the socket. While ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) system call closes the whole socket, the ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2)
system call partially closes the socket for read/write.
 Communication Networks Course
Page | 12
Appendix C â€“ Random data generator
The data that you are going to send in this assignment is randomly generated. You can use
your own file with appropriate size or use the following function (or a function of your own)
to generate the data:
/*
* @brief A random data generator function based on srand() and rand().
* @param size The size of the data to generate (up to 2^32 bytes).
* @return A pointer to the buffer.
*/
char *util_generate_random_data(unsigned int size) {
 char *buffer = NULL;
 // Argument check.
 if (size == 0)
 return NULL;
 buffer = (char *)calloc(size, sizeof(char));
 // Error checking.
 if (buffer == NULL)
 return NULL;
 // Randomize the seed of the random number generator.
 srand(time(NULL));
 for (unsigned int i = 0; i < size; i++)
 *(buffer + i) = ((unsigned int)rand() % 256);
 return buffer;
}
 Communication Networks Course
Page | 13
Appendix D â€“ Checksum function
A checksum is a small-sized block of data derived from another block of digital data for the
purpose of detecting errors that may have been introduced during its transmission or
storage. By themselves, checksums are often used to verify data integrity but are not relied
upon to verify data authenticity.
Below is a simple yet efficient implementation of the checksum function, you can use it for
the assignment, but you can implement your own checksum function.
/*
* @brief A checksum function that returns 16 bit checksum for data.
* @param data The data to do the checksum for.
* @param bytes The length of the data in bytes.
* @return The checksum itself as 16 bit unsigned number.
* @note This function is taken from RFC1071, can be found here:
* @note https://tools.ietf.org/html/rfc1071
* @note It is the simplest way to calculate a checksum and is not very strong.
* However, it is good enough for this assignment.
* @note You are free to use any other checksum function as well.
* You can also use this function as such without any change.
*/
unsigned short int calculate_checksum(void *data, unsigned int bytes) {
 unsigned short int *data_pointer = (unsigned short int *)data;
 unsigned int total_sum = 0;
 // Main summing loop
 while (bytes > 1) {
 total_sum += *data_pointer++;
 bytes -= 2;
 }
 // Add left-over byte, if any
 if (bytes > 0)
 total_sum += *((unsigned char *)data_pointer);
 // Fold 32-bit sum to 16 bits
 while (total_sum >> 16)
 total_sum = (total_sum & 0xFFFF) + (total_sum >> 16);
 return (~((unsigned short int)total_sum));
} Communication Networks Course
Page | 1
Assignment 3 â€“ Transport Layer
Assignment Notes and Instructions
This assignment is to be done in pairs only. You must upload all the necessary files in a ZIP
file named after both of the studentâ€™s ID. For example: ğŸğŸğŸ‘ğŸ’ğŸ“ğŸ”ğŸ•ğŸ–ğŸ—_ğŸ—ğŸ–ğŸ•ğŸ”ğŸ“ğŸ’ğŸ‘ğŸğŸ. ğ’›ğ’Šğ’‘.
1) The assignment must be submitted by the date specified in the submission box.
2) All the assignment files (Code, Wireshark pcap files, PDF) must be submitted in a ZIP file. The
PDF must contain all the necessary screenshots with a description for each one of them.
3) The assignment must be done in pairs only. In exceptional cases, you should send an email to
the course coordinator.
4) You can use any reference material available through the course Moodle website or any
material passed during the exercises.
5) You can use any reference from the web, but copying codes from websites is forbidden; this
includes codes from other GitHub repositories. A student who gets caught in the act will
automatically fail this assignment (score 0). Any website youâ€™ve used to solve the
assignment, every website you used to solve the assignment must be noted in the PDF.
6) No delays in submission without special permission. Lateness without approval will result in
failure of the assignment (score 0).
7) All submissions will be submitted via the course's Moodle website. Email submissions will not
be accepted, resulting in a failure in the assignment.
8) The order and design of the code must be carefully considered. Make sure that the program
output is as clear as possible, comments in the code, and meaningful variable names. You
must also submit a makefile that compiles all the programs.
9) The assignment code must be written in C only.
10) The assignment is personal for each pair, and you should not accept help from other people,
whether outside the university or inside it. You can contact the course staff during reception
hours for help or raise a question in the course forum. Do not transfer code sections
between students, upload solutions or parts of solutions to websites on the Internet or in
various communication groups.
11) Students who copy a solution will receive a 0 in all assignments in the course and a report will
be made to the institutional disciplinary committee.
12) All code files of the assignment are required to both compile and run properly on the Ubuntu
22.04 LTS operating system. This is the operating system where the submissions will be
tested. You mustnâ€™t code it in Windows, as it uses different API for sockets. WSL wonâ€™t work,
as the task needs a tool that works only in a fully Linux environment.
Good Luck!
 Communication Networks Course
Page | 2
Part A â€“ Transmission Control Protocol (TCP) â€“ 30 points
In this part, youâ€™ll write two program files: ğ‘»ğ‘ªğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and ğ‘»ğ‘ªğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
The Sender will send a randomly generated file and the Receiver will receive it and measure
the time it took for his program to receive the file. The file size should be at least 2MB.
When running the Sender and Receiver, they both should support two standard congestion
control algorithms: TCP Reno and TCP Cubic.
Notes:
â€¢ The main goal of this part is to get familiar with the TCP concept of sending
messages between two endpoints.
â€¢ For approaching this part of the assignment, please be sure that you are familiar
with the congestion control algorithms and how to change them using the correct
method in C (see Appendix B for more information).
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). You've
learned that TCP is reliable by design, so you can assume that all the data have been
passed correctly, and thus, no need to recheck.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
Usage:
â€¢ Receiver:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
â€¢ Sender:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port of the Receiver.
â€¢ ğ‘¨ğ‘³ğ‘®ğ‘¶ â€“ The TCP congestion control algorithm that will be used by the party
member (either ğ’“ğ’†ğ’ğ’ for TCP Reno or ğ’„ğ’–ğ’ƒğ’Šğ’„ for TCP Cubic).
 Communication Networks Course
Page | 3
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a TCP socket between the Sender and the
Receiver.
3) Send the file.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a TCP connection between the Receiver and
the Sender.
2) Get a connection from the sender.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./TCP_Receiver -p 1234 -algo reno
Starting Receiver...
Waiting for TCP connection...
Sender connected, beginning to receive file...
File transfer completed.
Waiting for Sender response...
Sender sent exit message.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 4
Part B â€“ Reliable User Datagram Protocol (Reliable UDP or RUDP) â€“ 40 points
Youâ€™ve learned that while TCP is reliable, it lacks speed and has an overhead data of 20 bytes,
compering to UDP that needs only 8 bytes of overhead data.
Reliable UDP or RUDP, is a protocol that uses the UDP protocol for a faster transmission of
data, while adding a reliability layer to it, but without adding too much overhead data like
TCP.
A simple sketch for a RUDP connection would look something like this:
Your task in this part is to implement a Reliable protocol using UDP only. For simplicity, your
implementation should only support a handshake, closing scheme, error checking,
acknowledgment of received packets, and retransmission of lost packets.
Guidance:
â€¢ You can use ğ‘ ğ‘’ğ‘¡ğ‘ ğ‘œğ‘ğ‘˜ğ‘œğ‘ğ‘¡(2) for detecting a timeout.
â€¢ You need to build your own protocol, as Reliable UDP isnâ€™t a standard protocol (see a
draft of RUDP in this link), and no official header is provided. You can use this sketch
for a header, but you can come up with your own protocol, as long as it works.
Where:
o ğ‘³ğ’†ğ’ğ’ˆğ’•ğ’‰ is the length of the data itself, without the RUDP header.
o ğ‘ªğ’‰ğ’†ğ’„ğ’Œğ’”ğ’–ğ’ is a 16bit number that validates the correctness of the data.
o ğ‘­ğ’ğ’‚ğ’ˆğ’” is a special byte where we classify the packet itself (SYN, ACK, etc.).
â€¢ In your PDF, you must explain how your implementation of RUDP works â€“ How does
it detect a timeout to do retransmissions, how does the handshake work, what is the
header overhead, etc.
â€¢ For this part, youâ€™ll write three files: ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¨ğ‘·ğ‘°. ğ’„, ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and
ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
Reliable UDP Header proposed sketch
Byte 0 Byte 1 Byte 2 Byte 3
Length (2 Bytes) Checksum (2 Bytes)
Flags (1 Byte)
Figure 1 - RUDP Protocol Architecture, Geeksforgeeks
 Communication Networks Course
Page | 5
Notes:
â€¢ The Sender will send a random generated file and the Receiver will receive it and
measure the time it took for his program to receive the file. The file size should be at
least 2MB.
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). But, as the
RUDP is based on UDP, itâ€™s not reliable. You must use some form of error checking
(like checksum) to ensure that the packet wasnâ€™t alerted during the transfer.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
â€¢ The RUDP needs support only 1 sender and 1 receiver, for simplicity purposes.
Usage:
â€¢ Receiver:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
â€¢ Sender:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port that both the Sender and the Receiver will use.
The ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„ file will contain all the implementations of the RUDP API functions (That is, to
prevent reusing the same chuck of code both in the Sender and the Receiver.).
The API should support at the bare minimum the following functions (you decide what
parameters to implement, and what are the names of the functions, as long as the API is
explained in the PDF):
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘œğ‘ğ‘˜ğ‘’ğ‘¡() â€“ Creating a RUDP socket and creating a handshake between two
peers.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘’ğ‘›ğ‘‘() â€“ Sending data to the peer. The function should wait for an
acknowledgment packet, and if it didnâ€™t receive any, retransmits the data.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘Ÿğ‘’ğ‘ğ‘£() â€“ Receive data from a peer.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ğ‘™ğ‘œğ‘ ğ‘’() â€“ Closes a connection between peers.
 Communication Networks Course
Page | 6
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a UDP socket between the Sender and the
Receiver.
3) Send the file via the RUDP protocol.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a UDP connection between the Receiver and
the Sender.
2) Get a connection from the sender, by the custom
RUDP protocol youâ€™ve built.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./RUDP_Receiver -p 1234
Starting Receiver...
Waiting for RUDP connection...
Connection request received, sending ACK.
Sender connected, beginning to receive file...
File transfer completed.
ACK sent.
Waiting for Sender response...
Sender sent exit message.
ACK sent.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 7
Part C â€“ Research â€“ 30 points
In this part, youâ€™ll conduct research about your implementations of part A and part B.
In the research itself, each one of the versions (TCP version and UDP version) will be run at
least 5 times (meaning that the file transfer will occur at least 5 times) by the following
conditions:
â€¢ For TCP, youâ€™ll run it in TCP Reno and TCP Cubic, alternating each time, for each
scenario, meaning that you run 5 times with TCP Reno in both Sender and Receiver,
and 5 times with TCP Cubic in both Sender and Receiver.
Bonus (5 points): Create a very large data set â€“ 5 times with TCP Reno in both Sender
and Receiver, 5 times with TCP Reno in Sender and TCP Cubic in Receiver, 5 times
with TCP Cubic in Sender and TCP Reno in Receiver, and 5 times with TCP Cubic in
both Sender and Receiver. This will give you a data set large enough, which allows
you to work with, compare with and to reach a definite conclusion.
â€¢ For RUDP, you will run it 5 times for each scenario.
â€¢ For both TCP and RUDP, you will run them on those scenarios of packet loss:
o 0% packet loss â€“ Control group, simulating perfect connection.
o 2% packet loss â€“ Simulating unstable connection that commonly occur.
o 5% packet loss â€“ Simulating bad connection.
o 10% packet loss â€“ Simulating extremely poor connection.
For each scenario, you must provide a filtered PCAP file and relevant screenshots that
explain each one of the steps in the process. (10 points)
After youâ€™ve gathered the data set for both TCP and Reliable UDP, answer the following
questions:
1) In TCP, which congestion control algorithm gave better results overall? TCP Reno or
TCP Cubic? Which one gave better results on high packet loss? Explain how you came
to this conclusion based on the data set youâ€™ve gathered. (5 points)
2) How did your implementation of Reliable UDP perform overall compared to regular
TCP? Which one is better for high packet loss? (5 points)
3) According to the data youâ€™ve gathered, in which scenarios and applications would we
prefer to use TCP and in which situations would we prefer to use reliable UDP?
Explain your answer. (5 points)
 Communication Networks Course
Page | 8
×¢× ×• ×¢×œ ×”×©××œ×•×ª ×”×‘××•×ª )5 × ×§×•×“×•×ª(:
â— ×‘"×¨×©×ª ×××™× ×”" ×”×›×•×•× ×” ×”×™× ×œ×¨×©×ª ×©×‘×” ××¢×˜ ×××•×“ ×—×‘×™×œ×•×ª ×”×•×œ×›×•×ª ×œ××™×‘×•×“. ×‘"×§×©×¨ ××¨×•×š" ×”×›×•×•× ×” ×”×™×
×œ×§×©×¨ TCP ×©×™×© ×‘×• ×”×¨×‘×” ×××•×“ ××™×“×¢ ×œ×©×œ×•×—. ××•×¦×¢ ×œ×”×’×“×™×œ ×‘ -TCP ××ª SSThreshold ×‘×ª×—×™×œ×ª ×”×§×©×¨.
×‘××™×–×” ××”××§×¨×™× ×”×‘××™× ×”×©×™× ×•×™ ×”×–×” ×¢×©×•×™ ×œ×”×•×¢×™×œ ×‘××™×“×” ×”××™×¨×‘×™×ª? × ××§.
.1 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
.2 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.3 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.4 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.5 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.6 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.7 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.8 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
â— A ×©×•×œ×— ×œ -B ×—×‘×™×œ×•×ª ××™×“×¢ ×‘×××¦×¢×•×ª ×§×©×¨ TCP. × ×ª×•×Ÿ ×›×™ ×”×§×©×¨ ××ª×—×™×œ ×¢× ×—×œ×•×Ÿ ×‘×’×•×“×œ 1MSS. ×”×§×©×¨
××¡×ª×™×™× ×‘×¤×¢× ×”×¨××©×•× ×” ×©×”×•× ××’×™×¢ ×œ -SSthresh. ×‘××”×œ×š ×”×§×©×¨ ×œ× ××•×‘×“×•×ª ×—×‘×™×œ×•×ª. × ×¡××Ÿ ×‘×§×™×¦×•×¨:
.SSthresh=S*MSS
× ×ª×•×Ÿ ×›×™ ×œ××•×¨×š ×›×œ ×”×§×©×¨ rwnd < MSS*S.
××”×™ ×”×ª×¤×•×§×” ×©×œ ×”×§×©×¨ ×-A ×œ-B( ×‘ -sec / Bytes )×‘×–××Ÿ ×”× "×œ? × ××§×™.
]S*MSS / [lg (S) * RTT*2 ×‘×¢×¨×š .1
]S*MSS / [S^0.5 * RTT*2 ×‘×¢×¨×š .2
S*MSS / RTT ×‘×¢×¨×š .3
S^2)*MSS / RTT( ×‘×¢×¨×š .4
â— ×©×ª×™ ×ª×—× ×•×ª ××ª×§×©×¨×•×ª ×‘××•×¤×Ÿ ××œ×—×•×˜×™ ×‘×©×™×˜×ª N Back Go.
× ×¡××Ÿ ×‘-X ××ª ×¡×¤×¨×ª ×”×‘×™×§×•×¨×ª ×©×œ ×”×ª.×–. ×©×œ×š. ×× ×©× ×™ ×©×•×ª×¤×™× ××’×™×©×™× ××ª ×”×ª×¨×’×™×œ ×™×—×“, X ×”×•× ×¡×¤×¨×ª
×”×‘×™×§×•×¨×ª ×‘×¢×œ×ª ×”×¢×¨×š ×”× ××•×š ×™×•×ª×¨ ××‘×™×Ÿ ×”×©×ª×™×™×.
×§×¦×‘ ×”×ª×§×©×•×¨×ª ×”×•× 8Gbps, ×•×’×•×“×œ ×›×œ ×—×‘×™×œ×” ×”×•× KByte*X. ×’×“×œ×™ ×”-headers ×•×” -Acks ×–× ×™×—×™×.
ï¿½ğ‘’ğ‘ ï¿½/ï¿½ï¿½ 8 , ×•×”××¨×—×§ ×‘×™×Ÿ ×”×ª×—× ×•×ª ×”×•× 1Km. ×§×¦×‘ ×”×”×ª×¤×©×˜×•×ª ×”×•× 10 â‹… 2
×–××Ÿ ×¢×™×‘×•×“ ×”× ×ª×•× ×™× ×‘×ª×—× ×•×ª ×–× ×™×—.
××£ ×—×‘×™×œ×” ×•××£ Ack ×œ× ×”×•×œ×›×™× ×œ××™×‘×•×“.
â— ××”×• X ×©×œ×š?
â— ××” ×¦×¨×™×š ×œ×”×™×•×ª ×’×•×“×œ ×—×œ×•×Ÿ ×”××©×œ×•×— ×›×“×™ ×œ×”×‘×˜×™×— ×ª×¤×•×§×” ××§×¡×™××œ×™×ª?
 Communication Networks Course
Page | 9
Bonus â€“ Improving the Reliable UDP â€“ 15 points
Note: This part isnâ€™t mandatory and is a bonus only!
In this part, youâ€™ll improve your RUDP implementation by adding the concepts of flow
control and congestion control from TCP. Youâ€™re free to choose which algorithms to
implement, as long as you explain in your PDF which algorithms youâ€™ve used. Youâ€™ll probably
need to make changes in the original design of the RUDP. Changes only need to be to the API
itself, ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„.
Points distribution:
â€¢ Flow control improvement â€“ 7 Points
â€¢ Congestion control improvement â€“ 8 points.
Guidance:
â€¢ For flow control, you must use one of the Sliding window techniques: stop-and-wait
ARQ, Go-Back-N or Selective repeat.
â€¢ List of known TCP congestion control algorithms, which you can use any one of them
for this bonus task, or makeup your own:
Figure 2 â€“ List of known TCP congestion control algorithms, Wikipedia
 Communication Networks Course
Page | 10
Appendix A â€“ Linux local packet loss tool
To simulate a packet loss in a local network, we'll use a Linux tool that's called Linux Traffic
Control (ğ‘¡ğ‘). This requires a full Linux installation, so working with WSL won't work.
If the tool isn't installed in your machine, you can install it by using the following commands:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’
If the installation didn't work, you can use the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’2
To create a packet loss scenario, type the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘ğ‘‘ğ‘‘ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
After creating a packet loss scenario, you can change the percentage by typing the following
command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘â„ğ‘ğ‘›ğ‘”ğ‘’ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
To remove the packet loss scenario, write the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘‘ğ‘’ğ‘™ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š
 Communication Networks Course
Page | 11
Appendix B â€“ ğ’ğ’‚ğ’(ğŸ) system calls
This appendixâ€™s purpose is to give you a better understanding of socket handling in C.
A recommended reference is Beejâ€™s Guide to Network Programming, by Brian â€œBeej
Jorgensenâ€ Hall, which gives a lot of information about sockets in C and functions.
Functions and documentation links:
â€¢ ğ’”ğ’ğ’„ğ’Œğ’†ğ’•(ğŸ) â€“ A Factory method system call that creates a socket with the given
parameters.
â€¢ ğ’ƒğ’Šğ’ğ’…(ğŸ) â€“ Whenever we create a new socket, we need to bind it to a specific port in
our machine, â€œto catch a portâ€. The port number is managed and used by the kernel
to link incoming packets to the corresponding application socket. The port numbers
are usually fixed. The ğ‘ğ‘‘ğ‘‘ğ‘Ÿ parameter must match the current socket that is used.
â€¢ ğ’ğ’Šğ’”ğ’•ğ’†ğ’(ğŸ) â€“ The ğ‘™ğ‘–ğ‘ ğ‘¡ğ‘’ğ‘›(2) system call doesn't do anything in the mean of
communication but only memory allocation (malloc) for stream sockets only. If we
won't allocate memory, any incoming connection will fail.
â€¢ ğ’„ğ’ğ’ğ’ğ’†ğ’„ğ’•(ğŸ) â€“ The ğ‘ğ‘œğ‘›ğ‘›ğ‘’ğ‘ğ‘¡(2) system call starts the link between a client and a
specific IP address and port number. The connection would complete when the
other side will call the ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call.
â€¢ ğ’‚ğ’„ğ’„ğ’†ğ’‘ğ’•(ğŸ) â€“ The ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call accepts the incoming stream connection
request from the other side, by the listening socket. This system call completes the
three-way handshake of stream socket (like TCP) and opens a new socket that has a
direct communication channel only with the other party in the handshake.
â€¢ ğ’”ğ’†ğ’ğ’…(ğŸ) and ğ’”ğ’†ğ’ğ’…ğ’•ğ’(ğŸ) â€“ The ğ‘ ğ‘’ğ‘›ğ‘‘(2) and ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system calls are an analogy
for the ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’(2) system call, specifcly for sockets, with flags set to 0. Those system
calls return the number of bytes that were sent through the socket itself, as the
number of bytes can vary. The ğ‘ ğ‘’ğ‘›ğ‘‘(2)system call designed for stream sockets (like
TCP), while the ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system call designed for datagram connection-less
sockets (like UDP). When the ğ‘ ğ‘’ğ‘›ğ‘‘(2) system call returns 0, it means that the other
party closed the connection.
â€¢ ğ’“ğ’†ğ’„ğ’—(ğŸ) and ğ’“ğ’†ğ’„ğ’—ğ’‡ğ’“ğ’ğ’(ğŸ) â€“ The ğ‘Ÿğ‘’ğ‘ğ‘£(2) and ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system calls are an
analogy for the ğ‘Ÿğ‘’ğ‘ğ‘‘(2) system call, specifically for sockets, with flags set to 0.
Those system calls return the number of bytes that were received through the socket
itself, as the number of bytes can vary. The ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call designed for stream
sockets (like TCP), while the ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system call designed for datagram
connection-less sockets (like UDP). When the ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call returns 0, it means
that the other party closed the connection.
â€¢ ğ’„ğ’ğ’ğ’”ğ’†(ğŸ) and ğ’”ğ’‰ğ’–ğ’•ğ’…ğ’ğ’˜ğ’(ğŸ) â€“ The ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) and ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2) system calls close
the socket. While ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) system call closes the whole socket, the ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2)
system call partially closes the socket for read/write.
 Communication Networks Course
Page | 12
Appendix C â€“ Random data generator
The data that you are going to send in this assignment is randomly generated. You can use
your own file with appropriate size or use the following function (or a function of your own)
to generate the data:
/*
* @brief A random data generator function based on srand() and rand().
* @param size The size of the data to generate (up to 2^32 bytes).
* @return A pointer to the buffer.
*/
char *util_generate_random_data(unsigned int size) {
 char *buffer = NULL;
 // Argument check.
 if (size == 0)
 return NULL;
 buffer = (char *)calloc(size, sizeof(char));
 // Error checking.
 if (buffer == NULL)
 return NULL;
 // Randomize the seed of the random number generator.
 srand(time(NULL));
 for (unsigned int i = 0; i < size; i++)
 *(buffer + i) = ((unsigned int)rand() % 256);
 return buffer;
}
 Communication Networks Course
Page | 13
Appendix D â€“ Checksum function
A checksum is a small-sized block of data derived from another block of digital data for the
purpose of detecting errors that may have been introduced during its transmission or
storage. By themselves, checksums are often used to verify data integrity but are not relied
upon to verify data authenticity.
Below is a simple yet efficient implementation of the checksum function, you can use it for
the assignment, but you can implement your own checksum function.
/*
* @brief A checksum function that returns 16 bit checksum for data.
* @param data The data to do the checksum for.
* @param bytes The length of the data in bytes.
* @return The checksum itself as 16 bit unsigned number.
* @note This function is taken from RFC1071, can be found here:
* @note https://tools.ietf.org/html/rfc1071
* @note It is the simplest way to calculate a checksum and is not very strong.
* However, it is good enough for this assignment.
* @note You are free to use any other checksum function as well.
* You can also use this function as such without any change.
*/
unsigned short int calculate_checksum(void *data, unsigned int bytes) {
 unsigned short int *data_pointer = (unsigned short int *)data;
 unsigned int total_sum = 0;
 // Main summing loop
 while (bytes > 1) {
 total_sum += *data_pointer++;
 bytes -= 2;
 }
 // Add left-over byte, if any
 if (bytes > 0)
 total_sum += *((unsigned char *)data_pointer);
 // Fold 32-bit sum to 16 bits
 while (total_sum >> 16)
 total_sum = (total_sum & 0xFFFF) + (total_sum >> 16);
 return (~((unsigned short int)total_sum));
} Communication Networks Course
Page | 1
Assignment 3 â€“ Transport Layer
Assignment Notes and Instructions
This assignment is to be done in pairs only. You must upload all the necessary files in a ZIP
file named after both of the studentâ€™s ID. For example: ğŸğŸğŸ‘ğŸ’ğŸ“ğŸ”ğŸ•ğŸ–ğŸ—_ğŸ—ğŸ–ğŸ•ğŸ”ğŸ“ğŸ’ğŸ‘ğŸğŸ. ğ’›ğ’Šğ’‘.
1) The assignment must be submitted by the date specified in the submission box.
2) All the assignment files (Code, Wireshark pcap files, PDF) must be submitted in a ZIP file. The
PDF must contain all the necessary screenshots with a description for each one of them.
3) The assignment must be done in pairs only. In exceptional cases, you should send an email to
the course coordinator.
4) You can use any reference material available through the course Moodle website or any
material passed during the exercises.
5) You can use any reference from the web, but copying codes from websites is forbidden; this
includes codes from other GitHub repositories. A student who gets caught in the act will
automatically fail this assignment (score 0). Any website youâ€™ve used to solve the
assignment, every website you used to solve the assignment must be noted in the PDF.
6) No delays in submission without special permission. Lateness without approval will result in
failure of the assignment (score 0).
7) All submissions will be submitted via the course's Moodle website. Email submissions will not
be accepted, resulting in a failure in the assignment.
8) The order and design of the code must be carefully considered. Make sure that the program
output is as clear as possible, comments in the code, and meaningful variable names. You
must also submit a makefile that compiles all the programs.
9) The assignment code must be written in C only.
10) The assignment is personal for each pair, and you should not accept help from other people,
whether outside the university or inside it. You can contact the course staff during reception
hours for help or raise a question in the course forum. Do not transfer code sections
between students, upload solutions or parts of solutions to websites on the Internet or in
various communication groups.
11) Students who copy a solution will receive a 0 in all assignments in the course and a report will
be made to the institutional disciplinary committee.
12) All code files of the assignment are required to both compile and run properly on the Ubuntu
22.04 LTS operating system. This is the operating system where the submissions will be
tested. You mustnâ€™t code it in Windows, as it uses different API for sockets. WSL wonâ€™t work,
as the task needs a tool that works only in a fully Linux environment.
Good Luck!
 Communication Networks Course
Page | 2
Part A â€“ Transmission Control Protocol (TCP) â€“ 30 points
In this part, youâ€™ll write two program files: ğ‘»ğ‘ªğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and ğ‘»ğ‘ªğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
The Sender will send a randomly generated file and the Receiver will receive it and measure
the time it took for his program to receive the file. The file size should be at least 2MB.
When running the Sender and Receiver, they both should support two standard congestion
control algorithms: TCP Reno and TCP Cubic.
Notes:
â€¢ The main goal of this part is to get familiar with the TCP concept of sending
messages between two endpoints.
â€¢ For approaching this part of the assignment, please be sure that you are familiar
with the congestion control algorithms and how to change them using the correct
method in C (see Appendix B for more information).
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). You've
learned that TCP is reliable by design, so you can assume that all the data have been
passed correctly, and thus, no need to recheck.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
Usage:
â€¢ Receiver:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
â€¢ Sender:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port of the Receiver.
â€¢ ğ‘¨ğ‘³ğ‘®ğ‘¶ â€“ The TCP congestion control algorithm that will be used by the party
member (either ğ’“ğ’†ğ’ğ’ for TCP Reno or ğ’„ğ’–ğ’ƒğ’Šğ’„ for TCP Cubic).
 Communication Networks Course
Page | 3
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a TCP socket between the Sender and the
Receiver.
3) Send the file.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a TCP connection between the Receiver and
the Sender.
2) Get a connection from the sender.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./TCP_Receiver -p 1234 -algo reno
Starting Receiver...
Waiting for TCP connection...
Sender connected, beginning to receive file...
File transfer completed.
Waiting for Sender response...
Sender sent exit message.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 4
Part B â€“ Reliable User Datagram Protocol (Reliable UDP or RUDP) â€“ 40 points
Youâ€™ve learned that while TCP is reliable, it lacks speed and has an overhead data of 20 bytes,
compering to UDP that needs only 8 bytes of overhead data.
Reliable UDP or RUDP, is a protocol that uses the UDP protocol for a faster transmission of
data, while adding a reliability layer to it, but without adding too much overhead data like
TCP.
A simple sketch for a RUDP connection would look something like this:
Your task in this part is to implement a Reliable protocol using UDP only. For simplicity, your
implementation should only support a handshake, closing scheme, error checking,
acknowledgment of received packets, and retransmission of lost packets.
Guidance:
â€¢ You can use ğ‘ ğ‘’ğ‘¡ğ‘ ğ‘œğ‘ğ‘˜ğ‘œğ‘ğ‘¡(2) for detecting a timeout.
â€¢ You need to build your own protocol, as Reliable UDP isnâ€™t a standard protocol (see a
draft of RUDP in this link), and no official header is provided. You can use this sketch
for a header, but you can come up with your own protocol, as long as it works.
Where:
o ğ‘³ğ’†ğ’ğ’ˆğ’•ğ’‰ is the length of the data itself, without the RUDP header.
o ğ‘ªğ’‰ğ’†ğ’„ğ’Œğ’”ğ’–ğ’ is a 16bit number that validates the correctness of the data.
o ğ‘­ğ’ğ’‚ğ’ˆğ’” is a special byte where we classify the packet itself (SYN, ACK, etc.).
â€¢ In your PDF, you must explain how your implementation of RUDP works â€“ How does
it detect a timeout to do retransmissions, how does the handshake work, what is the
header overhead, etc.
â€¢ For this part, youâ€™ll write three files: ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¨ğ‘·ğ‘°. ğ’„, ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and
ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
Reliable UDP Header proposed sketch
Byte 0 Byte 1 Byte 2 Byte 3
Length (2 Bytes) Checksum (2 Bytes)
Flags (1 Byte)
Figure 1 - RUDP Protocol Architecture, Geeksforgeeks
 Communication Networks Course
Page | 5
Notes:
â€¢ The Sender will send a random generated file and the Receiver will receive it and
measure the time it took for his program to receive the file. The file size should be at
least 2MB.
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). But, as the
RUDP is based on UDP, itâ€™s not reliable. You must use some form of error checking
(like checksum) to ensure that the packet wasnâ€™t alerted during the transfer.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
â€¢ The RUDP needs support only 1 sender and 1 receiver, for simplicity purposes.
Usage:
â€¢ Receiver:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
â€¢ Sender:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port that both the Sender and the Receiver will use.
The ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„ file will contain all the implementations of the RUDP API functions (That is, to
prevent reusing the same chuck of code both in the Sender and the Receiver.).
The API should support at the bare minimum the following functions (you decide what
parameters to implement, and what are the names of the functions, as long as the API is
explained in the PDF):
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘œğ‘ğ‘˜ğ‘’ğ‘¡() â€“ Creating a RUDP socket and creating a handshake between two
peers.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘’ğ‘›ğ‘‘() â€“ Sending data to the peer. The function should wait for an
acknowledgment packet, and if it didnâ€™t receive any, retransmits the data.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘Ÿğ‘’ğ‘ğ‘£() â€“ Receive data from a peer.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ğ‘™ğ‘œğ‘ ğ‘’() â€“ Closes a connection between peers.
 Communication Networks Course
Page | 6
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a UDP socket between the Sender and the
Receiver.
3) Send the file via the RUDP protocol.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a UDP connection between the Receiver and
the Sender.
2) Get a connection from the sender, by the custom
RUDP protocol youâ€™ve built.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./RUDP_Receiver -p 1234
Starting Receiver...
Waiting for RUDP connection...
Connection request received, sending ACK.
Sender connected, beginning to receive file...
File transfer completed.
ACK sent.
Waiting for Sender response...
Sender sent exit message.
ACK sent.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 7
Part C â€“ Research â€“ 30 points
In this part, youâ€™ll conduct research about your implementations of part A and part B.
In the research itself, each one of the versions (TCP version and UDP version) will be run at
least 5 times (meaning that the file transfer will occur at least 5 times) by the following
conditions:
â€¢ For TCP, youâ€™ll run it in TCP Reno and TCP Cubic, alternating each time, for each
scenario, meaning that you run 5 times with TCP Reno in both Sender and Receiver,
and 5 times with TCP Cubic in both Sender and Receiver.
Bonus (5 points): Create a very large data set â€“ 5 times with TCP Reno in both Sender
and Receiver, 5 times with TCP Reno in Sender and TCP Cubic in Receiver, 5 times
with TCP Cubic in Sender and TCP Reno in Receiver, and 5 times with TCP Cubic in
both Sender and Receiver. This will give you a data set large enough, which allows
you to work with, compare with and to reach a definite conclusion.
â€¢ For RUDP, you will run it 5 times for each scenario.
â€¢ For both TCP and RUDP, you will run them on those scenarios of packet loss:
o 0% packet loss â€“ Control group, simulating perfect connection.
o 2% packet loss â€“ Simulating unstable connection that commonly occur.
o 5% packet loss â€“ Simulating bad connection.
o 10% packet loss â€“ Simulating extremely poor connection.
For each scenario, you must provide a filtered PCAP file and relevant screenshots that
explain each one of the steps in the process. (10 points)
After youâ€™ve gathered the data set for both TCP and Reliable UDP, answer the following
questions:
1) In TCP, which congestion control algorithm gave better results overall? TCP Reno or
TCP Cubic? Which one gave better results on high packet loss? Explain how you came
to this conclusion based on the data set youâ€™ve gathered. (5 points)
2) How did your implementation of Reliable UDP perform overall compared to regular
TCP? Which one is better for high packet loss? (5 points)
3) According to the data youâ€™ve gathered, in which scenarios and applications would we
prefer to use TCP and in which situations would we prefer to use reliable UDP?
Explain your answer. (5 points)
 Communication Networks Course
Page | 8
×¢× ×• ×¢×œ ×”×©××œ×•×ª ×”×‘××•×ª )5 × ×§×•×“×•×ª(:
â— ×‘"×¨×©×ª ×××™× ×”" ×”×›×•×•× ×” ×”×™× ×œ×¨×©×ª ×©×‘×” ××¢×˜ ×××•×“ ×—×‘×™×œ×•×ª ×”×•×œ×›×•×ª ×œ××™×‘×•×“. ×‘"×§×©×¨ ××¨×•×š" ×”×›×•×•× ×” ×”×™×
×œ×§×©×¨ TCP ×©×™×© ×‘×• ×”×¨×‘×” ×××•×“ ××™×“×¢ ×œ×©×œ×•×—. ××•×¦×¢ ×œ×”×’×“×™×œ ×‘ -TCP ××ª SSThreshold ×‘×ª×—×™×œ×ª ×”×§×©×¨.
×‘××™×–×” ××”××§×¨×™× ×”×‘××™× ×”×©×™× ×•×™ ×”×–×” ×¢×©×•×™ ×œ×”×•×¢×™×œ ×‘××™×“×” ×”××™×¨×‘×™×ª? × ××§.
.1 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
.2 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.3 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.4 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.5 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.6 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.7 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.8 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
â— A ×©×•×œ×— ×œ -B ×—×‘×™×œ×•×ª ××™×“×¢ ×‘×××¦×¢×•×ª ×§×©×¨ TCP. × ×ª×•×Ÿ ×›×™ ×”×§×©×¨ ××ª×—×™×œ ×¢× ×—×œ×•×Ÿ ×‘×’×•×“×œ 1MSS. ×”×§×©×¨
××¡×ª×™×™× ×‘×¤×¢× ×”×¨××©×•× ×” ×©×”×•× ××’×™×¢ ×œ -SSthresh. ×‘××”×œ×š ×”×§×©×¨ ×œ× ××•×‘×“×•×ª ×—×‘×™×œ×•×ª. × ×¡××Ÿ ×‘×§×™×¦×•×¨:
.SSthresh=S*MSS
× ×ª×•×Ÿ ×›×™ ×œ××•×¨×š ×›×œ ×”×§×©×¨ rwnd < MSS*S.
××”×™ ×”×ª×¤×•×§×” ×©×œ ×”×§×©×¨ ×-A ×œ-B( ×‘ -sec / Bytes )×‘×–××Ÿ ×”× "×œ? × ××§×™.
]S*MSS / [lg (S) * RTT*2 ×‘×¢×¨×š .1
]S*MSS / [S^0.5 * RTT*2 ×‘×¢×¨×š .2
S*MSS / RTT ×‘×¢×¨×š .3
S^2)*MSS / RTT( ×‘×¢×¨×š .4
â— ×©×ª×™ ×ª×—× ×•×ª ××ª×§×©×¨×•×ª ×‘××•×¤×Ÿ ××œ×—×•×˜×™ ×‘×©×™×˜×ª N Back Go.
× ×¡××Ÿ ×‘-X ××ª ×¡×¤×¨×ª ×”×‘×™×§×•×¨×ª ×©×œ ×”×ª.×–. ×©×œ×š. ×× ×©× ×™ ×©×•×ª×¤×™× ××’×™×©×™× ××ª ×”×ª×¨×’×™×œ ×™×—×“, X ×”×•× ×¡×¤×¨×ª
×”×‘×™×§×•×¨×ª ×‘×¢×œ×ª ×”×¢×¨×š ×”× ××•×š ×™×•×ª×¨ ××‘×™×Ÿ ×”×©×ª×™×™×.
×§×¦×‘ ×”×ª×§×©×•×¨×ª ×”×•× 8Gbps, ×•×’×•×“×œ ×›×œ ×—×‘×™×œ×” ×”×•× KByte*X. ×’×“×œ×™ ×”-headers ×•×” -Acks ×–× ×™×—×™×.
ï¿½ğ‘’ğ‘ ï¿½/ï¿½ï¿½ 8 , ×•×”××¨×—×§ ×‘×™×Ÿ ×”×ª×—× ×•×ª ×”×•× 1Km. ×§×¦×‘ ×”×”×ª×¤×©×˜×•×ª ×”×•× 10 â‹… 2
×–××Ÿ ×¢×™×‘×•×“ ×”× ×ª×•× ×™× ×‘×ª×—× ×•×ª ×–× ×™×—.
××£ ×—×‘×™×œ×” ×•××£ Ack ×œ× ×”×•×œ×›×™× ×œ××™×‘×•×“.
â— ××”×• X ×©×œ×š?
â— ××” ×¦×¨×™×š ×œ×”×™×•×ª ×’×•×“×œ ×—×œ×•×Ÿ ×”××©×œ×•×— ×›×“×™ ×œ×”×‘×˜×™×— ×ª×¤×•×§×” ××§×¡×™××œ×™×ª?
 Communication Networks Course
Page | 9
Bonus â€“ Improving the Reliable UDP â€“ 15 points
Note: This part isnâ€™t mandatory and is a bonus only!
In this part, youâ€™ll improve your RUDP implementation by adding the concepts of flow
control and congestion control from TCP. Youâ€™re free to choose which algorithms to
implement, as long as you explain in your PDF which algorithms youâ€™ve used. Youâ€™ll probably
need to make changes in the original design of the RUDP. Changes only need to be to the API
itself, ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„.
Points distribution:
â€¢ Flow control improvement â€“ 7 Points
â€¢ Congestion control improvement â€“ 8 points.
Guidance:
â€¢ For flow control, you must use one of the Sliding window techniques: stop-and-wait
ARQ, Go-Back-N or Selective repeat.
â€¢ List of known TCP congestion control algorithms, which you can use any one of them
for this bonus task, or makeup your own:
Figure 2 â€“ List of known TCP congestion control algorithms, Wikipedia
 Communication Networks Course
Page | 10
Appendix A â€“ Linux local packet loss tool
To simulate a packet loss in a local network, we'll use a Linux tool that's called Linux Traffic
Control (ğ‘¡ğ‘). This requires a full Linux installation, so working with WSL won't work.
If the tool isn't installed in your machine, you can install it by using the following commands:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’
If the installation didn't work, you can use the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’2
To create a packet loss scenario, type the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘ğ‘‘ğ‘‘ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
After creating a packet loss scenario, you can change the percentage by typing the following
command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘â„ğ‘ğ‘›ğ‘”ğ‘’ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
To remove the packet loss scenario, write the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘‘ğ‘’ğ‘™ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š
 Communication Networks Course
Page | 11
Appendix B â€“ ğ’ğ’‚ğ’(ğŸ) system calls
This appendixâ€™s purpose is to give you a better understanding of socket handling in C.
A recommended reference is Beejâ€™s Guide to Network Programming, by Brian â€œBeej
Jorgensenâ€ Hall, which gives a lot of information about sockets in C and functions.
Functions and documentation links:
â€¢ ğ’”ğ’ğ’„ğ’Œğ’†ğ’•(ğŸ) â€“ A Factory method system call that creates a socket with the given
parameters.
â€¢ ğ’ƒğ’Šğ’ğ’…(ğŸ) â€“ Whenever we create a new socket, we need to bind it to a specific port in
our machine, â€œto catch a portâ€. The port number is managed and used by the kernel
to link incoming packets to the corresponding application socket. The port numbers
are usually fixed. The ğ‘ğ‘‘ğ‘‘ğ‘Ÿ parameter must match the current socket that is used.
â€¢ ğ’ğ’Šğ’”ğ’•ğ’†ğ’(ğŸ) â€“ The ğ‘™ğ‘–ğ‘ ğ‘¡ğ‘’ğ‘›(2) system call doesn't do anything in the mean of
communication but only memory allocation (malloc) for stream sockets only. If we
won't allocate memory, any incoming connection will fail.
â€¢ ğ’„ğ’ğ’ğ’ğ’†ğ’„ğ’•(ğŸ) â€“ The ğ‘ğ‘œğ‘›ğ‘›ğ‘’ğ‘ğ‘¡(2) system call starts the link between a client and a
specific IP address and port number. The connection would complete when the
other side will call the ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call.
â€¢ ğ’‚ğ’„ğ’„ğ’†ğ’‘ğ’•(ğŸ) â€“ The ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call accepts the incoming stream connection
request from the other side, by the listening socket. This system call completes the
three-way handshake of stream socket (like TCP) and opens a new socket that has a
direct communication channel only with the other party in the handshake.
â€¢ ğ’”ğ’†ğ’ğ’…(ğŸ) and ğ’”ğ’†ğ’ğ’…ğ’•ğ’(ğŸ) â€“ The ğ‘ ğ‘’ğ‘›ğ‘‘(2) and ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system calls are an analogy
for the ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’(2) system call, specifcly for sockets, with flags set to 0. Those system
calls return the number of bytes that were sent through the socket itself, as the
number of bytes can vary. The ğ‘ ğ‘’ğ‘›ğ‘‘(2)system call designed for stream sockets (like
TCP), while the ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system call designed for datagram connection-less
sockets (like UDP). When the ğ‘ ğ‘’ğ‘›ğ‘‘(2) system call returns 0, it means that the other
party closed the connection.
â€¢ ğ’“ğ’†ğ’„ğ’—(ğŸ) and ğ’“ğ’†ğ’„ğ’—ğ’‡ğ’“ğ’ğ’(ğŸ) â€“ The ğ‘Ÿğ‘’ğ‘ğ‘£(2) and ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system calls are an
analogy for the ğ‘Ÿğ‘’ğ‘ğ‘‘(2) system call, specifically for sockets, with flags set to 0.
Those system calls return the number of bytes that were received through the socket
itself, as the number of bytes can vary. The ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call designed for stream
sockets (like TCP), while the ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system call designed for datagram
connection-less sockets (like UDP). When the ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call returns 0, it means
that the other party closed the connection.
â€¢ ğ’„ğ’ğ’ğ’”ğ’†(ğŸ) and ğ’”ğ’‰ğ’–ğ’•ğ’…ğ’ğ’˜ğ’(ğŸ) â€“ The ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) and ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2) system calls close
the socket. While ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) system call closes the whole socket, the ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2)
system call partially closes the socket for read/write.
 Communication Networks Course
Page | 12
Appendix C â€“ Random data generator
The data that you are going to send in this assignment is randomly generated. You can use
your own file with appropriate size or use the following function (or a function of your own)
to generate the data:
/*
* @brief A random data generator function based on srand() and rand().
* @param size The size of the data to generate (up to 2^32 bytes).
* @return A pointer to the buffer.
*/
char *util_generate_random_data(unsigned int size) {
 char *buffer = NULL;
 // Argument check.
 if (size == 0)
 return NULL;
 buffer = (char *)calloc(size, sizeof(char));
 // Error checking.
 if (buffer == NULL)
 return NULL;
 // Randomize the seed of the random number generator.
 srand(time(NULL));
 for (unsigned int i = 0; i < size; i++)
 *(buffer + i) = ((unsigned int)rand() % 256);
 return buffer;
}
 Communication Networks Course
Page | 13
Appendix D â€“ Checksum function
A checksum is a small-sized block of data derived from another block of digital data for the
purpose of detecting errors that may have been introduced during its transmission or
storage. By themselves, checksums are often used to verify data integrity but are not relied
upon to verify data authenticity.
Below is a simple yet efficient implementation of the checksum function, you can use it for
the assignment, but you can implement your own checksum function.
/*
* @brief A checksum function that returns 16 bit checksum for data.
* @param data The data to do the checksum for.
* @param bytes The length of the data in bytes.
* @return The checksum itself as 16 bit unsigned number.
* @note This function is taken from RFC1071, can be found here:
* @note https://tools.ietf.org/html/rfc1071
* @note It is the simplest way to calculate a checksum and is not very strong.
* However, it is good enough for this assignment.
* @note You are free to use any other checksum function as well.
* You can also use this function as such without any change.
*/
unsigned short int calculate_checksum(void *data, unsigned int bytes) {
 unsigned short int *data_pointer = (unsigned short int *)data;
 unsigned int total_sum = 0;
 // Main summing loop
 while (bytes > 1) {
 total_sum += *data_pointer++;
 bytes -= 2;
 }
 // Add left-over byte, if any
 if (bytes > 0)
 total_sum += *((unsigned char *)data_pointer);
 // Fold 32-bit sum to 16 bits
 while (total_sum >> 16)
 total_sum = (total_sum & 0xFFFF) + (total_sum >> 16);
 return (~((unsigned short int)total_sum));
} Communication Networks Course
Page | 1
Assignment 3 â€“ Transport Layer
Assignment Notes and Instructions
This assignment is to be done in pairs only. You must upload all the necessary files in a ZIP
file named after both of the studentâ€™s ID. For example: ğŸğŸğŸ‘ğŸ’ğŸ“ğŸ”ğŸ•ğŸ–ğŸ—_ğŸ—ğŸ–ğŸ•ğŸ”ğŸ“ğŸ’ğŸ‘ğŸğŸ. ğ’›ğ’Šğ’‘.
1) The assignment must be submitted by the date specified in the submission box.
2) All the assignment files (Code, Wireshark pcap files, PDF) must be submitted in a ZIP file. The
PDF must contain all the necessary screenshots with a description for each one of them.
3) The assignment must be done in pairs only. In exceptional cases, you should send an email to
the course coordinator.
4) You can use any reference material available through the course Moodle website or any
material passed during the exercises.
5) You can use any reference from the web, but copying codes from websites is forbidden; this
includes codes from other GitHub repositories. A student who gets caught in the act will
automatically fail this assignment (score 0). Any website youâ€™ve used to solve the
assignment, every website you used to solve the assignment must be noted in the PDF.
6) No delays in submission without special permission. Lateness without approval will result in
failure of the assignment (score 0).
7) All submissions will be submitted via the course's Moodle website. Email submissions will not
be accepted, resulting in a failure in the assignment.
8) The order and design of the code must be carefully considered. Make sure that the program
output is as clear as possible, comments in the code, and meaningful variable names. You
must also submit a makefile that compiles all the programs.
9) The assignment code must be written in C only.
10) The assignment is personal for each pair, and you should not accept help from other people,
whether outside the university or inside it. You can contact the course staff during reception
hours for help or raise a question in the course forum. Do not transfer code sections
between students, upload solutions or parts of solutions to websites on the Internet or in
various communication groups.
11) Students who copy a solution will receive a 0 in all assignments in the course and a report will
be made to the institutional disciplinary committee.
12) All code files of the assignment are required to both compile and run properly on the Ubuntu
22.04 LTS operating system. This is the operating system where the submissions will be
tested. You mustnâ€™t code it in Windows, as it uses different API for sockets. WSL wonâ€™t work,
as the task needs a tool that works only in a fully Linux environment.
Good Luck!
 Communication Networks Course
Page | 2
Part A â€“ Transmission Control Protocol (TCP) â€“ 30 points
In this part, youâ€™ll write two program files: ğ‘»ğ‘ªğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and ğ‘»ğ‘ªğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
The Sender will send a randomly generated file and the Receiver will receive it and measure
the time it took for his program to receive the file. The file size should be at least 2MB.
When running the Sender and Receiver, they both should support two standard congestion
control algorithms: TCP Reno and TCP Cubic.
Notes:
â€¢ The main goal of this part is to get familiar with the TCP concept of sending
messages between two endpoints.
â€¢ For approaching this part of the assignment, please be sure that you are familiar
with the congestion control algorithms and how to change them using the correct
method in C (see Appendix B for more information).
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). You've
learned that TCP is reliable by design, so you can assume that all the data have been
passed correctly, and thus, no need to recheck.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
Usage:
â€¢ Receiver:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
â€¢ Sender:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port of the Receiver.
â€¢ ğ‘¨ğ‘³ğ‘®ğ‘¶ â€“ The TCP congestion control algorithm that will be used by the party
member (either ğ’“ğ’†ğ’ğ’ for TCP Reno or ğ’„ğ’–ğ’ƒğ’Šğ’„ for TCP Cubic).
 Communication Networks Course
Page | 3
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a TCP socket between the Sender and the
Receiver.
3) Send the file.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a TCP connection between the Receiver and
the Sender.
2) Get a connection from the sender.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./TCP_Receiver -p 1234 -algo reno
Starting Receiver...
Waiting for TCP connection...
Sender connected, beginning to receive file...
File transfer completed.
Waiting for Sender response...
Sender sent exit message.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 4
Part B â€“ Reliable User Datagram Protocol (Reliable UDP or RUDP) â€“ 40 points
Youâ€™ve learned that while TCP is reliable, it lacks speed and has an overhead data of 20 bytes,
compering to UDP that needs only 8 bytes of overhead data.
Reliable UDP or RUDP, is a protocol that uses the UDP protocol for a faster transmission of
data, while adding a reliability layer to it, but without adding too much overhead data like
TCP.
A simple sketch for a RUDP connection would look something like this:
Your task in this part is to implement a Reliable protocol using UDP only. For simplicity, your
implementation should only support a handshake, closing scheme, error checking,
acknowledgment of received packets, and retransmission of lost packets.
Guidance:
â€¢ You can use ğ‘ ğ‘’ğ‘¡ğ‘ ğ‘œğ‘ğ‘˜ğ‘œğ‘ğ‘¡(2) for detecting a timeout.
â€¢ You need to build your own protocol, as Reliable UDP isnâ€™t a standard protocol (see a
draft of RUDP in this link), and no official header is provided. You can use this sketch
for a header, but you can come up with your own protocol, as long as it works.
Where:
o ğ‘³ğ’†ğ’ğ’ˆğ’•ğ’‰ is the length of the data itself, without the RUDP header.
o ğ‘ªğ’‰ğ’†ğ’„ğ’Œğ’”ğ’–ğ’ is a 16bit number that validates the correctness of the data.
o ğ‘­ğ’ğ’‚ğ’ˆğ’” is a special byte where we classify the packet itself (SYN, ACK, etc.).
â€¢ In your PDF, you must explain how your implementation of RUDP works â€“ How does
it detect a timeout to do retransmissions, how does the handshake work, what is the
header overhead, etc.
â€¢ For this part, youâ€™ll write three files: ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¨ğ‘·ğ‘°. ğ’„, ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and
ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
Reliable UDP Header proposed sketch
Byte 0 Byte 1 Byte 2 Byte 3
Length (2 Bytes) Checksum (2 Bytes)
Flags (1 Byte)
Figure 1 - RUDP Protocol Architecture, Geeksforgeeks
 Communication Networks Course
Page | 5
Notes:
â€¢ The Sender will send a random generated file and the Receiver will receive it and
measure the time it took for his program to receive the file. The file size should be at
least 2MB.
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). But, as the
RUDP is based on UDP, itâ€™s not reliable. You must use some form of error checking
(like checksum) to ensure that the packet wasnâ€™t alerted during the transfer.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
â€¢ The RUDP needs support only 1 sender and 1 receiver, for simplicity purposes.
Usage:
â€¢ Receiver:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
â€¢ Sender:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port that both the Sender and the Receiver will use.
The ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„ file will contain all the implementations of the RUDP API functions (That is, to
prevent reusing the same chuck of code both in the Sender and the Receiver.).
The API should support at the bare minimum the following functions (you decide what
parameters to implement, and what are the names of the functions, as long as the API is
explained in the PDF):
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘œğ‘ğ‘˜ğ‘’ğ‘¡() â€“ Creating a RUDP socket and creating a handshake between two
peers.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘’ğ‘›ğ‘‘() â€“ Sending data to the peer. The function should wait for an
acknowledgment packet, and if it didnâ€™t receive any, retransmits the data.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘Ÿğ‘’ğ‘ğ‘£() â€“ Receive data from a peer.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ğ‘™ğ‘œğ‘ ğ‘’() â€“ Closes a connection between peers.
 Communication Networks Course
Page | 6
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a UDP socket between the Sender and the
Receiver.
3) Send the file via the RUDP protocol.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a UDP connection between the Receiver and
the Sender.
2) Get a connection from the sender, by the custom
RUDP protocol youâ€™ve built.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./RUDP_Receiver -p 1234
Starting Receiver...
Waiting for RUDP connection...
Connection request received, sending ACK.
Sender connected, beginning to receive file...
File transfer completed.
ACK sent.
Waiting for Sender response...
Sender sent exit message.
ACK sent.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 7
Part C â€“ Research â€“ 30 points
In this part, youâ€™ll conduct research about your implementations of part A and part B.
In the research itself, each one of the versions (TCP version and UDP version) will be run at
least 5 times (meaning that the file transfer will occur at least 5 times) by the following
conditions:
â€¢ For TCP, youâ€™ll run it in TCP Reno and TCP Cubic, alternating each time, for each
scenario, meaning that you run 5 times with TCP Reno in both Sender and Receiver,
and 5 times with TCP Cubic in both Sender and Receiver.
Bonus (5 points): Create a very large data set â€“ 5 times with TCP Reno in both Sender
and Receiver, 5 times with TCP Reno in Sender and TCP Cubic in Receiver, 5 times
with TCP Cubic in Sender and TCP Reno in Receiver, and 5 times with TCP Cubic in
both Sender and Receiver. This will give you a data set large enough, which allows
you to work with, compare with and to reach a definite conclusion.
â€¢ For RUDP, you will run it 5 times for each scenario.
â€¢ For both TCP and RUDP, you will run them on those scenarios of packet loss:
o 0% packet loss â€“ Control group, simulating perfect connection.
o 2% packet loss â€“ Simulating unstable connection that commonly occur.
o 5% packet loss â€“ Simulating bad connection.
o 10% packet loss â€“ Simulating extremely poor connection.
For each scenario, you must provide a filtered PCAP file and relevant screenshots that
explain each one of the steps in the process. (10 points)
After youâ€™ve gathered the data set for both TCP and Reliable UDP, answer the following
questions:
1) In TCP, which congestion control algorithm gave better results overall? TCP Reno or
TCP Cubic? Which one gave better results on high packet loss? Explain how you came
to this conclusion based on the data set youâ€™ve gathered. (5 points)
2) How did your implementation of Reliable UDP perform overall compared to regular
TCP? Which one is better for high packet loss? (5 points)
3) According to the data youâ€™ve gathered, in which scenarios and applications would we
prefer to use TCP and in which situations would we prefer to use reliable UDP?
Explain your answer. (5 points)
 Communication Networks Course
Page | 8
×¢× ×• ×¢×œ ×”×©××œ×•×ª ×”×‘××•×ª )5 × ×§×•×“×•×ª(:
â— ×‘"×¨×©×ª ×××™× ×”" ×”×›×•×•× ×” ×”×™× ×œ×¨×©×ª ×©×‘×” ××¢×˜ ×××•×“ ×—×‘×™×œ×•×ª ×”×•×œ×›×•×ª ×œ××™×‘×•×“. ×‘"×§×©×¨ ××¨×•×š" ×”×›×•×•× ×” ×”×™×
×œ×§×©×¨ TCP ×©×™×© ×‘×• ×”×¨×‘×” ×××•×“ ××™×“×¢ ×œ×©×œ×•×—. ××•×¦×¢ ×œ×”×’×“×™×œ ×‘ -TCP ××ª SSThreshold ×‘×ª×—×™×œ×ª ×”×§×©×¨.
×‘××™×–×” ××”××§×¨×™× ×”×‘××™× ×”×©×™× ×•×™ ×”×–×” ×¢×©×•×™ ×œ×”×•×¢×™×œ ×‘××™×“×” ×”××™×¨×‘×™×ª? × ××§.
.1 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
.2 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.3 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.4 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.5 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.6 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.7 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.8 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
â— A ×©×•×œ×— ×œ -B ×—×‘×™×œ×•×ª ××™×“×¢ ×‘×××¦×¢×•×ª ×§×©×¨ TCP. × ×ª×•×Ÿ ×›×™ ×”×§×©×¨ ××ª×—×™×œ ×¢× ×—×œ×•×Ÿ ×‘×’×•×“×œ 1MSS. ×”×§×©×¨
××¡×ª×™×™× ×‘×¤×¢× ×”×¨××©×•× ×” ×©×”×•× ××’×™×¢ ×œ -SSthresh. ×‘××”×œ×š ×”×§×©×¨ ×œ× ××•×‘×“×•×ª ×—×‘×™×œ×•×ª. × ×¡××Ÿ ×‘×§×™×¦×•×¨:
.SSthresh=S*MSS
× ×ª×•×Ÿ ×›×™ ×œ××•×¨×š ×›×œ ×”×§×©×¨ rwnd < MSS*S.
××”×™ ×”×ª×¤×•×§×” ×©×œ ×”×§×©×¨ ×-A ×œ-B( ×‘ -sec / Bytes )×‘×–××Ÿ ×”× "×œ? × ××§×™.
]S*MSS / [lg (S) * RTT*2 ×‘×¢×¨×š .1
]S*MSS / [S^0.5 * RTT*2 ×‘×¢×¨×š .2
S*MSS / RTT ×‘×¢×¨×š .3
S^2)*MSS / RTT( ×‘×¢×¨×š .4
â— ×©×ª×™ ×ª×—× ×•×ª ××ª×§×©×¨×•×ª ×‘××•×¤×Ÿ ××œ×—×•×˜×™ ×‘×©×™×˜×ª N Back Go.
× ×¡××Ÿ ×‘-X ××ª ×¡×¤×¨×ª ×”×‘×™×§×•×¨×ª ×©×œ ×”×ª.×–. ×©×œ×š. ×× ×©× ×™ ×©×•×ª×¤×™× ××’×™×©×™× ××ª ×”×ª×¨×’×™×œ ×™×—×“, X ×”×•× ×¡×¤×¨×ª
×”×‘×™×§×•×¨×ª ×‘×¢×œ×ª ×”×¢×¨×š ×”× ××•×š ×™×•×ª×¨ ××‘×™×Ÿ ×”×©×ª×™×™×.
×§×¦×‘ ×”×ª×§×©×•×¨×ª ×”×•× 8Gbps, ×•×’×•×“×œ ×›×œ ×—×‘×™×œ×” ×”×•× KByte*X. ×’×“×œ×™ ×”-headers ×•×” -Acks ×–× ×™×—×™×.
ï¿½ğ‘’ğ‘ ï¿½/ï¿½ï¿½ 8 , ×•×”××¨×—×§ ×‘×™×Ÿ ×”×ª×—× ×•×ª ×”×•× 1Km. ×§×¦×‘ ×”×”×ª×¤×©×˜×•×ª ×”×•× 10 â‹… 2
×–××Ÿ ×¢×™×‘×•×“ ×”× ×ª×•× ×™× ×‘×ª×—× ×•×ª ×–× ×™×—.
××£ ×—×‘×™×œ×” ×•××£ Ack ×œ× ×”×•×œ×›×™× ×œ××™×‘×•×“.
â— ××”×• X ×©×œ×š?
â— ××” ×¦×¨×™×š ×œ×”×™×•×ª ×’×•×“×œ ×—×œ×•×Ÿ ×”××©×œ×•×— ×›×“×™ ×œ×”×‘×˜×™×— ×ª×¤×•×§×” ××§×¡×™××œ×™×ª?
 Communication Networks Course
Page | 9
Bonus â€“ Improving the Reliable UDP â€“ 15 points
Note: This part isnâ€™t mandatory and is a bonus only!
In this part, youâ€™ll improve your RUDP implementation by adding the concepts of flow
control and congestion control from TCP. Youâ€™re free to choose which algorithms to
implement, as long as you explain in your PDF which algorithms youâ€™ve used. Youâ€™ll probably
need to make changes in the original design of the RUDP. Changes only need to be to the API
itself, ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„.
Points distribution:
â€¢ Flow control improvement â€“ 7 Points
â€¢ Congestion control improvement â€“ 8 points.
Guidance:
â€¢ For flow control, you must use one of the Sliding window techniques: stop-and-wait
ARQ, Go-Back-N or Selective repeat.
â€¢ List of known TCP congestion control algorithms, which you can use any one of them
for this bonus task, or makeup your own:
Figure 2 â€“ List of known TCP congestion control algorithms, Wikipedia
 Communication Networks Course
Page | 10
Appendix A â€“ Linux local packet loss tool
To simulate a packet loss in a local network, we'll use a Linux tool that's called Linux Traffic
Control (ğ‘¡ğ‘). This requires a full Linux installation, so working with WSL won't work.
If the tool isn't installed in your machine, you can install it by using the following commands:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’
If the installation didn't work, you can use the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’2
To create a packet loss scenario, type the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘ğ‘‘ğ‘‘ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
After creating a packet loss scenario, you can change the percentage by typing the following
command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘â„ğ‘ğ‘›ğ‘”ğ‘’ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
To remove the packet loss scenario, write the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘‘ğ‘’ğ‘™ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š
 Communication Networks Course
Page | 11
Appendix B â€“ ğ’ğ’‚ğ’(ğŸ) system calls
This appendixâ€™s purpose is to give you a better understanding of socket handling in C.
A recommended reference is Beejâ€™s Guide to Network Programming, by Brian â€œBeej
Jorgensenâ€ Hall, which gives a lot of information about sockets in C and functions.
Functions and documentation links:
â€¢ ğ’”ğ’ğ’„ğ’Œğ’†ğ’•(ğŸ) â€“ A Factory method system call that creates a socket with the given
parameters.
â€¢ ğ’ƒğ’Šğ’ğ’…(ğŸ) â€“ Whenever we create a new socket, we need to bind it to a specific port in
our machine, â€œto catch a portâ€. The port number is managed and used by the kernel
to link incoming packets to the corresponding application socket. The port numbers
are usually fixed. The ğ‘ğ‘‘ğ‘‘ğ‘Ÿ parameter must match the current socket that is used.
â€¢ ğ’ğ’Šğ’”ğ’•ğ’†ğ’(ğŸ) â€“ The ğ‘™ğ‘–ğ‘ ğ‘¡ğ‘’ğ‘›(2) system call doesn't do anything in the mean of
communication but only memory allocation (malloc) for stream sockets only. If we
won't allocate memory, any incoming connection will fail.
â€¢ ğ’„ğ’ğ’ğ’ğ’†ğ’„ğ’•(ğŸ) â€“ The ğ‘ğ‘œğ‘›ğ‘›ğ‘’ğ‘ğ‘¡(2) system call starts the link between a client and a
specific IP address and port number. The connection would complete when the
other side will call the ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call.
â€¢ ğ’‚ğ’„ğ’„ğ’†ğ’‘ğ’•(ğŸ) â€“ The ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call accepts the incoming stream connection
request from the other side, by the listening socket. This system call completes the
three-way handshake of stream socket (like TCP) and opens a new socket that has a
direct communication channel only with the other party in the handshake.
â€¢ ğ’”ğ’†ğ’ğ’…(ğŸ) and ğ’”ğ’†ğ’ğ’…ğ’•ğ’(ğŸ) â€“ The ğ‘ ğ‘’ğ‘›ğ‘‘(2) and ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system calls are an analogy
for the ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’(2) system call, specifcly for sockets, with flags set to 0. Those system
calls return the number of bytes that were sent through the socket itself, as the
number of bytes can vary. The ğ‘ ğ‘’ğ‘›ğ‘‘(2)system call designed for stream sockets (like
TCP), while the ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system call designed for datagram connection-less
sockets (like UDP). When the ğ‘ ğ‘’ğ‘›ğ‘‘(2) system call returns 0, it means that the other
party closed the connection.
â€¢ ğ’“ğ’†ğ’„ğ’—(ğŸ) and ğ’“ğ’†ğ’„ğ’—ğ’‡ğ’“ğ’ğ’(ğŸ) â€“ The ğ‘Ÿğ‘’ğ‘ğ‘£(2) and ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system calls are an
analogy for the ğ‘Ÿğ‘’ğ‘ğ‘‘(2) system call, specifically for sockets, with flags set to 0.
Those system calls return the number of bytes that were received through the socket
itself, as the number of bytes can vary. The ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call designed for stream
sockets (like TCP), while the ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system call designed for datagram
connection-less sockets (like UDP). When the ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call returns 0, it means
that the other party closed the connection.
â€¢ ğ’„ğ’ğ’ğ’”ğ’†(ğŸ) and ğ’”ğ’‰ğ’–ğ’•ğ’…ğ’ğ’˜ğ’(ğŸ) â€“ The ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) and ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2) system calls close
the socket. While ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) system call closes the whole socket, the ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2)
system call partially closes the socket for read/write.
 Communication Networks Course
Page | 12
Appendix C â€“ Random data generator
The data that you are going to send in this assignment is randomly generated. You can use
your own file with appropriate size or use the following function (or a function of your own)
to generate the data:
/*
* @brief A random data generator function based on srand() and rand().
* @param size The size of the data to generate (up to 2^32 bytes).
* @return A pointer to the buffer.
*/
char *util_generate_random_data(unsigned int size) {
 char *buffer = NULL;
 // Argument check.
 if (size == 0)
 return NULL;
 buffer = (char *)calloc(size, sizeof(char));
 // Error checking.
 if (buffer == NULL)
 return NULL;
 // Randomize the seed of the random number generator.
 srand(time(NULL));
 for (unsigned int i = 0; i < size; i++)
 *(buffer + i) = ((unsigned int)rand() % 256);
 return buffer;
}
 Communication Networks Course
Page | 13
Appendix D â€“ Checksum function
A checksum is a small-sized block of data derived from another block of digital data for the
purpose of detecting errors that may have been introduced during its transmission or
storage. By themselves, checksums are often used to verify data integrity but are not relied
upon to verify data authenticity.
Below is a simple yet efficient implementation of the checksum function, you can use it for
the assignment, but you can implement your own checksum function.
/*
* @brief A checksum function that returns 16 bit checksum for data.
* @param data The data to do the checksum for.
* @param bytes The length of the data in bytes.
* @return The checksum itself as 16 bit unsigned number.
* @note This function is taken from RFC1071, can be found here:
* @note https://tools.ietf.org/html/rfc1071
* @note It is the simplest way to calculate a checksum and is not very strong.
* However, it is good enough for this assignment.
* @note You are free to use any other checksum function as well.
* You can also use this function as such without any change.
*/
unsigned short int calculate_checksum(void *data, unsigned int bytes) {
 unsigned short int *data_pointer = (unsigned short int *)data;
 unsigned int total_sum = 0;
 // Main summing loop
 while (bytes > 1) {
 total_sum += *data_pointer++;
 bytes -= 2;
 }
 // Add left-over byte, if any
 if (bytes > 0)
 total_sum += *((unsigned char *)data_pointer);
 // Fold 32-bit sum to 16 bits
 while (total_sum >> 16)
 total_sum = (total_sum & 0xFFFF) + (total_sum >> 16);
 return (~((unsigned short int)total_sum));
} Communication Networks Course
Page | 1
Assignment 3 â€“ Transport Layer
Assignment Notes and Instructions
This assignment is to be done in pairs only. You must upload all the necessary files in a ZIP
file named after both of the studentâ€™s ID. For example: ğŸğŸğŸ‘ğŸ’ğŸ“ğŸ”ğŸ•ğŸ–ğŸ—_ğŸ—ğŸ–ğŸ•ğŸ”ğŸ“ğŸ’ğŸ‘ğŸğŸ. ğ’›ğ’Šğ’‘.
1) The assignment must be submitted by the date specified in the submission box.
2) All the assignment files (Code, Wireshark pcap files, PDF) must be submitted in a ZIP file. The
PDF must contain all the necessary screenshots with a description for each one of them.
3) The assignment must be done in pairs only. In exceptional cases, you should send an email to
the course coordinator.
4) You can use any reference material available through the course Moodle website or any
material passed during the exercises.
5) You can use any reference from the web, but copying codes from websites is forbidden; this
includes codes from other GitHub repositories. A student who gets caught in the act will
automatically fail this assignment (score 0). Any website youâ€™ve used to solve the
assignment, every website you used to solve the assignment must be noted in the PDF.
6) No delays in submission without special permission. Lateness without approval will result in
failure of the assignment (score 0).
7) All submissions will be submitted via the course's Moodle website. Email submissions will not
be accepted, resulting in a failure in the assignment.
8) The order and design of the code must be carefully considered. Make sure that the program
output is as clear as possible, comments in the code, and meaningful variable names. You
must also submit a makefile that compiles all the programs.
9) The assignment code must be written in C only.
10) The assignment is personal for each pair, and you should not accept help from other people,
whether outside the university or inside it. You can contact the course staff during reception
hours for help or raise a question in the course forum. Do not transfer code sections
between students, upload solutions or parts of solutions to websites on the Internet or in
various communication groups.
11) Students who copy a solution will receive a 0 in all assignments in the course and a report will
be made to the institutional disciplinary committee.
12) All code files of the assignment are required to both compile and run properly on the Ubuntu
22.04 LTS operating system. This is the operating system where the submissions will be
tested. You mustnâ€™t code it in Windows, as it uses different API for sockets. WSL wonâ€™t work,
as the task needs a tool that works only in a fully Linux environment.
Good Luck!
 Communication Networks Course
Page | 2
Part A â€“ Transmission Control Protocol (TCP) â€“ 30 points
In this part, youâ€™ll write two program files: ğ‘»ğ‘ªğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and ğ‘»ğ‘ªğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
The Sender will send a randomly generated file and the Receiver will receive it and measure
the time it took for his program to receive the file. The file size should be at least 2MB.
When running the Sender and Receiver, they both should support two standard congestion
control algorithms: TCP Reno and TCP Cubic.
Notes:
â€¢ The main goal of this part is to get familiar with the TCP concept of sending
messages between two endpoints.
â€¢ For approaching this part of the assignment, please be sure that you are familiar
with the congestion control algorithms and how to change them using the correct
method in C (see Appendix B for more information).
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). You've
learned that TCP is reliable by design, so you can assume that all the data have been
passed correctly, and thus, no need to recheck.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
Usage:
â€¢ Receiver:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
â€¢ Sender:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port of the Receiver.
â€¢ ğ‘¨ğ‘³ğ‘®ğ‘¶ â€“ The TCP congestion control algorithm that will be used by the party
member (either ğ’“ğ’†ğ’ğ’ for TCP Reno or ğ’„ğ’–ğ’ƒğ’Šğ’„ for TCP Cubic).
 Communication Networks Course
Page | 3
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a TCP socket between the Sender and the
Receiver.
3) Send the file.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a TCP connection between the Receiver and
the Sender.
2) Get a connection from the sender.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./TCP_Receiver -p 1234 -algo reno
Starting Receiver...
Waiting for TCP connection...
Sender connected, beginning to receive file...
File transfer completed.
Waiting for Sender response...
Sender sent exit message.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 4
Part B â€“ Reliable User Datagram Protocol (Reliable UDP or RUDP) â€“ 40 points
Youâ€™ve learned that while TCP is reliable, it lacks speed and has an overhead data of 20 bytes,
compering to UDP that needs only 8 bytes of overhead data.
Reliable UDP or RUDP, is a protocol that uses the UDP protocol for a faster transmission of
data, while adding a reliability layer to it, but without adding too much overhead data like
TCP.
A simple sketch for a RUDP connection would look something like this:
Your task in this part is to implement a Reliable protocol using UDP only. For simplicity, your
implementation should only support a handshake, closing scheme, error checking,
acknowledgment of received packets, and retransmission of lost packets.
Guidance:
â€¢ You can use ğ‘ ğ‘’ğ‘¡ğ‘ ğ‘œğ‘ğ‘˜ğ‘œğ‘ğ‘¡(2) for detecting a timeout.
â€¢ You need to build your own protocol, as Reliable UDP isnâ€™t a standard protocol (see a
draft of RUDP in this link), and no official header is provided. You can use this sketch
for a header, but you can come up with your own protocol, as long as it works.
Where:
o ğ‘³ğ’†ğ’ğ’ˆğ’•ğ’‰ is the length of the data itself, without the RUDP header.
o ğ‘ªğ’‰ğ’†ğ’„ğ’Œğ’”ğ’–ğ’ is a 16bit number that validates the correctness of the data.
o ğ‘­ğ’ğ’‚ğ’ˆğ’” is a special byte where we classify the packet itself (SYN, ACK, etc.).
â€¢ In your PDF, you must explain how your implementation of RUDP works â€“ How does
it detect a timeout to do retransmissions, how does the handshake work, what is the
header overhead, etc.
â€¢ For this part, youâ€™ll write three files: ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¨ğ‘·ğ‘°. ğ’„, ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and
ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
Reliable UDP Header proposed sketch
Byte 0 Byte 1 Byte 2 Byte 3
Length (2 Bytes) Checksum (2 Bytes)
Flags (1 Byte)
Figure 1 - RUDP Protocol Architecture, Geeksforgeeks
 Communication Networks Course
Page | 5
Notes:
â€¢ The Sender will send a random generated file and the Receiver will receive it and
measure the time it took for his program to receive the file. The file size should be at
least 2MB.
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). But, as the
RUDP is based on UDP, itâ€™s not reliable. You must use some form of error checking
(like checksum) to ensure that the packet wasnâ€™t alerted during the transfer.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
â€¢ The RUDP needs support only 1 sender and 1 receiver, for simplicity purposes.
Usage:
â€¢ Receiver:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
â€¢ Sender:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port that both the Sender and the Receiver will use.
The ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„ file will contain all the implementations of the RUDP API functions (That is, to
prevent reusing the same chuck of code both in the Sender and the Receiver.).
The API should support at the bare minimum the following functions (you decide what
parameters to implement, and what are the names of the functions, as long as the API is
explained in the PDF):
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘œğ‘ğ‘˜ğ‘’ğ‘¡() â€“ Creating a RUDP socket and creating a handshake between two
peers.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘’ğ‘›ğ‘‘() â€“ Sending data to the peer. The function should wait for an
acknowledgment packet, and if it didnâ€™t receive any, retransmits the data.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘Ÿğ‘’ğ‘ğ‘£() â€“ Receive data from a peer.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ğ‘™ğ‘œğ‘ ğ‘’() â€“ Closes a connection between peers.
 Communication Networks Course
Page | 6
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a UDP socket between the Sender and the
Receiver.
3) Send the file via the RUDP protocol.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a UDP connection between the Receiver and
the Sender.
2) Get a connection from the sender, by the custom
RUDP protocol youâ€™ve built.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./RUDP_Receiver -p 1234
Starting Receiver...
Waiting for RUDP connection...
Connection request received, sending ACK.
Sender connected, beginning to receive file...
File transfer completed.
ACK sent.
Waiting for Sender response...
Sender sent exit message.
ACK sent.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 7
Part C â€“ Research â€“ 30 points
In this part, youâ€™ll conduct research about your implementations of part A and part B.
In the research itself, each one of the versions (TCP version and UDP version) will be run at
least 5 times (meaning that the file transfer will occur at least 5 times) by the following
conditions:
â€¢ For TCP, youâ€™ll run it in TCP Reno and TCP Cubic, alternating each time, for each
scenario, meaning that you run 5 times with TCP Reno in both Sender and Receiver,
and 5 times with TCP Cubic in both Sender and Receiver.
Bonus (5 points): Create a very large data set â€“ 5 times with TCP Reno in both Sender
and Receiver, 5 times with TCP Reno in Sender and TCP Cubic in Receiver, 5 times
with TCP Cubic in Sender and TCP Reno in Receiver, and 5 times with TCP Cubic in
both Sender and Receiver. This will give you a data set large enough, which allows
you to work with, compare with and to reach a definite conclusion.
â€¢ For RUDP, you will run it 5 times for each scenario.
â€¢ For both TCP and RUDP, you will run them on those scenarios of packet loss:
o 0% packet loss â€“ Control group, simulating perfect connection.
o 2% packet loss â€“ Simulating unstable connection that commonly occur.
o 5% packet loss â€“ Simulating bad connection.
o 10% packet loss â€“ Simulating extremely poor connection.
For each scenario, you must provide a filtered PCAP file and relevant screenshots that
explain each one of the steps in the process. (10 points)
After youâ€™ve gathered the data set for both TCP and Reliable UDP, answer the following
questions:
1) In TCP, which congestion control algorithm gave better results overall? TCP Reno or
TCP Cubic? Which one gave better results on high packet loss? Explain how you came
to this conclusion based on the data set youâ€™ve gathered. (5 points)
2) How did your implementation of Reliable UDP perform overall compared to regular
TCP? Which one is better for high packet loss? (5 points)
3) According to the data youâ€™ve gathered, in which scenarios and applications would we
prefer to use TCP and in which situations would we prefer to use reliable UDP?
Explain your answer. (5 points)
 Communication Networks Course
Page | 8
×¢× ×• ×¢×œ ×”×©××œ×•×ª ×”×‘××•×ª )5 × ×§×•×“×•×ª(:
â— ×‘"×¨×©×ª ×××™× ×”" ×”×›×•×•× ×” ×”×™× ×œ×¨×©×ª ×©×‘×” ××¢×˜ ×××•×“ ×—×‘×™×œ×•×ª ×”×•×œ×›×•×ª ×œ××™×‘×•×“. ×‘"×§×©×¨ ××¨×•×š" ×”×›×•×•× ×” ×”×™×
×œ×§×©×¨ TCP ×©×™×© ×‘×• ×”×¨×‘×” ×××•×“ ××™×“×¢ ×œ×©×œ×•×—. ××•×¦×¢ ×œ×”×’×“×™×œ ×‘ -TCP ××ª SSThreshold ×‘×ª×—×™×œ×ª ×”×§×©×¨.
×‘××™×–×” ××”××§×¨×™× ×”×‘××™× ×”×©×™× ×•×™ ×”×–×” ×¢×©×•×™ ×œ×”×•×¢×™×œ ×‘××™×“×” ×”××™×¨×‘×™×ª? × ××§.
.1 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
.2 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.3 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.4 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.5 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.6 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.7 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.8 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
â— A ×©×•×œ×— ×œ -B ×—×‘×™×œ×•×ª ××™×“×¢ ×‘×××¦×¢×•×ª ×§×©×¨ TCP. × ×ª×•×Ÿ ×›×™ ×”×§×©×¨ ××ª×—×™×œ ×¢× ×—×œ×•×Ÿ ×‘×’×•×“×œ 1MSS. ×”×§×©×¨
××¡×ª×™×™× ×‘×¤×¢× ×”×¨××©×•× ×” ×©×”×•× ××’×™×¢ ×œ -SSthresh. ×‘××”×œ×š ×”×§×©×¨ ×œ× ××•×‘×“×•×ª ×—×‘×™×œ×•×ª. × ×¡××Ÿ ×‘×§×™×¦×•×¨:
.SSthresh=S*MSS
× ×ª×•×Ÿ ×›×™ ×œ××•×¨×š ×›×œ ×”×§×©×¨ rwnd < MSS*S.
××”×™ ×”×ª×¤×•×§×” ×©×œ ×”×§×©×¨ ×-A ×œ-B( ×‘ -sec / Bytes )×‘×–××Ÿ ×”× "×œ? × ××§×™.
]S*MSS / [lg (S) * RTT*2 ×‘×¢×¨×š .1
]S*MSS / [S^0.5 * RTT*2 ×‘×¢×¨×š .2
S*MSS / RTT ×‘×¢×¨×š .3
S^2)*MSS / RTT( ×‘×¢×¨×š .4
â— ×©×ª×™ ×ª×—× ×•×ª ××ª×§×©×¨×•×ª ×‘××•×¤×Ÿ ××œ×—×•×˜×™ ×‘×©×™×˜×ª N Back Go.
× ×¡××Ÿ ×‘-X ××ª ×¡×¤×¨×ª ×”×‘×™×§×•×¨×ª ×©×œ ×”×ª.×–. ×©×œ×š. ×× ×©× ×™ ×©×•×ª×¤×™× ××’×™×©×™× ××ª ×”×ª×¨×’×™×œ ×™×—×“, X ×”×•× ×¡×¤×¨×ª
×”×‘×™×§×•×¨×ª ×‘×¢×œ×ª ×”×¢×¨×š ×”× ××•×š ×™×•×ª×¨ ××‘×™×Ÿ ×”×©×ª×™×™×.
×§×¦×‘ ×”×ª×§×©×•×¨×ª ×”×•× 8Gbps, ×•×’×•×“×œ ×›×œ ×—×‘×™×œ×” ×”×•× KByte*X. ×’×“×œ×™ ×”-headers ×•×” -Acks ×–× ×™×—×™×.
ï¿½ğ‘’ğ‘ ï¿½/ï¿½ï¿½ 8 , ×•×”××¨×—×§ ×‘×™×Ÿ ×”×ª×—× ×•×ª ×”×•× 1Km. ×§×¦×‘ ×”×”×ª×¤×©×˜×•×ª ×”×•× 10 â‹… 2
×–××Ÿ ×¢×™×‘×•×“ ×”× ×ª×•× ×™× ×‘×ª×—× ×•×ª ×–× ×™×—.
××£ ×—×‘×™×œ×” ×•××£ Ack ×œ× ×”×•×œ×›×™× ×œ××™×‘×•×“.
â— ××”×• X ×©×œ×š?
â— ××” ×¦×¨×™×š ×œ×”×™×•×ª ×’×•×“×œ ×—×œ×•×Ÿ ×”××©×œ×•×— ×›×“×™ ×œ×”×‘×˜×™×— ×ª×¤×•×§×” ××§×¡×™××œ×™×ª?
 Communication Networks Course
Page | 9
Bonus â€“ Improving the Reliable UDP â€“ 15 points
Note: This part isnâ€™t mandatory and is a bonus only!
In this part, youâ€™ll improve your RUDP implementation by adding the concepts of flow
control and congestion control from TCP. Youâ€™re free to choose which algorithms to
implement, as long as you explain in your PDF which algorithms youâ€™ve used. Youâ€™ll probably
need to make changes in the original design of the RUDP. Changes only need to be to the API
itself, ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„.
Points distribution:
â€¢ Flow control improvement â€“ 7 Points
â€¢ Congestion control improvement â€“ 8 points.
Guidance:
â€¢ For flow control, you must use one of the Sliding window techniques: stop-and-wait
ARQ, Go-Back-N or Selective repeat.
â€¢ List of known TCP congestion control algorithms, which you can use any one of them
for this bonus task, or makeup your own:
Figure 2 â€“ List of known TCP congestion control algorithms, Wikipedia
 Communication Networks Course
Page | 10
Appendix A â€“ Linux local packet loss tool
To simulate a packet loss in a local network, we'll use a Linux tool that's called Linux Traffic
Control (ğ‘¡ğ‘). This requires a full Linux installation, so working with WSL won't work.
If the tool isn't installed in your machine, you can install it by using the following commands:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’
If the installation didn't work, you can use the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’2
To create a packet loss scenario, type the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘ğ‘‘ğ‘‘ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
After creating a packet loss scenario, you can change the percentage by typing the following
command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘â„ğ‘ğ‘›ğ‘”ğ‘’ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
To remove the packet loss scenario, write the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘‘ğ‘’ğ‘™ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š
 Communication Networks Course
Page | 11
Appendix B â€“ ğ’ğ’‚ğ’(ğŸ) system calls
This appendixâ€™s purpose is to give you a better understanding of socket handling in C.
A recommended reference is Beejâ€™s Guide to Network Programming, by Brian â€œBeej
Jorgensenâ€ Hall, which gives a lot of information about sockets in C and functions.
Functions and documentation links:
â€¢ ğ’”ğ’ğ’„ğ’Œğ’†ğ’•(ğŸ) â€“ A Factory method system call that creates a socket with the given
parameters.
â€¢ ğ’ƒğ’Šğ’ğ’…(ğŸ) â€“ Whenever we create a new socket, we need to bind it to a specific port in
our machine, â€œto catch a portâ€. The port number is managed and used by the kernel
to link incoming packets to the corresponding application socket. The port numbers
are usually fixed. The ğ‘ğ‘‘ğ‘‘ğ‘Ÿ parameter must match the current socket that is used.
â€¢ ğ’ğ’Šğ’”ğ’•ğ’†ğ’(ğŸ) â€“ The ğ‘™ğ‘–ğ‘ ğ‘¡ğ‘’ğ‘›(2) system call doesn't do anything in the mean of
communication but only memory allocation (malloc) for stream sockets only. If we
won't allocate memory, any incoming connection will fail.
â€¢ ğ’„ğ’ğ’ğ’ğ’†ğ’„ğ’•(ğŸ) â€“ The ğ‘ğ‘œğ‘›ğ‘›ğ‘’ğ‘ğ‘¡(2) system call starts the link between a client and a
specific IP address and port number. The connection would complete when the
other side will call the ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call.
â€¢ ğ’‚ğ’„ğ’„ğ’†ğ’‘ğ’•(ğŸ) â€“ The ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call accepts the incoming stream connection
request from the other side, by the listening socket. This system call completes the
three-way handshake of stream socket (like TCP) and opens a new socket that has a
direct communication channel only with the other party in the handshake.
â€¢ ğ’”ğ’†ğ’ğ’…(ğŸ) and ğ’”ğ’†ğ’ğ’…ğ’•ğ’(ğŸ) â€“ The ğ‘ ğ‘’ğ‘›ğ‘‘(2) and ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system calls are an analogy
for the ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’(2) system call, specifcly for sockets, with flags set to 0. Those system
calls return the number of bytes that were sent through the socket itself, as the
number of bytes can vary. The ğ‘ ğ‘’ğ‘›ğ‘‘(2)system call designed for stream sockets (like
TCP), while the ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system call designed for datagram connection-less
sockets (like UDP). When the ğ‘ ğ‘’ğ‘›ğ‘‘(2) system call returns 0, it means that the other
party closed the connection.
â€¢ ğ’“ğ’†ğ’„ğ’—(ğŸ) and ğ’“ğ’†ğ’„ğ’—ğ’‡ğ’“ğ’ğ’(ğŸ) â€“ The ğ‘Ÿğ‘’ğ‘ğ‘£(2) and ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system calls are an
analogy for the ğ‘Ÿğ‘’ğ‘ğ‘‘(2) system call, specifically for sockets, with flags set to 0.
Those system calls return the number of bytes that were received through the socket
itself, as the number of bytes can vary. The ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call designed for stream
sockets (like TCP), while the ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system call designed for datagram
connection-less sockets (like UDP). When the ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call returns 0, it means
that the other party closed the connection.
â€¢ ğ’„ğ’ğ’ğ’”ğ’†(ğŸ) and ğ’”ğ’‰ğ’–ğ’•ğ’…ğ’ğ’˜ğ’(ğŸ) â€“ The ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) and ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2) system calls close
the socket. While ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) system call closes the whole socket, the ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2)
system call partially closes the socket for read/write.
 Communication Networks Course
Page | 12
Appendix C â€“ Random data generator
The data that you are going to send in this assignment is randomly generated. You can use
your own file with appropriate size or use the following function (or a function of your own)
to generate the data:
/*
* @brief A random data generator function based on srand() and rand().
* @param size The size of the data to generate (up to 2^32 bytes).
* @return A pointer to the buffer.
*/
char *util_generate_random_data(unsigned int size) {
 char *buffer = NULL;
 // Argument check.
 if (size == 0)
 return NULL;
 buffer = (char *)calloc(size, sizeof(char));
 // Error checking.
 if (buffer == NULL)
 return NULL;
 // Randomize the seed of the random number generator.
 srand(time(NULL));
 for (unsigned int i = 0; i < size; i++)
 *(buffer + i) = ((unsigned int)rand() % 256);
 return buffer;
}
 Communication Networks Course
Page | 13
Appendix D â€“ Checksum function
A checksum is a small-sized block of data derived from another block of digital data for the
purpose of detecting errors that may have been introduced during its transmission or
storage. By themselves, checksums are often used to verify data integrity but are not relied
upon to verify data authenticity.
Below is a simple yet efficient implementation of the checksum function, you can use it for
the assignment, but you can implement your own checksum function.
/*
* @brief A checksum function that returns 16 bit checksum for data.
* @param data The data to do the checksum for.
* @param bytes The length of the data in bytes.
* @return The checksum itself as 16 bit unsigned number.
* @note This function is taken from RFC1071, can be found here:
* @note https://tools.ietf.org/html/rfc1071
* @note It is the simplest way to calculate a checksum and is not very strong.
* However, it is good enough for this assignment.
* @note You are free to use any other checksum function as well.
* You can also use this function as such without any change.
*/
unsigned short int calculate_checksum(void *data, unsigned int bytes) {
 unsigned short int *data_pointer = (unsigned short int *)data;
 unsigned int total_sum = 0;
 // Main summing loop
 while (bytes > 1) {
 total_sum += *data_pointer++;
 bytes -= 2;
 }
 // Add left-over byte, if any
 if (bytes > 0)
 total_sum += *((unsigned char *)data_pointer);
 // Fold 32-bit sum to 16 bits
 while (total_sum >> 16)
 total_sum = (total_sum & 0xFFFF) + (total_sum >> 16);
 return (~((unsigned short int)total_sum));
} Communication Networks Course
Page | 1
Assignment 3 â€“ Transport Layer
Assignment Notes and Instructions
This assignment is to be done in pairs only. You must upload all the necessary files in a ZIP
file named after both of the studentâ€™s ID. For example: ğŸğŸğŸ‘ğŸ’ğŸ“ğŸ”ğŸ•ğŸ–ğŸ—_ğŸ—ğŸ–ğŸ•ğŸ”ğŸ“ğŸ’ğŸ‘ğŸğŸ. ğ’›ğ’Šğ’‘.
1) The assignment must be submitted by the date specified in the submission box.
2) All the assignment files (Code, Wireshark pcap files, PDF) must be submitted in a ZIP file. The
PDF must contain all the necessary screenshots with a description for each one of them.
3) The assignment must be done in pairs only. In exceptional cases, you should send an email to
the course coordinator.
4) You can use any reference material available through the course Moodle website or any
material passed during the exercises.
5) You can use any reference from the web, but copying codes from websites is forbidden; this
includes codes from other GitHub repositories. A student who gets caught in the act will
automatically fail this assignment (score 0). Any website youâ€™ve used to solve the
assignment, every website you used to solve the assignment must be noted in the PDF.
6) No delays in submission without special permission. Lateness without approval will result in
failure of the assignment (score 0).
7) All submissions will be submitted via the course's Moodle website. Email submissions will not
be accepted, resulting in a failure in the assignment.
8) The order and design of the code must be carefully considered. Make sure that the program
output is as clear as possible, comments in the code, and meaningful variable names. You
must also submit a makefile that compiles all the programs.
9) The assignment code must be written in C only.
10) The assignment is personal for each pair, and you should not accept help from other people,
whether outside the university or inside it. You can contact the course staff during reception
hours for help or raise a question in the course forum. Do not transfer code sections
between students, upload solutions or parts of solutions to websites on the Internet or in
various communication groups.
11) Students who copy a solution will receive a 0 in all assignments in the course and a report will
be made to the institutional disciplinary committee.
12) All code files of the assignment are required to both compile and run properly on the Ubuntu
22.04 LTS operating system. This is the operating system where the submissions will be
tested. You mustnâ€™t code it in Windows, as it uses different API for sockets. WSL wonâ€™t work,
as the task needs a tool that works only in a fully Linux environment.
Good Luck!
 Communication Networks Course
Page | 2
Part A â€“ Transmission Control Protocol (TCP) â€“ 30 points
In this part, youâ€™ll write two program files: ğ‘»ğ‘ªğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and ğ‘»ğ‘ªğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
The Sender will send a randomly generated file and the Receiver will receive it and measure
the time it took for his program to receive the file. The file size should be at least 2MB.
When running the Sender and Receiver, they both should support two standard congestion
control algorithms: TCP Reno and TCP Cubic.
Notes:
â€¢ The main goal of this part is to get familiar with the TCP concept of sending
messages between two endpoints.
â€¢ For approaching this part of the assignment, please be sure that you are familiar
with the congestion control algorithms and how to change them using the correct
method in C (see Appendix B for more information).
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). You've
learned that TCP is reliable by design, so you can assume that all the data have been
passed correctly, and thus, no need to recheck.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
Usage:
â€¢ Receiver:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
â€¢ Sender:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port of the Receiver.
â€¢ ğ‘¨ğ‘³ğ‘®ğ‘¶ â€“ The TCP congestion control algorithm that will be used by the party
member (either ğ’“ğ’†ğ’ğ’ for TCP Reno or ğ’„ğ’–ğ’ƒğ’Šğ’„ for TCP Cubic).
 Communication Networks Course
Page | 3
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a TCP socket between the Sender and the
Receiver.
3) Send the file.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a TCP connection between the Receiver and
the Sender.
2) Get a connection from the sender.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./TCP_Receiver -p 1234 -algo reno
Starting Receiver...
Waiting for TCP connection...
Sender connected, beginning to receive file...
File transfer completed.
Waiting for Sender response...
Sender sent exit message.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 4
Part B â€“ Reliable User Datagram Protocol (Reliable UDP or RUDP) â€“ 40 points
Youâ€™ve learned that while TCP is reliable, it lacks speed and has an overhead data of 20 bytes,
compering to UDP that needs only 8 bytes of overhead data.
Reliable UDP or RUDP, is a protocol that uses the UDP protocol for a faster transmission of
data, while adding a reliability layer to it, but without adding too much overhead data like
TCP.
A simple sketch for a RUDP connection would look something like this:
Your task in this part is to implement a Reliable protocol using UDP only. For simplicity, your
implementation should only support a handshake, closing scheme, error checking,
acknowledgment of received packets, and retransmission of lost packets.
Guidance:
â€¢ You can use ğ‘ ğ‘’ğ‘¡ğ‘ ğ‘œğ‘ğ‘˜ğ‘œğ‘ğ‘¡(2) for detecting a timeout.
â€¢ You need to build your own protocol, as Reliable UDP isnâ€™t a standard protocol (see a
draft of RUDP in this link), and no official header is provided. You can use this sketch
for a header, but you can come up with your own protocol, as long as it works.
Where:
o ğ‘³ğ’†ğ’ğ’ˆğ’•ğ’‰ is the length of the data itself, without the RUDP header.
o ğ‘ªğ’‰ğ’†ğ’„ğ’Œğ’”ğ’–ğ’ is a 16bit number that validates the correctness of the data.
o ğ‘­ğ’ğ’‚ğ’ˆğ’” is a special byte where we classify the packet itself (SYN, ACK, etc.).
â€¢ In your PDF, you must explain how your implementation of RUDP works â€“ How does
it detect a timeout to do retransmissions, how does the handshake work, what is the
header overhead, etc.
â€¢ For this part, youâ€™ll write three files: ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¨ğ‘·ğ‘°. ğ’„, ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and
ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
Reliable UDP Header proposed sketch
Byte 0 Byte 1 Byte 2 Byte 3
Length (2 Bytes) Checksum (2 Bytes)
Flags (1 Byte)
Figure 1 - RUDP Protocol Architecture, Geeksforgeeks
 Communication Networks Course
Page | 5
Notes:
â€¢ The Sender will send a random generated file and the Receiver will receive it and
measure the time it took for his program to receive the file. The file size should be at
least 2MB.
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). But, as the
RUDP is based on UDP, itâ€™s not reliable. You must use some form of error checking
(like checksum) to ensure that the packet wasnâ€™t alerted during the transfer.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
â€¢ The RUDP needs support only 1 sender and 1 receiver, for simplicity purposes.
Usage:
â€¢ Receiver:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
â€¢ Sender:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port that both the Sender and the Receiver will use.
The ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„ file will contain all the implementations of the RUDP API functions (That is, to
prevent reusing the same chuck of code both in the Sender and the Receiver.).
The API should support at the bare minimum the following functions (you decide what
parameters to implement, and what are the names of the functions, as long as the API is
explained in the PDF):
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘œğ‘ğ‘˜ğ‘’ğ‘¡() â€“ Creating a RUDP socket and creating a handshake between two
peers.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘’ğ‘›ğ‘‘() â€“ Sending data to the peer. The function should wait for an
acknowledgment packet, and if it didnâ€™t receive any, retransmits the data.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘Ÿğ‘’ğ‘ğ‘£() â€“ Receive data from a peer.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ğ‘™ğ‘œğ‘ ğ‘’() â€“ Closes a connection between peers.
 Communication Networks Course
Page | 6
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a UDP socket between the Sender and the
Receiver.
3) Send the file via the RUDP protocol.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a UDP connection between the Receiver and
the Sender.
2) Get a connection from the sender, by the custom
RUDP protocol youâ€™ve built.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./RUDP_Receiver -p 1234
Starting Receiver...
Waiting for RUDP connection...
Connection request received, sending ACK.
Sender connected, beginning to receive file...
File transfer completed.
ACK sent.
Waiting for Sender response...
Sender sent exit message.
ACK sent.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 7
Part C â€“ Research â€“ 30 points
In this part, youâ€™ll conduct research about your implementations of part A and part B.
In the research itself, each one of the versions (TCP version and UDP version) will be run at
least 5 times (meaning that the file transfer will occur at least 5 times) by the following
conditions:
â€¢ For TCP, youâ€™ll run it in TCP Reno and TCP Cubic, alternating each time, for each
scenario, meaning that you run 5 times with TCP Reno in both Sender and Receiver,
and 5 times with TCP Cubic in both Sender and Receiver.
Bonus (5 points): Create a very large data set â€“ 5 times with TCP Reno in both Sender
and Receiver, 5 times with TCP Reno in Sender and TCP Cubic in Receiver, 5 times
with TCP Cubic in Sender and TCP Reno in Receiver, and 5 times with TCP Cubic in
both Sender and Receiver. This will give you a data set large enough, which allows
you to work with, compare with and to reach a definite conclusion.
â€¢ For RUDP, you will run it 5 times for each scenario.
â€¢ For both TCP and RUDP, you will run them on those scenarios of packet loss:
o 0% packet loss â€“ Control group, simulating perfect connection.
o 2% packet loss â€“ Simulating unstable connection that commonly occur.
o 5% packet loss â€“ Simulating bad connection.
o 10% packet loss â€“ Simulating extremely poor connection.
For each scenario, you must provide a filtered PCAP file and relevant screenshots that
explain each one of the steps in the process. (10 points)
After youâ€™ve gathered the data set for both TCP and Reliable UDP, answer the following
questions:
1) In TCP, which congestion control algorithm gave better results overall? TCP Reno or
TCP Cubic? Which one gave better results on high packet loss? Explain how you came
to this conclusion based on the data set youâ€™ve gathered. (5 points)
2) How did your implementation of Reliable UDP perform overall compared to regular
TCP? Which one is better for high packet loss? (5 points)
3) According to the data youâ€™ve gathered, in which scenarios and applications would we
prefer to use TCP and in which situations would we prefer to use reliable UDP?
Explain your answer. (5 points)
 Communication Networks Course
Page | 8
×¢× ×• ×¢×œ ×”×©××œ×•×ª ×”×‘××•×ª )5 × ×§×•×“×•×ª(:
â— ×‘"×¨×©×ª ×××™× ×”" ×”×›×•×•× ×” ×”×™× ×œ×¨×©×ª ×©×‘×” ××¢×˜ ×××•×“ ×—×‘×™×œ×•×ª ×”×•×œ×›×•×ª ×œ××™×‘×•×“. ×‘"×§×©×¨ ××¨×•×š" ×”×›×•×•× ×” ×”×™×
×œ×§×©×¨ TCP ×©×™×© ×‘×• ×”×¨×‘×” ×××•×“ ××™×“×¢ ×œ×©×œ×•×—. ××•×¦×¢ ×œ×”×’×“×™×œ ×‘ -TCP ××ª SSThreshold ×‘×ª×—×™×œ×ª ×”×§×©×¨.
×‘××™×–×” ××”××§×¨×™× ×”×‘××™× ×”×©×™× ×•×™ ×”×–×” ×¢×©×•×™ ×œ×”×•×¢×™×œ ×‘××™×“×” ×”××™×¨×‘×™×ª? × ××§.
.1 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
.2 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.3 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.4 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.5 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.6 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.7 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.8 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
â— A ×©×•×œ×— ×œ -B ×—×‘×™×œ×•×ª ××™×“×¢ ×‘×××¦×¢×•×ª ×§×©×¨ TCP. × ×ª×•×Ÿ ×›×™ ×”×§×©×¨ ××ª×—×™×œ ×¢× ×—×œ×•×Ÿ ×‘×’×•×“×œ 1MSS. ×”×§×©×¨
××¡×ª×™×™× ×‘×¤×¢× ×”×¨××©×•× ×” ×©×”×•× ××’×™×¢ ×œ -SSthresh. ×‘××”×œ×š ×”×§×©×¨ ×œ× ××•×‘×“×•×ª ×—×‘×™×œ×•×ª. × ×¡××Ÿ ×‘×§×™×¦×•×¨:
.SSthresh=S*MSS
× ×ª×•×Ÿ ×›×™ ×œ××•×¨×š ×›×œ ×”×§×©×¨ rwnd < MSS*S.
××”×™ ×”×ª×¤×•×§×” ×©×œ ×”×§×©×¨ ×-A ×œ-B( ×‘ -sec / Bytes )×‘×–××Ÿ ×”× "×œ? × ××§×™.
]S*MSS / [lg (S) * RTT*2 ×‘×¢×¨×š .1
]S*MSS / [S^0.5 * RTT*2 ×‘×¢×¨×š .2
S*MSS / RTT ×‘×¢×¨×š .3
S^2)*MSS / RTT( ×‘×¢×¨×š .4
â— ×©×ª×™ ×ª×—× ×•×ª ××ª×§×©×¨×•×ª ×‘××•×¤×Ÿ ××œ×—×•×˜×™ ×‘×©×™×˜×ª N Back Go.
× ×¡××Ÿ ×‘-X ××ª ×¡×¤×¨×ª ×”×‘×™×§×•×¨×ª ×©×œ ×”×ª.×–. ×©×œ×š. ×× ×©× ×™ ×©×•×ª×¤×™× ××’×™×©×™× ××ª ×”×ª×¨×’×™×œ ×™×—×“, X ×”×•× ×¡×¤×¨×ª
×”×‘×™×§×•×¨×ª ×‘×¢×œ×ª ×”×¢×¨×š ×”× ××•×š ×™×•×ª×¨ ××‘×™×Ÿ ×”×©×ª×™×™×.
×§×¦×‘ ×”×ª×§×©×•×¨×ª ×”×•× 8Gbps, ×•×’×•×“×œ ×›×œ ×—×‘×™×œ×” ×”×•× KByte*X. ×’×“×œ×™ ×”-headers ×•×” -Acks ×–× ×™×—×™×.
ï¿½ğ‘’ğ‘ ï¿½/ï¿½ï¿½ 8 , ×•×”××¨×—×§ ×‘×™×Ÿ ×”×ª×—× ×•×ª ×”×•× 1Km. ×§×¦×‘ ×”×”×ª×¤×©×˜×•×ª ×”×•× 10 â‹… 2
×–××Ÿ ×¢×™×‘×•×“ ×”× ×ª×•× ×™× ×‘×ª×—× ×•×ª ×–× ×™×—.
××£ ×—×‘×™×œ×” ×•××£ Ack ×œ× ×”×•×œ×›×™× ×œ××™×‘×•×“.
â— ××”×• X ×©×œ×š?
â— ××” ×¦×¨×™×š ×œ×”×™×•×ª ×’×•×“×œ ×—×œ×•×Ÿ ×”××©×œ×•×— ×›×“×™ ×œ×”×‘×˜×™×— ×ª×¤×•×§×” ××§×¡×™××œ×™×ª?
 Communication Networks Course
Page | 9
Bonus â€“ Improving the Reliable UDP â€“ 15 points
Note: This part isnâ€™t mandatory and is a bonus only!
In this part, youâ€™ll improve your RUDP implementation by adding the concepts of flow
control and congestion control from TCP. Youâ€™re free to choose which algorithms to
implement, as long as you explain in your PDF which algorithms youâ€™ve used. Youâ€™ll probably
need to make changes in the original design of the RUDP. Changes only need to be to the API
itself, ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„.
Points distribution:
â€¢ Flow control improvement â€“ 7 Points
â€¢ Congestion control improvement â€“ 8 points.
Guidance:
â€¢ For flow control, you must use one of the Sliding window techniques: stop-and-wait
ARQ, Go-Back-N or Selective repeat.
â€¢ List of known TCP congestion control algorithms, which you can use any one of them
for this bonus task, or makeup your own:
Figure 2 â€“ List of known TCP congestion control algorithms, Wikipedia
 Communication Networks Course
Page | 10
Appendix A â€“ Linux local packet loss tool
To simulate a packet loss in a local network, we'll use a Linux tool that's called Linux Traffic
Control (ğ‘¡ğ‘). This requires a full Linux installation, so working with WSL won't work.
If the tool isn't installed in your machine, you can install it by using the following commands:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’
If the installation didn't work, you can use the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’2
To create a packet loss scenario, type the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘ğ‘‘ğ‘‘ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
After creating a packet loss scenario, you can change the percentage by typing the following
command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘â„ğ‘ğ‘›ğ‘”ğ‘’ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
To remove the packet loss scenario, write the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘‘ğ‘’ğ‘™ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š
 Communication Networks Course
Page | 11
Appendix B â€“ ğ’ğ’‚ğ’(ğŸ) system calls
This appendixâ€™s purpose is to give you a better understanding of socket handling in C.
A recommended reference is Beejâ€™s Guide to Network Programming, by Brian â€œBeej
Jorgensenâ€ Hall, which gives a lot of information about sockets in C and functions.
Functions and documentation links:
â€¢ ğ’”ğ’ğ’„ğ’Œğ’†ğ’•(ğŸ) â€“ A Factory method system call that creates a socket with the given
parameters.
â€¢ ğ’ƒğ’Šğ’ğ’…(ğŸ) â€“ Whenever we create a new socket, we need to bind it to a specific port in
our machine, â€œto catch a portâ€. The port number is managed and used by the kernel
to link incoming packets to the corresponding application socket. The port numbers
are usually fixed. The ğ‘ğ‘‘ğ‘‘ğ‘Ÿ parameter must match the current socket that is used.
â€¢ ğ’ğ’Šğ’”ğ’•ğ’†ğ’(ğŸ) â€“ The ğ‘™ğ‘–ğ‘ ğ‘¡ğ‘’ğ‘›(2) system call doesn't do anything in the mean of
communication but only memory allocation (malloc) for stream sockets only. If we
won't allocate memory, any incoming connection will fail.
â€¢ ğ’„ğ’ğ’ğ’ğ’†ğ’„ğ’•(ğŸ) â€“ The ğ‘ğ‘œğ‘›ğ‘›ğ‘’ğ‘ğ‘¡(2) system call starts the link between a client and a
specific IP address and port number. The connection would complete when the
other side will call the ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call.
â€¢ ğ’‚ğ’„ğ’„ğ’†ğ’‘ğ’•(ğŸ) â€“ The ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call accepts the incoming stream connection
request from the other side, by the listening socket. This system call completes the
three-way handshake of stream socket (like TCP) and opens a new socket that has a
direct communication channel only with the other party in the handshake.
â€¢ ğ’”ğ’†ğ’ğ’…(ğŸ) and ğ’”ğ’†ğ’ğ’…ğ’•ğ’(ğŸ) â€“ The ğ‘ ğ‘’ğ‘›ğ‘‘(2) and ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system calls are an analogy
for the ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’(2) system call, specifcly for sockets, with flags set to 0. Those system
calls return the number of bytes that were sent through the socket itself, as the
number of bytes can vary. The ğ‘ ğ‘’ğ‘›ğ‘‘(2)system call designed for stream sockets (like
TCP), while the ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system call designed for datagram connection-less
sockets (like UDP). When the ğ‘ ğ‘’ğ‘›ğ‘‘(2) system call returns 0, it means that the other
party closed the connection.
â€¢ ğ’“ğ’†ğ’„ğ’—(ğŸ) and ğ’“ğ’†ğ’„ğ’—ğ’‡ğ’“ğ’ğ’(ğŸ) â€“ The ğ‘Ÿğ‘’ğ‘ğ‘£(2) and ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system calls are an
analogy for the ğ‘Ÿğ‘’ğ‘ğ‘‘(2) system call, specifically for sockets, with flags set to 0.
Those system calls return the number of bytes that were received through the socket
itself, as the number of bytes can vary. The ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call designed for stream
sockets (like TCP), while the ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system call designed for datagram
connection-less sockets (like UDP). When the ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call returns 0, it means
that the other party closed the connection.
â€¢ ğ’„ğ’ğ’ğ’”ğ’†(ğŸ) and ğ’”ğ’‰ğ’–ğ’•ğ’…ğ’ğ’˜ğ’(ğŸ) â€“ The ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) and ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2) system calls close
the socket. While ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) system call closes the whole socket, the ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2)
system call partially closes the socket for read/write.
 Communication Networks Course
Page | 12
Appendix C â€“ Random data generator
The data that you are going to send in this assignment is randomly generated. You can use
your own file with appropriate size or use the following function (or a function of your own)
to generate the data:
/*
* @brief A random data generator function based on srand() and rand().
* @param size The size of the data to generate (up to 2^32 bytes).
* @return A pointer to the buffer.
*/
char *util_generate_random_data(unsigned int size) {
 char *buffer = NULL;
 // Argument check.
 if (size == 0)
 return NULL;
 buffer = (char *)calloc(size, sizeof(char));
 // Error checking.
 if (buffer == NULL)
 return NULL;
 // Randomize the seed of the random number generator.
 srand(time(NULL));
 for (unsigned int i = 0; i < size; i++)
 *(buffer + i) = ((unsigned int)rand() % 256);
 return buffer;
}
 Communication Networks Course
Page | 13
Appendix D â€“ Checksum function
A checksum is a small-sized block of data derived from another block of digital data for the
purpose of detecting errors that may have been introduced during its transmission or
storage. By themselves, checksums are often used to verify data integrity but are not relied
upon to verify data authenticity.
Below is a simple yet efficient implementation of the checksum function, you can use it for
the assignment, but you can implement your own checksum function.
/*
* @brief A checksum function that returns 16 bit checksum for data.
* @param data The data to do the checksum for.
* @param bytes The length of the data in bytes.
* @return The checksum itself as 16 bit unsigned number.
* @note This function is taken from RFC1071, can be found here:
* @note https://tools.ietf.org/html/rfc1071
* @note It is the simplest way to calculate a checksum and is not very strong.
* However, it is good enough for this assignment.
* @note You are free to use any other checksum function as well.
* You can also use this function as such without any change.
*/
unsigned short int calculate_checksum(void *data, unsigned int bytes) {
 unsigned short int *data_pointer = (unsigned short int *)data;
 unsigned int total_sum = 0;
 // Main summing loop
 while (bytes > 1) {
 total_sum += *data_pointer++;
 bytes -= 2;
 }
 // Add left-over byte, if any
 if (bytes > 0)
 total_sum += *((unsigned char *)data_pointer);
 // Fold 32-bit sum to 16 bits
 while (total_sum >> 16)
 total_sum = (total_sum & 0xFFFF) + (total_sum >> 16);
 return (~((unsigned short int)total_sum));
} Communication Networks Course
Page | 1
Assignment 3 â€“ Transport Layer
Assignment Notes and Instructions
This assignment is to be done in pairs only. You must upload all the necessary files in a ZIP
file named after both of the studentâ€™s ID. For example: ğŸğŸğŸ‘ğŸ’ğŸ“ğŸ”ğŸ•ğŸ–ğŸ—_ğŸ—ğŸ–ğŸ•ğŸ”ğŸ“ğŸ’ğŸ‘ğŸğŸ. ğ’›ğ’Šğ’‘.
1) The assignment must be submitted by the date specified in the submission box.
2) All the assignment files (Code, Wireshark pcap files, PDF) must be submitted in a ZIP file. The
PDF must contain all the necessary screenshots with a description for each one of them.
3) The assignment must be done in pairs only. In exceptional cases, you should send an email to
the course coordinator.
4) You can use any reference material available through the course Moodle website or any
material passed during the exercises.
5) You can use any reference from the web, but copying codes from websites is forbidden; this
includes codes from other GitHub repositories. A student who gets caught in the act will
automatically fail this assignment (score 0). Any website youâ€™ve used to solve the
assignment, every website you used to solve the assignment must be noted in the PDF.
6) No delays in submission without special permission. Lateness without approval will result in
failure of the assignment (score 0).
7) All submissions will be submitted via the course's Moodle website. Email submissions will not
be accepted, resulting in a failure in the assignment.
8) The order and design of the code must be carefully considered. Make sure that the program
output is as clear as possible, comments in the code, and meaningful variable names. You
must also submit a makefile that compiles all the programs.
9) The assignment code must be written in C only.
10) The assignment is personal for each pair, and you should not accept help from other people,
whether outside the university or inside it. You can contact the course staff during reception
hours for help or raise a question in the course forum. Do not transfer code sections
between students, upload solutions or parts of solutions to websites on the Internet or in
various communication groups.
11) Students who copy a solution will receive a 0 in all assignments in the course and a report will
be made to the institutional disciplinary committee.
12) All code files of the assignment are required to both compile and run properly on the Ubuntu
22.04 LTS operating system. This is the operating system where the submissions will be
tested. You mustnâ€™t code it in Windows, as it uses different API for sockets. WSL wonâ€™t work,
as the task needs a tool that works only in a fully Linux environment.
Good Luck!
 Communication Networks Course
Page | 2
Part A â€“ Transmission Control Protocol (TCP) â€“ 30 points
In this part, youâ€™ll write two program files: ğ‘»ğ‘ªğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and ğ‘»ğ‘ªğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
The Sender will send a randomly generated file and the Receiver will receive it and measure
the time it took for his program to receive the file. The file size should be at least 2MB.
When running the Sender and Receiver, they both should support two standard congestion
control algorithms: TCP Reno and TCP Cubic.
Notes:
â€¢ The main goal of this part is to get familiar with the TCP concept of sending
messages between two endpoints.
â€¢ For approaching this part of the assignment, please be sure that you are familiar
with the congestion control algorithms and how to change them using the correct
method in C (see Appendix B for more information).
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). You've
learned that TCP is reliable by design, so you can assume that all the data have been
passed correctly, and thus, no need to recheck.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
Usage:
â€¢ Receiver:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
â€¢ Sender:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port of the Receiver.
â€¢ ğ‘¨ğ‘³ğ‘®ğ‘¶ â€“ The TCP congestion control algorithm that will be used by the party
member (either ğ’“ğ’†ğ’ğ’ for TCP Reno or ğ’„ğ’–ğ’ƒğ’Šğ’„ for TCP Cubic).
 Communication Networks Course
Page | 3
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a TCP socket between the Sender and the
Receiver.
3) Send the file.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a TCP connection between the Receiver and
the Sender.
2) Get a connection from the sender.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./TCP_Receiver -p 1234 -algo reno
Starting Receiver...
Waiting for TCP connection...
Sender connected, beginning to receive file...
File transfer completed.
Waiting for Sender response...
Sender sent exit message.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 4
Part B â€“ Reliable User Datagram Protocol (Reliable UDP or RUDP) â€“ 40 points
Youâ€™ve learned that while TCP is reliable, it lacks speed and has an overhead data of 20 bytes,
compering to UDP that needs only 8 bytes of overhead data.
Reliable UDP or RUDP, is a protocol that uses the UDP protocol for a faster transmission of
data, while adding a reliability layer to it, but without adding too much overhead data like
TCP.
A simple sketch for a RUDP connection would look something like this:
Your task in this part is to implement a Reliable protocol using UDP only. For simplicity, your
implementation should only support a handshake, closing scheme, error checking,
acknowledgment of received packets, and retransmission of lost packets.
Guidance:
â€¢ You can use ğ‘ ğ‘’ğ‘¡ğ‘ ğ‘œğ‘ğ‘˜ğ‘œğ‘ğ‘¡(2) for detecting a timeout.
â€¢ You need to build your own protocol, as Reliable UDP isnâ€™t a standard protocol (see a
draft of RUDP in this link), and no official header is provided. You can use this sketch
for a header, but you can come up with your own protocol, as long as it works.
Where:
o ğ‘³ğ’†ğ’ğ’ˆğ’•ğ’‰ is the length of the data itself, without the RUDP header.
o ğ‘ªğ’‰ğ’†ğ’„ğ’Œğ’”ğ’–ğ’ is a 16bit number that validates the correctness of the data.
o ğ‘­ğ’ğ’‚ğ’ˆğ’” is a special byte where we classify the packet itself (SYN, ACK, etc.).
â€¢ In your PDF, you must explain how your implementation of RUDP works â€“ How does
it detect a timeout to do retransmissions, how does the handshake work, what is the
header overhead, etc.
â€¢ For this part, youâ€™ll write three files: ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¨ğ‘·ğ‘°. ğ’„, ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and
ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
Reliable UDP Header proposed sketch
Byte 0 Byte 1 Byte 2 Byte 3
Length (2 Bytes) Checksum (2 Bytes)
Flags (1 Byte)
Figure 1 - RUDP Protocol Architecture, Geeksforgeeks
 Communication Networks Course
Page | 5
Notes:
â€¢ The Sender will send a random generated file and the Receiver will receive it and
measure the time it took for his program to receive the file. The file size should be at
least 2MB.
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). But, as the
RUDP is based on UDP, itâ€™s not reliable. You must use some form of error checking
(like checksum) to ensure that the packet wasnâ€™t alerted during the transfer.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
â€¢ The RUDP needs support only 1 sender and 1 receiver, for simplicity purposes.
Usage:
â€¢ Receiver:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
â€¢ Sender:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port that both the Sender and the Receiver will use.
The ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„ file will contain all the implementations of the RUDP API functions (That is, to
prevent reusing the same chuck of code both in the Sender and the Receiver.).
The API should support at the bare minimum the following functions (you decide what
parameters to implement, and what are the names of the functions, as long as the API is
explained in the PDF):
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘œğ‘ğ‘˜ğ‘’ğ‘¡() â€“ Creating a RUDP socket and creating a handshake between two
peers.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘’ğ‘›ğ‘‘() â€“ Sending data to the peer. The function should wait for an
acknowledgment packet, and if it didnâ€™t receive any, retransmits the data.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘Ÿğ‘’ğ‘ğ‘£() â€“ Receive data from a peer.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ğ‘™ğ‘œğ‘ ğ‘’() â€“ Closes a connection between peers.
 Communication Networks Course
Page | 6
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a UDP socket between the Sender and the
Receiver.
3) Send the file via the RUDP protocol.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a UDP connection between the Receiver and
the Sender.
2) Get a connection from the sender, by the custom
RUDP protocol youâ€™ve built.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./RUDP_Receiver -p 1234
Starting Receiver...
Waiting for RUDP connection...
Connection request received, sending ACK.
Sender connected, beginning to receive file...
File transfer completed.
ACK sent.
Waiting for Sender response...
Sender sent exit message.
ACK sent.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 7
Part C â€“ Research â€“ 30 points
In this part, youâ€™ll conduct research about your implementations of part A and part B.
In the research itself, each one of the versions (TCP version and UDP version) will be run at
least 5 times (meaning that the file transfer will occur at least 5 times) by the following
conditions:
â€¢ For TCP, youâ€™ll run it in TCP Reno and TCP Cubic, alternating each time, for each
scenario, meaning that you run 5 times with TCP Reno in both Sender and Receiver,
and 5 times with TCP Cubic in both Sender and Receiver.
Bonus (5 points): Create a very large data set â€“ 5 times with TCP Reno in both Sender
and Receiver, 5 times with TCP Reno in Sender and TCP Cubic in Receiver, 5 times
with TCP Cubic in Sender and TCP Reno in Receiver, and 5 times with TCP Cubic in
both Sender and Receiver. This will give you a data set large enough, which allows
you to work with, compare with and to reach a definite conclusion.
â€¢ For RUDP, you will run it 5 times for each scenario.
â€¢ For both TCP and RUDP, you will run them on those scenarios of packet loss:
o 0% packet loss â€“ Control group, simulating perfect connection.
o 2% packet loss â€“ Simulating unstable connection that commonly occur.
o 5% packet loss â€“ Simulating bad connection.
o 10% packet loss â€“ Simulating extremely poor connection.
For each scenario, you must provide a filtered PCAP file and relevant screenshots that
explain each one of the steps in the process. (10 points)
After youâ€™ve gathered the data set for both TCP and Reliable UDP, answer the following
questions:
1) In TCP, which congestion control algorithm gave better results overall? TCP Reno or
TCP Cubic? Which one gave better results on high packet loss? Explain how you came
to this conclusion based on the data set youâ€™ve gathered. (5 points)
2) How did your implementation of Reliable UDP perform overall compared to regular
TCP? Which one is better for high packet loss? (5 points)
3) According to the data youâ€™ve gathered, in which scenarios and applications would we
prefer to use TCP and in which situations would we prefer to use reliable UDP?
Explain your answer. (5 points)
 Communication Networks Course
Page | 8
×¢× ×• ×¢×œ ×”×©××œ×•×ª ×”×‘××•×ª )5 × ×§×•×“×•×ª(:
â— ×‘"×¨×©×ª ×××™× ×”" ×”×›×•×•× ×” ×”×™× ×œ×¨×©×ª ×©×‘×” ××¢×˜ ×××•×“ ×—×‘×™×œ×•×ª ×”×•×œ×›×•×ª ×œ××™×‘×•×“. ×‘"×§×©×¨ ××¨×•×š" ×”×›×•×•× ×” ×”×™×
×œ×§×©×¨ TCP ×©×™×© ×‘×• ×”×¨×‘×” ×××•×“ ××™×“×¢ ×œ×©×œ×•×—. ××•×¦×¢ ×œ×”×’×“×™×œ ×‘ -TCP ××ª SSThreshold ×‘×ª×—×™×œ×ª ×”×§×©×¨.
×‘××™×–×” ××”××§×¨×™× ×”×‘××™× ×”×©×™× ×•×™ ×”×–×” ×¢×©×•×™ ×œ×”×•×¢×™×œ ×‘××™×“×” ×”××™×¨×‘×™×ª? × ××§.
.1 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
.2 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.3 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.4 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.5 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.6 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.7 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.8 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
â— A ×©×•×œ×— ×œ -B ×—×‘×™×œ×•×ª ××™×“×¢ ×‘×××¦×¢×•×ª ×§×©×¨ TCP. × ×ª×•×Ÿ ×›×™ ×”×§×©×¨ ××ª×—×™×œ ×¢× ×—×œ×•×Ÿ ×‘×’×•×“×œ 1MSS. ×”×§×©×¨
××¡×ª×™×™× ×‘×¤×¢× ×”×¨××©×•× ×” ×©×”×•× ××’×™×¢ ×œ -SSthresh. ×‘××”×œ×š ×”×§×©×¨ ×œ× ××•×‘×“×•×ª ×—×‘×™×œ×•×ª. × ×¡××Ÿ ×‘×§×™×¦×•×¨:
.SSthresh=S*MSS
× ×ª×•×Ÿ ×›×™ ×œ××•×¨×š ×›×œ ×”×§×©×¨ rwnd < MSS*S.
××”×™ ×”×ª×¤×•×§×” ×©×œ ×”×§×©×¨ ×-A ×œ-B( ×‘ -sec / Bytes )×‘×–××Ÿ ×”× "×œ? × ××§×™.
]S*MSS / [lg (S) * RTT*2 ×‘×¢×¨×š .1
]S*MSS / [S^0.5 * RTT*2 ×‘×¢×¨×š .2
S*MSS / RTT ×‘×¢×¨×š .3
S^2)*MSS / RTT( ×‘×¢×¨×š .4
â— ×©×ª×™ ×ª×—× ×•×ª ××ª×§×©×¨×•×ª ×‘××•×¤×Ÿ ××œ×—×•×˜×™ ×‘×©×™×˜×ª N Back Go.
× ×¡××Ÿ ×‘-X ××ª ×¡×¤×¨×ª ×”×‘×™×§×•×¨×ª ×©×œ ×”×ª.×–. ×©×œ×š. ×× ×©× ×™ ×©×•×ª×¤×™× ××’×™×©×™× ××ª ×”×ª×¨×’×™×œ ×™×—×“, X ×”×•× ×¡×¤×¨×ª
×”×‘×™×§×•×¨×ª ×‘×¢×œ×ª ×”×¢×¨×š ×”× ××•×š ×™×•×ª×¨ ××‘×™×Ÿ ×”×©×ª×™×™×.
×§×¦×‘ ×”×ª×§×©×•×¨×ª ×”×•× 8Gbps, ×•×’×•×“×œ ×›×œ ×—×‘×™×œ×” ×”×•× KByte*X. ×’×“×œ×™ ×”-headers ×•×” -Acks ×–× ×™×—×™×.
ï¿½ğ‘’ğ‘ ï¿½/ï¿½ï¿½ 8 , ×•×”××¨×—×§ ×‘×™×Ÿ ×”×ª×—× ×•×ª ×”×•× 1Km. ×§×¦×‘ ×”×”×ª×¤×©×˜×•×ª ×”×•× 10 â‹… 2
×–××Ÿ ×¢×™×‘×•×“ ×”× ×ª×•× ×™× ×‘×ª×—× ×•×ª ×–× ×™×—.
××£ ×—×‘×™×œ×” ×•××£ Ack ×œ× ×”×•×œ×›×™× ×œ××™×‘×•×“.
â— ××”×• X ×©×œ×š?
â— ××” ×¦×¨×™×š ×œ×”×™×•×ª ×’×•×“×œ ×—×œ×•×Ÿ ×”××©×œ×•×— ×›×“×™ ×œ×”×‘×˜×™×— ×ª×¤×•×§×” ××§×¡×™××œ×™×ª?
 Communication Networks Course
Page | 9
Bonus â€“ Improving the Reliable UDP â€“ 15 points
Note: This part isnâ€™t mandatory and is a bonus only!
In this part, youâ€™ll improve your RUDP implementation by adding the concepts of flow
control and congestion control from TCP. Youâ€™re free to choose which algorithms to
implement, as long as you explain in your PDF which algorithms youâ€™ve used. Youâ€™ll probably
need to make changes in the original design of the RUDP. Changes only need to be to the API
itself, ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„.
Points distribution:
â€¢ Flow control improvement â€“ 7 Points
â€¢ Congestion control improvement â€“ 8 points.
Guidance:
â€¢ For flow control, you must use one of the Sliding window techniques: stop-and-wait
ARQ, Go-Back-N or Selective repeat.
â€¢ List of known TCP congestion control algorithms, which you can use any one of them
for this bonus task, or makeup your own:
Figure 2 â€“ List of known TCP congestion control algorithms, Wikipedia
 Communication Networks Course
Page | 10
Appendix A â€“ Linux local packet loss tool
To simulate a packet loss in a local network, we'll use a Linux tool that's called Linux Traffic
Control (ğ‘¡ğ‘). This requires a full Linux installation, so working with WSL won't work.
If the tool isn't installed in your machine, you can install it by using the following commands:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’
If the installation didn't work, you can use the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’2
To create a packet loss scenario, type the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘ğ‘‘ğ‘‘ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
After creating a packet loss scenario, you can change the percentage by typing the following
command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘â„ğ‘ğ‘›ğ‘”ğ‘’ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
To remove the packet loss scenario, write the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘‘ğ‘’ğ‘™ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š
 Communication Networks Course
Page | 11
Appendix B â€“ ğ’ğ’‚ğ’(ğŸ) system calls
This appendixâ€™s purpose is to give you a better understanding of socket handling in C.
A recommended reference is Beejâ€™s Guide to Network Programming, by Brian â€œBeej
Jorgensenâ€ Hall, which gives a lot of information about sockets in C and functions.
Functions and documentation links:
â€¢ ğ’”ğ’ğ’„ğ’Œğ’†ğ’•(ğŸ) â€“ A Factory method system call that creates a socket with the given
parameters.
â€¢ ğ’ƒğ’Šğ’ğ’…(ğŸ) â€“ Whenever we create a new socket, we need to bind it to a specific port in
our machine, â€œto catch a portâ€. The port number is managed and used by the kernel
to link incoming packets to the corresponding application socket. The port numbers
are usually fixed. The ğ‘ğ‘‘ğ‘‘ğ‘Ÿ parameter must match the current socket that is used.
â€¢ ğ’ğ’Šğ’”ğ’•ğ’†ğ’(ğŸ) â€“ The ğ‘™ğ‘–ğ‘ ğ‘¡ğ‘’ğ‘›(2) system call doesn't do anything in the mean of
communication but only memory allocation (malloc) for stream sockets only. If we
won't allocate memory, any incoming connection will fail.
â€¢ ğ’„ğ’ğ’ğ’ğ’†ğ’„ğ’•(ğŸ) â€“ The ğ‘ğ‘œğ‘›ğ‘›ğ‘’ğ‘ğ‘¡(2) system call starts the link between a client and a
specific IP address and port number. The connection would complete when the
other side will call the ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call.
â€¢ ğ’‚ğ’„ğ’„ğ’†ğ’‘ğ’•(ğŸ) â€“ The ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call accepts the incoming stream connection
request from the other side, by the listening socket. This system call completes the
three-way handshake of stream socket (like TCP) and opens a new socket that has a
direct communication channel only with the other party in the handshake.
â€¢ ğ’”ğ’†ğ’ğ’…(ğŸ) and ğ’”ğ’†ğ’ğ’…ğ’•ğ’(ğŸ) â€“ The ğ‘ ğ‘’ğ‘›ğ‘‘(2) and ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system calls are an analogy
for the ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’(2) system call, specifcly for sockets, with flags set to 0. Those system
calls return the number of bytes that were sent through the socket itself, as the
number of bytes can vary. The ğ‘ ğ‘’ğ‘›ğ‘‘(2)system call designed for stream sockets (like
TCP), while the ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system call designed for datagram connection-less
sockets (like UDP). When the ğ‘ ğ‘’ğ‘›ğ‘‘(2) system call returns 0, it means that the other
party closed the connection.
â€¢ ğ’“ğ’†ğ’„ğ’—(ğŸ) and ğ’“ğ’†ğ’„ğ’—ğ’‡ğ’“ğ’ğ’(ğŸ) â€“ The ğ‘Ÿğ‘’ğ‘ğ‘£(2) and ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system calls are an
analogy for the ğ‘Ÿğ‘’ğ‘ğ‘‘(2) system call, specifically for sockets, with flags set to 0.
Those system calls return the number of bytes that were received through the socket
itself, as the number of bytes can vary. The ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call designed for stream
sockets (like TCP), while the ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system call designed for datagram
connection-less sockets (like UDP). When the ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call returns 0, it means
that the other party closed the connection.
â€¢ ğ’„ğ’ğ’ğ’”ğ’†(ğŸ) and ğ’”ğ’‰ğ’–ğ’•ğ’…ğ’ğ’˜ğ’(ğŸ) â€“ The ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) and ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2) system calls close
the socket. While ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) system call closes the whole socket, the ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2)
system call partially closes the socket for read/write.
 Communication Networks Course
Page | 12
Appendix C â€“ Random data generator
The data that you are going to send in this assignment is randomly generated. You can use
your own file with appropriate size or use the following function (or a function of your own)
to generate the data:
/*
* @brief A random data generator function based on srand() and rand().
* @param size The size of the data to generate (up to 2^32 bytes).
* @return A pointer to the buffer.
*/
char *util_generate_random_data(unsigned int size) {
 char *buffer = NULL;
 // Argument check.
 if (size == 0)
 return NULL;
 buffer = (char *)calloc(size, sizeof(char));
 // Error checking.
 if (buffer == NULL)
 return NULL;
 // Randomize the seed of the random number generator.
 srand(time(NULL));
 for (unsigned int i = 0; i < size; i++)
 *(buffer + i) = ((unsigned int)rand() % 256);
 return buffer;
}
 Communication Networks Course
Page | 13
Appendix D â€“ Checksum function
A checksum is a small-sized block of data derived from another block of digital data for the
purpose of detecting errors that may have been introduced during its transmission or
storage. By themselves, checksums are often used to verify data integrity but are not relied
upon to verify data authenticity.
Below is a simple yet efficient implementation of the checksum function, you can use it for
the assignment, but you can implement your own checksum function.
/*
* @brief A checksum function that returns 16 bit checksum for data.
* @param data The data to do the checksum for.
* @param bytes The length of the data in bytes.
* @return The checksum itself as 16 bit unsigned number.
* @note This function is taken from RFC1071, can be found here:
* @note https://tools.ietf.org/html/rfc1071
* @note It is the simplest way to calculate a checksum and is not very strong.
* However, it is good enough for this assignment.
* @note You are free to use any other checksum function as well.
* You can also use this function as such without any change.
*/
unsigned short int calculate_checksum(void *data, unsigned int bytes) {
 unsigned short int *data_pointer = (unsigned short int *)data;
 unsigned int total_sum = 0;
 // Main summing loop
 while (bytes > 1) {
 total_sum += *data_pointer++;
 bytes -= 2;
 }
 // Add left-over byte, if any
 if (bytes > 0)
 total_sum += *((unsigned char *)data_pointer);
 // Fold 32-bit sum to 16 bits
 while (total_sum >> 16)
 total_sum = (total_sum & 0xFFFF) + (total_sum >> 16);
 return (~((unsigned short int)total_sum));
} Communication Networks Course
Page | 1
Assignment 3 â€“ Transport Layer
Assignment Notes and Instructions
This assignment is to be done in pairs only. You must upload all the necessary files in a ZIP
file named after both of the studentâ€™s ID. For example: ğŸğŸğŸ‘ğŸ’ğŸ“ğŸ”ğŸ•ğŸ–ğŸ—_ğŸ—ğŸ–ğŸ•ğŸ”ğŸ“ğŸ’ğŸ‘ğŸğŸ. ğ’›ğ’Šğ’‘.
1) The assignment must be submitted by the date specified in the submission box.
2) All the assignment files (Code, Wireshark pcap files, PDF) must be submitted in a ZIP file. The
PDF must contain all the necessary screenshots with a description for each one of them.
3) The assignment must be done in pairs only. In exceptional cases, you should send an email to
the course coordinator.
4) You can use any reference material available through the course Moodle website or any
material passed during the exercises.
5) You can use any reference from the web, but copying codes from websites is forbidden; this
includes codes from other GitHub repositories. A student who gets caught in the act will
automatically fail this assignment (score 0). Any website youâ€™ve used to solve the
assignment, every website you used to solve the assignment must be noted in the PDF.
6) No delays in submission without special permission. Lateness without approval will result in
failure of the assignment (score 0).
7) All submissions will be submitted via the course's Moodle website. Email submissions will not
be accepted, resulting in a failure in the assignment.
8) The order and design of the code must be carefully considered. Make sure that the program
output is as clear as possible, comments in the code, and meaningful variable names. You
must also submit a makefile that compiles all the programs.
9) The assignment code must be written in C only.
10) The assignment is personal for each pair, and you should not accept help from other people,
whether outside the university or inside it. You can contact the course staff during reception
hours for help or raise a question in the course forum. Do not transfer code sections
between students, upload solutions or parts of solutions to websites on the Internet or in
various communication groups.
11) Students who copy a solution will receive a 0 in all assignments in the course and a report will
be made to the institutional disciplinary committee.
12) All code files of the assignment are required to both compile and run properly on the Ubuntu
22.04 LTS operating system. This is the operating system where the submissions will be
tested. You mustnâ€™t code it in Windows, as it uses different API for sockets. WSL wonâ€™t work,
as the task needs a tool that works only in a fully Linux environment.
Good Luck!
 Communication Networks Course
Page | 2
Part A â€“ Transmission Control Protocol (TCP) â€“ 30 points
In this part, youâ€™ll write two program files: ğ‘»ğ‘ªğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and ğ‘»ğ‘ªğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
The Sender will send a randomly generated file and the Receiver will receive it and measure
the time it took for his program to receive the file. The file size should be at least 2MB.
When running the Sender and Receiver, they both should support two standard congestion
control algorithms: TCP Reno and TCP Cubic.
Notes:
â€¢ The main goal of this part is to get familiar with the TCP concept of sending
messages between two endpoints.
â€¢ For approaching this part of the assignment, please be sure that you are familiar
with the congestion control algorithms and how to change them using the correct
method in C (see Appendix B for more information).
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). You've
learned that TCP is reliable by design, so you can assume that all the data have been
passed correctly, and thus, no need to recheck.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
Usage:
â€¢ Receiver:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
â€¢ Sender:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port of the Receiver.
â€¢ ğ‘¨ğ‘³ğ‘®ğ‘¶ â€“ The TCP congestion control algorithm that will be used by the party
member (either ğ’“ğ’†ğ’ğ’ for TCP Reno or ğ’„ğ’–ğ’ƒğ’Šğ’„ for TCP Cubic).
 Communication Networks Course
Page | 3
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a TCP socket between the Sender and the
Receiver.
3) Send the file.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a TCP connection between the Receiver and
the Sender.
2) Get a connection from the sender.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./TCP_Receiver -p 1234 -algo reno
Starting Receiver...
Waiting for TCP connection...
Sender connected, beginning to receive file...
File transfer completed.
Waiting for Sender response...
Sender sent exit message.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 4
Part B â€“ Reliable User Datagram Protocol (Reliable UDP or RUDP) â€“ 40 points
Youâ€™ve learned that while TCP is reliable, it lacks speed and has an overhead data of 20 bytes,
compering to UDP that needs only 8 bytes of overhead data.
Reliable UDP or RUDP, is a protocol that uses the UDP protocol for a faster transmission of
data, while adding a reliability layer to it, but without adding too much overhead data like
TCP.
A simple sketch for a RUDP connection would look something like this:
Your task in this part is to implement a Reliable protocol using UDP only. For simplicity, your
implementation should only support a handshake, closing scheme, error checking,
acknowledgment of received packets, and retransmission of lost packets.
Guidance:
â€¢ You can use ğ‘ ğ‘’ğ‘¡ğ‘ ğ‘œğ‘ğ‘˜ğ‘œğ‘ğ‘¡(2) for detecting a timeout.
â€¢ You need to build your own protocol, as Reliable UDP isnâ€™t a standard protocol (see a
draft of RUDP in this link), and no official header is provided. You can use this sketch
for a header, but you can come up with your own protocol, as long as it works.
Where:
o ğ‘³ğ’†ğ’ğ’ˆğ’•ğ’‰ is the length of the data itself, without the RUDP header.
o ğ‘ªğ’‰ğ’†ğ’„ğ’Œğ’”ğ’–ğ’ is a 16bit number that validates the correctness of the data.
o ğ‘­ğ’ğ’‚ğ’ˆğ’” is a special byte where we classify the packet itself (SYN, ACK, etc.).
â€¢ In your PDF, you must explain how your implementation of RUDP works â€“ How does
it detect a timeout to do retransmissions, how does the handshake work, what is the
header overhead, etc.
â€¢ For this part, youâ€™ll write three files: ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¨ğ‘·ğ‘°. ğ’„, ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and
ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
Reliable UDP Header proposed sketch
Byte 0 Byte 1 Byte 2 Byte 3
Length (2 Bytes) Checksum (2 Bytes)
Flags (1 Byte)
Figure 1 - RUDP Protocol Architecture, Geeksforgeeks
 Communication Networks Course
Page | 5
Notes:
â€¢ The Sender will send a random generated file and the Receiver will receive it and
measure the time it took for his program to receive the file. The file size should be at
least 2MB.
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). But, as the
RUDP is based on UDP, itâ€™s not reliable. You must use some form of error checking
(like checksum) to ensure that the packet wasnâ€™t alerted during the transfer.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
â€¢ The RUDP needs support only 1 sender and 1 receiver, for simplicity purposes.
Usage:
â€¢ Receiver:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
â€¢ Sender:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port that both the Sender and the Receiver will use.
The ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„ file will contain all the implementations of the RUDP API functions (That is, to
prevent reusing the same chuck of code both in the Sender and the Receiver.).
The API should support at the bare minimum the following functions (you decide what
parameters to implement, and what are the names of the functions, as long as the API is
explained in the PDF):
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘œğ‘ğ‘˜ğ‘’ğ‘¡() â€“ Creating a RUDP socket and creating a handshake between two
peers.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘’ğ‘›ğ‘‘() â€“ Sending data to the peer. The function should wait for an
acknowledgment packet, and if it didnâ€™t receive any, retransmits the data.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘Ÿğ‘’ğ‘ğ‘£() â€“ Receive data from a peer.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ğ‘™ğ‘œğ‘ ğ‘’() â€“ Closes a connection between peers.
 Communication Networks Course
Page | 6
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a UDP socket between the Sender and the
Receiver.
3) Send the file via the RUDP protocol.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a UDP connection between the Receiver and
the Sender.
2) Get a connection from the sender, by the custom
RUDP protocol youâ€™ve built.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./RUDP_Receiver -p 1234
Starting Receiver...
Waiting for RUDP connection...
Connection request received, sending ACK.
Sender connected, beginning to receive file...
File transfer completed.
ACK sent.
Waiting for Sender response...
Sender sent exit message.
ACK sent.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 7
Part C â€“ Research â€“ 30 points
In this part, youâ€™ll conduct research about your implementations of part A and part B.
In the research itself, each one of the versions (TCP version and UDP version) will be run at
least 5 times (meaning that the file transfer will occur at least 5 times) by the following
conditions:
â€¢ For TCP, youâ€™ll run it in TCP Reno and TCP Cubic, alternating each time, for each
scenario, meaning that you run 5 times with TCP Reno in both Sender and Receiver,
and 5 times with TCP Cubic in both Sender and Receiver.
Bonus (5 points): Create a very large data set â€“ 5 times with TCP Reno in both Sender
and Receiver, 5 times with TCP Reno in Sender and TCP Cubic in Receiver, 5 times
with TCP Cubic in Sender and TCP Reno in Receiver, and 5 times with TCP Cubic in
both Sender and Receiver. This will give you a data set large enough, which allows
you to work with, compare with and to reach a definite conclusion.
â€¢ For RUDP, you will run it 5 times for each scenario.
â€¢ For both TCP and RUDP, you will run them on those scenarios of packet loss:
o 0% packet loss â€“ Control group, simulating perfect connection.
o 2% packet loss â€“ Simulating unstable connection that commonly occur.
o 5% packet loss â€“ Simulating bad connection.
o 10% packet loss â€“ Simulating extremely poor connection.
For each scenario, you must provide a filtered PCAP file and relevant screenshots that
explain each one of the steps in the process. (10 points)
After youâ€™ve gathered the data set for both TCP and Reliable UDP, answer the following
questions:
1) In TCP, which congestion control algorithm gave better results overall? TCP Reno or
TCP Cubic? Which one gave better results on high packet loss? Explain how you came
to this conclusion based on the data set youâ€™ve gathered. (5 points)
2) How did your implementation of Reliable UDP perform overall compared to regular
TCP? Which one is better for high packet loss? (5 points)
3) According to the data youâ€™ve gathered, in which scenarios and applications would we
prefer to use TCP and in which situations would we prefer to use reliable UDP?
Explain your answer. (5 points)
 Communication Networks Course
Page | 8
×¢× ×• ×¢×œ ×”×©××œ×•×ª ×”×‘××•×ª )5 × ×§×•×“×•×ª(:
â— ×‘"×¨×©×ª ×××™× ×”" ×”×›×•×•× ×” ×”×™× ×œ×¨×©×ª ×©×‘×” ××¢×˜ ×××•×“ ×—×‘×™×œ×•×ª ×”×•×œ×›×•×ª ×œ××™×‘×•×“. ×‘"×§×©×¨ ××¨×•×š" ×”×›×•×•× ×” ×”×™×
×œ×§×©×¨ TCP ×©×™×© ×‘×• ×”×¨×‘×” ×××•×“ ××™×“×¢ ×œ×©×œ×•×—. ××•×¦×¢ ×œ×”×’×“×™×œ ×‘ -TCP ××ª SSThreshold ×‘×ª×—×™×œ×ª ×”×§×©×¨.
×‘××™×–×” ××”××§×¨×™× ×”×‘××™× ×”×©×™× ×•×™ ×”×–×” ×¢×©×•×™ ×œ×”×•×¢×™×œ ×‘××™×“×” ×”××™×¨×‘×™×ª? × ××§.
.1 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
.2 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.3 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.4 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.5 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.6 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.7 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.8 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
â— A ×©×•×œ×— ×œ -B ×—×‘×™×œ×•×ª ××™×“×¢ ×‘×××¦×¢×•×ª ×§×©×¨ TCP. × ×ª×•×Ÿ ×›×™ ×”×§×©×¨ ××ª×—×™×œ ×¢× ×—×œ×•×Ÿ ×‘×’×•×“×œ 1MSS. ×”×§×©×¨
××¡×ª×™×™× ×‘×¤×¢× ×”×¨××©×•× ×” ×©×”×•× ××’×™×¢ ×œ -SSthresh. ×‘××”×œ×š ×”×§×©×¨ ×œ× ××•×‘×“×•×ª ×—×‘×™×œ×•×ª. × ×¡××Ÿ ×‘×§×™×¦×•×¨:
.SSthresh=S*MSS
× ×ª×•×Ÿ ×›×™ ×œ××•×¨×š ×›×œ ×”×§×©×¨ rwnd < MSS*S.
××”×™ ×”×ª×¤×•×§×” ×©×œ ×”×§×©×¨ ×-A ×œ-B( ×‘ -sec / Bytes )×‘×–××Ÿ ×”× "×œ? × ××§×™.
]S*MSS / [lg (S) * RTT*2 ×‘×¢×¨×š .1
]S*MSS / [S^0.5 * RTT*2 ×‘×¢×¨×š .2
S*MSS / RTT ×‘×¢×¨×š .3
S^2)*MSS / RTT( ×‘×¢×¨×š .4
â— ×©×ª×™ ×ª×—× ×•×ª ××ª×§×©×¨×•×ª ×‘××•×¤×Ÿ ××œ×—×•×˜×™ ×‘×©×™×˜×ª N Back Go.
× ×¡××Ÿ ×‘-X ××ª ×¡×¤×¨×ª ×”×‘×™×§×•×¨×ª ×©×œ ×”×ª.×–. ×©×œ×š. ×× ×©× ×™ ×©×•×ª×¤×™× ××’×™×©×™× ××ª ×”×ª×¨×’×™×œ ×™×—×“, X ×”×•× ×¡×¤×¨×ª
×”×‘×™×§×•×¨×ª ×‘×¢×œ×ª ×”×¢×¨×š ×”× ××•×š ×™×•×ª×¨ ××‘×™×Ÿ ×”×©×ª×™×™×.
×§×¦×‘ ×”×ª×§×©×•×¨×ª ×”×•× 8Gbps, ×•×’×•×“×œ ×›×œ ×—×‘×™×œ×” ×”×•× KByte*X. ×’×“×œ×™ ×”-headers ×•×” -Acks ×–× ×™×—×™×.
ï¿½ğ‘’ğ‘ ï¿½/ï¿½ï¿½ 8 , ×•×”××¨×—×§ ×‘×™×Ÿ ×”×ª×—× ×•×ª ×”×•× 1Km. ×§×¦×‘ ×”×”×ª×¤×©×˜×•×ª ×”×•× 10 â‹… 2
×–××Ÿ ×¢×™×‘×•×“ ×”× ×ª×•× ×™× ×‘×ª×—× ×•×ª ×–× ×™×—.
××£ ×—×‘×™×œ×” ×•××£ Ack ×œ× ×”×•×œ×›×™× ×œ××™×‘×•×“.
â— ××”×• X ×©×œ×š?
â— ××” ×¦×¨×™×š ×œ×”×™×•×ª ×’×•×“×œ ×—×œ×•×Ÿ ×”××©×œ×•×— ×›×“×™ ×œ×”×‘×˜×™×— ×ª×¤×•×§×” ××§×¡×™××œ×™×ª?
 Communication Networks Course
Page | 9
Bonus â€“ Improving the Reliable UDP â€“ 15 points
Note: This part isnâ€™t mandatory and is a bonus only!
In this part, youâ€™ll improve your RUDP implementation by adding the concepts of flow
control and congestion control from TCP. Youâ€™re free to choose which algorithms to
implement, as long as you explain in your PDF which algorithms youâ€™ve used. Youâ€™ll probably
need to make changes in the original design of the RUDP. Changes only need to be to the API
itself, ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„.
Points distribution:
â€¢ Flow control improvement â€“ 7 Points
â€¢ Congestion control improvement â€“ 8 points.
Guidance:
â€¢ For flow control, you must use one of the Sliding window techniques: stop-and-wait
ARQ, Go-Back-N or Selective repeat.
â€¢ List of known TCP congestion control algorithms, which you can use any one of them
for this bonus task, or makeup your own:
Figure 2 â€“ List of known TCP congestion control algorithms, Wikipedia
 Communication Networks Course
Page | 10
Appendix A â€“ Linux local packet loss tool
To simulate a packet loss in a local network, we'll use a Linux tool that's called Linux Traffic
Control (ğ‘¡ğ‘). This requires a full Linux installation, so working with WSL won't work.
If the tool isn't installed in your machine, you can install it by using the following commands:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’
If the installation didn't work, you can use the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’2
To create a packet loss scenario, type the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘ğ‘‘ğ‘‘ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
After creating a packet loss scenario, you can change the percentage by typing the following
command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘â„ğ‘ğ‘›ğ‘”ğ‘’ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
To remove the packet loss scenario, write the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘‘ğ‘’ğ‘™ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š
 Communication Networks Course
Page | 11
Appendix B â€“ ğ’ğ’‚ğ’(ğŸ) system calls
This appendixâ€™s purpose is to give you a better understanding of socket handling in C.
A recommended reference is Beejâ€™s Guide to Network Programming, by Brian â€œBeej
Jorgensenâ€ Hall, which gives a lot of information about sockets in C and functions.
Functions and documentation links:
â€¢ ğ’”ğ’ğ’„ğ’Œğ’†ğ’•(ğŸ) â€“ A Factory method system call that creates a socket with the given
parameters.
â€¢ ğ’ƒğ’Šğ’ğ’…(ğŸ) â€“ Whenever we create a new socket, we need to bind it to a specific port in
our machine, â€œto catch a portâ€. The port number is managed and used by the kernel
to link incoming packets to the corresponding application socket. The port numbers
are usually fixed. The ğ‘ğ‘‘ğ‘‘ğ‘Ÿ parameter must match the current socket that is used.
â€¢ ğ’ğ’Šğ’”ğ’•ğ’†ğ’(ğŸ) â€“ The ğ‘™ğ‘–ğ‘ ğ‘¡ğ‘’ğ‘›(2) system call doesn't do anything in the mean of
communication but only memory allocation (malloc) for stream sockets only. If we
won't allocate memory, any incoming connection will fail.
â€¢ ğ’„ğ’ğ’ğ’ğ’†ğ’„ğ’•(ğŸ) â€“ The ğ‘ğ‘œğ‘›ğ‘›ğ‘’ğ‘ğ‘¡(2) system call starts the link between a client and a
specific IP address and port number. The connection would complete when the
other side will call the ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call.
â€¢ ğ’‚ğ’„ğ’„ğ’†ğ’‘ğ’•(ğŸ) â€“ The ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call accepts the incoming stream connection
request from the other side, by the listening socket. This system call completes the
three-way handshake of stream socket (like TCP) and opens a new socket that has a
direct communication channel only with the other party in the handshake.
â€¢ ğ’”ğ’†ğ’ğ’…(ğŸ) and ğ’”ğ’†ğ’ğ’…ğ’•ğ’(ğŸ) â€“ The ğ‘ ğ‘’ğ‘›ğ‘‘(2) and ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system calls are an analogy
for the ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’(2) system call, specifcly for sockets, with flags set to 0. Those system
calls return the number of bytes that were sent through the socket itself, as the
number of bytes can vary. The ğ‘ ğ‘’ğ‘›ğ‘‘(2)system call designed for stream sockets (like
TCP), while the ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system call designed for datagram connection-less
sockets (like UDP). When the ğ‘ ğ‘’ğ‘›ğ‘‘(2) system call returns 0, it means that the other
party closed the connection.
â€¢ ğ’“ğ’†ğ’„ğ’—(ğŸ) and ğ’“ğ’†ğ’„ğ’—ğ’‡ğ’“ğ’ğ’(ğŸ) â€“ The ğ‘Ÿğ‘’ğ‘ğ‘£(2) and ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system calls are an
analogy for the ğ‘Ÿğ‘’ğ‘ğ‘‘(2) system call, specifically for sockets, with flags set to 0.
Those system calls return the number of bytes that were received through the socket
itself, as the number of bytes can vary. The ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call designed for stream
sockets (like TCP), while the ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system call designed for datagram
connection-less sockets (like UDP). When the ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call returns 0, it means
that the other party closed the connection.
â€¢ ğ’„ğ’ğ’ğ’”ğ’†(ğŸ) and ğ’”ğ’‰ğ’–ğ’•ğ’…ğ’ğ’˜ğ’(ğŸ) â€“ The ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) and ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2) system calls close
the socket. While ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) system call closes the whole socket, the ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2)
system call partially closes the socket for read/write.
 Communication Networks Course
Page | 12
Appendix C â€“ Random data generator
The data that you are going to send in this assignment is randomly generated. You can use
your own file with appropriate size or use the following function (or a function of your own)
to generate the data:
/*
* @brief A random data generator function based on srand() and rand().
* @param size The size of the data to generate (up to 2^32 bytes).
* @return A pointer to the buffer.
*/
char *util_generate_random_data(unsigned int size) {
 char *buffer = NULL;
 // Argument check.
 if (size == 0)
 return NULL;
 buffer = (char *)calloc(size, sizeof(char));
 // Error checking.
 if (buffer == NULL)
 return NULL;
 // Randomize the seed of the random number generator.
 srand(time(NULL));
 for (unsigned int i = 0; i < size; i++)
 *(buffer + i) = ((unsigned int)rand() % 256);
 return buffer;
}
 Communication Networks Course
Page | 13
Appendix D â€“ Checksum function
A checksum is a small-sized block of data derived from another block of digital data for the
purpose of detecting errors that may have been introduced during its transmission or
storage. By themselves, checksums are often used to verify data integrity but are not relied
upon to verify data authenticity.
Below is a simple yet efficient implementation of the checksum function, you can use it for
the assignment, but you can implement your own checksum function.
/*
* @brief A checksum function that returns 16 bit checksum for data.
* @param data The data to do the checksum for.
* @param bytes The length of the data in bytes.
* @return The checksum itself as 16 bit unsigned number.
* @note This function is taken from RFC1071, can be found here:
* @note https://tools.ietf.org/html/rfc1071
* @note It is the simplest way to calculate a checksum and is not very strong.
* However, it is good enough for this assignment.
* @note You are free to use any other checksum function as well.
* You can also use this function as such without any change.
*/
unsigned short int calculate_checksum(void *data, unsigned int bytes) {
 unsigned short int *data_pointer = (unsigned short int *)data;
 unsigned int total_sum = 0;
 // Main summing loop
 while (bytes > 1) {
 total_sum += *data_pointer++;
 bytes -= 2;
 }
 // Add left-over byte, if any
 if (bytes > 0)
 total_sum += *((unsigned char *)data_pointer);
 // Fold 32-bit sum to 16 bits
 while (total_sum >> 16)
 total_sum = (total_sum & 0xFFFF) + (total_sum >> 16);
 return (~((unsigned short int)total_sum));
} Communication Networks Course
Page | 1
Assignment 3 â€“ Transport Layer
Assignment Notes and Instructions
This assignment is to be done in pairs only. You must upload all the necessary files in a ZIP
file named after both of the studentâ€™s ID. For example: ğŸğŸğŸ‘ğŸ’ğŸ“ğŸ”ğŸ•ğŸ–ğŸ—_ğŸ—ğŸ–ğŸ•ğŸ”ğŸ“ğŸ’ğŸ‘ğŸğŸ. ğ’›ğ’Šğ’‘.
1) The assignment must be submitted by the date specified in the submission box.
2) All the assignment files (Code, Wireshark pcap files, PDF) must be submitted in a ZIP file. The
PDF must contain all the necessary screenshots with a description for each one of them.
3) The assignment must be done in pairs only. In exceptional cases, you should send an email to
the course coordinator.
4) You can use any reference material available through the course Moodle website or any
material passed during the exercises.
5) You can use any reference from the web, but copying codes from websites is forbidden; this
includes codes from other GitHub repositories. A student who gets caught in the act will
automatically fail this assignment (score 0). Any website youâ€™ve used to solve the
assignment, every website you used to solve the assignment must be noted in the PDF.
6) No delays in submission without special permission. Lateness without approval will result in
failure of the assignment (score 0).
7) All submissions will be submitted via the course's Moodle website. Email submissions will not
be accepted, resulting in a failure in the assignment.
8) The order and design of the code must be carefully considered. Make sure that the program
output is as clear as possible, comments in the code, and meaningful variable names. You
must also submit a makefile that compiles all the programs.
9) The assignment code must be written in C only.
10) The assignment is personal for each pair, and you should not accept help from other people,
whether outside the university or inside it. You can contact the course staff during reception
hours for help or raise a question in the course forum. Do not transfer code sections
between students, upload solutions or parts of solutions to websites on the Internet or in
various communication groups.
11) Students who copy a solution will receive a 0 in all assignments in the course and a report will
be made to the institutional disciplinary committee.
12) All code files of the assignment are required to both compile and run properly on the Ubuntu
22.04 LTS operating system. This is the operating system where the submissions will be
tested. You mustnâ€™t code it in Windows, as it uses different API for sockets. WSL wonâ€™t work,
as the task needs a tool that works only in a fully Linux environment.
Good Luck!
 Communication Networks Course
Page | 2
Part A â€“ Transmission Control Protocol (TCP) â€“ 30 points
In this part, youâ€™ll write two program files: ğ‘»ğ‘ªğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and ğ‘»ğ‘ªğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
The Sender will send a randomly generated file and the Receiver will receive it and measure
the time it took for his program to receive the file. The file size should be at least 2MB.
When running the Sender and Receiver, they both should support two standard congestion
control algorithms: TCP Reno and TCP Cubic.
Notes:
â€¢ The main goal of this part is to get familiar with the TCP concept of sending
messages between two endpoints.
â€¢ For approaching this part of the assignment, please be sure that you are familiar
with the congestion control algorithms and how to change them using the correct
method in C (see Appendix B for more information).
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). You've
learned that TCP is reliable by design, so you can assume that all the data have been
passed correctly, and thus, no need to recheck.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
Usage:
â€¢ Receiver:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
â€¢ Sender:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port of the Receiver.
â€¢ ğ‘¨ğ‘³ğ‘®ğ‘¶ â€“ The TCP congestion control algorithm that will be used by the party
member (either ğ’“ğ’†ğ’ğ’ for TCP Reno or ğ’„ğ’–ğ’ƒğ’Šğ’„ for TCP Cubic).
 Communication Networks Course
Page | 3
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a TCP socket between the Sender and the
Receiver.
3) Send the file.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a TCP connection between the Receiver and
the Sender.
2) Get a connection from the sender.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./TCP_Receiver -p 1234 -algo reno
Starting Receiver...
Waiting for TCP connection...
Sender connected, beginning to receive file...
File transfer completed.
Waiting for Sender response...
Sender sent exit message.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 4
Part B â€“ Reliable User Datagram Protocol (Reliable UDP or RUDP) â€“ 40 points
Youâ€™ve learned that while TCP is reliable, it lacks speed and has an overhead data of 20 bytes,
compering to UDP that needs only 8 bytes of overhead data.
Reliable UDP or RUDP, is a protocol that uses the UDP protocol for a faster transmission of
data, while adding a reliability layer to it, but without adding too much overhead data like
TCP.
A simple sketch for a RUDP connection would look something like this:
Your task in this part is to implement a Reliable protocol using UDP only. For simplicity, your
implementation should only support a handshake, closing scheme, error checking,
acknowledgment of received packets, and retransmission of lost packets.
Guidance:
â€¢ You can use ğ‘ ğ‘’ğ‘¡ğ‘ ğ‘œğ‘ğ‘˜ğ‘œğ‘ğ‘¡(2) for detecting a timeout.
â€¢ You need to build your own protocol, as Reliable UDP isnâ€™t a standard protocol (see a
draft of RUDP in this link), and no official header is provided. You can use this sketch
for a header, but you can come up with your own protocol, as long as it works.
Where:
o ğ‘³ğ’†ğ’ğ’ˆğ’•ğ’‰ is the length of the data itself, without the RUDP header.
o ğ‘ªğ’‰ğ’†ğ’„ğ’Œğ’”ğ’–ğ’ is a 16bit number that validates the correctness of the data.
o ğ‘­ğ’ğ’‚ğ’ˆğ’” is a special byte where we classify the packet itself (SYN, ACK, etc.).
â€¢ In your PDF, you must explain how your implementation of RUDP works â€“ How does
it detect a timeout to do retransmissions, how does the handshake work, what is the
header overhead, etc.
â€¢ For this part, youâ€™ll write three files: ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¨ğ‘·ğ‘°. ğ’„, ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and
ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
Reliable UDP Header proposed sketch
Byte 0 Byte 1 Byte 2 Byte 3
Length (2 Bytes) Checksum (2 Bytes)
Flags (1 Byte)
Figure 1 - RUDP Protocol Architecture, Geeksforgeeks
 Communication Networks Course
Page | 5
Notes:
â€¢ The Sender will send a random generated file and the Receiver will receive it and
measure the time it took for his program to receive the file. The file size should be at
least 2MB.
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). But, as the
RUDP is based on UDP, itâ€™s not reliable. You must use some form of error checking
(like checksum) to ensure that the packet wasnâ€™t alerted during the transfer.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
â€¢ The RUDP needs support only 1 sender and 1 receiver, for simplicity purposes.
Usage:
â€¢ Receiver:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
â€¢ Sender:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port that both the Sender and the Receiver will use.
The ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„ file will contain all the implementations of the RUDP API functions (That is, to
prevent reusing the same chuck of code both in the Sender and the Receiver.).
The API should support at the bare minimum the following functions (you decide what
parameters to implement, and what are the names of the functions, as long as the API is
explained in the PDF):
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘œğ‘ğ‘˜ğ‘’ğ‘¡() â€“ Creating a RUDP socket and creating a handshake between two
peers.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘’ğ‘›ğ‘‘() â€“ Sending data to the peer. The function should wait for an
acknowledgment packet, and if it didnâ€™t receive any, retransmits the data.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘Ÿğ‘’ğ‘ğ‘£() â€“ Receive data from a peer.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ğ‘™ğ‘œğ‘ ğ‘’() â€“ Closes a connection between peers.
 Communication Networks Course
Page | 6
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a UDP socket between the Sender and the
Receiver.
3) Send the file via the RUDP protocol.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a UDP connection between the Receiver and
the Sender.
2) Get a connection from the sender, by the custom
RUDP protocol youâ€™ve built.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./RUDP_Receiver -p 1234
Starting Receiver...
Waiting for RUDP connection...
Connection request received, sending ACK.
Sender connected, beginning to receive file...
File transfer completed.
ACK sent.
Waiting for Sender response...
Sender sent exit message.
ACK sent.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 7
Part C â€“ Research â€“ 30 points
In this part, youâ€™ll conduct research about your implementations of part A and part B.
In the research itself, each one of the versions (TCP version and UDP version) will be run at
least 5 times (meaning that the file transfer will occur at least 5 times) by the following
conditions:
â€¢ For TCP, youâ€™ll run it in TCP Reno and TCP Cubic, alternating each time, for each
scenario, meaning that you run 5 times with TCP Reno in both Sender and Receiver,
and 5 times with TCP Cubic in both Sender and Receiver.
Bonus (5 points): Create a very large data set â€“ 5 times with TCP Reno in both Sender
and Receiver, 5 times with TCP Reno in Sender and TCP Cubic in Receiver, 5 times
with TCP Cubic in Sender and TCP Reno in Receiver, and 5 times with TCP Cubic in
both Sender and Receiver. This will give you a data set large enough, which allows
you to work with, compare with and to reach a definite conclusion.
â€¢ For RUDP, you will run it 5 times for each scenario.
â€¢ For both TCP and RUDP, you will run them on those scenarios of packet loss:
o 0% packet loss â€“ Control group, simulating perfect connection.
o 2% packet loss â€“ Simulating unstable connection that commonly occur.
o 5% packet loss â€“ Simulating bad connection.
o 10% packet loss â€“ Simulating extremely poor connection.
For each scenario, you must provide a filtered PCAP file and relevant screenshots that
explain each one of the steps in the process. (10 points)
After youâ€™ve gathered the data set for both TCP and Reliable UDP, answer the following
questions:
1) In TCP, which congestion control algorithm gave better results overall? TCP Reno or
TCP Cubic? Which one gave better results on high packet loss? Explain how you came
to this conclusion based on the data set youâ€™ve gathered. (5 points)
2) How did your implementation of Reliable UDP perform overall compared to regular
TCP? Which one is better for high packet loss? (5 points)
3) According to the data youâ€™ve gathered, in which scenarios and applications would we
prefer to use TCP and in which situations would we prefer to use reliable UDP?
Explain your answer. (5 points)
 Communication Networks Course
Page | 8
×¢× ×• ×¢×œ ×”×©××œ×•×ª ×”×‘××•×ª )5 × ×§×•×“×•×ª(:
â— ×‘"×¨×©×ª ×××™× ×”" ×”×›×•×•× ×” ×”×™× ×œ×¨×©×ª ×©×‘×” ××¢×˜ ×××•×“ ×—×‘×™×œ×•×ª ×”×•×œ×›×•×ª ×œ××™×‘×•×“. ×‘"×§×©×¨ ××¨×•×š" ×”×›×•×•× ×” ×”×™×
×œ×§×©×¨ TCP ×©×™×© ×‘×• ×”×¨×‘×” ×××•×“ ××™×“×¢ ×œ×©×œ×•×—. ××•×¦×¢ ×œ×”×’×“×™×œ ×‘ -TCP ××ª SSThreshold ×‘×ª×—×™×œ×ª ×”×§×©×¨.
×‘××™×–×” ××”××§×¨×™× ×”×‘××™× ×”×©×™× ×•×™ ×”×–×” ×¢×©×•×™ ×œ×”×•×¢×™×œ ×‘××™×“×” ×”××™×¨×‘×™×ª? × ××§.
.1 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
.2 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.3 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.4 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.5 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.6 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.7 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.8 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
â— A ×©×•×œ×— ×œ -B ×—×‘×™×œ×•×ª ××™×“×¢ ×‘×××¦×¢×•×ª ×§×©×¨ TCP. × ×ª×•×Ÿ ×›×™ ×”×§×©×¨ ××ª×—×™×œ ×¢× ×—×œ×•×Ÿ ×‘×’×•×“×œ 1MSS. ×”×§×©×¨
××¡×ª×™×™× ×‘×¤×¢× ×”×¨××©×•× ×” ×©×”×•× ××’×™×¢ ×œ -SSthresh. ×‘××”×œ×š ×”×§×©×¨ ×œ× ××•×‘×“×•×ª ×—×‘×™×œ×•×ª. × ×¡××Ÿ ×‘×§×™×¦×•×¨:
.SSthresh=S*MSS
× ×ª×•×Ÿ ×›×™ ×œ××•×¨×š ×›×œ ×”×§×©×¨ rwnd < MSS*S.
××”×™ ×”×ª×¤×•×§×” ×©×œ ×”×§×©×¨ ×-A ×œ-B( ×‘ -sec / Bytes )×‘×–××Ÿ ×”× "×œ? × ××§×™.
]S*MSS / [lg (S) * RTT*2 ×‘×¢×¨×š .1
]S*MSS / [S^0.5 * RTT*2 ×‘×¢×¨×š .2
S*MSS / RTT ×‘×¢×¨×š .3
S^2)*MSS / RTT( ×‘×¢×¨×š .4
â— ×©×ª×™ ×ª×—× ×•×ª ××ª×§×©×¨×•×ª ×‘××•×¤×Ÿ ××œ×—×•×˜×™ ×‘×©×™×˜×ª N Back Go.
× ×¡××Ÿ ×‘-X ××ª ×¡×¤×¨×ª ×”×‘×™×§×•×¨×ª ×©×œ ×”×ª.×–. ×©×œ×š. ×× ×©× ×™ ×©×•×ª×¤×™× ××’×™×©×™× ××ª ×”×ª×¨×’×™×œ ×™×—×“, X ×”×•× ×¡×¤×¨×ª
×”×‘×™×§×•×¨×ª ×‘×¢×œ×ª ×”×¢×¨×š ×”× ××•×š ×™×•×ª×¨ ××‘×™×Ÿ ×”×©×ª×™×™×.
×§×¦×‘ ×”×ª×§×©×•×¨×ª ×”×•× 8Gbps, ×•×’×•×“×œ ×›×œ ×—×‘×™×œ×” ×”×•× KByte*X. ×’×“×œ×™ ×”-headers ×•×” -Acks ×–× ×™×—×™×.
ï¿½ğ‘’ğ‘ ï¿½/ï¿½ï¿½ 8 , ×•×”××¨×—×§ ×‘×™×Ÿ ×”×ª×—× ×•×ª ×”×•× 1Km. ×§×¦×‘ ×”×”×ª×¤×©×˜×•×ª ×”×•× 10 â‹… 2
×–××Ÿ ×¢×™×‘×•×“ ×”× ×ª×•× ×™× ×‘×ª×—× ×•×ª ×–× ×™×—.
××£ ×—×‘×™×œ×” ×•××£ Ack ×œ× ×”×•×œ×›×™× ×œ××™×‘×•×“.
â— ××”×• X ×©×œ×š?
â— ××” ×¦×¨×™×š ×œ×”×™×•×ª ×’×•×“×œ ×—×œ×•×Ÿ ×”××©×œ×•×— ×›×“×™ ×œ×”×‘×˜×™×— ×ª×¤×•×§×” ××§×¡×™××œ×™×ª?
 Communication Networks Course
Page | 9
Bonus â€“ Improving the Reliable UDP â€“ 15 points
Note: This part isnâ€™t mandatory and is a bonus only!
In this part, youâ€™ll improve your RUDP implementation by adding the concepts of flow
control and congestion control from TCP. Youâ€™re free to choose which algorithms to
implement, as long as you explain in your PDF which algorithms youâ€™ve used. Youâ€™ll probably
need to make changes in the original design of the RUDP. Changes only need to be to the API
itself, ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„.
Points distribution:
â€¢ Flow control improvement â€“ 7 Points
â€¢ Congestion control improvement â€“ 8 points.
Guidance:
â€¢ For flow control, you must use one of the Sliding window techniques: stop-and-wait
ARQ, Go-Back-N or Selective repeat.
â€¢ List of known TCP congestion control algorithms, which you can use any one of them
for this bonus task, or makeup your own:
Figure 2 â€“ List of known TCP congestion control algorithms, Wikipedia
 Communication Networks Course
Page | 10
Appendix A â€“ Linux local packet loss tool
To simulate a packet loss in a local network, we'll use a Linux tool that's called Linux Traffic
Control (ğ‘¡ğ‘). This requires a full Linux installation, so working with WSL won't work.
If the tool isn't installed in your machine, you can install it by using the following commands:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’
If the installation didn't work, you can use the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’2
To create a packet loss scenario, type the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘ğ‘‘ğ‘‘ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
After creating a packet loss scenario, you can change the percentage by typing the following
command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘â„ğ‘ğ‘›ğ‘”ğ‘’ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
To remove the packet loss scenario, write the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘‘ğ‘’ğ‘™ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š
 Communication Networks Course
Page | 11
Appendix B â€“ ğ’ğ’‚ğ’(ğŸ) system calls
This appendixâ€™s purpose is to give you a better understanding of socket handling in C.
A recommended reference is Beejâ€™s Guide to Network Programming, by Brian â€œBeej
Jorgensenâ€ Hall, which gives a lot of information about sockets in C and functions.
Functions and documentation links:
â€¢ ğ’”ğ’ğ’„ğ’Œğ’†ğ’•(ğŸ) â€“ A Factory method system call that creates a socket with the given
parameters.
â€¢ ğ’ƒğ’Šğ’ğ’…(ğŸ) â€“ Whenever we create a new socket, we need to bind it to a specific port in
our machine, â€œto catch a portâ€. The port number is managed and used by the kernel
to link incoming packets to the corresponding application socket. The port numbers
are usually fixed. The ğ‘ğ‘‘ğ‘‘ğ‘Ÿ parameter must match the current socket that is used.
â€¢ ğ’ğ’Šğ’”ğ’•ğ’†ğ’(ğŸ) â€“ The ğ‘™ğ‘–ğ‘ ğ‘¡ğ‘’ğ‘›(2) system call doesn't do anything in the mean of
communication but only memory allocation (malloc) for stream sockets only. If we
won't allocate memory, any incoming connection will fail.
â€¢ ğ’„ğ’ğ’ğ’ğ’†ğ’„ğ’•(ğŸ) â€“ The ğ‘ğ‘œğ‘›ğ‘›ğ‘’ğ‘ğ‘¡(2) system call starts the link between a client and a
specific IP address and port number. The connection would complete when the
other side will call the ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call.
â€¢ ğ’‚ğ’„ğ’„ğ’†ğ’‘ğ’•(ğŸ) â€“ The ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call accepts the incoming stream connection
request from the other side, by the listening socket. This system call completes the
three-way handshake of stream socket (like TCP) and opens a new socket that has a
direct communication channel only with the other party in the handshake.
â€¢ ğ’”ğ’†ğ’ğ’…(ğŸ) and ğ’”ğ’†ğ’ğ’…ğ’•ğ’(ğŸ) â€“ The ğ‘ ğ‘’ğ‘›ğ‘‘(2) and ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system calls are an analogy
for the ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’(2) system call, specifcly for sockets, with flags set to 0. Those system
calls return the number of bytes that were sent through the socket itself, as the
number of bytes can vary. The ğ‘ ğ‘’ğ‘›ğ‘‘(2)system call designed for stream sockets (like
TCP), while the ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system call designed for datagram connection-less
sockets (like UDP). When the ğ‘ ğ‘’ğ‘›ğ‘‘(2) system call returns 0, it means that the other
party closed the connection.
â€¢ ğ’“ğ’†ğ’„ğ’—(ğŸ) and ğ’“ğ’†ğ’„ğ’—ğ’‡ğ’“ğ’ğ’(ğŸ) â€“ The ğ‘Ÿğ‘’ğ‘ğ‘£(2) and ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system calls are an
analogy for the ğ‘Ÿğ‘’ğ‘ğ‘‘(2) system call, specifically for sockets, with flags set to 0.
Those system calls return the number of bytes that were received through the socket
itself, as the number of bytes can vary. The ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call designed for stream
sockets (like TCP), while the ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system call designed for datagram
connection-less sockets (like UDP). When the ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call returns 0, it means
that the other party closed the connection.
â€¢ ğ’„ğ’ğ’ğ’”ğ’†(ğŸ) and ğ’”ğ’‰ğ’–ğ’•ğ’…ğ’ğ’˜ğ’(ğŸ) â€“ The ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) and ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2) system calls close
the socket. While ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) system call closes the whole socket, the ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2)
system call partially closes the socket for read/write.
 Communication Networks Course
Page | 12
Appendix C â€“ Random data generator
The data that you are going to send in this assignment is randomly generated. You can use
your own file with appropriate size or use the following function (or a function of your own)
to generate the data:
/*
* @brief A random data generator function based on srand() and rand().
* @param size The size of the data to generate (up to 2^32 bytes).
* @return A pointer to the buffer.
*/
char *util_generate_random_data(unsigned int size) {
 char *buffer = NULL;
 // Argument check.
 if (size == 0)
 return NULL;
 buffer = (char *)calloc(size, sizeof(char));
 // Error checking.
 if (buffer == NULL)
 return NULL;
 // Randomize the seed of the random number generator.
 srand(time(NULL));
 for (unsigned int i = 0; i < size; i++)
 *(buffer + i) = ((unsigned int)rand() % 256);
 return buffer;
}
 Communication Networks Course
Page | 13
Appendix D â€“ Checksum function
A checksum is a small-sized block of data derived from another block of digital data for the
purpose of detecting errors that may have been introduced during its transmission or
storage. By themselves, checksums are often used to verify data integrity but are not relied
upon to verify data authenticity.
Below is a simple yet efficient implementation of the checksum function, you can use it for
the assignment, but you can implement your own checksum function.
/*
* @brief A checksum function that returns 16 bit checksum for data.
* @param data The data to do the checksum for.
* @param bytes The length of the data in bytes.
* @return The checksum itself as 16 bit unsigned number.
* @note This function is taken from RFC1071, can be found here:
* @note https://tools.ietf.org/html/rfc1071
* @note It is the simplest way to calculate a checksum and is not very strong.
* However, it is good enough for this assignment.
* @note You are free to use any other checksum function as well.
* You can also use this function as such without any change.
*/
unsigned short int calculate_checksum(void *data, unsigned int bytes) {
 unsigned short int *data_pointer = (unsigned short int *)data;
 unsigned int total_sum = 0;
 // Main summing loop
 while (bytes > 1) {
 total_sum += *data_pointer++;
 bytes -= 2;
 }
 // Add left-over byte, if any
 if (bytes > 0)
 total_sum += *((unsigned char *)data_pointer);
 // Fold 32-bit sum to 16 bits
 while (total_sum >> 16)
 total_sum = (total_sum & 0xFFFF) + (total_sum >> 16);
 return (~((unsigned short int)total_sum));
} Communication Networks Course
Page | 1
Assignment 3 â€“ Transport Layer
Assignment Notes and Instructions
This assignment is to be done in pairs only. You must upload all the necessary files in a ZIP
file named after both of the studentâ€™s ID. For example: ğŸğŸğŸ‘ğŸ’ğŸ“ğŸ”ğŸ•ğŸ–ğŸ—_ğŸ—ğŸ–ğŸ•ğŸ”ğŸ“ğŸ’ğŸ‘ğŸğŸ. ğ’›ğ’Šğ’‘.
1) The assignment must be submitted by the date specified in the submission box.
2) All the assignment files (Code, Wireshark pcap files, PDF) must be submitted in a ZIP file. The
PDF must contain all the necessary screenshots with a description for each one of them.
3) The assignment must be done in pairs only. In exceptional cases, you should send an email to
the course coordinator.
4) You can use any reference material available through the course Moodle website or any
material passed during the exercises.
5) You can use any reference from the web, but copying codes from websites is forbidden; this
includes codes from other GitHub repositories. A student who gets caught in the act will
automatically fail this assignment (score 0). Any website youâ€™ve used to solve the
assignment, every website you used to solve the assignment must be noted in the PDF.
6) No delays in submission without special permission. Lateness without approval will result in
failure of the assignment (score 0).
7) All submissions will be submitted via the course's Moodle website. Email submissions will not
be accepted, resulting in a failure in the assignment.
8) The order and design of the code must be carefully considered. Make sure that the program
output is as clear as possible, comments in the code, and meaningful variable names. You
must also submit a makefile that compiles all the programs.
9) The assignment code must be written in C only.
10) The assignment is personal for each pair, and you should not accept help from other people,
whether outside the university or inside it. You can contact the course staff during reception
hours for help or raise a question in the course forum. Do not transfer code sections
between students, upload solutions or parts of solutions to websites on the Internet or in
various communication groups.
11) Students who copy a solution will receive a 0 in all assignments in the course and a report will
be made to the institutional disciplinary committee.
12) All code files of the assignment are required to both compile and run properly on the Ubuntu
22.04 LTS operating system. This is the operating system where the submissions will be
tested. You mustnâ€™t code it in Windows, as it uses different API for sockets. WSL wonâ€™t work,
as the task needs a tool that works only in a fully Linux environment.
Good Luck!
 Communication Networks Course
Page | 2
Part A â€“ Transmission Control Protocol (TCP) â€“ 30 points
In this part, youâ€™ll write two program files: ğ‘»ğ‘ªğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and ğ‘»ğ‘ªğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
The Sender will send a randomly generated file and the Receiver will receive it and measure
the time it took for his program to receive the file. The file size should be at least 2MB.
When running the Sender and Receiver, they both should support two standard congestion
control algorithms: TCP Reno and TCP Cubic.
Notes:
â€¢ The main goal of this part is to get familiar with the TCP concept of sending
messages between two endpoints.
â€¢ For approaching this part of the assignment, please be sure that you are familiar
with the congestion control algorithms and how to change them using the correct
method in C (see Appendix B for more information).
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). You've
learned that TCP is reliable by design, so you can assume that all the data have been
passed correctly, and thus, no need to recheck.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
Usage:
â€¢ Receiver:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
â€¢ Sender:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port of the Receiver.
â€¢ ğ‘¨ğ‘³ğ‘®ğ‘¶ â€“ The TCP congestion control algorithm that will be used by the party
member (either ğ’“ğ’†ğ’ğ’ for TCP Reno or ğ’„ğ’–ğ’ƒğ’Šğ’„ for TCP Cubic).
 Communication Networks Course
Page | 3
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a TCP socket between the Sender and the
Receiver.
3) Send the file.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a TCP connection between the Receiver and
the Sender.
2) Get a connection from the sender.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./TCP_Receiver -p 1234 -algo reno
Starting Receiver...
Waiting for TCP connection...
Sender connected, beginning to receive file...
File transfer completed.
Waiting for Sender response...
Sender sent exit message.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 4
Part B â€“ Reliable User Datagram Protocol (Reliable UDP or RUDP) â€“ 40 points
Youâ€™ve learned that while TCP is reliable, it lacks speed and has an overhead data of 20 bytes,
compering to UDP that needs only 8 bytes of overhead data.
Reliable UDP or RUDP, is a protocol that uses the UDP protocol for a faster transmission of
data, while adding a reliability layer to it, but without adding too much overhead data like
TCP.
A simple sketch for a RUDP connection would look something like this:
Your task in this part is to implement a Reliable protocol using UDP only. For simplicity, your
implementation should only support a handshake, closing scheme, error checking,
acknowledgment of received packets, and retransmission of lost packets.
Guidance:
â€¢ You can use ğ‘ ğ‘’ğ‘¡ğ‘ ğ‘œğ‘ğ‘˜ğ‘œğ‘ğ‘¡(2) for detecting a timeout.
â€¢ You need to build your own protocol, as Reliable UDP isnâ€™t a standard protocol (see a
draft of RUDP in this link), and no official header is provided. You can use this sketch
for a header, but you can come up with your own protocol, as long as it works.
Where:
o ğ‘³ğ’†ğ’ğ’ˆğ’•ğ’‰ is the length of the data itself, without the RUDP header.
o ğ‘ªğ’‰ğ’†ğ’„ğ’Œğ’”ğ’–ğ’ is a 16bit number that validates the correctness of the data.
o ğ‘­ğ’ğ’‚ğ’ˆğ’” is a special byte where we classify the packet itself (SYN, ACK, etc.).
â€¢ In your PDF, you must explain how your implementation of RUDP works â€“ How does
it detect a timeout to do retransmissions, how does the handshake work, what is the
header overhead, etc.
â€¢ For this part, youâ€™ll write three files: ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¨ğ‘·ğ‘°. ğ’„, ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and
ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
Reliable UDP Header proposed sketch
Byte 0 Byte 1 Byte 2 Byte 3
Length (2 Bytes) Checksum (2 Bytes)
Flags (1 Byte)
Figure 1 - RUDP Protocol Architecture, Geeksforgeeks
 Communication Networks Course
Page | 5
Notes:
â€¢ The Sender will send a random generated file and the Receiver will receive it and
measure the time it took for his program to receive the file. The file size should be at
least 2MB.
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). But, as the
RUDP is based on UDP, itâ€™s not reliable. You must use some form of error checking
(like checksum) to ensure that the packet wasnâ€™t alerted during the transfer.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
â€¢ The RUDP needs support only 1 sender and 1 receiver, for simplicity purposes.
Usage:
â€¢ Receiver:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
â€¢ Sender:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port that both the Sender and the Receiver will use.
The ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„ file will contain all the implementations of the RUDP API functions (That is, to
prevent reusing the same chuck of code both in the Sender and the Receiver.).
The API should support at the bare minimum the following functions (you decide what
parameters to implement, and what are the names of the functions, as long as the API is
explained in the PDF):
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘œğ‘ğ‘˜ğ‘’ğ‘¡() â€“ Creating a RUDP socket and creating a handshake between two
peers.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘’ğ‘›ğ‘‘() â€“ Sending data to the peer. The function should wait for an
acknowledgment packet, and if it didnâ€™t receive any, retransmits the data.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘Ÿğ‘’ğ‘ğ‘£() â€“ Receive data from a peer.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ğ‘™ğ‘œğ‘ ğ‘’() â€“ Closes a connection between peers.
 Communication Networks Course
Page | 6
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a UDP socket between the Sender and the
Receiver.
3) Send the file via the RUDP protocol.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a UDP connection between the Receiver and
the Sender.
2) Get a connection from the sender, by the custom
RUDP protocol youâ€™ve built.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./RUDP_Receiver -p 1234
Starting Receiver...
Waiting for RUDP connection...
Connection request received, sending ACK.
Sender connected, beginning to receive file...
File transfer completed.
ACK sent.
Waiting for Sender response...
Sender sent exit message.
ACK sent.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 7
Part C â€“ Research â€“ 30 points
In this part, youâ€™ll conduct research about your implementations of part A and part B.
In the research itself, each one of the versions (TCP version and UDP version) will be run at
least 5 times (meaning that the file transfer will occur at least 5 times) by the following
conditions:
â€¢ For TCP, youâ€™ll run it in TCP Reno and TCP Cubic, alternating each time, for each
scenario, meaning that you run 5 times with TCP Reno in both Sender and Receiver,
and 5 times with TCP Cubic in both Sender and Receiver.
Bonus (5 points): Create a very large data set â€“ 5 times with TCP Reno in both Sender
and Receiver, 5 times with TCP Reno in Sender and TCP Cubic in Receiver, 5 times
with TCP Cubic in Sender and TCP Reno in Receiver, and 5 times with TCP Cubic in
both Sender and Receiver. This will give you a data set large enough, which allows
you to work with, compare with and to reach a definite conclusion.
â€¢ For RUDP, you will run it 5 times for each scenario.
â€¢ For both TCP and RUDP, you will run them on those scenarios of packet loss:
o 0% packet loss â€“ Control group, simulating perfect connection.
o 2% packet loss â€“ Simulating unstable connection that commonly occur.
o 5% packet loss â€“ Simulating bad connection.
o 10% packet loss â€“ Simulating extremely poor connection.
For each scenario, you must provide a filtered PCAP file and relevant screenshots that
explain each one of the steps in the process. (10 points)
After youâ€™ve gathered the data set for both TCP and Reliable UDP, answer the following
questions:
1) In TCP, which congestion control algorithm gave better results overall? TCP Reno or
TCP Cubic? Which one gave better results on high packet loss? Explain how you came
to this conclusion based on the data set youâ€™ve gathered. (5 points)
2) How did your implementation of Reliable UDP perform overall compared to regular
TCP? Which one is better for high packet loss? (5 points)
3) According to the data youâ€™ve gathered, in which scenarios and applications would we
prefer to use TCP and in which situations would we prefer to use reliable UDP?
Explain your answer. (5 points)
 Communication Networks Course
Page | 8
×¢× ×• ×¢×œ ×”×©××œ×•×ª ×”×‘××•×ª )5 × ×§×•×“×•×ª(:
â— ×‘"×¨×©×ª ×××™× ×”" ×”×›×•×•× ×” ×”×™× ×œ×¨×©×ª ×©×‘×” ××¢×˜ ×××•×“ ×—×‘×™×œ×•×ª ×”×•×œ×›×•×ª ×œ××™×‘×•×“. ×‘"×§×©×¨ ××¨×•×š" ×”×›×•×•× ×” ×”×™×
×œ×§×©×¨ TCP ×©×™×© ×‘×• ×”×¨×‘×” ×××•×“ ××™×“×¢ ×œ×©×œ×•×—. ××•×¦×¢ ×œ×”×’×“×™×œ ×‘ -TCP ××ª SSThreshold ×‘×ª×—×™×œ×ª ×”×§×©×¨.
×‘××™×–×” ××”××§×¨×™× ×”×‘××™× ×”×©×™× ×•×™ ×”×–×” ×¢×©×•×™ ×œ×”×•×¢×™×œ ×‘××™×“×” ×”××™×¨×‘×™×ª? × ××§.
.1 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
.2 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.3 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.4 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.5 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.6 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.7 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.8 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
â— A ×©×•×œ×— ×œ -B ×—×‘×™×œ×•×ª ××™×“×¢ ×‘×××¦×¢×•×ª ×§×©×¨ TCP. × ×ª×•×Ÿ ×›×™ ×”×§×©×¨ ××ª×—×™×œ ×¢× ×—×œ×•×Ÿ ×‘×’×•×“×œ 1MSS. ×”×§×©×¨
××¡×ª×™×™× ×‘×¤×¢× ×”×¨××©×•× ×” ×©×”×•× ××’×™×¢ ×œ -SSthresh. ×‘××”×œ×š ×”×§×©×¨ ×œ× ××•×‘×“×•×ª ×—×‘×™×œ×•×ª. × ×¡××Ÿ ×‘×§×™×¦×•×¨:
.SSthresh=S*MSS
× ×ª×•×Ÿ ×›×™ ×œ××•×¨×š ×›×œ ×”×§×©×¨ rwnd < MSS*S.
××”×™ ×”×ª×¤×•×§×” ×©×œ ×”×§×©×¨ ×-A ×œ-B( ×‘ -sec / Bytes )×‘×–××Ÿ ×”× "×œ? × ××§×™.
]S*MSS / [lg (S) * RTT*2 ×‘×¢×¨×š .1
]S*MSS / [S^0.5 * RTT*2 ×‘×¢×¨×š .2
S*MSS / RTT ×‘×¢×¨×š .3
S^2)*MSS / RTT( ×‘×¢×¨×š .4
â— ×©×ª×™ ×ª×—× ×•×ª ××ª×§×©×¨×•×ª ×‘××•×¤×Ÿ ××œ×—×•×˜×™ ×‘×©×™×˜×ª N Back Go.
× ×¡××Ÿ ×‘-X ××ª ×¡×¤×¨×ª ×”×‘×™×§×•×¨×ª ×©×œ ×”×ª.×–. ×©×œ×š. ×× ×©× ×™ ×©×•×ª×¤×™× ××’×™×©×™× ××ª ×”×ª×¨×’×™×œ ×™×—×“, X ×”×•× ×¡×¤×¨×ª
×”×‘×™×§×•×¨×ª ×‘×¢×œ×ª ×”×¢×¨×š ×”× ××•×š ×™×•×ª×¨ ××‘×™×Ÿ ×”×©×ª×™×™×.
×§×¦×‘ ×”×ª×§×©×•×¨×ª ×”×•× 8Gbps, ×•×’×•×“×œ ×›×œ ×—×‘×™×œ×” ×”×•× KByte*X. ×’×“×œ×™ ×”-headers ×•×” -Acks ×–× ×™×—×™×.
ï¿½ğ‘’ğ‘ ï¿½/ï¿½ï¿½ 8 , ×•×”××¨×—×§ ×‘×™×Ÿ ×”×ª×—× ×•×ª ×”×•× 1Km. ×§×¦×‘ ×”×”×ª×¤×©×˜×•×ª ×”×•× 10 â‹… 2
×–××Ÿ ×¢×™×‘×•×“ ×”× ×ª×•× ×™× ×‘×ª×—× ×•×ª ×–× ×™×—.
××£ ×—×‘×™×œ×” ×•××£ Ack ×œ× ×”×•×œ×›×™× ×œ××™×‘×•×“.
â— ××”×• X ×©×œ×š?
â— ××” ×¦×¨×™×š ×œ×”×™×•×ª ×’×•×“×œ ×—×œ×•×Ÿ ×”××©×œ×•×— ×›×“×™ ×œ×”×‘×˜×™×— ×ª×¤×•×§×” ××§×¡×™××œ×™×ª?
 Communication Networks Course
Page | 9
Bonus â€“ Improving the Reliable UDP â€“ 15 points
Note: This part isnâ€™t mandatory and is a bonus only!
In this part, youâ€™ll improve your RUDP implementation by adding the concepts of flow
control and congestion control from TCP. Youâ€™re free to choose which algorithms to
implement, as long as you explain in your PDF which algorithms youâ€™ve used. Youâ€™ll probably
need to make changes in the original design of the RUDP. Changes only need to be to the API
itself, ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„.
Points distribution:
â€¢ Flow control improvement â€“ 7 Points
â€¢ Congestion control improvement â€“ 8 points.
Guidance:
â€¢ For flow control, you must use one of the Sliding window techniques: stop-and-wait
ARQ, Go-Back-N or Selective repeat.
â€¢ List of known TCP congestion control algorithms, which you can use any one of them
for this bonus task, or makeup your own:
Figure 2 â€“ List of known TCP congestion control algorithms, Wikipedia
 Communication Networks Course
Page | 10
Appendix A â€“ Linux local packet loss tool
To simulate a packet loss in a local network, we'll use a Linux tool that's called Linux Traffic
Control (ğ‘¡ğ‘). This requires a full Linux installation, so working with WSL won't work.
If the tool isn't installed in your machine, you can install it by using the following commands:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’
If the installation didn't work, you can use the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’2
To create a packet loss scenario, type the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘ğ‘‘ğ‘‘ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
After creating a packet loss scenario, you can change the percentage by typing the following
command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘â„ğ‘ğ‘›ğ‘”ğ‘’ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
To remove the packet loss scenario, write the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘‘ğ‘’ğ‘™ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š
 Communication Networks Course
Page | 11
Appendix B â€“ ğ’ğ’‚ğ’(ğŸ) system calls
This appendixâ€™s purpose is to give you a better understanding of socket handling in C.
A recommended reference is Beejâ€™s Guide to Network Programming, by Brian â€œBeej
Jorgensenâ€ Hall, which gives a lot of information about sockets in C and functions.
Functions and documentation links:
â€¢ ğ’”ğ’ğ’„ğ’Œğ’†ğ’•(ğŸ) â€“ A Factory method system call that creates a socket with the given
parameters.
â€¢ ğ’ƒğ’Šğ’ğ’…(ğŸ) â€“ Whenever we create a new socket, we need to bind it to a specific port in
our machine, â€œto catch a portâ€. The port number is managed and used by the kernel
to link incoming packets to the corresponding application socket. The port numbers
are usually fixed. The ğ‘ğ‘‘ğ‘‘ğ‘Ÿ parameter must match the current socket that is used.
â€¢ ğ’ğ’Šğ’”ğ’•ğ’†ğ’(ğŸ) â€“ The ğ‘™ğ‘–ğ‘ ğ‘¡ğ‘’ğ‘›(2) system call doesn't do anything in the mean of
communication but only memory allocation (malloc) for stream sockets only. If we
won't allocate memory, any incoming connection will fail.
â€¢ ğ’„ğ’ğ’ğ’ğ’†ğ’„ğ’•(ğŸ) â€“ The ğ‘ğ‘œğ‘›ğ‘›ğ‘’ğ‘ğ‘¡(2) system call starts the link between a client and a
specific IP address and port number. The connection would complete when the
other side will call the ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call.
â€¢ ğ’‚ğ’„ğ’„ğ’†ğ’‘ğ’•(ğŸ) â€“ The ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call accepts the incoming stream connection
request from the other side, by the listening socket. This system call completes the
three-way handshake of stream socket (like TCP) and opens a new socket that has a
direct communication channel only with the other party in the handshake.
â€¢ ğ’”ğ’†ğ’ğ’…(ğŸ) and ğ’”ğ’†ğ’ğ’…ğ’•ğ’(ğŸ) â€“ The ğ‘ ğ‘’ğ‘›ğ‘‘(2) and ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system calls are an analogy
for the ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’(2) system call, specifcly for sockets, with flags set to 0. Those system
calls return the number of bytes that were sent through the socket itself, as the
number of bytes can vary. The ğ‘ ğ‘’ğ‘›ğ‘‘(2)system call designed for stream sockets (like
TCP), while the ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system call designed for datagram connection-less
sockets (like UDP). When the ğ‘ ğ‘’ğ‘›ğ‘‘(2) system call returns 0, it means that the other
party closed the connection.
â€¢ ğ’“ğ’†ğ’„ğ’—(ğŸ) and ğ’“ğ’†ğ’„ğ’—ğ’‡ğ’“ğ’ğ’(ğŸ) â€“ The ğ‘Ÿğ‘’ğ‘ğ‘£(2) and ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system calls are an
analogy for the ğ‘Ÿğ‘’ğ‘ğ‘‘(2) system call, specifically for sockets, with flags set to 0.
Those system calls return the number of bytes that were received through the socket
itself, as the number of bytes can vary. The ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call designed for stream
sockets (like TCP), while the ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system call designed for datagram
connection-less sockets (like UDP). When the ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call returns 0, it means
that the other party closed the connection.
â€¢ ğ’„ğ’ğ’ğ’”ğ’†(ğŸ) and ğ’”ğ’‰ğ’–ğ’•ğ’…ğ’ğ’˜ğ’(ğŸ) â€“ The ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) and ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2) system calls close
the socket. While ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) system call closes the whole socket, the ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2)
system call partially closes the socket for read/write.
 Communication Networks Course
Page | 12
Appendix C â€“ Random data generator
The data that you are going to send in this assignment is randomly generated. You can use
your own file with appropriate size or use the following function (or a function of your own)
to generate the data:
/*
* @brief A random data generator function based on srand() and rand().
* @param size The size of the data to generate (up to 2^32 bytes).
* @return A pointer to the buffer.
*/
char *util_generate_random_data(unsigned int size) {
 char *buffer = NULL;
 // Argument check.
 if (size == 0)
 return NULL;
 buffer = (char *)calloc(size, sizeof(char));
 // Error checking.
 if (buffer == NULL)
 return NULL;
 // Randomize the seed of the random number generator.
 srand(time(NULL));
 for (unsigned int i = 0; i < size; i++)
 *(buffer + i) = ((unsigned int)rand() % 256);
 return buffer;
}
 Communication Networks Course
Page | 13
Appendix D â€“ Checksum function
A checksum is a small-sized block of data derived from another block of digital data for the
purpose of detecting errors that may have been introduced during its transmission or
storage. By themselves, checksums are often used to verify data integrity but are not relied
upon to verify data authenticity.
Below is a simple yet efficient implementation of the checksum function, you can use it for
the assignment, but you can implement your own checksum function.
/*
* @brief A checksum function that returns 16 bit checksum for data.
* @param data The data to do the checksum for.
* @param bytes The length of the data in bytes.
* @return The checksum itself as 16 bit unsigned number.
* @note This function is taken from RFC1071, can be found here:
* @note https://tools.ietf.org/html/rfc1071
* @note It is the simplest way to calculate a checksum and is not very strong.
* However, it is good enough for this assignment.
* @note You are free to use any other checksum function as well.
* You can also use this function as such without any change.
*/
unsigned short int calculate_checksum(void *data, unsigned int bytes) {
 unsigned short int *data_pointer = (unsigned short int *)data;
 unsigned int total_sum = 0;
 // Main summing loop
 while (bytes > 1) {
 total_sum += *data_pointer++;
 bytes -= 2;
 }
 // Add left-over byte, if any
 if (bytes > 0)
 total_sum += *((unsigned char *)data_pointer);
 // Fold 32-bit sum to 16 bits
 while (total_sum >> 16)
 total_sum = (total_sum & 0xFFFF) + (total_sum >> 16);
 return (~((unsigned short int)total_sum));
} Communication Networks Course
Page | 1
Assignment 3 â€“ Transport Layer
Assignment Notes and Instructions
This assignment is to be done in pairs only. You must upload all the necessary files in a ZIP
file named after both of the studentâ€™s ID. For example: ğŸğŸğŸ‘ğŸ’ğŸ“ğŸ”ğŸ•ğŸ–ğŸ—_ğŸ—ğŸ–ğŸ•ğŸ”ğŸ“ğŸ’ğŸ‘ğŸğŸ. ğ’›ğ’Šğ’‘.
1) The assignment must be submitted by the date specified in the submission box.
2) All the assignment files (Code, Wireshark pcap files, PDF) must be submitted in a ZIP file. The
PDF must contain all the necessary screenshots with a description for each one of them.
3) The assignment must be done in pairs only. In exceptional cases, you should send an email to
the course coordinator.
4) You can use any reference material available through the course Moodle website or any
material passed during the exercises.
5) You can use any reference from the web, but copying codes from websites is forbidden; this
includes codes from other GitHub repositories. A student who gets caught in the act will
automatically fail this assignment (score 0). Any website youâ€™ve used to solve the
assignment, every website you used to solve the assignment must be noted in the PDF.
6) No delays in submission without special permission. Lateness without approval will result in
failure of the assignment (score 0).
7) All submissions will be submitted via the course's Moodle website. Email submissions will not
be accepted, resulting in a failure in the assignment.
8) The order and design of the code must be carefully considered. Make sure that the program
output is as clear as possible, comments in the code, and meaningful variable names. You
must also submit a makefile that compiles all the programs.
9) The assignment code must be written in C only.
10) The assignment is personal for each pair, and you should not accept help from other people,
whether outside the university or inside it. You can contact the course staff during reception
hours for help or raise a question in the course forum. Do not transfer code sections
between students, upload solutions or parts of solutions to websites on the Internet or in
various communication groups.
11) Students who copy a solution will receive a 0 in all assignments in the course and a report will
be made to the institutional disciplinary committee.
12) All code files of the assignment are required to both compile and run properly on the Ubuntu
22.04 LTS operating system. This is the operating system where the submissions will be
tested. You mustnâ€™t code it in Windows, as it uses different API for sockets. WSL wonâ€™t work,
as the task needs a tool that works only in a fully Linux environment.
Good Luck!
 Communication Networks Course
Page | 2
Part A â€“ Transmission Control Protocol (TCP) â€“ 30 points
In this part, youâ€™ll write two program files: ğ‘»ğ‘ªğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and ğ‘»ğ‘ªğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
The Sender will send a randomly generated file and the Receiver will receive it and measure
the time it took for his program to receive the file. The file size should be at least 2MB.
When running the Sender and Receiver, they both should support two standard congestion
control algorithms: TCP Reno and TCP Cubic.
Notes:
â€¢ The main goal of this part is to get familiar with the TCP concept of sending
messages between two endpoints.
â€¢ For approaching this part of the assignment, please be sure that you are familiar
with the congestion control algorithms and how to change them using the correct
method in C (see Appendix B for more information).
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). You've
learned that TCP is reliable by design, so you can assume that all the data have been
passed correctly, and thus, no need to recheck.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
Usage:
â€¢ Receiver:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
â€¢ Sender:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port of the Receiver.
â€¢ ğ‘¨ğ‘³ğ‘®ğ‘¶ â€“ The TCP congestion control algorithm that will be used by the party
member (either ğ’“ğ’†ğ’ğ’ for TCP Reno or ğ’„ğ’–ğ’ƒğ’Šğ’„ for TCP Cubic).
 Communication Networks Course
Page | 3
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a TCP socket between the Sender and the
Receiver.
3) Send the file.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a TCP connection between the Receiver and
the Sender.
2) Get a connection from the sender.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./TCP_Receiver -p 1234 -algo reno
Starting Receiver...
Waiting for TCP connection...
Sender connected, beginning to receive file...
File transfer completed.
Waiting for Sender response...
Sender sent exit message.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 4
Part B â€“ Reliable User Datagram Protocol (Reliable UDP or RUDP) â€“ 40 points
Youâ€™ve learned that while TCP is reliable, it lacks speed and has an overhead data of 20 bytes,
compering to UDP that needs only 8 bytes of overhead data.
Reliable UDP or RUDP, is a protocol that uses the UDP protocol for a faster transmission of
data, while adding a reliability layer to it, but without adding too much overhead data like
TCP.
A simple sketch for a RUDP connection would look something like this:
Your task in this part is to implement a Reliable protocol using UDP only. For simplicity, your
implementation should only support a handshake, closing scheme, error checking,
acknowledgment of received packets, and retransmission of lost packets.
Guidance:
â€¢ You can use ğ‘ ğ‘’ğ‘¡ğ‘ ğ‘œğ‘ğ‘˜ğ‘œğ‘ğ‘¡(2) for detecting a timeout.
â€¢ You need to build your own protocol, as Reliable UDP isnâ€™t a standard protocol (see a
draft of RUDP in this link), and no official header is provided. You can use this sketch
for a header, but you can come up with your own protocol, as long as it works.
Where:
o ğ‘³ğ’†ğ’ğ’ˆğ’•ğ’‰ is the length of the data itself, without the RUDP header.
o ğ‘ªğ’‰ğ’†ğ’„ğ’Œğ’”ğ’–ğ’ is a 16bit number that validates the correctness of the data.
o ğ‘­ğ’ğ’‚ğ’ˆğ’” is a special byte where we classify the packet itself (SYN, ACK, etc.).
â€¢ In your PDF, you must explain how your implementation of RUDP works â€“ How does
it detect a timeout to do retransmissions, how does the handshake work, what is the
header overhead, etc.
â€¢ For this part, youâ€™ll write three files: ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¨ğ‘·ğ‘°. ğ’„, ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and
ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
Reliable UDP Header proposed sketch
Byte 0 Byte 1 Byte 2 Byte 3
Length (2 Bytes) Checksum (2 Bytes)
Flags (1 Byte)
Figure 1 - RUDP Protocol Architecture, Geeksforgeeks
 Communication Networks Course
Page | 5
Notes:
â€¢ The Sender will send a random generated file and the Receiver will receive it and
measure the time it took for his program to receive the file. The file size should be at
least 2MB.
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). But, as the
RUDP is based on UDP, itâ€™s not reliable. You must use some form of error checking
(like checksum) to ensure that the packet wasnâ€™t alerted during the transfer.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
â€¢ The RUDP needs support only 1 sender and 1 receiver, for simplicity purposes.
Usage:
â€¢ Receiver:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
â€¢ Sender:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port that both the Sender and the Receiver will use.
The ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„ file will contain all the implementations of the RUDP API functions (That is, to
prevent reusing the same chuck of code both in the Sender and the Receiver.).
The API should support at the bare minimum the following functions (you decide what
parameters to implement, and what are the names of the functions, as long as the API is
explained in the PDF):
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘œğ‘ğ‘˜ğ‘’ğ‘¡() â€“ Creating a RUDP socket and creating a handshake between two
peers.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘’ğ‘›ğ‘‘() â€“ Sending data to the peer. The function should wait for an
acknowledgment packet, and if it didnâ€™t receive any, retransmits the data.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘Ÿğ‘’ğ‘ğ‘£() â€“ Receive data from a peer.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ğ‘™ğ‘œğ‘ ğ‘’() â€“ Closes a connection between peers.
 Communication Networks Course
Page | 6
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a UDP socket between the Sender and the
Receiver.
3) Send the file via the RUDP protocol.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a UDP connection between the Receiver and
the Sender.
2) Get a connection from the sender, by the custom
RUDP protocol youâ€™ve built.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./RUDP_Receiver -p 1234
Starting Receiver...
Waiting for RUDP connection...
Connection request received, sending ACK.
Sender connected, beginning to receive file...
File transfer completed.
ACK sent.
Waiting for Sender response...
Sender sent exit message.
ACK sent.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 7
Part C â€“ Research â€“ 30 points
In this part, youâ€™ll conduct research about your implementations of part A and part B.
In the research itself, each one of the versions (TCP version and UDP version) will be run at
least 5 times (meaning that the file transfer will occur at least 5 times) by the following
conditions:
â€¢ For TCP, youâ€™ll run it in TCP Reno and TCP Cubic, alternating each time, for each
scenario, meaning that you run 5 times with TCP Reno in both Sender and Receiver,
and 5 times with TCP Cubic in both Sender and Receiver.
Bonus (5 points): Create a very large data set â€“ 5 times with TCP Reno in both Sender
and Receiver, 5 times with TCP Reno in Sender and TCP Cubic in Receiver, 5 times
with TCP Cubic in Sender and TCP Reno in Receiver, and 5 times with TCP Cubic in
both Sender and Receiver. This will give you a data set large enough, which allows
you to work with, compare with and to reach a definite conclusion.
â€¢ For RUDP, you will run it 5 times for each scenario.
â€¢ For both TCP and RUDP, you will run them on those scenarios of packet loss:
o 0% packet loss â€“ Control group, simulating perfect connection.
o 2% packet loss â€“ Simulating unstable connection that commonly occur.
o 5% packet loss â€“ Simulating bad connection.
o 10% packet loss â€“ Simulating extremely poor connection.
For each scenario, you must provide a filtered PCAP file and relevant screenshots that
explain each one of the steps in the process. (10 points)
After youâ€™ve gathered the data set for both TCP and Reliable UDP, answer the following
questions:
1) In TCP, which congestion control algorithm gave better results overall? TCP Reno or
TCP Cubic? Which one gave better results on high packet loss? Explain how you came
to this conclusion based on the data set youâ€™ve gathered. (5 points)
2) How did your implementation of Reliable UDP perform overall compared to regular
TCP? Which one is better for high packet loss? (5 points)
3) According to the data youâ€™ve gathered, in which scenarios and applications would we
prefer to use TCP and in which situations would we prefer to use reliable UDP?
Explain your answer. (5 points)
 Communication Networks Course
Page | 8
×¢× ×• ×¢×œ ×”×©××œ×•×ª ×”×‘××•×ª )5 × ×§×•×“×•×ª(:
â— ×‘"×¨×©×ª ×××™× ×”" ×”×›×•×•× ×” ×”×™× ×œ×¨×©×ª ×©×‘×” ××¢×˜ ×××•×“ ×—×‘×™×œ×•×ª ×”×•×œ×›×•×ª ×œ××™×‘×•×“. ×‘"×§×©×¨ ××¨×•×š" ×”×›×•×•× ×” ×”×™×
×œ×§×©×¨ TCP ×©×™×© ×‘×• ×”×¨×‘×” ×××•×“ ××™×“×¢ ×œ×©×œ×•×—. ××•×¦×¢ ×œ×”×’×“×™×œ ×‘ -TCP ××ª SSThreshold ×‘×ª×—×™×œ×ª ×”×§×©×¨.
×‘××™×–×” ××”××§×¨×™× ×”×‘××™× ×”×©×™× ×•×™ ×”×–×” ×¢×©×•×™ ×œ×”×•×¢×™×œ ×‘××™×“×” ×”××™×¨×‘×™×ª? × ××§.
.1 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
.2 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.3 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.4 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.5 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.6 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.7 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.8 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
â— A ×©×•×œ×— ×œ -B ×—×‘×™×œ×•×ª ××™×“×¢ ×‘×××¦×¢×•×ª ×§×©×¨ TCP. × ×ª×•×Ÿ ×›×™ ×”×§×©×¨ ××ª×—×™×œ ×¢× ×—×œ×•×Ÿ ×‘×’×•×“×œ 1MSS. ×”×§×©×¨
××¡×ª×™×™× ×‘×¤×¢× ×”×¨××©×•× ×” ×©×”×•× ××’×™×¢ ×œ -SSthresh. ×‘××”×œ×š ×”×§×©×¨ ×œ× ××•×‘×“×•×ª ×—×‘×™×œ×•×ª. × ×¡××Ÿ ×‘×§×™×¦×•×¨:
.SSthresh=S*MSS
× ×ª×•×Ÿ ×›×™ ×œ××•×¨×š ×›×œ ×”×§×©×¨ rwnd < MSS*S.
××”×™ ×”×ª×¤×•×§×” ×©×œ ×”×§×©×¨ ×-A ×œ-B( ×‘ -sec / Bytes )×‘×–××Ÿ ×”× "×œ? × ××§×™.
]S*MSS / [lg (S) * RTT*2 ×‘×¢×¨×š .1
]S*MSS / [S^0.5 * RTT*2 ×‘×¢×¨×š .2
S*MSS / RTT ×‘×¢×¨×š .3
S^2)*MSS / RTT( ×‘×¢×¨×š .4
â— ×©×ª×™ ×ª×—× ×•×ª ××ª×§×©×¨×•×ª ×‘××•×¤×Ÿ ××œ×—×•×˜×™ ×‘×©×™×˜×ª N Back Go.
× ×¡××Ÿ ×‘-X ××ª ×¡×¤×¨×ª ×”×‘×™×§×•×¨×ª ×©×œ ×”×ª.×–. ×©×œ×š. ×× ×©× ×™ ×©×•×ª×¤×™× ××’×™×©×™× ××ª ×”×ª×¨×’×™×œ ×™×—×“, X ×”×•× ×¡×¤×¨×ª
×”×‘×™×§×•×¨×ª ×‘×¢×œ×ª ×”×¢×¨×š ×”× ××•×š ×™×•×ª×¨ ××‘×™×Ÿ ×”×©×ª×™×™×.
×§×¦×‘ ×”×ª×§×©×•×¨×ª ×”×•× 8Gbps, ×•×’×•×“×œ ×›×œ ×—×‘×™×œ×” ×”×•× KByte*X. ×’×“×œ×™ ×”-headers ×•×” -Acks ×–× ×™×—×™×.
ï¿½ğ‘’ğ‘ ï¿½/ï¿½ï¿½ 8 , ×•×”××¨×—×§ ×‘×™×Ÿ ×”×ª×—× ×•×ª ×”×•× 1Km. ×§×¦×‘ ×”×”×ª×¤×©×˜×•×ª ×”×•× 10 â‹… 2
×–××Ÿ ×¢×™×‘×•×“ ×”× ×ª×•× ×™× ×‘×ª×—× ×•×ª ×–× ×™×—.
××£ ×—×‘×™×œ×” ×•××£ Ack ×œ× ×”×•×œ×›×™× ×œ××™×‘×•×“.
â— ××”×• X ×©×œ×š?
â— ××” ×¦×¨×™×š ×œ×”×™×•×ª ×’×•×“×œ ×—×œ×•×Ÿ ×”××©×œ×•×— ×›×“×™ ×œ×”×‘×˜×™×— ×ª×¤×•×§×” ××§×¡×™××œ×™×ª?
 Communication Networks Course
Page | 9
Bonus â€“ Improving the Reliable UDP â€“ 15 points
Note: This part isnâ€™t mandatory and is a bonus only!
In this part, youâ€™ll improve your RUDP implementation by adding the concepts of flow
control and congestion control from TCP. Youâ€™re free to choose which algorithms to
implement, as long as you explain in your PDF which algorithms youâ€™ve used. Youâ€™ll probably
need to make changes in the original design of the RUDP. Changes only need to be to the API
itself, ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„.
Points distribution:
â€¢ Flow control improvement â€“ 7 Points
â€¢ Congestion control improvement â€“ 8 points.
Guidance:
â€¢ For flow control, you must use one of the Sliding window techniques: stop-and-wait
ARQ, Go-Back-N or Selective repeat.
â€¢ List of known TCP congestion control algorithms, which you can use any one of them
for this bonus task, or makeup your own:
Figure 2 â€“ List of known TCP congestion control algorithms, Wikipedia
 Communication Networks Course
Page | 10
Appendix A â€“ Linux local packet loss tool
To simulate a packet loss in a local network, we'll use a Linux tool that's called Linux Traffic
Control (ğ‘¡ğ‘). This requires a full Linux installation, so working with WSL won't work.
If the tool isn't installed in your machine, you can install it by using the following commands:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’
If the installation didn't work, you can use the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’2
To create a packet loss scenario, type the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘ğ‘‘ğ‘‘ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
After creating a packet loss scenario, you can change the percentage by typing the following
command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘â„ğ‘ğ‘›ğ‘”ğ‘’ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
To remove the packet loss scenario, write the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘‘ğ‘’ğ‘™ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š
 Communication Networks Course
Page | 11
Appendix B â€“ ğ’ğ’‚ğ’(ğŸ) system calls
This appendixâ€™s purpose is to give you a better understanding of socket handling in C.
A recommended reference is Beejâ€™s Guide to Network Programming, by Brian â€œBeej
Jorgensenâ€ Hall, which gives a lot of information about sockets in C and functions.
Functions and documentation links:
â€¢ ğ’”ğ’ğ’„ğ’Œğ’†ğ’•(ğŸ) â€“ A Factory method system call that creates a socket with the given
parameters.
â€¢ ğ’ƒğ’Šğ’ğ’…(ğŸ) â€“ Whenever we create a new socket, we need to bind it to a specific port in
our machine, â€œto catch a portâ€. The port number is managed and used by the kernel
to link incoming packets to the corresponding application socket. The port numbers
are usually fixed. The ğ‘ğ‘‘ğ‘‘ğ‘Ÿ parameter must match the current socket that is used.
â€¢ ğ’ğ’Šğ’”ğ’•ğ’†ğ’(ğŸ) â€“ The ğ‘™ğ‘–ğ‘ ğ‘¡ğ‘’ğ‘›(2) system call doesn't do anything in the mean of
communication but only memory allocation (malloc) for stream sockets only. If we
won't allocate memory, any incoming connection will fail.
â€¢ ğ’„ğ’ğ’ğ’ğ’†ğ’„ğ’•(ğŸ) â€“ The ğ‘ğ‘œğ‘›ğ‘›ğ‘’ğ‘ğ‘¡(2) system call starts the link between a client and a
specific IP address and port number. The connection would complete when the
other side will call the ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call.
â€¢ ğ’‚ğ’„ğ’„ğ’†ğ’‘ğ’•(ğŸ) â€“ The ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call accepts the incoming stream connection
request from the other side, by the listening socket. This system call completes the
three-way handshake of stream socket (like TCP) and opens a new socket that has a
direct communication channel only with the other party in the handshake.
â€¢ ğ’”ğ’†ğ’ğ’…(ğŸ) and ğ’”ğ’†ğ’ğ’…ğ’•ğ’(ğŸ) â€“ The ğ‘ ğ‘’ğ‘›ğ‘‘(2) and ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system calls are an analogy
for the ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’(2) system call, specifcly for sockets, with flags set to 0. Those system
calls return the number of bytes that were sent through the socket itself, as the
number of bytes can vary. The ğ‘ ğ‘’ğ‘›ğ‘‘(2)system call designed for stream sockets (like
TCP), while the ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system call designed for datagram connection-less
sockets (like UDP). When the ğ‘ ğ‘’ğ‘›ğ‘‘(2) system call returns 0, it means that the other
party closed the connection.
â€¢ ğ’“ğ’†ğ’„ğ’—(ğŸ) and ğ’“ğ’†ğ’„ğ’—ğ’‡ğ’“ğ’ğ’(ğŸ) â€“ The ğ‘Ÿğ‘’ğ‘ğ‘£(2) and ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system calls are an
analogy for the ğ‘Ÿğ‘’ğ‘ğ‘‘(2) system call, specifically for sockets, with flags set to 0.
Those system calls return the number of bytes that were received through the socket
itself, as the number of bytes can vary. The ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call designed for stream
sockets (like TCP), while the ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system call designed for datagram
connection-less sockets (like UDP). When the ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call returns 0, it means
that the other party closed the connection.
â€¢ ğ’„ğ’ğ’ğ’”ğ’†(ğŸ) and ğ’”ğ’‰ğ’–ğ’•ğ’…ğ’ğ’˜ğ’(ğŸ) â€“ The ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) and ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2) system calls close
the socket. While ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) system call closes the whole socket, the ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2)
system call partially closes the socket for read/write.
 Communication Networks Course
Page | 12
Appendix C â€“ Random data generator
The data that you are going to send in this assignment is randomly generated. You can use
your own file with appropriate size or use the following function (or a function of your own)
to generate the data:
/*
* @brief A random data generator function based on srand() and rand().
* @param size The size of the data to generate (up to 2^32 bytes).
* @return A pointer to the buffer.
*/
char *util_generate_random_data(unsigned int size) {
 char *buffer = NULL;
 // Argument check.
 if (size == 0)
 return NULL;
 buffer = (char *)calloc(size, sizeof(char));
 // Error checking.
 if (buffer == NULL)
 return NULL;
 // Randomize the seed of the random number generator.
 srand(time(NULL));
 for (unsigned int i = 0; i < size; i++)
 *(buffer + i) = ((unsigned int)rand() % 256);
 return buffer;
}
 Communication Networks Course
Page | 13
Appendix D â€“ Checksum function
A checksum is a small-sized block of data derived from another block of digital data for the
purpose of detecting errors that may have been introduced during its transmission or
storage. By themselves, checksums are often used to verify data integrity but are not relied
upon to verify data authenticity.
Below is a simple yet efficient implementation of the checksum function, you can use it for
the assignment, but you can implement your own checksum function.
/*
* @brief A checksum function that returns 16 bit checksum for data.
* @param data The data to do the checksum for.
* @param bytes The length of the data in bytes.
* @return The checksum itself as 16 bit unsigned number.
* @note This function is taken from RFC1071, can be found here:
* @note https://tools.ietf.org/html/rfc1071
* @note It is the simplest way to calculate a checksum and is not very strong.
* However, it is good enough for this assignment.
* @note You are free to use any other checksum function as well.
* You can also use this function as such without any change.
*/
unsigned short int calculate_checksum(void *data, unsigned int bytes) {
 unsigned short int *data_pointer = (unsigned short int *)data;
 unsigned int total_sum = 0;
 // Main summing loop
 while (bytes > 1) {
 total_sum += *data_pointer++;
 bytes -= 2;
 }
 // Add left-over byte, if any
 if (bytes > 0)
 total_sum += *((unsigned char *)data_pointer);
 // Fold 32-bit sum to 16 bits
 while (total_sum >> 16)
 total_sum = (total_sum & 0xFFFF) + (total_sum >> 16);
 return (~((unsigned short int)total_sum));
} Communication Networks Course
Page | 1
Assignment 3 â€“ Transport Layer
Assignment Notes and Instructions
This assignment is to be done in pairs only. You must upload all the necessary files in a ZIP
file named after both of the studentâ€™s ID. For example: ğŸğŸğŸ‘ğŸ’ğŸ“ğŸ”ğŸ•ğŸ–ğŸ—_ğŸ—ğŸ–ğŸ•ğŸ”ğŸ“ğŸ’ğŸ‘ğŸğŸ. ğ’›ğ’Šğ’‘.
1) The assignment must be submitted by the date specified in the submission box.
2) All the assignment files (Code, Wireshark pcap files, PDF) must be submitted in a ZIP file. The
PDF must contain all the necessary screenshots with a description for each one of them.
3) The assignment must be done in pairs only. In exceptional cases, you should send an email to
the course coordinator.
4) You can use any reference material available through the course Moodle website or any
material passed during the exercises.
5) You can use any reference from the web, but copying codes from websites is forbidden; this
includes codes from other GitHub repositories. A student who gets caught in the act will
automatically fail this assignment (score 0). Any website youâ€™ve used to solve the
assignment, every website you used to solve the assignment must be noted in the PDF.
6) No delays in submission without special permission. Lateness without approval will result in
failure of the assignment (score 0).
7) All submissions will be submitted via the course's Moodle website. Email submissions will not
be accepted, resulting in a failure in the assignment.
8) The order and design of the code must be carefully considered. Make sure that the program
output is as clear as possible, comments in the code, and meaningful variable names. You
must also submit a makefile that compiles all the programs.
9) The assignment code must be written in C only.
10) The assignment is personal for each pair, and you should not accept help from other people,
whether outside the university or inside it. You can contact the course staff during reception
hours for help or raise a question in the course forum. Do not transfer code sections
between students, upload solutions or parts of solutions to websites on the Internet or in
various communication groups.
11) Students who copy a solution will receive a 0 in all assignments in the course and a report will
be made to the institutional disciplinary committee.
12) All code files of the assignment are required to both compile and run properly on the Ubuntu
22.04 LTS operating system. This is the operating system where the submissions will be
tested. You mustnâ€™t code it in Windows, as it uses different API for sockets. WSL wonâ€™t work,
as the task needs a tool that works only in a fully Linux environment.
Good Luck!
 Communication Networks Course
Page | 2
Part A â€“ Transmission Control Protocol (TCP) â€“ 30 points
In this part, youâ€™ll write two program files: ğ‘»ğ‘ªğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and ğ‘»ğ‘ªğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
The Sender will send a randomly generated file and the Receiver will receive it and measure
the time it took for his program to receive the file. The file size should be at least 2MB.
When running the Sender and Receiver, they both should support two standard congestion
control algorithms: TCP Reno and TCP Cubic.
Notes:
â€¢ The main goal of this part is to get familiar with the TCP concept of sending
messages between two endpoints.
â€¢ For approaching this part of the assignment, please be sure that you are familiar
with the congestion control algorithms and how to change them using the correct
method in C (see Appendix B for more information).
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). You've
learned that TCP is reliable by design, so you can assume that all the data have been
passed correctly, and thus, no need to recheck.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
Usage:
â€¢ Receiver:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
â€¢ Sender:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port of the Receiver.
â€¢ ğ‘¨ğ‘³ğ‘®ğ‘¶ â€“ The TCP congestion control algorithm that will be used by the party
member (either ğ’“ğ’†ğ’ğ’ for TCP Reno or ğ’„ğ’–ğ’ƒğ’Šğ’„ for TCP Cubic).
 Communication Networks Course
Page | 3
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a TCP socket between the Sender and the
Receiver.
3) Send the file.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a TCP connection between the Receiver and
the Sender.
2) Get a connection from the sender.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./TCP_Receiver -p 1234 -algo reno
Starting Receiver...
Waiting for TCP connection...
Sender connected, beginning to receive file...
File transfer completed.
Waiting for Sender response...
Sender sent exit message.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 4
Part B â€“ Reliable User Datagram Protocol (Reliable UDP or RUDP) â€“ 40 points
Youâ€™ve learned that while TCP is reliable, it lacks speed and has an overhead data of 20 bytes,
compering to UDP that needs only 8 bytes of overhead data.
Reliable UDP or RUDP, is a protocol that uses the UDP protocol for a faster transmission of
data, while adding a reliability layer to it, but without adding too much overhead data like
TCP.
A simple sketch for a RUDP connection would look something like this:
Your task in this part is to implement a Reliable protocol using UDP only. For simplicity, your
implementation should only support a handshake, closing scheme, error checking,
acknowledgment of received packets, and retransmission of lost packets.
Guidance:
â€¢ You can use ğ‘ ğ‘’ğ‘¡ğ‘ ğ‘œğ‘ğ‘˜ğ‘œğ‘ğ‘¡(2) for detecting a timeout.
â€¢ You need to build your own protocol, as Reliable UDP isnâ€™t a standard protocol (see a
draft of RUDP in this link), and no official header is provided. You can use this sketch
for a header, but you can come up with your own protocol, as long as it works.
Where:
o ğ‘³ğ’†ğ’ğ’ˆğ’•ğ’‰ is the length of the data itself, without the RUDP header.
o ğ‘ªğ’‰ğ’†ğ’„ğ’Œğ’”ğ’–ğ’ is a 16bit number that validates the correctness of the data.
o ğ‘­ğ’ğ’‚ğ’ˆğ’” is a special byte where we classify the packet itself (SYN, ACK, etc.).
â€¢ In your PDF, you must explain how your implementation of RUDP works â€“ How does
it detect a timeout to do retransmissions, how does the handshake work, what is the
header overhead, etc.
â€¢ For this part, youâ€™ll write three files: ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¨ğ‘·ğ‘°. ğ’„, ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and
ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
Reliable UDP Header proposed sketch
Byte 0 Byte 1 Byte 2 Byte 3
Length (2 Bytes) Checksum (2 Bytes)
Flags (1 Byte)
Figure 1 - RUDP Protocol Architecture, Geeksforgeeks
 Communication Networks Course
Page | 5
Notes:
â€¢ The Sender will send a random generated file and the Receiver will receive it and
measure the time it took for his program to receive the file. The file size should be at
least 2MB.
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). But, as the
RUDP is based on UDP, itâ€™s not reliable. You must use some form of error checking
(like checksum) to ensure that the packet wasnâ€™t alerted during the transfer.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
â€¢ The RUDP needs support only 1 sender and 1 receiver, for simplicity purposes.
Usage:
â€¢ Receiver:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
â€¢ Sender:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port that both the Sender and the Receiver will use.
The ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„ file will contain all the implementations of the RUDP API functions (That is, to
prevent reusing the same chuck of code both in the Sender and the Receiver.).
The API should support at the bare minimum the following functions (you decide what
parameters to implement, and what are the names of the functions, as long as the API is
explained in the PDF):
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘œğ‘ğ‘˜ğ‘’ğ‘¡() â€“ Creating a RUDP socket and creating a handshake between two
peers.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘’ğ‘›ğ‘‘() â€“ Sending data to the peer. The function should wait for an
acknowledgment packet, and if it didnâ€™t receive any, retransmits the data.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘Ÿğ‘’ğ‘ğ‘£() â€“ Receive data from a peer.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ğ‘™ğ‘œğ‘ ğ‘’() â€“ Closes a connection between peers.
 Communication Networks Course
Page | 6
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a UDP socket between the Sender and the
Receiver.
3) Send the file via the RUDP protocol.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a UDP connection between the Receiver and
the Sender.
2) Get a connection from the sender, by the custom
RUDP protocol youâ€™ve built.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./RUDP_Receiver -p 1234
Starting Receiver...
Waiting for RUDP connection...
Connection request received, sending ACK.
Sender connected, beginning to receive file...
File transfer completed.
ACK sent.
Waiting for Sender response...
Sender sent exit message.
ACK sent.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 7
Part C â€“ Research â€“ 30 points
In this part, youâ€™ll conduct research about your implementations of part A and part B.
In the research itself, each one of the versions (TCP version and UDP version) will be run at
least 5 times (meaning that the file transfer will occur at least 5 times) by the following
conditions:
â€¢ For TCP, youâ€™ll run it in TCP Reno and TCP Cubic, alternating each time, for each
scenario, meaning that you run 5 times with TCP Reno in both Sender and Receiver,
and 5 times with TCP Cubic in both Sender and Receiver.
Bonus (5 points): Create a very large data set â€“ 5 times with TCP Reno in both Sender
and Receiver, 5 times with TCP Reno in Sender and TCP Cubic in Receiver, 5 times
with TCP Cubic in Sender and TCP Reno in Receiver, and 5 times with TCP Cubic in
both Sender and Receiver. This will give you a data set large enough, which allows
you to work with, compare with and to reach a definite conclusion.
â€¢ For RUDP, you will run it 5 times for each scenario.
â€¢ For both TCP and RUDP, you will run them on those scenarios of packet loss:
o 0% packet loss â€“ Control group, simulating perfect connection.
o 2% packet loss â€“ Simulating unstable connection that commonly occur.
o 5% packet loss â€“ Simulating bad connection.
o 10% packet loss â€“ Simulating extremely poor connection.
For each scenario, you must provide a filtered PCAP file and relevant screenshots that
explain each one of the steps in the process. (10 points)
After youâ€™ve gathered the data set for both TCP and Reliable UDP, answer the following
questions:
1) In TCP, which congestion control algorithm gave better results overall? TCP Reno or
TCP Cubic? Which one gave better results on high packet loss? Explain how you came
to this conclusion based on the data set youâ€™ve gathered. (5 points)
2) How did your implementation of Reliable UDP perform overall compared to regular
TCP? Which one is better for high packet loss? (5 points)
3) According to the data youâ€™ve gathered, in which scenarios and applications would we
prefer to use TCP and in which situations would we prefer to use reliable UDP?
Explain your answer. (5 points)
 Communication Networks Course
Page | 8
×¢× ×• ×¢×œ ×”×©××œ×•×ª ×”×‘××•×ª )5 × ×§×•×“×•×ª(:
â— ×‘"×¨×©×ª ×××™× ×”" ×”×›×•×•× ×” ×”×™× ×œ×¨×©×ª ×©×‘×” ××¢×˜ ×××•×“ ×—×‘×™×œ×•×ª ×”×•×œ×›×•×ª ×œ××™×‘×•×“. ×‘"×§×©×¨ ××¨×•×š" ×”×›×•×•× ×” ×”×™×
×œ×§×©×¨ TCP ×©×™×© ×‘×• ×”×¨×‘×” ×××•×“ ××™×“×¢ ×œ×©×œ×•×—. ××•×¦×¢ ×œ×”×’×“×™×œ ×‘ -TCP ××ª SSThreshold ×‘×ª×—×™×œ×ª ×”×§×©×¨.
×‘××™×–×” ××”××§×¨×™× ×”×‘××™× ×”×©×™× ×•×™ ×”×–×” ×¢×©×•×™ ×œ×”×•×¢×™×œ ×‘××™×“×” ×”××™×¨×‘×™×ª? × ××§.
.1 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
.2 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.3 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.4 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.5 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.6 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.7 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.8 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
â— A ×©×•×œ×— ×œ -B ×—×‘×™×œ×•×ª ××™×“×¢ ×‘×××¦×¢×•×ª ×§×©×¨ TCP. × ×ª×•×Ÿ ×›×™ ×”×§×©×¨ ××ª×—×™×œ ×¢× ×—×œ×•×Ÿ ×‘×’×•×“×œ 1MSS. ×”×§×©×¨
××¡×ª×™×™× ×‘×¤×¢× ×”×¨××©×•× ×” ×©×”×•× ××’×™×¢ ×œ -SSthresh. ×‘××”×œ×š ×”×§×©×¨ ×œ× ××•×‘×“×•×ª ×—×‘×™×œ×•×ª. × ×¡××Ÿ ×‘×§×™×¦×•×¨:
.SSthresh=S*MSS
× ×ª×•×Ÿ ×›×™ ×œ××•×¨×š ×›×œ ×”×§×©×¨ rwnd < MSS*S.
××”×™ ×”×ª×¤×•×§×” ×©×œ ×”×§×©×¨ ×-A ×œ-B( ×‘ -sec / Bytes )×‘×–××Ÿ ×”× "×œ? × ××§×™.
]S*MSS / [lg (S) * RTT*2 ×‘×¢×¨×š .1
]S*MSS / [S^0.5 * RTT*2 ×‘×¢×¨×š .2
S*MSS / RTT ×‘×¢×¨×š .3
S^2)*MSS / RTT( ×‘×¢×¨×š .4
â— ×©×ª×™ ×ª×—× ×•×ª ××ª×§×©×¨×•×ª ×‘××•×¤×Ÿ ××œ×—×•×˜×™ ×‘×©×™×˜×ª N Back Go.
× ×¡××Ÿ ×‘-X ××ª ×¡×¤×¨×ª ×”×‘×™×§×•×¨×ª ×©×œ ×”×ª.×–. ×©×œ×š. ×× ×©× ×™ ×©×•×ª×¤×™× ××’×™×©×™× ××ª ×”×ª×¨×’×™×œ ×™×—×“, X ×”×•× ×¡×¤×¨×ª
×”×‘×™×§×•×¨×ª ×‘×¢×œ×ª ×”×¢×¨×š ×”× ××•×š ×™×•×ª×¨ ××‘×™×Ÿ ×”×©×ª×™×™×.
×§×¦×‘ ×”×ª×§×©×•×¨×ª ×”×•× 8Gbps, ×•×’×•×“×œ ×›×œ ×—×‘×™×œ×” ×”×•× KByte*X. ×’×“×œ×™ ×”-headers ×•×” -Acks ×–× ×™×—×™×.
ï¿½ğ‘’ğ‘ ï¿½/ï¿½ï¿½ 8 , ×•×”××¨×—×§ ×‘×™×Ÿ ×”×ª×—× ×•×ª ×”×•× 1Km. ×§×¦×‘ ×”×”×ª×¤×©×˜×•×ª ×”×•× 10 â‹… 2
×–××Ÿ ×¢×™×‘×•×“ ×”× ×ª×•× ×™× ×‘×ª×—× ×•×ª ×–× ×™×—.
××£ ×—×‘×™×œ×” ×•××£ Ack ×œ× ×”×•×œ×›×™× ×œ××™×‘×•×“.
â— ××”×• X ×©×œ×š?
â— ××” ×¦×¨×™×š ×œ×”×™×•×ª ×’×•×“×œ ×—×œ×•×Ÿ ×”××©×œ×•×— ×›×“×™ ×œ×”×‘×˜×™×— ×ª×¤×•×§×” ××§×¡×™××œ×™×ª?
 Communication Networks Course
Page | 9
Bonus â€“ Improving the Reliable UDP â€“ 15 points
Note: This part isnâ€™t mandatory and is a bonus only!
In this part, youâ€™ll improve your RUDP implementation by adding the concepts of flow
control and congestion control from TCP. Youâ€™re free to choose which algorithms to
implement, as long as you explain in your PDF which algorithms youâ€™ve used. Youâ€™ll probably
need to make changes in the original design of the RUDP. Changes only need to be to the API
itself, ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„.
Points distribution:
â€¢ Flow control improvement â€“ 7 Points
â€¢ Congestion control improvement â€“ 8 points.
Guidance:
â€¢ For flow control, you must use one of the Sliding window techniques: stop-and-wait
ARQ, Go-Back-N or Selective repeat.
â€¢ List of known TCP congestion control algorithms, which you can use any one of them
for this bonus task, or makeup your own:
Figure 2 â€“ List of known TCP congestion control algorithms, Wikipedia
 Communication Networks Course
Page | 10
Appendix A â€“ Linux local packet loss tool
To simulate a packet loss in a local network, we'll use a Linux tool that's called Linux Traffic
Control (ğ‘¡ğ‘). This requires a full Linux installation, so working with WSL won't work.
If the tool isn't installed in your machine, you can install it by using the following commands:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’
If the installation didn't work, you can use the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’2
To create a packet loss scenario, type the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘ğ‘‘ğ‘‘ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
After creating a packet loss scenario, you can change the percentage by typing the following
command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘â„ğ‘ğ‘›ğ‘”ğ‘’ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
To remove the packet loss scenario, write the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘‘ğ‘’ğ‘™ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š
 Communication Networks Course
Page | 11
Appendix B â€“ ğ’ğ’‚ğ’(ğŸ) system calls
This appendixâ€™s purpose is to give you a better understanding of socket handling in C.
A recommended reference is Beejâ€™s Guide to Network Programming, by Brian â€œBeej
Jorgensenâ€ Hall, which gives a lot of information about sockets in C and functions.
Functions and documentation links:
â€¢ ğ’”ğ’ğ’„ğ’Œğ’†ğ’•(ğŸ) â€“ A Factory method system call that creates a socket with the given
parameters.
â€¢ ğ’ƒğ’Šğ’ğ’…(ğŸ) â€“ Whenever we create a new socket, we need to bind it to a specific port in
our machine, â€œto catch a portâ€. The port number is managed and used by the kernel
to link incoming packets to the corresponding application socket. The port numbers
are usually fixed. The ğ‘ğ‘‘ğ‘‘ğ‘Ÿ parameter must match the current socket that is used.
â€¢ ğ’ğ’Šğ’”ğ’•ğ’†ğ’(ğŸ) â€“ The ğ‘™ğ‘–ğ‘ ğ‘¡ğ‘’ğ‘›(2) system call doesn't do anything in the mean of
communication but only memory allocation (malloc) for stream sockets only. If we
won't allocate memory, any incoming connection will fail.
â€¢ ğ’„ğ’ğ’ğ’ğ’†ğ’„ğ’•(ğŸ) â€“ The ğ‘ğ‘œğ‘›ğ‘›ğ‘’ğ‘ğ‘¡(2) system call starts the link between a client and a
specific IP address and port number. The connection would complete when the
other side will call the ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call.
â€¢ ğ’‚ğ’„ğ’„ğ’†ğ’‘ğ’•(ğŸ) â€“ The ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call accepts the incoming stream connection
request from the other side, by the listening socket. This system call completes the
three-way handshake of stream socket (like TCP) and opens a new socket that has a
direct communication channel only with the other party in the handshake.
â€¢ ğ’”ğ’†ğ’ğ’…(ğŸ) and ğ’”ğ’†ğ’ğ’…ğ’•ğ’(ğŸ) â€“ The ğ‘ ğ‘’ğ‘›ğ‘‘(2) and ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system calls are an analogy
for the ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’(2) system call, specifcly for sockets, with flags set to 0. Those system
calls return the number of bytes that were sent through the socket itself, as the
number of bytes can vary. The ğ‘ ğ‘’ğ‘›ğ‘‘(2)system call designed for stream sockets (like
TCP), while the ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system call designed for datagram connection-less
sockets (like UDP). When the ğ‘ ğ‘’ğ‘›ğ‘‘(2) system call returns 0, it means that the other
party closed the connection.
â€¢ ğ’“ğ’†ğ’„ğ’—(ğŸ) and ğ’“ğ’†ğ’„ğ’—ğ’‡ğ’“ğ’ğ’(ğŸ) â€“ The ğ‘Ÿğ‘’ğ‘ğ‘£(2) and ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system calls are an
analogy for the ğ‘Ÿğ‘’ğ‘ğ‘‘(2) system call, specifically for sockets, with flags set to 0.
Those system calls return the number of bytes that were received through the socket
itself, as the number of bytes can vary. The ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call designed for stream
sockets (like TCP), while the ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system call designed for datagram
connection-less sockets (like UDP). When the ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call returns 0, it means
that the other party closed the connection.
â€¢ ğ’„ğ’ğ’ğ’”ğ’†(ğŸ) and ğ’”ğ’‰ğ’–ğ’•ğ’…ğ’ğ’˜ğ’(ğŸ) â€“ The ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) and ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2) system calls close
the socket. While ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) system call closes the whole socket, the ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2)
system call partially closes the socket for read/write.
 Communication Networks Course
Page | 12
Appendix C â€“ Random data generator
The data that you are going to send in this assignment is randomly generated. You can use
your own file with appropriate size or use the following function (or a function of your own)
to generate the data:
/*
* @brief A random data generator function based on srand() and rand().
* @param size The size of the data to generate (up to 2^32 bytes).
* @return A pointer to the buffer.
*/
char *util_generate_random_data(unsigned int size) {
 char *buffer = NULL;
 // Argument check.
 if (size == 0)
 return NULL;
 buffer = (char *)calloc(size, sizeof(char));
 // Error checking.
 if (buffer == NULL)
 return NULL;
 // Randomize the seed of the random number generator.
 srand(time(NULL));
 for (unsigned int i = 0; i < size; i++)
 *(buffer + i) = ((unsigned int)rand() % 256);
 return buffer;
}
 Communication Networks Course
Page | 13
Appendix D â€“ Checksum function
A checksum is a small-sized block of data derived from another block of digital data for the
purpose of detecting errors that may have been introduced during its transmission or
storage. By themselves, checksums are often used to verify data integrity but are not relied
upon to verify data authenticity.
Below is a simple yet efficient implementation of the checksum function, you can use it for
the assignment, but you can implement your own checksum function.
/*
* @brief A checksum function that returns 16 bit checksum for data.
* @param data The data to do the checksum for.
* @param bytes The length of the data in bytes.
* @return The checksum itself as 16 bit unsigned number.
* @note This function is taken from RFC1071, can be found here:
* @note https://tools.ietf.org/html/rfc1071
* @note It is the simplest way to calculate a checksum and is not very strong.
* However, it is good enough for this assignment.
* @note You are free to use any other checksum function as well.
* You can also use this function as such without any change.
*/
unsigned short int calculate_checksum(void *data, unsigned int bytes) {
 unsigned short int *data_pointer = (unsigned short int *)data;
 unsigned int total_sum = 0;
 // Main summing loop
 while (bytes > 1) {
 total_sum += *data_pointer++;
 bytes -= 2;
 }
 // Add left-over byte, if any
 if (bytes > 0)
 total_sum += *((unsigned char *)data_pointer);
 // Fold 32-bit sum to 16 bits
 while (total_sum >> 16)
 total_sum = (total_sum & 0xFFFF) + (total_sum >> 16);
 return (~((unsigned short int)total_sum));
} Communication Networks Course
Page | 1
Assignment 3 â€“ Transport Layer
Assignment Notes and Instructions
This assignment is to be done in pairs only. You must upload all the necessary files in a ZIP
file named after both of the studentâ€™s ID. For example: ğŸğŸğŸ‘ğŸ’ğŸ“ğŸ”ğŸ•ğŸ–ğŸ—_ğŸ—ğŸ–ğŸ•ğŸ”ğŸ“ğŸ’ğŸ‘ğŸğŸ. ğ’›ğ’Šğ’‘.
1) The assignment must be submitted by the date specified in the submission box.
2) All the assignment files (Code, Wireshark pcap files, PDF) must be submitted in a ZIP file. The
PDF must contain all the necessary screenshots with a description for each one of them.
3) The assignment must be done in pairs only. In exceptional cases, you should send an email to
the course coordinator.
4) You can use any reference material available through the course Moodle website or any
material passed during the exercises.
5) You can use any reference from the web, but copying codes from websites is forbidden; this
includes codes from other GitHub repositories. A student who gets caught in the act will
automatically fail this assignment (score 0). Any website youâ€™ve used to solve the
assignment, every website you used to solve the assignment must be noted in the PDF.
6) No delays in submission without special permission. Lateness without approval will result in
failure of the assignment (score 0).
7) All submissions will be submitted via the course's Moodle website. Email submissions will not
be accepted, resulting in a failure in the assignment.
8) The order and design of the code must be carefully considered. Make sure that the program
output is as clear as possible, comments in the code, and meaningful variable names. You
must also submit a makefile that compiles all the programs.
9) The assignment code must be written in C only.
10) The assignment is personal for each pair, and you should not accept help from other people,
whether outside the university or inside it. You can contact the course staff during reception
hours for help or raise a question in the course forum. Do not transfer code sections
between students, upload solutions or parts of solutions to websites on the Internet or in
various communication groups.
11) Students who copy a solution will receive a 0 in all assignments in the course and a report will
be made to the institutional disciplinary committee.
12) All code files of the assignment are required to both compile and run properly on the Ubuntu
22.04 LTS operating system. This is the operating system where the submissions will be
tested. You mustnâ€™t code it in Windows, as it uses different API for sockets. WSL wonâ€™t work,
as the task needs a tool that works only in a fully Linux environment.
Good Luck!
 Communication Networks Course
Page | 2
Part A â€“ Transmission Control Protocol (TCP) â€“ 30 points
In this part, youâ€™ll write two program files: ğ‘»ğ‘ªğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and ğ‘»ğ‘ªğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
The Sender will send a randomly generated file and the Receiver will receive it and measure
the time it took for his program to receive the file. The file size should be at least 2MB.
When running the Sender and Receiver, they both should support two standard congestion
control algorithms: TCP Reno and TCP Cubic.
Notes:
â€¢ The main goal of this part is to get familiar with the TCP concept of sending
messages between two endpoints.
â€¢ For approaching this part of the assignment, please be sure that you are familiar
with the congestion control algorithms and how to change them using the correct
method in C (see Appendix B for more information).
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). You've
learned that TCP is reliable by design, so you can assume that all the data have been
passed correctly, and thus, no need to recheck.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
Usage:
â€¢ Receiver:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
â€¢ Sender:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port of the Receiver.
â€¢ ğ‘¨ğ‘³ğ‘®ğ‘¶ â€“ The TCP congestion control algorithm that will be used by the party
member (either ğ’“ğ’†ğ’ğ’ for TCP Reno or ğ’„ğ’–ğ’ƒğ’Šğ’„ for TCP Cubic).
 Communication Networks Course
Page | 3
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a TCP socket between the Sender and the
Receiver.
3) Send the file.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a TCP connection between the Receiver and
the Sender.
2) Get a connection from the sender.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./TCP_Receiver -p 1234 -algo reno
Starting Receiver...
Waiting for TCP connection...
Sender connected, beginning to receive file...
File transfer completed.
Waiting for Sender response...
Sender sent exit message.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 4
Part B â€“ Reliable User Datagram Protocol (Reliable UDP or RUDP) â€“ 40 points
Youâ€™ve learned that while TCP is reliable, it lacks speed and has an overhead data of 20 bytes,
compering to UDP that needs only 8 bytes of overhead data.
Reliable UDP or RUDP, is a protocol that uses the UDP protocol for a faster transmission of
data, while adding a reliability layer to it, but without adding too much overhead data like
TCP.
A simple sketch for a RUDP connection would look something like this:
Your task in this part is to implement a Reliable protocol using UDP only. For simplicity, your
implementation should only support a handshake, closing scheme, error checking,
acknowledgment of received packets, and retransmission of lost packets.
Guidance:
â€¢ You can use ğ‘ ğ‘’ğ‘¡ğ‘ ğ‘œğ‘ğ‘˜ğ‘œğ‘ğ‘¡(2) for detecting a timeout.
â€¢ You need to build your own protocol, as Reliable UDP isnâ€™t a standard protocol (see a
draft of RUDP in this link), and no official header is provided. You can use this sketch
for a header, but you can come up with your own protocol, as long as it works.
Where:
o ğ‘³ğ’†ğ’ğ’ˆğ’•ğ’‰ is the length of the data itself, without the RUDP header.
o ğ‘ªğ’‰ğ’†ğ’„ğ’Œğ’”ğ’–ğ’ is a 16bit number that validates the correctness of the data.
o ğ‘­ğ’ğ’‚ğ’ˆğ’” is a special byte where we classify the packet itself (SYN, ACK, etc.).
â€¢ In your PDF, you must explain how your implementation of RUDP works â€“ How does
it detect a timeout to do retransmissions, how does the handshake work, what is the
header overhead, etc.
â€¢ For this part, youâ€™ll write three files: ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¨ğ‘·ğ‘°. ğ’„, ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and
ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
Reliable UDP Header proposed sketch
Byte 0 Byte 1 Byte 2 Byte 3
Length (2 Bytes) Checksum (2 Bytes)
Flags (1 Byte)
Figure 1 - RUDP Protocol Architecture, Geeksforgeeks
 Communication Networks Course
Page | 5
Notes:
â€¢ The Sender will send a random generated file and the Receiver will receive it and
measure the time it took for his program to receive the file. The file size should be at
least 2MB.
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). But, as the
RUDP is based on UDP, itâ€™s not reliable. You must use some form of error checking
(like checksum) to ensure that the packet wasnâ€™t alerted during the transfer.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
â€¢ The RUDP needs support only 1 sender and 1 receiver, for simplicity purposes.
Usage:
â€¢ Receiver:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
â€¢ Sender:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port that both the Sender and the Receiver will use.
The ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„ file will contain all the implementations of the RUDP API functions (That is, to
prevent reusing the same chuck of code both in the Sender and the Receiver.).
The API should support at the bare minimum the following functions (you decide what
parameters to implement, and what are the names of the functions, as long as the API is
explained in the PDF):
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘œğ‘ğ‘˜ğ‘’ğ‘¡() â€“ Creating a RUDP socket and creating a handshake between two
peers.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘’ğ‘›ğ‘‘() â€“ Sending data to the peer. The function should wait for an
acknowledgment packet, and if it didnâ€™t receive any, retransmits the data.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘Ÿğ‘’ğ‘ğ‘£() â€“ Receive data from a peer.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ğ‘™ğ‘œğ‘ ğ‘’() â€“ Closes a connection between peers.
 Communication Networks Course
Page | 6
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a UDP socket between the Sender and the
Receiver.
3) Send the file via the RUDP protocol.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a UDP connection between the Receiver and
the Sender.
2) Get a connection from the sender, by the custom
RUDP protocol youâ€™ve built.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./RUDP_Receiver -p 1234
Starting Receiver...
Waiting for RUDP connection...
Connection request received, sending ACK.
Sender connected, beginning to receive file...
File transfer completed.
ACK sent.
Waiting for Sender response...
Sender sent exit message.
ACK sent.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 7
Part C â€“ Research â€“ 30 points
In this part, youâ€™ll conduct research about your implementations of part A and part B.
In the research itself, each one of the versions (TCP version and UDP version) will be run at
least 5 times (meaning that the file transfer will occur at least 5 times) by the following
conditions:
â€¢ For TCP, youâ€™ll run it in TCP Reno and TCP Cubic, alternating each time, for each
scenario, meaning that you run 5 times with TCP Reno in both Sender and Receiver,
and 5 times with TCP Cubic in both Sender and Receiver.
Bonus (5 points): Create a very large data set â€“ 5 times with TCP Reno in both Sender
and Receiver, 5 times with TCP Reno in Sender and TCP Cubic in Receiver, 5 times
with TCP Cubic in Sender and TCP Reno in Receiver, and 5 times with TCP Cubic in
both Sender and Receiver. This will give you a data set large enough, which allows
you to work with, compare with and to reach a definite conclusion.
â€¢ For RUDP, you will run it 5 times for each scenario.
â€¢ For both TCP and RUDP, you will run them on those scenarios of packet loss:
o 0% packet loss â€“ Control group, simulating perfect connection.
o 2% packet loss â€“ Simulating unstable connection that commonly occur.
o 5% packet loss â€“ Simulating bad connection.
o 10% packet loss â€“ Simulating extremely poor connection.
For each scenario, you must provide a filtered PCAP file and relevant screenshots that
explain each one of the steps in the process. (10 points)
After youâ€™ve gathered the data set for both TCP and Reliable UDP, answer the following
questions:
1) In TCP, which congestion control algorithm gave better results overall? TCP Reno or
TCP Cubic? Which one gave better results on high packet loss? Explain how you came
to this conclusion based on the data set youâ€™ve gathered. (5 points)
2) How did your implementation of Reliable UDP perform overall compared to regular
TCP? Which one is better for high packet loss? (5 points)
3) According to the data youâ€™ve gathered, in which scenarios and applications would we
prefer to use TCP and in which situations would we prefer to use reliable UDP?
Explain your answer. (5 points)
 Communication Networks Course
Page | 8
×¢× ×• ×¢×œ ×”×©××œ×•×ª ×”×‘××•×ª )5 × ×§×•×“×•×ª(:
â— ×‘"×¨×©×ª ×××™× ×”" ×”×›×•×•× ×” ×”×™× ×œ×¨×©×ª ×©×‘×” ××¢×˜ ×××•×“ ×—×‘×™×œ×•×ª ×”×•×œ×›×•×ª ×œ××™×‘×•×“. ×‘"×§×©×¨ ××¨×•×š" ×”×›×•×•× ×” ×”×™×
×œ×§×©×¨ TCP ×©×™×© ×‘×• ×”×¨×‘×” ×××•×“ ××™×“×¢ ×œ×©×œ×•×—. ××•×¦×¢ ×œ×”×’×“×™×œ ×‘ -TCP ××ª SSThreshold ×‘×ª×—×™×œ×ª ×”×§×©×¨.
×‘××™×–×” ××”××§×¨×™× ×”×‘××™× ×”×©×™× ×•×™ ×”×–×” ×¢×©×•×™ ×œ×”×•×¢×™×œ ×‘××™×“×” ×”××™×¨×‘×™×ª? × ××§.
.1 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
.2 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.3 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.4 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.5 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.6 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.7 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.8 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
â— A ×©×•×œ×— ×œ -B ×—×‘×™×œ×•×ª ××™×“×¢ ×‘×××¦×¢×•×ª ×§×©×¨ TCP. × ×ª×•×Ÿ ×›×™ ×”×§×©×¨ ××ª×—×™×œ ×¢× ×—×œ×•×Ÿ ×‘×’×•×“×œ 1MSS. ×”×§×©×¨
××¡×ª×™×™× ×‘×¤×¢× ×”×¨××©×•× ×” ×©×”×•× ××’×™×¢ ×œ -SSthresh. ×‘××”×œ×š ×”×§×©×¨ ×œ× ××•×‘×“×•×ª ×—×‘×™×œ×•×ª. × ×¡××Ÿ ×‘×§×™×¦×•×¨:
.SSthresh=S*MSS
× ×ª×•×Ÿ ×›×™ ×œ××•×¨×š ×›×œ ×”×§×©×¨ rwnd < MSS*S.
××”×™ ×”×ª×¤×•×§×” ×©×œ ×”×§×©×¨ ×-A ×œ-B( ×‘ -sec / Bytes )×‘×–××Ÿ ×”× "×œ? × ××§×™.
]S*MSS / [lg (S) * RTT*2 ×‘×¢×¨×š .1
]S*MSS / [S^0.5 * RTT*2 ×‘×¢×¨×š .2
S*MSS / RTT ×‘×¢×¨×š .3
S^2)*MSS / RTT( ×‘×¢×¨×š .4
â— ×©×ª×™ ×ª×—× ×•×ª ××ª×§×©×¨×•×ª ×‘××•×¤×Ÿ ××œ×—×•×˜×™ ×‘×©×™×˜×ª N Back Go.
× ×¡××Ÿ ×‘-X ××ª ×¡×¤×¨×ª ×”×‘×™×§×•×¨×ª ×©×œ ×”×ª.×–. ×©×œ×š. ×× ×©× ×™ ×©×•×ª×¤×™× ××’×™×©×™× ××ª ×”×ª×¨×’×™×œ ×™×—×“, X ×”×•× ×¡×¤×¨×ª
×”×‘×™×§×•×¨×ª ×‘×¢×œ×ª ×”×¢×¨×š ×”× ××•×š ×™×•×ª×¨ ××‘×™×Ÿ ×”×©×ª×™×™×.
×§×¦×‘ ×”×ª×§×©×•×¨×ª ×”×•× 8Gbps, ×•×’×•×“×œ ×›×œ ×—×‘×™×œ×” ×”×•× KByte*X. ×’×“×œ×™ ×”-headers ×•×” -Acks ×–× ×™×—×™×.
ï¿½ğ‘’ğ‘ ï¿½/ï¿½ï¿½ 8 , ×•×”××¨×—×§ ×‘×™×Ÿ ×”×ª×—× ×•×ª ×”×•× 1Km. ×§×¦×‘ ×”×”×ª×¤×©×˜×•×ª ×”×•× 10 â‹… 2
×–××Ÿ ×¢×™×‘×•×“ ×”× ×ª×•× ×™× ×‘×ª×—× ×•×ª ×–× ×™×—.
××£ ×—×‘×™×œ×” ×•××£ Ack ×œ× ×”×•×œ×›×™× ×œ××™×‘×•×“.
â— ××”×• X ×©×œ×š?
â— ××” ×¦×¨×™×š ×œ×”×™×•×ª ×’×•×“×œ ×—×œ×•×Ÿ ×”××©×œ×•×— ×›×“×™ ×œ×”×‘×˜×™×— ×ª×¤×•×§×” ××§×¡×™××œ×™×ª?
 Communication Networks Course
Page | 9
Bonus â€“ Improving the Reliable UDP â€“ 15 points
Note: This part isnâ€™t mandatory and is a bonus only!
In this part, youâ€™ll improve your RUDP implementation by adding the concepts of flow
control and congestion control from TCP. Youâ€™re free to choose which algorithms to
implement, as long as you explain in your PDF which algorithms youâ€™ve used. Youâ€™ll probably
need to make changes in the original design of the RUDP. Changes only need to be to the API
itself, ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„.
Points distribution:
â€¢ Flow control improvement â€“ 7 Points
â€¢ Congestion control improvement â€“ 8 points.
Guidance:
â€¢ For flow control, you must use one of the Sliding window techniques: stop-and-wait
ARQ, Go-Back-N or Selective repeat.
â€¢ List of known TCP congestion control algorithms, which you can use any one of them
for this bonus task, or makeup your own:
Figure 2 â€“ List of known TCP congestion control algorithms, Wikipedia
 Communication Networks Course
Page | 10
Appendix A â€“ Linux local packet loss tool
To simulate a packet loss in a local network, we'll use a Linux tool that's called Linux Traffic
Control (ğ‘¡ğ‘). This requires a full Linux installation, so working with WSL won't work.
If the tool isn't installed in your machine, you can install it by using the following commands:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’
If the installation didn't work, you can use the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’2
To create a packet loss scenario, type the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘ğ‘‘ğ‘‘ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
After creating a packet loss scenario, you can change the percentage by typing the following
command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘â„ğ‘ğ‘›ğ‘”ğ‘’ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
To remove the packet loss scenario, write the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘‘ğ‘’ğ‘™ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š
 Communication Networks Course
Page | 11
Appendix B â€“ ğ’ğ’‚ğ’(ğŸ) system calls
This appendixâ€™s purpose is to give you a better understanding of socket handling in C.
A recommended reference is Beejâ€™s Guide to Network Programming, by Brian â€œBeej
Jorgensenâ€ Hall, which gives a lot of information about sockets in C and functions.
Functions and documentation links:
â€¢ ğ’”ğ’ğ’„ğ’Œğ’†ğ’•(ğŸ) â€“ A Factory method system call that creates a socket with the given
parameters.
â€¢ ğ’ƒğ’Šğ’ğ’…(ğŸ) â€“ Whenever we create a new socket, we need to bind it to a specific port in
our machine, â€œto catch a portâ€. The port number is managed and used by the kernel
to link incoming packets to the corresponding application socket. The port numbers
are usually fixed. The ğ‘ğ‘‘ğ‘‘ğ‘Ÿ parameter must match the current socket that is used.
â€¢ ğ’ğ’Šğ’”ğ’•ğ’†ğ’(ğŸ) â€“ The ğ‘™ğ‘–ğ‘ ğ‘¡ğ‘’ğ‘›(2) system call doesn't do anything in the mean of
communication but only memory allocation (malloc) for stream sockets only. If we
won't allocate memory, any incoming connection will fail.
â€¢ ğ’„ğ’ğ’ğ’ğ’†ğ’„ğ’•(ğŸ) â€“ The ğ‘ğ‘œğ‘›ğ‘›ğ‘’ğ‘ğ‘¡(2) system call starts the link between a client and a
specific IP address and port number. The connection would complete when the
other side will call the ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call.
â€¢ ğ’‚ğ’„ğ’„ğ’†ğ’‘ğ’•(ğŸ) â€“ The ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call accepts the incoming stream connection
request from the other side, by the listening socket. This system call completes the
three-way handshake of stream socket (like TCP) and opens a new socket that has a
direct communication channel only with the other party in the handshake.
â€¢ ğ’”ğ’†ğ’ğ’…(ğŸ) and ğ’”ğ’†ğ’ğ’…ğ’•ğ’(ğŸ) â€“ The ğ‘ ğ‘’ğ‘›ğ‘‘(2) and ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system calls are an analogy
for the ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’(2) system call, specifcly for sockets, with flags set to 0. Those system
calls return the number of bytes that were sent through the socket itself, as the
number of bytes can vary. The ğ‘ ğ‘’ğ‘›ğ‘‘(2)system call designed for stream sockets (like
TCP), while the ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system call designed for datagram connection-less
sockets (like UDP). When the ğ‘ ğ‘’ğ‘›ğ‘‘(2) system call returns 0, it means that the other
party closed the connection.
â€¢ ğ’“ğ’†ğ’„ğ’—(ğŸ) and ğ’“ğ’†ğ’„ğ’—ğ’‡ğ’“ğ’ğ’(ğŸ) â€“ The ğ‘Ÿğ‘’ğ‘ğ‘£(2) and ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system calls are an
analogy for the ğ‘Ÿğ‘’ğ‘ğ‘‘(2) system call, specifically for sockets, with flags set to 0.
Those system calls return the number of bytes that were received through the socket
itself, as the number of bytes can vary. The ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call designed for stream
sockets (like TCP), while the ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system call designed for datagram
connection-less sockets (like UDP). When the ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call returns 0, it means
that the other party closed the connection.
â€¢ ğ’„ğ’ğ’ğ’”ğ’†(ğŸ) and ğ’”ğ’‰ğ’–ğ’•ğ’…ğ’ğ’˜ğ’(ğŸ) â€“ The ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) and ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2) system calls close
the socket. While ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) system call closes the whole socket, the ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2)
system call partially closes the socket for read/write.
 Communication Networks Course
Page | 12
Appendix C â€“ Random data generator
The data that you are going to send in this assignment is randomly generated. You can use
your own file with appropriate size or use the following function (or a function of your own)
to generate the data:
/*
* @brief A random data generator function based on srand() and rand().
* @param size The size of the data to generate (up to 2^32 bytes).
* @return A pointer to the buffer.
*/
char *util_generate_random_data(unsigned int size) {
 char *buffer = NULL;
 // Argument check.
 if (size == 0)
 return NULL;
 buffer = (char *)calloc(size, sizeof(char));
 // Error checking.
 if (buffer == NULL)
 return NULL;
 // Randomize the seed of the random number generator.
 srand(time(NULL));
 for (unsigned int i = 0; i < size; i++)
 *(buffer + i) = ((unsigned int)rand() % 256);
 return buffer;
}
 Communication Networks Course
Page | 13
Appendix D â€“ Checksum function
A checksum is a small-sized block of data derived from another block of digital data for the
purpose of detecting errors that may have been introduced during its transmission or
storage. By themselves, checksums are often used to verify data integrity but are not relied
upon to verify data authenticity.
Below is a simple yet efficient implementation of the checksum function, you can use it for
the assignment, but you can implement your own checksum function.
/*
* @brief A checksum function that returns 16 bit checksum for data.
* @param data The data to do the checksum for.
* @param bytes The length of the data in bytes.
* @return The checksum itself as 16 bit unsigned number.
* @note This function is taken from RFC1071, can be found here:
* @note https://tools.ietf.org/html/rfc1071
* @note It is the simplest way to calculate a checksum and is not very strong.
* However, it is good enough for this assignment.
* @note You are free to use any other checksum function as well.
* You can also use this function as such without any change.
*/
unsigned short int calculate_checksum(void *data, unsigned int bytes) {
 unsigned short int *data_pointer = (unsigned short int *)data;
 unsigned int total_sum = 0;
 // Main summing loop
 while (bytes > 1) {
 total_sum += *data_pointer++;
 bytes -= 2;
 }
 // Add left-over byte, if any
 if (bytes > 0)
 total_sum += *((unsigned char *)data_pointer);
 // Fold 32-bit sum to 16 bits
 while (total_sum >> 16)
 total_sum = (total_sum & 0xFFFF) + (total_sum >> 16);
 return (~((unsigned short int)total_sum));
} Communication Networks Course
Page | 1
Assignment 3 â€“ Transport Layer
Assignment Notes and Instructions
This assignment is to be done in pairs only. You must upload all the necessary files in a ZIP
file named after both of the studentâ€™s ID. For example: ğŸğŸğŸ‘ğŸ’ğŸ“ğŸ”ğŸ•ğŸ–ğŸ—_ğŸ—ğŸ–ğŸ•ğŸ”ğŸ“ğŸ’ğŸ‘ğŸğŸ. ğ’›ğ’Šğ’‘.
1) The assignment must be submitted by the date specified in the submission box.
2) All the assignment files (Code, Wireshark pcap files, PDF) must be submitted in a ZIP file. The
PDF must contain all the necessary screenshots with a description for each one of them.
3) The assignment must be done in pairs only. In exceptional cases, you should send an email to
the course coordinator.
4) You can use any reference material available through the course Moodle website or any
material passed during the exercises.
5) You can use any reference from the web, but copying codes from websites is forbidden; this
includes codes from other GitHub repositories. A student who gets caught in the act will
automatically fail this assignment (score 0). Any website youâ€™ve used to solve the
assignment, every website you used to solve the assignment must be noted in the PDF.
6) No delays in submission without special permission. Lateness without approval will result in
failure of the assignment (score 0).
7) All submissions will be submitted via the course's Moodle website. Email submissions will not
be accepted, resulting in a failure in the assignment.
8) The order and design of the code must be carefully considered. Make sure that the program
output is as clear as possible, comments in the code, and meaningful variable names. You
must also submit a makefile that compiles all the programs.
9) The assignment code must be written in C only.
10) The assignment is personal for each pair, and you should not accept help from other people,
whether outside the university or inside it. You can contact the course staff during reception
hours for help or raise a question in the course forum. Do not transfer code sections
between students, upload solutions or parts of solutions to websites on the Internet or in
various communication groups.
11) Students who copy a solution will receive a 0 in all assignments in the course and a report will
be made to the institutional disciplinary committee.
12) All code files of the assignment are required to both compile and run properly on the Ubuntu
22.04 LTS operating system. This is the operating system where the submissions will be
tested. You mustnâ€™t code it in Windows, as it uses different API for sockets. WSL wonâ€™t work,
as the task needs a tool that works only in a fully Linux environment.
Good Luck!
 Communication Networks Course
Page | 2
Part A â€“ Transmission Control Protocol (TCP) â€“ 30 points
In this part, youâ€™ll write two program files: ğ‘»ğ‘ªğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and ğ‘»ğ‘ªğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
The Sender will send a randomly generated file and the Receiver will receive it and measure
the time it took for his program to receive the file. The file size should be at least 2MB.
When running the Sender and Receiver, they both should support two standard congestion
control algorithms: TCP Reno and TCP Cubic.
Notes:
â€¢ The main goal of this part is to get familiar with the TCP concept of sending
messages between two endpoints.
â€¢ For approaching this part of the assignment, please be sure that you are familiar
with the congestion control algorithms and how to change them using the correct
method in C (see Appendix B for more information).
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). You've
learned that TCP is reliable by design, so you can assume that all the data have been
passed correctly, and thus, no need to recheck.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
Usage:
â€¢ Receiver:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
â€¢ Sender:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port of the Receiver.
â€¢ ğ‘¨ğ‘³ğ‘®ğ‘¶ â€“ The TCP congestion control algorithm that will be used by the party
member (either ğ’“ğ’†ğ’ğ’ for TCP Reno or ğ’„ğ’–ğ’ƒğ’Šğ’„ for TCP Cubic).
 Communication Networks Course
Page | 3
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a TCP socket between the Sender and the
Receiver.
3) Send the file.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a TCP connection between the Receiver and
the Sender.
2) Get a connection from the sender.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./TCP_Receiver -p 1234 -algo reno
Starting Receiver...
Waiting for TCP connection...
Sender connected, beginning to receive file...
File transfer completed.
Waiting for Sender response...
Sender sent exit message.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 4
Part B â€“ Reliable User Datagram Protocol (Reliable UDP or RUDP) â€“ 40 points
Youâ€™ve learned that while TCP is reliable, it lacks speed and has an overhead data of 20 bytes,
compering to UDP that needs only 8 bytes of overhead data.
Reliable UDP or RUDP, is a protocol that uses the UDP protocol for a faster transmission of
data, while adding a reliability layer to it, but without adding too much overhead data like
TCP.
A simple sketch for a RUDP connection would look something like this:
Your task in this part is to implement a Reliable protocol using UDP only. For simplicity, your
implementation should only support a handshake, closing scheme, error checking,
acknowledgment of received packets, and retransmission of lost packets.
Guidance:
â€¢ You can use ğ‘ ğ‘’ğ‘¡ğ‘ ğ‘œğ‘ğ‘˜ğ‘œğ‘ğ‘¡(2) for detecting a timeout.
â€¢ You need to build your own protocol, as Reliable UDP isnâ€™t a standard protocol (see a
draft of RUDP in this link), and no official header is provided. You can use this sketch
for a header, but you can come up with your own protocol, as long as it works.
Where:
o ğ‘³ğ’†ğ’ğ’ˆğ’•ğ’‰ is the length of the data itself, without the RUDP header.
o ğ‘ªğ’‰ğ’†ğ’„ğ’Œğ’”ğ’–ğ’ is a 16bit number that validates the correctness of the data.
o ğ‘­ğ’ğ’‚ğ’ˆğ’” is a special byte where we classify the packet itself (SYN, ACK, etc.).
â€¢ In your PDF, you must explain how your implementation of RUDP works â€“ How does
it detect a timeout to do retransmissions, how does the handshake work, what is the
header overhead, etc.
â€¢ For this part, youâ€™ll write three files: ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¨ğ‘·ğ‘°. ğ’„, ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and
ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
Reliable UDP Header proposed sketch
Byte 0 Byte 1 Byte 2 Byte 3
Length (2 Bytes) Checksum (2 Bytes)
Flags (1 Byte)
Figure 1 - RUDP Protocol Architecture, Geeksforgeeks
 Communication Networks Course
Page | 5
Notes:
â€¢ The Sender will send a random generated file and the Receiver will receive it and
measure the time it took for his program to receive the file. The file size should be at
least 2MB.
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). But, as the
RUDP is based on UDP, itâ€™s not reliable. You must use some form of error checking
(like checksum) to ensure that the packet wasnâ€™t alerted during the transfer.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
â€¢ The RUDP needs support only 1 sender and 1 receiver, for simplicity purposes.
Usage:
â€¢ Receiver:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
â€¢ Sender:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port that both the Sender and the Receiver will use.
The ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„ file will contain all the implementations of the RUDP API functions (That is, to
prevent reusing the same chuck of code both in the Sender and the Receiver.).
The API should support at the bare minimum the following functions (you decide what
parameters to implement, and what are the names of the functions, as long as the API is
explained in the PDF):
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘œğ‘ğ‘˜ğ‘’ğ‘¡() â€“ Creating a RUDP socket and creating a handshake between two
peers.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘’ğ‘›ğ‘‘() â€“ Sending data to the peer. The function should wait for an
acknowledgment packet, and if it didnâ€™t receive any, retransmits the data.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘Ÿğ‘’ğ‘ğ‘£() â€“ Receive data from a peer.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ğ‘™ğ‘œğ‘ ğ‘’() â€“ Closes a connection between peers.
 Communication Networks Course
Page | 6
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a UDP socket between the Sender and the
Receiver.
3) Send the file via the RUDP protocol.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a UDP connection between the Receiver and
the Sender.
2) Get a connection from the sender, by the custom
RUDP protocol youâ€™ve built.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./RUDP_Receiver -p 1234
Starting Receiver...
Waiting for RUDP connection...
Connection request received, sending ACK.
Sender connected, beginning to receive file...
File transfer completed.
ACK sent.
Waiting for Sender response...
Sender sent exit message.
ACK sent.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 7
Part C â€“ Research â€“ 30 points
In this part, youâ€™ll conduct research about your implementations of part A and part B.
In the research itself, each one of the versions (TCP version and UDP version) will be run at
least 5 times (meaning that the file transfer will occur at least 5 times) by the following
conditions:
â€¢ For TCP, youâ€™ll run it in TCP Reno and TCP Cubic, alternating each time, for each
scenario, meaning that you run 5 times with TCP Reno in both Sender and Receiver,
and 5 times with TCP Cubic in both Sender and Receiver.
Bonus (5 points): Create a very large data set â€“ 5 times with TCP Reno in both Sender
and Receiver, 5 times with TCP Reno in Sender and TCP Cubic in Receiver, 5 times
with TCP Cubic in Sender and TCP Reno in Receiver, and 5 times with TCP Cubic in
both Sender and Receiver. This will give you a data set large enough, which allows
you to work with, compare with and to reach a definite conclusion.
â€¢ For RUDP, you will run it 5 times for each scenario.
â€¢ For both TCP and RUDP, you will run them on those scenarios of packet loss:
o 0% packet loss â€“ Control group, simulating perfect connection.
o 2% packet loss â€“ Simulating unstable connection that commonly occur.
o 5% packet loss â€“ Simulating bad connection.
o 10% packet loss â€“ Simulating extremely poor connection.
For each scenario, you must provide a filtered PCAP file and relevant screenshots that
explain each one of the steps in the process. (10 points)
After youâ€™ve gathered the data set for both TCP and Reliable UDP, answer the following
questions:
1) In TCP, which congestion control algorithm gave better results overall? TCP Reno or
TCP Cubic? Which one gave better results on high packet loss? Explain how you came
to this conclusion based on the data set youâ€™ve gathered. (5 points)
2) How did your implementation of Reliable UDP perform overall compared to regular
TCP? Which one is better for high packet loss? (5 points)
3) According to the data youâ€™ve gathered, in which scenarios and applications would we
prefer to use TCP and in which situations would we prefer to use reliable UDP?
Explain your answer. (5 points)
 Communication Networks Course
Page | 8
×¢× ×• ×¢×œ ×”×©××œ×•×ª ×”×‘××•×ª )5 × ×§×•×“×•×ª(:
â— ×‘"×¨×©×ª ×××™× ×”" ×”×›×•×•× ×” ×”×™× ×œ×¨×©×ª ×©×‘×” ××¢×˜ ×××•×“ ×—×‘×™×œ×•×ª ×”×•×œ×›×•×ª ×œ××™×‘×•×“. ×‘"×§×©×¨ ××¨×•×š" ×”×›×•×•× ×” ×”×™×
×œ×§×©×¨ TCP ×©×™×© ×‘×• ×”×¨×‘×” ×××•×“ ××™×“×¢ ×œ×©×œ×•×—. ××•×¦×¢ ×œ×”×’×“×™×œ ×‘ -TCP ××ª SSThreshold ×‘×ª×—×™×œ×ª ×”×§×©×¨.
×‘××™×–×” ××”××§×¨×™× ×”×‘××™× ×”×©×™× ×•×™ ×”×–×” ×¢×©×•×™ ×œ×”×•×¢×™×œ ×‘××™×“×” ×”××™×¨×‘×™×ª? × ××§.
.1 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
.2 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.3 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.4 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.5 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.6 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.7 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.8 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
â— A ×©×•×œ×— ×œ -B ×—×‘×™×œ×•×ª ××™×“×¢ ×‘×××¦×¢×•×ª ×§×©×¨ TCP. × ×ª×•×Ÿ ×›×™ ×”×§×©×¨ ××ª×—×™×œ ×¢× ×—×œ×•×Ÿ ×‘×’×•×“×œ 1MSS. ×”×§×©×¨
××¡×ª×™×™× ×‘×¤×¢× ×”×¨××©×•× ×” ×©×”×•× ××’×™×¢ ×œ -SSthresh. ×‘××”×œ×š ×”×§×©×¨ ×œ× ××•×‘×“×•×ª ×—×‘×™×œ×•×ª. × ×¡××Ÿ ×‘×§×™×¦×•×¨:
.SSthresh=S*MSS
× ×ª×•×Ÿ ×›×™ ×œ××•×¨×š ×›×œ ×”×§×©×¨ rwnd < MSS*S.
××”×™ ×”×ª×¤×•×§×” ×©×œ ×”×§×©×¨ ×-A ×œ-B( ×‘ -sec / Bytes )×‘×–××Ÿ ×”× "×œ? × ××§×™.
]S*MSS / [lg (S) * RTT*2 ×‘×¢×¨×š .1
]S*MSS / [S^0.5 * RTT*2 ×‘×¢×¨×š .2
S*MSS / RTT ×‘×¢×¨×š .3
S^2)*MSS / RTT( ×‘×¢×¨×š .4
â— ×©×ª×™ ×ª×—× ×•×ª ××ª×§×©×¨×•×ª ×‘××•×¤×Ÿ ××œ×—×•×˜×™ ×‘×©×™×˜×ª N Back Go.
× ×¡××Ÿ ×‘-X ××ª ×¡×¤×¨×ª ×”×‘×™×§×•×¨×ª ×©×œ ×”×ª.×–. ×©×œ×š. ×× ×©× ×™ ×©×•×ª×¤×™× ××’×™×©×™× ××ª ×”×ª×¨×’×™×œ ×™×—×“, X ×”×•× ×¡×¤×¨×ª
×”×‘×™×§×•×¨×ª ×‘×¢×œ×ª ×”×¢×¨×š ×”× ××•×š ×™×•×ª×¨ ××‘×™×Ÿ ×”×©×ª×™×™×.
×§×¦×‘ ×”×ª×§×©×•×¨×ª ×”×•× 8Gbps, ×•×’×•×“×œ ×›×œ ×—×‘×™×œ×” ×”×•× KByte*X. ×’×“×œ×™ ×”-headers ×•×” -Acks ×–× ×™×—×™×.
ï¿½ğ‘’ğ‘ ï¿½/ï¿½ï¿½ 8 , ×•×”××¨×—×§ ×‘×™×Ÿ ×”×ª×—× ×•×ª ×”×•× 1Km. ×§×¦×‘ ×”×”×ª×¤×©×˜×•×ª ×”×•× 10 â‹… 2
×–××Ÿ ×¢×™×‘×•×“ ×”× ×ª×•× ×™× ×‘×ª×—× ×•×ª ×–× ×™×—.
××£ ×—×‘×™×œ×” ×•××£ Ack ×œ× ×”×•×œ×›×™× ×œ××™×‘×•×“.
â— ××”×• X ×©×œ×š?
â— ××” ×¦×¨×™×š ×œ×”×™×•×ª ×’×•×“×œ ×—×œ×•×Ÿ ×”××©×œ×•×— ×›×“×™ ×œ×”×‘×˜×™×— ×ª×¤×•×§×” ××§×¡×™××œ×™×ª?
 Communication Networks Course
Page | 9
Bonus â€“ Improving the Reliable UDP â€“ 15 points
Note: This part isnâ€™t mandatory and is a bonus only!
In this part, youâ€™ll improve your RUDP implementation by adding the concepts of flow
control and congestion control from TCP. Youâ€™re free to choose which algorithms to
implement, as long as you explain in your PDF which algorithms youâ€™ve used. Youâ€™ll probably
need to make changes in the original design of the RUDP. Changes only need to be to the API
itself, ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„.
Points distribution:
â€¢ Flow control improvement â€“ 7 Points
â€¢ Congestion control improvement â€“ 8 points.
Guidance:
â€¢ For flow control, you must use one of the Sliding window techniques: stop-and-wait
ARQ, Go-Back-N or Selective repeat.
â€¢ List of known TCP congestion control algorithms, which you can use any one of them
for this bonus task, or makeup your own:
Figure 2 â€“ List of known TCP congestion control algorithms, Wikipedia
 Communication Networks Course
Page | 10
Appendix A â€“ Linux local packet loss tool
To simulate a packet loss in a local network, we'll use a Linux tool that's called Linux Traffic
Control (ğ‘¡ğ‘). This requires a full Linux installation, so working with WSL won't work.
If the tool isn't installed in your machine, you can install it by using the following commands:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’
If the installation didn't work, you can use the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’2
To create a packet loss scenario, type the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘ğ‘‘ğ‘‘ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
After creating a packet loss scenario, you can change the percentage by typing the following
command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘â„ğ‘ğ‘›ğ‘”ğ‘’ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
To remove the packet loss scenario, write the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘‘ğ‘’ğ‘™ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š
 Communication Networks Course
Page | 11
Appendix B â€“ ğ’ğ’‚ğ’(ğŸ) system calls
This appendixâ€™s purpose is to give you a better understanding of socket handling in C.
A recommended reference is Beejâ€™s Guide to Network Programming, by Brian â€œBeej
Jorgensenâ€ Hall, which gives a lot of information about sockets in C and functions.
Functions and documentation links:
â€¢ ğ’”ğ’ğ’„ğ’Œğ’†ğ’•(ğŸ) â€“ A Factory method system call that creates a socket with the given
parameters.
â€¢ ğ’ƒğ’Šğ’ğ’…(ğŸ) â€“ Whenever we create a new socket, we need to bind it to a specific port in
our machine, â€œto catch a portâ€. The port number is managed and used by the kernel
to link incoming packets to the corresponding application socket. The port numbers
are usually fixed. The ğ‘ğ‘‘ğ‘‘ğ‘Ÿ parameter must match the current socket that is used.
â€¢ ğ’ğ’Šğ’”ğ’•ğ’†ğ’(ğŸ) â€“ The ğ‘™ğ‘–ğ‘ ğ‘¡ğ‘’ğ‘›(2) system call doesn't do anything in the mean of
communication but only memory allocation (malloc) for stream sockets only. If we
won't allocate memory, any incoming connection will fail.
â€¢ ğ’„ğ’ğ’ğ’ğ’†ğ’„ğ’•(ğŸ) â€“ The ğ‘ğ‘œğ‘›ğ‘›ğ‘’ğ‘ğ‘¡(2) system call starts the link between a client and a
specific IP address and port number. The connection would complete when the
other side will call the ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call.
â€¢ ğ’‚ğ’„ğ’„ğ’†ğ’‘ğ’•(ğŸ) â€“ The ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call accepts the incoming stream connection
request from the other side, by the listening socket. This system call completes the
three-way handshake of stream socket (like TCP) and opens a new socket that has a
direct communication channel only with the other party in the handshake.
â€¢ ğ’”ğ’†ğ’ğ’…(ğŸ) and ğ’”ğ’†ğ’ğ’…ğ’•ğ’(ğŸ) â€“ The ğ‘ ğ‘’ğ‘›ğ‘‘(2) and ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system calls are an analogy
for the ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’(2) system call, specifcly for sockets, with flags set to 0. Those system
calls return the number of bytes that were sent through the socket itself, as the
number of bytes can vary. The ğ‘ ğ‘’ğ‘›ğ‘‘(2)system call designed for stream sockets (like
TCP), while the ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system call designed for datagram connection-less
sockets (like UDP). When the ğ‘ ğ‘’ğ‘›ğ‘‘(2) system call returns 0, it means that the other
party closed the connection.
â€¢ ğ’“ğ’†ğ’„ğ’—(ğŸ) and ğ’“ğ’†ğ’„ğ’—ğ’‡ğ’“ğ’ğ’(ğŸ) â€“ The ğ‘Ÿğ‘’ğ‘ğ‘£(2) and ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system calls are an
analogy for the ğ‘Ÿğ‘’ğ‘ğ‘‘(2) system call, specifically for sockets, with flags set to 0.
Those system calls return the number of bytes that were received through the socket
itself, as the number of bytes can vary. The ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call designed for stream
sockets (like TCP), while the ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system call designed for datagram
connection-less sockets (like UDP). When the ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call returns 0, it means
that the other party closed the connection.
â€¢ ğ’„ğ’ğ’ğ’”ğ’†(ğŸ) and ğ’”ğ’‰ğ’–ğ’•ğ’…ğ’ğ’˜ğ’(ğŸ) â€“ The ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) and ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2) system calls close
the socket. While ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) system call closes the whole socket, the ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2)
system call partially closes the socket for read/write.
 Communication Networks Course
Page | 12
Appendix C â€“ Random data generator
The data that you are going to send in this assignment is randomly generated. You can use
your own file with appropriate size or use the following function (or a function of your own)
to generate the data:
/*
* @brief A random data generator function based on srand() and rand().
* @param size The size of the data to generate (up to 2^32 bytes).
* @return A pointer to the buffer.
*/
char *util_generate_random_data(unsigned int size) {
 char *buffer = NULL;
 // Argument check.
 if (size == 0)
 return NULL;
 buffer = (char *)calloc(size, sizeof(char));
 // Error checking.
 if (buffer == NULL)
 return NULL;
 // Randomize the seed of the random number generator.
 srand(time(NULL));
 for (unsigned int i = 0; i < size; i++)
 *(buffer + i) = ((unsigned int)rand() % 256);
 return buffer;
}
 Communication Networks Course
Page | 13
Appendix D â€“ Checksum function
A checksum is a small-sized block of data derived from another block of digital data for the
purpose of detecting errors that may have been introduced during its transmission or
storage. By themselves, checksums are often used to verify data integrity but are not relied
upon to verify data authenticity.
Below is a simple yet efficient implementation of the checksum function, you can use it for
the assignment, but you can implement your own checksum function.
/*
* @brief A checksum function that returns 16 bit checksum for data.
* @param data The data to do the checksum for.
* @param bytes The length of the data in bytes.
* @return The checksum itself as 16 bit unsigned number.
* @note This function is taken from RFC1071, can be found here:
* @note https://tools.ietf.org/html/rfc1071
* @note It is the simplest way to calculate a checksum and is not very strong.
* However, it is good enough for this assignment.
* @note You are free to use any other checksum function as well.
* You can also use this function as such without any change.
*/
unsigned short int calculate_checksum(void *data, unsigned int bytes) {
 unsigned short int *data_pointer = (unsigned short int *)data;
 unsigned int total_sum = 0;
 // Main summing loop
 while (bytes > 1) {
 total_sum += *data_pointer++;
 bytes -= 2;
 }
 // Add left-over byte, if any
 if (bytes > 0)
 total_sum += *((unsigned char *)data_pointer);
 // Fold 32-bit sum to 16 bits
 while (total_sum >> 16)
 total_sum = (total_sum & 0xFFFF) + (total_sum >> 16);
 return (~((unsigned short int)total_sum));
} Communication Networks Course
Page | 1
Assignment 3 â€“ Transport Layer
Assignment Notes and Instructions
This assignment is to be done in pairs only. You must upload all the necessary files in a ZIP
file named after both of the studentâ€™s ID. For example: ğŸğŸğŸ‘ğŸ’ğŸ“ğŸ”ğŸ•ğŸ–ğŸ—_ğŸ—ğŸ–ğŸ•ğŸ”ğŸ“ğŸ’ğŸ‘ğŸğŸ. ğ’›ğ’Šğ’‘.
1) The assignment must be submitted by the date specified in the submission box.
2) All the assignment files (Code, Wireshark pcap files, PDF) must be submitted in a ZIP file. The
PDF must contain all the necessary screenshots with a description for each one of them.
3) The assignment must be done in pairs only. In exceptional cases, you should send an email to
the course coordinator.
4) You can use any reference material available through the course Moodle website or any
material passed during the exercises.
5) You can use any reference from the web, but copying codes from websites is forbidden; this
includes codes from other GitHub repositories. A student who gets caught in the act will
automatically fail this assignment (score 0). Any website youâ€™ve used to solve the
assignment, every website you used to solve the assignment must be noted in the PDF.
6) No delays in submission without special permission. Lateness without approval will result in
failure of the assignment (score 0).
7) All submissions will be submitted via the course's Moodle website. Email submissions will not
be accepted, resulting in a failure in the assignment.
8) The order and design of the code must be carefully considered. Make sure that the program
output is as clear as possible, comments in the code, and meaningful variable names. You
must also submit a makefile that compiles all the programs.
9) The assignment code must be written in C only.
10) The assignment is personal for each pair, and you should not accept help from other people,
whether outside the university or inside it. You can contact the course staff during reception
hours for help or raise a question in the course forum. Do not transfer code sections
between students, upload solutions or parts of solutions to websites on the Internet or in
various communication groups.
11) Students who copy a solution will receive a 0 in all assignments in the course and a report will
be made to the institutional disciplinary committee.
12) All code files of the assignment are required to both compile and run properly on the Ubuntu
22.04 LTS operating system. This is the operating system where the submissions will be
tested. You mustnâ€™t code it in Windows, as it uses different API for sockets. WSL wonâ€™t work,
as the task needs a tool that works only in a fully Linux environment.
Good Luck!
 Communication Networks Course
Page | 2
Part A â€“ Transmission Control Protocol (TCP) â€“ 30 points
In this part, youâ€™ll write two program files: ğ‘»ğ‘ªğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and ğ‘»ğ‘ªğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
The Sender will send a randomly generated file and the Receiver will receive it and measure
the time it took for his program to receive the file. The file size should be at least 2MB.
When running the Sender and Receiver, they both should support two standard congestion
control algorithms: TCP Reno and TCP Cubic.
Notes:
â€¢ The main goal of this part is to get familiar with the TCP concept of sending
messages between two endpoints.
â€¢ For approaching this part of the assignment, please be sure that you are familiar
with the congestion control algorithms and how to change them using the correct
method in C (see Appendix B for more information).
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). You've
learned that TCP is reliable by design, so you can assume that all the data have been
passed correctly, and thus, no need to recheck.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
Usage:
â€¢ Receiver:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
â€¢ Sender:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port of the Receiver.
â€¢ ğ‘¨ğ‘³ğ‘®ğ‘¶ â€“ The TCP congestion control algorithm that will be used by the party
member (either ğ’“ğ’†ğ’ğ’ for TCP Reno or ğ’„ğ’–ğ’ƒğ’Šğ’„ for TCP Cubic).
 Communication Networks Course
Page | 3
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a TCP socket between the Sender and the
Receiver.
3) Send the file.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a TCP connection between the Receiver and
the Sender.
2) Get a connection from the sender.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./TCP_Receiver -p 1234 -algo reno
Starting Receiver...
Waiting for TCP connection...
Sender connected, beginning to receive file...
File transfer completed.
Waiting for Sender response...
Sender sent exit message.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 4
Part B â€“ Reliable User Datagram Protocol (Reliable UDP or RUDP) â€“ 40 points
Youâ€™ve learned that while TCP is reliable, it lacks speed and has an overhead data of 20 bytes,
compering to UDP that needs only 8 bytes of overhead data.
Reliable UDP or RUDP, is a protocol that uses the UDP protocol for a faster transmission of
data, while adding a reliability layer to it, but without adding too much overhead data like
TCP.
A simple sketch for a RUDP connection would look something like this:
Your task in this part is to implement a Reliable protocol using UDP only. For simplicity, your
implementation should only support a handshake, closing scheme, error checking,
acknowledgment of received packets, and retransmission of lost packets.
Guidance:
â€¢ You can use ğ‘ ğ‘’ğ‘¡ğ‘ ğ‘œğ‘ğ‘˜ğ‘œğ‘ğ‘¡(2) for detecting a timeout.
â€¢ You need to build your own protocol, as Reliable UDP isnâ€™t a standard protocol (see a
draft of RUDP in this link), and no official header is provided. You can use this sketch
for a header, but you can come up with your own protocol, as long as it works.
Where:
o ğ‘³ğ’†ğ’ğ’ˆğ’•ğ’‰ is the length of the data itself, without the RUDP header.
o ğ‘ªğ’‰ğ’†ğ’„ğ’Œğ’”ğ’–ğ’ is a 16bit number that validates the correctness of the data.
o ğ‘­ğ’ğ’‚ğ’ˆğ’” is a special byte where we classify the packet itself (SYN, ACK, etc.).
â€¢ In your PDF, you must explain how your implementation of RUDP works â€“ How does
it detect a timeout to do retransmissions, how does the handshake work, what is the
header overhead, etc.
â€¢ For this part, youâ€™ll write three files: ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¨ğ‘·ğ‘°. ğ’„, ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and
ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
Reliable UDP Header proposed sketch
Byte 0 Byte 1 Byte 2 Byte 3
Length (2 Bytes) Checksum (2 Bytes)
Flags (1 Byte)
Figure 1 - RUDP Protocol Architecture, Geeksforgeeks
 Communication Networks Course
Page | 5
Notes:
â€¢ The Sender will send a random generated file and the Receiver will receive it and
measure the time it took for his program to receive the file. The file size should be at
least 2MB.
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). But, as the
RUDP is based on UDP, itâ€™s not reliable. You must use some form of error checking
(like checksum) to ensure that the packet wasnâ€™t alerted during the transfer.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
â€¢ The RUDP needs support only 1 sender and 1 receiver, for simplicity purposes.
Usage:
â€¢ Receiver:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
â€¢ Sender:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port that both the Sender and the Receiver will use.
The ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„ file will contain all the implementations of the RUDP API functions (That is, to
prevent reusing the same chuck of code both in the Sender and the Receiver.).
The API should support at the bare minimum the following functions (you decide what
parameters to implement, and what are the names of the functions, as long as the API is
explained in the PDF):
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘œğ‘ğ‘˜ğ‘’ğ‘¡() â€“ Creating a RUDP socket and creating a handshake between two
peers.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘’ğ‘›ğ‘‘() â€“ Sending data to the peer. The function should wait for an
acknowledgment packet, and if it didnâ€™t receive any, retransmits the data.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘Ÿğ‘’ğ‘ğ‘£() â€“ Receive data from a peer.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ğ‘™ğ‘œğ‘ ğ‘’() â€“ Closes a connection between peers.
 Communication Networks Course
Page | 6
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a UDP socket between the Sender and the
Receiver.
3) Send the file via the RUDP protocol.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a UDP connection between the Receiver and
the Sender.
2) Get a connection from the sender, by the custom
RUDP protocol youâ€™ve built.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./RUDP_Receiver -p 1234
Starting Receiver...
Waiting for RUDP connection...
Connection request received, sending ACK.
Sender connected, beginning to receive file...
File transfer completed.
ACK sent.
Waiting for Sender response...
Sender sent exit message.
ACK sent.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 7
Part C â€“ Research â€“ 30 points
In this part, youâ€™ll conduct research about your implementations of part A and part B.
In the research itself, each one of the versions (TCP version and UDP version) will be run at
least 5 times (meaning that the file transfer will occur at least 5 times) by the following
conditions:
â€¢ For TCP, youâ€™ll run it in TCP Reno and TCP Cubic, alternating each time, for each
scenario, meaning that you run 5 times with TCP Reno in both Sender and Receiver,
and 5 times with TCP Cubic in both Sender and Receiver.
Bonus (5 points): Create a very large data set â€“ 5 times with TCP Reno in both Sender
and Receiver, 5 times with TCP Reno in Sender and TCP Cubic in Receiver, 5 times
with TCP Cubic in Sender and TCP Reno in Receiver, and 5 times with TCP Cubic in
both Sender and Receiver. This will give you a data set large enough, which allows
you to work with, compare with and to reach a definite conclusion.
â€¢ For RUDP, you will run it 5 times for each scenario.
â€¢ For both TCP and RUDP, you will run them on those scenarios of packet loss:
o 0% packet loss â€“ Control group, simulating perfect connection.
o 2% packet loss â€“ Simulating unstable connection that commonly occur.
o 5% packet loss â€“ Simulating bad connection.
o 10% packet loss â€“ Simulating extremely poor connection.
For each scenario, you must provide a filtered PCAP file and relevant screenshots that
explain each one of the steps in the process. (10 points)
After youâ€™ve gathered the data set for both TCP and Reliable UDP, answer the following
questions:
1) In TCP, which congestion control algorithm gave better results overall? TCP Reno or
TCP Cubic? Which one gave better results on high packet loss? Explain how you came
to this conclusion based on the data set youâ€™ve gathered. (5 points)
2) How did your implementation of Reliable UDP perform overall compared to regular
TCP? Which one is better for high packet loss? (5 points)
3) According to the data youâ€™ve gathered, in which scenarios and applications would we
prefer to use TCP and in which situations would we prefer to use reliable UDP?
Explain your answer. (5 points)
 Communication Networks Course
Page | 8
×¢× ×• ×¢×œ ×”×©××œ×•×ª ×”×‘××•×ª )5 × ×§×•×“×•×ª(:
â— ×‘"×¨×©×ª ×××™× ×”" ×”×›×•×•× ×” ×”×™× ×œ×¨×©×ª ×©×‘×” ××¢×˜ ×××•×“ ×—×‘×™×œ×•×ª ×”×•×œ×›×•×ª ×œ××™×‘×•×“. ×‘"×§×©×¨ ××¨×•×š" ×”×›×•×•× ×” ×”×™×
×œ×§×©×¨ TCP ×©×™×© ×‘×• ×”×¨×‘×” ×××•×“ ××™×“×¢ ×œ×©×œ×•×—. ××•×¦×¢ ×œ×”×’×“×™×œ ×‘ -TCP ××ª SSThreshold ×‘×ª×—×™×œ×ª ×”×§×©×¨.
×‘××™×–×” ××”××§×¨×™× ×”×‘××™× ×”×©×™× ×•×™ ×”×–×” ×¢×©×•×™ ×œ×”×•×¢×™×œ ×‘××™×“×” ×”××™×¨×‘×™×ª? × ××§.
.1 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
.2 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.3 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.4 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.5 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.6 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.7 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.8 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
â— A ×©×•×œ×— ×œ -B ×—×‘×™×œ×•×ª ××™×“×¢ ×‘×××¦×¢×•×ª ×§×©×¨ TCP. × ×ª×•×Ÿ ×›×™ ×”×§×©×¨ ××ª×—×™×œ ×¢× ×—×œ×•×Ÿ ×‘×’×•×“×œ 1MSS. ×”×§×©×¨
××¡×ª×™×™× ×‘×¤×¢× ×”×¨××©×•× ×” ×©×”×•× ××’×™×¢ ×œ -SSthresh. ×‘××”×œ×š ×”×§×©×¨ ×œ× ××•×‘×“×•×ª ×—×‘×™×œ×•×ª. × ×¡××Ÿ ×‘×§×™×¦×•×¨:
.SSthresh=S*MSS
× ×ª×•×Ÿ ×›×™ ×œ××•×¨×š ×›×œ ×”×§×©×¨ rwnd < MSS*S.
××”×™ ×”×ª×¤×•×§×” ×©×œ ×”×§×©×¨ ×-A ×œ-B( ×‘ -sec / Bytes )×‘×–××Ÿ ×”× "×œ? × ××§×™.
]S*MSS / [lg (S) * RTT*2 ×‘×¢×¨×š .1
]S*MSS / [S^0.5 * RTT*2 ×‘×¢×¨×š .2
S*MSS / RTT ×‘×¢×¨×š .3
S^2)*MSS / RTT( ×‘×¢×¨×š .4
â— ×©×ª×™ ×ª×—× ×•×ª ××ª×§×©×¨×•×ª ×‘××•×¤×Ÿ ××œ×—×•×˜×™ ×‘×©×™×˜×ª N Back Go.
× ×¡××Ÿ ×‘-X ××ª ×¡×¤×¨×ª ×”×‘×™×§×•×¨×ª ×©×œ ×”×ª.×–. ×©×œ×š. ×× ×©× ×™ ×©×•×ª×¤×™× ××’×™×©×™× ××ª ×”×ª×¨×’×™×œ ×™×—×“, X ×”×•× ×¡×¤×¨×ª
×”×‘×™×§×•×¨×ª ×‘×¢×œ×ª ×”×¢×¨×š ×”× ××•×š ×™×•×ª×¨ ××‘×™×Ÿ ×”×©×ª×™×™×.
×§×¦×‘ ×”×ª×§×©×•×¨×ª ×”×•× 8Gbps, ×•×’×•×“×œ ×›×œ ×—×‘×™×œ×” ×”×•× KByte*X. ×’×“×œ×™ ×”-headers ×•×” -Acks ×–× ×™×—×™×.
ï¿½ğ‘’ğ‘ ï¿½/ï¿½ï¿½ 8 , ×•×”××¨×—×§ ×‘×™×Ÿ ×”×ª×—× ×•×ª ×”×•× 1Km. ×§×¦×‘ ×”×”×ª×¤×©×˜×•×ª ×”×•× 10 â‹… 2
×–××Ÿ ×¢×™×‘×•×“ ×”× ×ª×•× ×™× ×‘×ª×—× ×•×ª ×–× ×™×—.
××£ ×—×‘×™×œ×” ×•××£ Ack ×œ× ×”×•×œ×›×™× ×œ××™×‘×•×“.
â— ××”×• X ×©×œ×š?
â— ××” ×¦×¨×™×š ×œ×”×™×•×ª ×’×•×“×œ ×—×œ×•×Ÿ ×”××©×œ×•×— ×›×“×™ ×œ×”×‘×˜×™×— ×ª×¤×•×§×” ××§×¡×™××œ×™×ª?
 Communication Networks Course
Page | 9
Bonus â€“ Improving the Reliable UDP â€“ 15 points
Note: This part isnâ€™t mandatory and is a bonus only!
In this part, youâ€™ll improve your RUDP implementation by adding the concepts of flow
control and congestion control from TCP. Youâ€™re free to choose which algorithms to
implement, as long as you explain in your PDF which algorithms youâ€™ve used. Youâ€™ll probably
need to make changes in the original design of the RUDP. Changes only need to be to the API
itself, ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„.
Points distribution:
â€¢ Flow control improvement â€“ 7 Points
â€¢ Congestion control improvement â€“ 8 points.
Guidance:
â€¢ For flow control, you must use one of the Sliding window techniques: stop-and-wait
ARQ, Go-Back-N or Selective repeat.
â€¢ List of known TCP congestion control algorithms, which you can use any one of them
for this bonus task, or makeup your own:
Figure 2 â€“ List of known TCP congestion control algorithms, Wikipedia
 Communication Networks Course
Page | 10
Appendix A â€“ Linux local packet loss tool
To simulate a packet loss in a local network, we'll use a Linux tool that's called Linux Traffic
Control (ğ‘¡ğ‘). This requires a full Linux installation, so working with WSL won't work.
If the tool isn't installed in your machine, you can install it by using the following commands:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’
If the installation didn't work, you can use the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’2
To create a packet loss scenario, type the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘ğ‘‘ğ‘‘ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
After creating a packet loss scenario, you can change the percentage by typing the following
command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘â„ğ‘ğ‘›ğ‘”ğ‘’ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
To remove the packet loss scenario, write the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘‘ğ‘’ğ‘™ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š
 Communication Networks Course
Page | 11
Appendix B â€“ ğ’ğ’‚ğ’(ğŸ) system calls
This appendixâ€™s purpose is to give you a better understanding of socket handling in C.
A recommended reference is Beejâ€™s Guide to Network Programming, by Brian â€œBeej
Jorgensenâ€ Hall, which gives a lot of information about sockets in C and functions.
Functions and documentation links:
â€¢ ğ’”ğ’ğ’„ğ’Œğ’†ğ’•(ğŸ) â€“ A Factory method system call that creates a socket with the given
parameters.
â€¢ ğ’ƒğ’Šğ’ğ’…(ğŸ) â€“ Whenever we create a new socket, we need to bind it to a specific port in
our machine, â€œto catch a portâ€. The port number is managed and used by the kernel
to link incoming packets to the corresponding application socket. The port numbers
are usually fixed. The ğ‘ğ‘‘ğ‘‘ğ‘Ÿ parameter must match the current socket that is used.
â€¢ ğ’ğ’Šğ’”ğ’•ğ’†ğ’(ğŸ) â€“ The ğ‘™ğ‘–ğ‘ ğ‘¡ğ‘’ğ‘›(2) system call doesn't do anything in the mean of
communication but only memory allocation (malloc) for stream sockets only. If we
won't allocate memory, any incoming connection will fail.
â€¢ ğ’„ğ’ğ’ğ’ğ’†ğ’„ğ’•(ğŸ) â€“ The ğ‘ğ‘œğ‘›ğ‘›ğ‘’ğ‘ğ‘¡(2) system call starts the link between a client and a
specific IP address and port number. The connection would complete when the
other side will call the ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call.
â€¢ ğ’‚ğ’„ğ’„ğ’†ğ’‘ğ’•(ğŸ) â€“ The ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call accepts the incoming stream connection
request from the other side, by the listening socket. This system call completes the
three-way handshake of stream socket (like TCP) and opens a new socket that has a
direct communication channel only with the other party in the handshake.
â€¢ ğ’”ğ’†ğ’ğ’…(ğŸ) and ğ’”ğ’†ğ’ğ’…ğ’•ğ’(ğŸ) â€“ The ğ‘ ğ‘’ğ‘›ğ‘‘(2) and ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system calls are an analogy
for the ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’(2) system call, specifcly for sockets, with flags set to 0. Those system
calls return the number of bytes that were sent through the socket itself, as the
number of bytes can vary. The ğ‘ ğ‘’ğ‘›ğ‘‘(2)system call designed for stream sockets (like
TCP), while the ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system call designed for datagram connection-less
sockets (like UDP). When the ğ‘ ğ‘’ğ‘›ğ‘‘(2) system call returns 0, it means that the other
party closed the connection.
â€¢ ğ’“ğ’†ğ’„ğ’—(ğŸ) and ğ’“ğ’†ğ’„ğ’—ğ’‡ğ’“ğ’ğ’(ğŸ) â€“ The ğ‘Ÿğ‘’ğ‘ğ‘£(2) and ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system calls are an
analogy for the ğ‘Ÿğ‘’ğ‘ğ‘‘(2) system call, specifically for sockets, with flags set to 0.
Those system calls return the number of bytes that were received through the socket
itself, as the number of bytes can vary. The ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call designed for stream
sockets (like TCP), while the ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system call designed for datagram
connection-less sockets (like UDP). When the ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call returns 0, it means
that the other party closed the connection.
â€¢ ğ’„ğ’ğ’ğ’”ğ’†(ğŸ) and ğ’”ğ’‰ğ’–ğ’•ğ’…ğ’ğ’˜ğ’(ğŸ) â€“ The ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) and ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2) system calls close
the socket. While ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) system call closes the whole socket, the ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2)
system call partially closes the socket for read/write.
 Communication Networks Course
Page | 12
Appendix C â€“ Random data generator
The data that you are going to send in this assignment is randomly generated. You can use
your own file with appropriate size or use the following function (or a function of your own)
to generate the data:
/*
* @brief A random data generator function based on srand() and rand().
* @param size The size of the data to generate (up to 2^32 bytes).
* @return A pointer to the buffer.
*/
char *util_generate_random_data(unsigned int size) {
 char *buffer = NULL;
 // Argument check.
 if (size == 0)
 return NULL;
 buffer = (char *)calloc(size, sizeof(char));
 // Error checking.
 if (buffer == NULL)
 return NULL;
 // Randomize the seed of the random number generator.
 srand(time(NULL));
 for (unsigned int i = 0; i < size; i++)
 *(buffer + i) = ((unsigned int)rand() % 256);
 return buffer;
}
 Communication Networks Course
Page | 13
Appendix D â€“ Checksum function
A checksum is a small-sized block of data derived from another block of digital data for the
purpose of detecting errors that may have been introduced during its transmission or
storage. By themselves, checksums are often used to verify data integrity but are not relied
upon to verify data authenticity.
Below is a simple yet efficient implementation of the checksum function, you can use it for
the assignment, but you can implement your own checksum function.
/*
* @brief A checksum function that returns 16 bit checksum for data.
* @param data The data to do the checksum for.
* @param bytes The length of the data in bytes.
* @return The checksum itself as 16 bit unsigned number.
* @note This function is taken from RFC1071, can be found here:
* @note https://tools.ietf.org/html/rfc1071
* @note It is the simplest way to calculate a checksum and is not very strong.
* However, it is good enough for this assignment.
* @note You are free to use any other checksum function as well.
* You can also use this function as such without any change.
*/
unsigned short int calculate_checksum(void *data, unsigned int bytes) {
 unsigned short int *data_pointer = (unsigned short int *)data;
 unsigned int total_sum = 0;
 // Main summing loop
 while (bytes > 1) {
 total_sum += *data_pointer++;
 bytes -= 2;
 }
 // Add left-over byte, if any
 if (bytes > 0)
 total_sum += *((unsigned char *)data_pointer);
 // Fold 32-bit sum to 16 bits
 while (total_sum >> 16)
 total_sum = (total_sum & 0xFFFF) + (total_sum >> 16);
 return (~((unsigned short int)total_sum));
} Communication Networks Course
Page | 1
Assignment 3 â€“ Transport Layer
Assignment Notes and Instructions
This assignment is to be done in pairs only. You must upload all the necessary files in a ZIP
file named after both of the studentâ€™s ID. For example: ğŸğŸğŸ‘ğŸ’ğŸ“ğŸ”ğŸ•ğŸ–ğŸ—_ğŸ—ğŸ–ğŸ•ğŸ”ğŸ“ğŸ’ğŸ‘ğŸğŸ. ğ’›ğ’Šğ’‘.
1) The assignment must be submitted by the date specified in the submission box.
2) All the assignment files (Code, Wireshark pcap files, PDF) must be submitted in a ZIP file. The
PDF must contain all the necessary screenshots with a description for each one of them.
3) The assignment must be done in pairs only. In exceptional cases, you should send an email to
the course coordinator.
4) You can use any reference material available through the course Moodle website or any
material passed during the exercises.
5) You can use any reference from the web, but copying codes from websites is forbidden; this
includes codes from other GitHub repositories. A student who gets caught in the act will
automatically fail this assignment (score 0). Any website youâ€™ve used to solve the
assignment, every website you used to solve the assignment must be noted in the PDF.
6) No delays in submission without special permission. Lateness without approval will result in
failure of the assignment (score 0).
7) All submissions will be submitted via the course's Moodle website. Email submissions will not
be accepted, resulting in a failure in the assignment.
8) The order and design of the code must be carefully considered. Make sure that the program
output is as clear as possible, comments in the code, and meaningful variable names. You
must also submit a makefile that compiles all the programs.
9) The assignment code must be written in C only.
10) The assignment is personal for each pair, and you should not accept help from other people,
whether outside the university or inside it. You can contact the course staff during reception
hours for help or raise a question in the course forum. Do not transfer code sections
between students, upload solutions or parts of solutions to websites on the Internet or in
various communication groups.
11) Students who copy a solution will receive a 0 in all assignments in the course and a report will
be made to the institutional disciplinary committee.
12) All code files of the assignment are required to both compile and run properly on the Ubuntu
22.04 LTS operating system. This is the operating system where the submissions will be
tested. You mustnâ€™t code it in Windows, as it uses different API for sockets. WSL wonâ€™t work,
as the task needs a tool that works only in a fully Linux environment.
Good Luck!
 Communication Networks Course
Page | 2
Part A â€“ Transmission Control Protocol (TCP) â€“ 30 points
In this part, youâ€™ll write two program files: ğ‘»ğ‘ªğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and ğ‘»ğ‘ªğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
The Sender will send a randomly generated file and the Receiver will receive it and measure
the time it took for his program to receive the file. The file size should be at least 2MB.
When running the Sender and Receiver, they both should support two standard congestion
control algorithms: TCP Reno and TCP Cubic.
Notes:
â€¢ The main goal of this part is to get familiar with the TCP concept of sending
messages between two endpoints.
â€¢ For approaching this part of the assignment, please be sure that you are familiar
with the congestion control algorithms and how to change them using the correct
method in C (see Appendix B for more information).
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). You've
learned that TCP is reliable by design, so you can assume that all the data have been
passed correctly, and thus, no need to recheck.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
Usage:
â€¢ Receiver:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
â€¢ Sender:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port of the Receiver.
â€¢ ğ‘¨ğ‘³ğ‘®ğ‘¶ â€“ The TCP congestion control algorithm that will be used by the party
member (either ğ’“ğ’†ğ’ğ’ for TCP Reno or ğ’„ğ’–ğ’ƒğ’Šğ’„ for TCP Cubic).
 Communication Networks Course
Page | 3
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a TCP socket between the Sender and the
Receiver.
3) Send the file.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a TCP connection between the Receiver and
the Sender.
2) Get a connection from the sender.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./TCP_Receiver -p 1234 -algo reno
Starting Receiver...
Waiting for TCP connection...
Sender connected, beginning to receive file...
File transfer completed.
Waiting for Sender response...
Sender sent exit message.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 4
Part B â€“ Reliable User Datagram Protocol (Reliable UDP or RUDP) â€“ 40 points
Youâ€™ve learned that while TCP is reliable, it lacks speed and has an overhead data of 20 bytes,
compering to UDP that needs only 8 bytes of overhead data.
Reliable UDP or RUDP, is a protocol that uses the UDP protocol for a faster transmission of
data, while adding a reliability layer to it, but without adding too much overhead data like
TCP.
A simple sketch for a RUDP connection would look something like this:
Your task in this part is to implement a Reliable protocol using UDP only. For simplicity, your
implementation should only support a handshake, closing scheme, error checking,
acknowledgment of received packets, and retransmission of lost packets.
Guidance:
â€¢ You can use ğ‘ ğ‘’ğ‘¡ğ‘ ğ‘œğ‘ğ‘˜ğ‘œğ‘ğ‘¡(2) for detecting a timeout.
â€¢ You need to build your own protocol, as Reliable UDP isnâ€™t a standard protocol (see a
draft of RUDP in this link), and no official header is provided. You can use this sketch
for a header, but you can come up with your own protocol, as long as it works.
Where:
o ğ‘³ğ’†ğ’ğ’ˆğ’•ğ’‰ is the length of the data itself, without the RUDP header.
o ğ‘ªğ’‰ğ’†ğ’„ğ’Œğ’”ğ’–ğ’ is a 16bit number that validates the correctness of the data.
o ğ‘­ğ’ğ’‚ğ’ˆğ’” is a special byte where we classify the packet itself (SYN, ACK, etc.).
â€¢ In your PDF, you must explain how your implementation of RUDP works â€“ How does
it detect a timeout to do retransmissions, how does the handshake work, what is the
header overhead, etc.
â€¢ For this part, youâ€™ll write three files: ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¨ğ‘·ğ‘°. ğ’„, ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and
ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
Reliable UDP Header proposed sketch
Byte 0 Byte 1 Byte 2 Byte 3
Length (2 Bytes) Checksum (2 Bytes)
Flags (1 Byte)
Figure 1 - RUDP Protocol Architecture, Geeksforgeeks
 Communication Networks Course
Page | 5
Notes:
â€¢ The Sender will send a random generated file and the Receiver will receive it and
measure the time it took for his program to receive the file. The file size should be at
least 2MB.
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). But, as the
RUDP is based on UDP, itâ€™s not reliable. You must use some form of error checking
(like checksum) to ensure that the packet wasnâ€™t alerted during the transfer.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
â€¢ The RUDP needs support only 1 sender and 1 receiver, for simplicity purposes.
Usage:
â€¢ Receiver:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
â€¢ Sender:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port that both the Sender and the Receiver will use.
The ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„ file will contain all the implementations of the RUDP API functions (That is, to
prevent reusing the same chuck of code both in the Sender and the Receiver.).
The API should support at the bare minimum the following functions (you decide what
parameters to implement, and what are the names of the functions, as long as the API is
explained in the PDF):
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘œğ‘ğ‘˜ğ‘’ğ‘¡() â€“ Creating a RUDP socket and creating a handshake between two
peers.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘’ğ‘›ğ‘‘() â€“ Sending data to the peer. The function should wait for an
acknowledgment packet, and if it didnâ€™t receive any, retransmits the data.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘Ÿğ‘’ğ‘ğ‘£() â€“ Receive data from a peer.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ğ‘™ğ‘œğ‘ ğ‘’() â€“ Closes a connection between peers.
 Communication Networks Course
Page | 6
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a UDP socket between the Sender and the
Receiver.
3) Send the file via the RUDP protocol.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a UDP connection between the Receiver and
the Sender.
2) Get a connection from the sender, by the custom
RUDP protocol youâ€™ve built.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./RUDP_Receiver -p 1234
Starting Receiver...
Waiting for RUDP connection...
Connection request received, sending ACK.
Sender connected, beginning to receive file...
File transfer completed.
ACK sent.
Waiting for Sender response...
Sender sent exit message.
ACK sent.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 7
Part C â€“ Research â€“ 30 points
In this part, youâ€™ll conduct research about your implementations of part A and part B.
In the research itself, each one of the versions (TCP version and UDP version) will be run at
least 5 times (meaning that the file transfer will occur at least 5 times) by the following
conditions:
â€¢ For TCP, youâ€™ll run it in TCP Reno and TCP Cubic, alternating each time, for each
scenario, meaning that you run 5 times with TCP Reno in both Sender and Receiver,
and 5 times with TCP Cubic in both Sender and Receiver.
Bonus (5 points): Create a very large data set â€“ 5 times with TCP Reno in both Sender
and Receiver, 5 times with TCP Reno in Sender and TCP Cubic in Receiver, 5 times
with TCP Cubic in Sender and TCP Reno in Receiver, and 5 times with TCP Cubic in
both Sender and Receiver. This will give you a data set large enough, which allows
you to work with, compare with and to reach a definite conclusion.
â€¢ For RUDP, you will run it 5 times for each scenario.
â€¢ For both TCP and RUDP, you will run them on those scenarios of packet loss:
o 0% packet loss â€“ Control group, simulating perfect connection.
o 2% packet loss â€“ Simulating unstable connection that commonly occur.
o 5% packet loss â€“ Simulating bad connection.
o 10% packet loss â€“ Simulating extremely poor connection.
For each scenario, you must provide a filtered PCAP file and relevant screenshots that
explain each one of the steps in the process. (10 points)
After youâ€™ve gathered the data set for both TCP and Reliable UDP, answer the following
questions:
1) In TCP, which congestion control algorithm gave better results overall? TCP Reno or
TCP Cubic? Which one gave better results on high packet loss? Explain how you came
to this conclusion based on the data set youâ€™ve gathered. (5 points)
2) How did your implementation of Reliable UDP perform overall compared to regular
TCP? Which one is better for high packet loss? (5 points)
3) According to the data youâ€™ve gathered, in which scenarios and applications would we
prefer to use TCP and in which situations would we prefer to use reliable UDP?
Explain your answer. (5 points)
 Communication Networks Course
Page | 8
×¢× ×• ×¢×œ ×”×©××œ×•×ª ×”×‘××•×ª )5 × ×§×•×“×•×ª(:
â— ×‘"×¨×©×ª ×××™× ×”" ×”×›×•×•× ×” ×”×™× ×œ×¨×©×ª ×©×‘×” ××¢×˜ ×××•×“ ×—×‘×™×œ×•×ª ×”×•×œ×›×•×ª ×œ××™×‘×•×“. ×‘"×§×©×¨ ××¨×•×š" ×”×›×•×•× ×” ×”×™×
×œ×§×©×¨ TCP ×©×™×© ×‘×• ×”×¨×‘×” ×××•×“ ××™×“×¢ ×œ×©×œ×•×—. ××•×¦×¢ ×œ×”×’×“×™×œ ×‘ -TCP ××ª SSThreshold ×‘×ª×—×™×œ×ª ×”×§×©×¨.
×‘××™×–×” ××”××§×¨×™× ×”×‘××™× ×”×©×™× ×•×™ ×”×–×” ×¢×©×•×™ ×œ×”×•×¢×™×œ ×‘××™×“×” ×”××™×¨×‘×™×ª? × ××§.
.1 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
.2 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.3 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.4 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.5 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.6 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.7 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.8 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
â— A ×©×•×œ×— ×œ -B ×—×‘×™×œ×•×ª ××™×“×¢ ×‘×××¦×¢×•×ª ×§×©×¨ TCP. × ×ª×•×Ÿ ×›×™ ×”×§×©×¨ ××ª×—×™×œ ×¢× ×—×œ×•×Ÿ ×‘×’×•×“×œ 1MSS. ×”×§×©×¨
××¡×ª×™×™× ×‘×¤×¢× ×”×¨××©×•× ×” ×©×”×•× ××’×™×¢ ×œ -SSthresh. ×‘××”×œ×š ×”×§×©×¨ ×œ× ××•×‘×“×•×ª ×—×‘×™×œ×•×ª. × ×¡××Ÿ ×‘×§×™×¦×•×¨:
.SSthresh=S*MSS
× ×ª×•×Ÿ ×›×™ ×œ××•×¨×š ×›×œ ×”×§×©×¨ rwnd < MSS*S.
××”×™ ×”×ª×¤×•×§×” ×©×œ ×”×§×©×¨ ×-A ×œ-B( ×‘ -sec / Bytes )×‘×–××Ÿ ×”× "×œ? × ××§×™.
]S*MSS / [lg (S) * RTT*2 ×‘×¢×¨×š .1
]S*MSS / [S^0.5 * RTT*2 ×‘×¢×¨×š .2
S*MSS / RTT ×‘×¢×¨×š .3
S^2)*MSS / RTT( ×‘×¢×¨×š .4
â— ×©×ª×™ ×ª×—× ×•×ª ××ª×§×©×¨×•×ª ×‘××•×¤×Ÿ ××œ×—×•×˜×™ ×‘×©×™×˜×ª N Back Go.
× ×¡××Ÿ ×‘-X ××ª ×¡×¤×¨×ª ×”×‘×™×§×•×¨×ª ×©×œ ×”×ª.×–. ×©×œ×š. ×× ×©× ×™ ×©×•×ª×¤×™× ××’×™×©×™× ××ª ×”×ª×¨×’×™×œ ×™×—×“, X ×”×•× ×¡×¤×¨×ª
×”×‘×™×§×•×¨×ª ×‘×¢×œ×ª ×”×¢×¨×š ×”× ××•×š ×™×•×ª×¨ ××‘×™×Ÿ ×”×©×ª×™×™×.
×§×¦×‘ ×”×ª×§×©×•×¨×ª ×”×•× 8Gbps, ×•×’×•×“×œ ×›×œ ×—×‘×™×œ×” ×”×•× KByte*X. ×’×“×œ×™ ×”-headers ×•×” -Acks ×–× ×™×—×™×.
ï¿½ğ‘’ğ‘ ï¿½/ï¿½ï¿½ 8 , ×•×”××¨×—×§ ×‘×™×Ÿ ×”×ª×—× ×•×ª ×”×•× 1Km. ×§×¦×‘ ×”×”×ª×¤×©×˜×•×ª ×”×•× 10 â‹… 2
×–××Ÿ ×¢×™×‘×•×“ ×”× ×ª×•× ×™× ×‘×ª×—× ×•×ª ×–× ×™×—.
××£ ×—×‘×™×œ×” ×•××£ Ack ×œ× ×”×•×œ×›×™× ×œ××™×‘×•×“.
â— ××”×• X ×©×œ×š?
â— ××” ×¦×¨×™×š ×œ×”×™×•×ª ×’×•×“×œ ×—×œ×•×Ÿ ×”××©×œ×•×— ×›×“×™ ×œ×”×‘×˜×™×— ×ª×¤×•×§×” ××§×¡×™××œ×™×ª?
 Communication Networks Course
Page | 9
Bonus â€“ Improving the Reliable UDP â€“ 15 points
Note: This part isnâ€™t mandatory and is a bonus only!
In this part, youâ€™ll improve your RUDP implementation by adding the concepts of flow
control and congestion control from TCP. Youâ€™re free to choose which algorithms to
implement, as long as you explain in your PDF which algorithms youâ€™ve used. Youâ€™ll probably
need to make changes in the original design of the RUDP. Changes only need to be to the API
itself, ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„.
Points distribution:
â€¢ Flow control improvement â€“ 7 Points
â€¢ Congestion control improvement â€“ 8 points.
Guidance:
â€¢ For flow control, you must use one of the Sliding window techniques: stop-and-wait
ARQ, Go-Back-N or Selective repeat.
â€¢ List of known TCP congestion control algorithms, which you can use any one of them
for this bonus task, or makeup your own:
Figure 2 â€“ List of known TCP congestion control algorithms, Wikipedia
 Communication Networks Course
Page | 10
Appendix A â€“ Linux local packet loss tool
To simulate a packet loss in a local network, we'll use a Linux tool that's called Linux Traffic
Control (ğ‘¡ğ‘). This requires a full Linux installation, so working with WSL won't work.
If the tool isn't installed in your machine, you can install it by using the following commands:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’
If the installation didn't work, you can use the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’2
To create a packet loss scenario, type the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘ğ‘‘ğ‘‘ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
After creating a packet loss scenario, you can change the percentage by typing the following
command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘â„ğ‘ğ‘›ğ‘”ğ‘’ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
To remove the packet loss scenario, write the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘‘ğ‘’ğ‘™ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š
 Communication Networks Course
Page | 11
Appendix B â€“ ğ’ğ’‚ğ’(ğŸ) system calls
This appendixâ€™s purpose is to give you a better understanding of socket handling in C.
A recommended reference is Beejâ€™s Guide to Network Programming, by Brian â€œBeej
Jorgensenâ€ Hall, which gives a lot of information about sockets in C and functions.
Functions and documentation links:
â€¢ ğ’”ğ’ğ’„ğ’Œğ’†ğ’•(ğŸ) â€“ A Factory method system call that creates a socket with the given
parameters.
â€¢ ğ’ƒğ’Šğ’ğ’…(ğŸ) â€“ Whenever we create a new socket, we need to bind it to a specific port in
our machine, â€œto catch a portâ€. The port number is managed and used by the kernel
to link incoming packets to the corresponding application socket. The port numbers
are usually fixed. The ğ‘ğ‘‘ğ‘‘ğ‘Ÿ parameter must match the current socket that is used.
â€¢ ğ’ğ’Šğ’”ğ’•ğ’†ğ’(ğŸ) â€“ The ğ‘™ğ‘–ğ‘ ğ‘¡ğ‘’ğ‘›(2) system call doesn't do anything in the mean of
communication but only memory allocation (malloc) for stream sockets only. If we
won't allocate memory, any incoming connection will fail.
â€¢ ğ’„ğ’ğ’ğ’ğ’†ğ’„ğ’•(ğŸ) â€“ The ğ‘ğ‘œğ‘›ğ‘›ğ‘’ğ‘ğ‘¡(2) system call starts the link between a client and a
specific IP address and port number. The connection would complete when the
other side will call the ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call.
â€¢ ğ’‚ğ’„ğ’„ğ’†ğ’‘ğ’•(ğŸ) â€“ The ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call accepts the incoming stream connection
request from the other side, by the listening socket. This system call completes the
three-way handshake of stream socket (like TCP) and opens a new socket that has a
direct communication channel only with the other party in the handshake.
â€¢ ğ’”ğ’†ğ’ğ’…(ğŸ) and ğ’”ğ’†ğ’ğ’…ğ’•ğ’(ğŸ) â€“ The ğ‘ ğ‘’ğ‘›ğ‘‘(2) and ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system calls are an analogy
for the ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’(2) system call, specifcly for sockets, with flags set to 0. Those system
calls return the number of bytes that were sent through the socket itself, as the
number of bytes can vary. The ğ‘ ğ‘’ğ‘›ğ‘‘(2)system call designed for stream sockets (like
TCP), while the ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system call designed for datagram connection-less
sockets (like UDP). When the ğ‘ ğ‘’ğ‘›ğ‘‘(2) system call returns 0, it means that the other
party closed the connection.
â€¢ ğ’“ğ’†ğ’„ğ’—(ğŸ) and ğ’“ğ’†ğ’„ğ’—ğ’‡ğ’“ğ’ğ’(ğŸ) â€“ The ğ‘Ÿğ‘’ğ‘ğ‘£(2) and ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system calls are an
analogy for the ğ‘Ÿğ‘’ğ‘ğ‘‘(2) system call, specifically for sockets, with flags set to 0.
Those system calls return the number of bytes that were received through the socket
itself, as the number of bytes can vary. The ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call designed for stream
sockets (like TCP), while the ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system call designed for datagram
connection-less sockets (like UDP). When the ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call returns 0, it means
that the other party closed the connection.
â€¢ ğ’„ğ’ğ’ğ’”ğ’†(ğŸ) and ğ’”ğ’‰ğ’–ğ’•ğ’…ğ’ğ’˜ğ’(ğŸ) â€“ The ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) and ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2) system calls close
the socket. While ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) system call closes the whole socket, the ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2)
system call partially closes the socket for read/write.
 Communication Networks Course
Page | 12
Appendix C â€“ Random data generator
The data that you are going to send in this assignment is randomly generated. You can use
your own file with appropriate size or use the following function (or a function of your own)
to generate the data:
/*
* @brief A random data generator function based on srand() and rand().
* @param size The size of the data to generate (up to 2^32 bytes).
* @return A pointer to the buffer.
*/
char *util_generate_random_data(unsigned int size) {
 char *buffer = NULL;
 // Argument check.
 if (size == 0)
 return NULL;
 buffer = (char *)calloc(size, sizeof(char));
 // Error checking.
 if (buffer == NULL)
 return NULL;
 // Randomize the seed of the random number generator.
 srand(time(NULL));
 for (unsigned int i = 0; i < size; i++)
 *(buffer + i) = ((unsigned int)rand() % 256);
 return buffer;
}
 Communication Networks Course
Page | 13
Appendix D â€“ Checksum function
A checksum is a small-sized block of data derived from another block of digital data for the
purpose of detecting errors that may have been introduced during its transmission or
storage. By themselves, checksums are often used to verify data integrity but are not relied
upon to verify data authenticity.
Below is a simple yet efficient implementation of the checksum function, you can use it for
the assignment, but you can implement your own checksum function.
/*
* @brief A checksum function that returns 16 bit checksum for data.
* @param data The data to do the checksum for.
* @param bytes The length of the data in bytes.
* @return The checksum itself as 16 bit unsigned number.
* @note This function is taken from RFC1071, can be found here:
* @note https://tools.ietf.org/html/rfc1071
* @note It is the simplest way to calculate a checksum and is not very strong.
* However, it is good enough for this assignment.
* @note You are free to use any other checksum function as well.
* You can also use this function as such without any change.
*/
unsigned short int calculate_checksum(void *data, unsigned int bytes) {
 unsigned short int *data_pointer = (unsigned short int *)data;
 unsigned int total_sum = 0;
 // Main summing loop
 while (bytes > 1) {
 total_sum += *data_pointer++;
 bytes -= 2;
 }
 // Add left-over byte, if any
 if (bytes > 0)
 total_sum += *((unsigned char *)data_pointer);
 // Fold 32-bit sum to 16 bits
 while (total_sum >> 16)
 total_sum = (total_sum & 0xFFFF) + (total_sum >> 16);
 return (~((unsigned short int)total_sum));
} Communication Networks Course
Page | 1
Assignment 3 â€“ Transport Layer
Assignment Notes and Instructions
This assignment is to be done in pairs only. You must upload all the necessary files in a ZIP
file named after both of the studentâ€™s ID. For example: ğŸğŸğŸ‘ğŸ’ğŸ“ğŸ”ğŸ•ğŸ–ğŸ—_ğŸ—ğŸ–ğŸ•ğŸ”ğŸ“ğŸ’ğŸ‘ğŸğŸ. ğ’›ğ’Šğ’‘.
1) The assignment must be submitted by the date specified in the submission box.
2) All the assignment files (Code, Wireshark pcap files, PDF) must be submitted in a ZIP file. The
PDF must contain all the necessary screenshots with a description for each one of them.
3) The assignment must be done in pairs only. In exceptional cases, you should send an email to
the course coordinator.
4) You can use any reference material available through the course Moodle website or any
material passed during the exercises.
5) You can use any reference from the web, but copying codes from websites is forbidden; this
includes codes from other GitHub repositories. A student who gets caught in the act will
automatically fail this assignment (score 0). Any website youâ€™ve used to solve the
assignment, every website you used to solve the assignment must be noted in the PDF.
6) No delays in submission without special permission. Lateness without approval will result in
failure of the assignment (score 0).
7) All submissions will be submitted via the course's Moodle website. Email submissions will not
be accepted, resulting in a failure in the assignment.
8) The order and design of the code must be carefully considered. Make sure that the program
output is as clear as possible, comments in the code, and meaningful variable names. You
must also submit a makefile that compiles all the programs.
9) The assignment code must be written in C only.
10) The assignment is personal for each pair, and you should not accept help from other people,
whether outside the university or inside it. You can contact the course staff during reception
hours for help or raise a question in the course forum. Do not transfer code sections
between students, upload solutions or parts of solutions to websites on the Internet or in
various communication groups.
11) Students who copy a solution will receive a 0 in all assignments in the course and a report will
be made to the institutional disciplinary committee.
12) All code files of the assignment are required to both compile and run properly on the Ubuntu
22.04 LTS operating system. This is the operating system where the submissions will be
tested. You mustnâ€™t code it in Windows, as it uses different API for sockets. WSL wonâ€™t work,
as the task needs a tool that works only in a fully Linux environment.
Good Luck!
 Communication Networks Course
Page | 2
Part A â€“ Transmission Control Protocol (TCP) â€“ 30 points
In this part, youâ€™ll write two program files: ğ‘»ğ‘ªğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and ğ‘»ğ‘ªğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
The Sender will send a randomly generated file and the Receiver will receive it and measure
the time it took for his program to receive the file. The file size should be at least 2MB.
When running the Sender and Receiver, they both should support two standard congestion
control algorithms: TCP Reno and TCP Cubic.
Notes:
â€¢ The main goal of this part is to get familiar with the TCP concept of sending
messages between two endpoints.
â€¢ For approaching this part of the assignment, please be sure that you are familiar
with the congestion control algorithms and how to change them using the correct
method in C (see Appendix B for more information).
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). You've
learned that TCP is reliable by design, so you can assume that all the data have been
passed correctly, and thus, no need to recheck.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
Usage:
â€¢ Receiver:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
â€¢ Sender:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port of the Receiver.
â€¢ ğ‘¨ğ‘³ğ‘®ğ‘¶ â€“ The TCP congestion control algorithm that will be used by the party
member (either ğ’“ğ’†ğ’ğ’ for TCP Reno or ğ’„ğ’–ğ’ƒğ’Šğ’„ for TCP Cubic).
 Communication Networks Course
Page | 3
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a TCP socket between the Sender and the
Receiver.
3) Send the file.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a TCP connection between the Receiver and
the Sender.
2) Get a connection from the sender.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./TCP_Receiver -p 1234 -algo reno
Starting Receiver...
Waiting for TCP connection...
Sender connected, beginning to receive file...
File transfer completed.
Waiting for Sender response...
Sender sent exit message.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 4
Part B â€“ Reliable User Datagram Protocol (Reliable UDP or RUDP) â€“ 40 points
Youâ€™ve learned that while TCP is reliable, it lacks speed and has an overhead data of 20 bytes,
compering to UDP that needs only 8 bytes of overhead data.
Reliable UDP or RUDP, is a protocol that uses the UDP protocol for a faster transmission of
data, while adding a reliability layer to it, but without adding too much overhead data like
TCP.
A simple sketch for a RUDP connection would look something like this:
Your task in this part is to implement a Reliable protocol using UDP only. For simplicity, your
implementation should only support a handshake, closing scheme, error checking,
acknowledgment of received packets, and retransmission of lost packets.
Guidance:
â€¢ You can use ğ‘ ğ‘’ğ‘¡ğ‘ ğ‘œğ‘ğ‘˜ğ‘œğ‘ğ‘¡(2) for detecting a timeout.
â€¢ You need to build your own protocol, as Reliable UDP isnâ€™t a standard protocol (see a
draft of RUDP in this link), and no official header is provided. You can use this sketch
for a header, but you can come up with your own protocol, as long as it works.
Where:
o ğ‘³ğ’†ğ’ğ’ˆğ’•ğ’‰ is the length of the data itself, without the RUDP header.
o ğ‘ªğ’‰ğ’†ğ’„ğ’Œğ’”ğ’–ğ’ is a 16bit number that validates the correctness of the data.
o ğ‘­ğ’ğ’‚ğ’ˆğ’” is a special byte where we classify the packet itself (SYN, ACK, etc.).
â€¢ In your PDF, you must explain how your implementation of RUDP works â€“ How does
it detect a timeout to do retransmissions, how does the handshake work, what is the
header overhead, etc.
â€¢ For this part, youâ€™ll write three files: ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¨ğ‘·ğ‘°. ğ’„, ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and
ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
Reliable UDP Header proposed sketch
Byte 0 Byte 1 Byte 2 Byte 3
Length (2 Bytes) Checksum (2 Bytes)
Flags (1 Byte)
Figure 1 - RUDP Protocol Architecture, Geeksforgeeks
 Communication Networks Course
Page | 5
Notes:
â€¢ The Sender will send a random generated file and the Receiver will receive it and
measure the time it took for his program to receive the file. The file size should be at
least 2MB.
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). But, as the
RUDP is based on UDP, itâ€™s not reliable. You must use some form of error checking
(like checksum) to ensure that the packet wasnâ€™t alerted during the transfer.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
â€¢ The RUDP needs support only 1 sender and 1 receiver, for simplicity purposes.
Usage:
â€¢ Receiver:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
â€¢ Sender:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port that both the Sender and the Receiver will use.
The ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„ file will contain all the implementations of the RUDP API functions (That is, to
prevent reusing the same chuck of code both in the Sender and the Receiver.).
The API should support at the bare minimum the following functions (you decide what
parameters to implement, and what are the names of the functions, as long as the API is
explained in the PDF):
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘œğ‘ğ‘˜ğ‘’ğ‘¡() â€“ Creating a RUDP socket and creating a handshake between two
peers.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘’ğ‘›ğ‘‘() â€“ Sending data to the peer. The function should wait for an
acknowledgment packet, and if it didnâ€™t receive any, retransmits the data.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘Ÿğ‘’ğ‘ğ‘£() â€“ Receive data from a peer.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ğ‘™ğ‘œğ‘ ğ‘’() â€“ Closes a connection between peers.
 Communication Networks Course
Page | 6
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a UDP socket between the Sender and the
Receiver.
3) Send the file via the RUDP protocol.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a UDP connection between the Receiver and
the Sender.
2) Get a connection from the sender, by the custom
RUDP protocol youâ€™ve built.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./RUDP_Receiver -p 1234
Starting Receiver...
Waiting for RUDP connection...
Connection request received, sending ACK.
Sender connected, beginning to receive file...
File transfer completed.
ACK sent.
Waiting for Sender response...
Sender sent exit message.
ACK sent.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 7
Part C â€“ Research â€“ 30 points
In this part, youâ€™ll conduct research about your implementations of part A and part B.
In the research itself, each one of the versions (TCP version and UDP version) will be run at
least 5 times (meaning that the file transfer will occur at least 5 times) by the following
conditions:
â€¢ For TCP, youâ€™ll run it in TCP Reno and TCP Cubic, alternating each time, for each
scenario, meaning that you run 5 times with TCP Reno in both Sender and Receiver,
and 5 times with TCP Cubic in both Sender and Receiver.
Bonus (5 points): Create a very large data set â€“ 5 times with TCP Reno in both Sender
and Receiver, 5 times with TCP Reno in Sender and TCP Cubic in Receiver, 5 times
with TCP Cubic in Sender and TCP Reno in Receiver, and 5 times with TCP Cubic in
both Sender and Receiver. This will give you a data set large enough, which allows
you to work with, compare with and to reach a definite conclusion.
â€¢ For RUDP, you will run it 5 times for each scenario.
â€¢ For both TCP and RUDP, you will run them on those scenarios of packet loss:
o 0% packet loss â€“ Control group, simulating perfect connection.
o 2% packet loss â€“ Simulating unstable connection that commonly occur.
o 5% packet loss â€“ Simulating bad connection.
o 10% packet loss â€“ Simulating extremely poor connection.
For each scenario, you must provide a filtered PCAP file and relevant screenshots that
explain each one of the steps in the process. (10 points)
After youâ€™ve gathered the data set for both TCP and Reliable UDP, answer the following
questions:
1) In TCP, which congestion control algorithm gave better results overall? TCP Reno or
TCP Cubic? Which one gave better results on high packet loss? Explain how you came
to this conclusion based on the data set youâ€™ve gathered. (5 points)
2) How did your implementation of Reliable UDP perform overall compared to regular
TCP? Which one is better for high packet loss? (5 points)
3) According to the data youâ€™ve gathered, in which scenarios and applications would we
prefer to use TCP and in which situations would we prefer to use reliable UDP?
Explain your answer. (5 points)
 Communication Networks Course
Page | 8
×¢× ×• ×¢×œ ×”×©××œ×•×ª ×”×‘××•×ª )5 × ×§×•×“×•×ª(:
â— ×‘"×¨×©×ª ×××™× ×”" ×”×›×•×•× ×” ×”×™× ×œ×¨×©×ª ×©×‘×” ××¢×˜ ×××•×“ ×—×‘×™×œ×•×ª ×”×•×œ×›×•×ª ×œ××™×‘×•×“. ×‘"×§×©×¨ ××¨×•×š" ×”×›×•×•× ×” ×”×™×
×œ×§×©×¨ TCP ×©×™×© ×‘×• ×”×¨×‘×” ×××•×“ ××™×“×¢ ×œ×©×œ×•×—. ××•×¦×¢ ×œ×”×’×“×™×œ ×‘ -TCP ××ª SSThreshold ×‘×ª×—×™×œ×ª ×”×§×©×¨.
×‘××™×–×” ××”××§×¨×™× ×”×‘××™× ×”×©×™× ×•×™ ×”×–×” ×¢×©×•×™ ×œ×”×•×¢×™×œ ×‘××™×“×” ×”××™×¨×‘×™×ª? × ××§.
.1 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
.2 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.3 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.4 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.5 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.6 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.7 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.8 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
â— A ×©×•×œ×— ×œ -B ×—×‘×™×œ×•×ª ××™×“×¢ ×‘×××¦×¢×•×ª ×§×©×¨ TCP. × ×ª×•×Ÿ ×›×™ ×”×§×©×¨ ××ª×—×™×œ ×¢× ×—×œ×•×Ÿ ×‘×’×•×“×œ 1MSS. ×”×§×©×¨
××¡×ª×™×™× ×‘×¤×¢× ×”×¨××©×•× ×” ×©×”×•× ××’×™×¢ ×œ -SSthresh. ×‘××”×œ×š ×”×§×©×¨ ×œ× ××•×‘×“×•×ª ×—×‘×™×œ×•×ª. × ×¡××Ÿ ×‘×§×™×¦×•×¨:
.SSthresh=S*MSS
× ×ª×•×Ÿ ×›×™ ×œ××•×¨×š ×›×œ ×”×§×©×¨ rwnd < MSS*S.
××”×™ ×”×ª×¤×•×§×” ×©×œ ×”×§×©×¨ ×-A ×œ-B( ×‘ -sec / Bytes )×‘×–××Ÿ ×”× "×œ? × ××§×™.
]S*MSS / [lg (S) * RTT*2 ×‘×¢×¨×š .1
]S*MSS / [S^0.5 * RTT*2 ×‘×¢×¨×š .2
S*MSS / RTT ×‘×¢×¨×š .3
S^2)*MSS / RTT( ×‘×¢×¨×š .4
â— ×©×ª×™ ×ª×—× ×•×ª ××ª×§×©×¨×•×ª ×‘××•×¤×Ÿ ××œ×—×•×˜×™ ×‘×©×™×˜×ª N Back Go.
× ×¡××Ÿ ×‘-X ××ª ×¡×¤×¨×ª ×”×‘×™×§×•×¨×ª ×©×œ ×”×ª.×–. ×©×œ×š. ×× ×©× ×™ ×©×•×ª×¤×™× ××’×™×©×™× ××ª ×”×ª×¨×’×™×œ ×™×—×“, X ×”×•× ×¡×¤×¨×ª
×”×‘×™×§×•×¨×ª ×‘×¢×œ×ª ×”×¢×¨×š ×”× ××•×š ×™×•×ª×¨ ××‘×™×Ÿ ×”×©×ª×™×™×.
×§×¦×‘ ×”×ª×§×©×•×¨×ª ×”×•× 8Gbps, ×•×’×•×“×œ ×›×œ ×—×‘×™×œ×” ×”×•× KByte*X. ×’×“×œ×™ ×”-headers ×•×” -Acks ×–× ×™×—×™×.
ï¿½ğ‘’ğ‘ ï¿½/ï¿½ï¿½ 8 , ×•×”××¨×—×§ ×‘×™×Ÿ ×”×ª×—× ×•×ª ×”×•× 1Km. ×§×¦×‘ ×”×”×ª×¤×©×˜×•×ª ×”×•× 10 â‹… 2
×–××Ÿ ×¢×™×‘×•×“ ×”× ×ª×•× ×™× ×‘×ª×—× ×•×ª ×–× ×™×—.
××£ ×—×‘×™×œ×” ×•××£ Ack ×œ× ×”×•×œ×›×™× ×œ××™×‘×•×“.
â— ××”×• X ×©×œ×š?
â— ××” ×¦×¨×™×š ×œ×”×™×•×ª ×’×•×“×œ ×—×œ×•×Ÿ ×”××©×œ×•×— ×›×“×™ ×œ×”×‘×˜×™×— ×ª×¤×•×§×” ××§×¡×™××œ×™×ª?
 Communication Networks Course
Page | 9
Bonus â€“ Improving the Reliable UDP â€“ 15 points
Note: This part isnâ€™t mandatory and is a bonus only!
In this part, youâ€™ll improve your RUDP implementation by adding the concepts of flow
control and congestion control from TCP. Youâ€™re free to choose which algorithms to
implement, as long as you explain in your PDF which algorithms youâ€™ve used. Youâ€™ll probably
need to make changes in the original design of the RUDP. Changes only need to be to the API
itself, ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„.
Points distribution:
â€¢ Flow control improvement â€“ 7 Points
â€¢ Congestion control improvement â€“ 8 points.
Guidance:
â€¢ For flow control, you must use one of the Sliding window techniques: stop-and-wait
ARQ, Go-Back-N or Selective repeat.
â€¢ List of known TCP congestion control algorithms, which you can use any one of them
for this bonus task, or makeup your own:
Figure 2 â€“ List of known TCP congestion control algorithms, Wikipedia
 Communication Networks Course
Page | 10
Appendix A â€“ Linux local packet loss tool
To simulate a packet loss in a local network, we'll use a Linux tool that's called Linux Traffic
Control (ğ‘¡ğ‘). This requires a full Linux installation, so working with WSL won't work.
If the tool isn't installed in your machine, you can install it by using the following commands:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’
If the installation didn't work, you can use the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’2
To create a packet loss scenario, type the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘ğ‘‘ğ‘‘ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
After creating a packet loss scenario, you can change the percentage by typing the following
command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘â„ğ‘ğ‘›ğ‘”ğ‘’ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
To remove the packet loss scenario, write the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘‘ğ‘’ğ‘™ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š
 Communication Networks Course
Page | 11
Appendix B â€“ ğ’ğ’‚ğ’(ğŸ) system calls
This appendixâ€™s purpose is to give you a better understanding of socket handling in C.
A recommended reference is Beejâ€™s Guide to Network Programming, by Brian â€œBeej
Jorgensenâ€ Hall, which gives a lot of information about sockets in C and functions.
Functions and documentation links:
â€¢ ğ’”ğ’ğ’„ğ’Œğ’†ğ’•(ğŸ) â€“ A Factory method system call that creates a socket with the given
parameters.
â€¢ ğ’ƒğ’Šğ’ğ’…(ğŸ) â€“ Whenever we create a new socket, we need to bind it to a specific port in
our machine, â€œto catch a portâ€. The port number is managed and used by the kernel
to link incoming packets to the corresponding application socket. The port numbers
are usually fixed. The ğ‘ğ‘‘ğ‘‘ğ‘Ÿ parameter must match the current socket that is used.
â€¢ ğ’ğ’Šğ’”ğ’•ğ’†ğ’(ğŸ) â€“ The ğ‘™ğ‘–ğ‘ ğ‘¡ğ‘’ğ‘›(2) system call doesn't do anything in the mean of
communication but only memory allocation (malloc) for stream sockets only. If we
won't allocate memory, any incoming connection will fail.
â€¢ ğ’„ğ’ğ’ğ’ğ’†ğ’„ğ’•(ğŸ) â€“ The ğ‘ğ‘œğ‘›ğ‘›ğ‘’ğ‘ğ‘¡(2) system call starts the link between a client and a
specific IP address and port number. The connection would complete when the
other side will call the ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call.
â€¢ ğ’‚ğ’„ğ’„ğ’†ğ’‘ğ’•(ğŸ) â€“ The ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call accepts the incoming stream connection
request from the other side, by the listening socket. This system call completes the
three-way handshake of stream socket (like TCP) and opens a new socket that has a
direct communication channel only with the other party in the handshake.
â€¢ ğ’”ğ’†ğ’ğ’…(ğŸ) and ğ’”ğ’†ğ’ğ’…ğ’•ğ’(ğŸ) â€“ The ğ‘ ğ‘’ğ‘›ğ‘‘(2) and ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system calls are an analogy
for the ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’(2) system call, specifcly for sockets, with flags set to 0. Those system
calls return the number of bytes that were sent through the socket itself, as the
number of bytes can vary. The ğ‘ ğ‘’ğ‘›ğ‘‘(2)system call designed for stream sockets (like
TCP), while the ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system call designed for datagram connection-less
sockets (like UDP). When the ğ‘ ğ‘’ğ‘›ğ‘‘(2) system call returns 0, it means that the other
party closed the connection.
â€¢ ğ’“ğ’†ğ’„ğ’—(ğŸ) and ğ’“ğ’†ğ’„ğ’—ğ’‡ğ’“ğ’ğ’(ğŸ) â€“ The ğ‘Ÿğ‘’ğ‘ğ‘£(2) and ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system calls are an
analogy for the ğ‘Ÿğ‘’ğ‘ğ‘‘(2) system call, specifically for sockets, with flags set to 0.
Those system calls return the number of bytes that were received through the socket
itself, as the number of bytes can vary. The ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call designed for stream
sockets (like TCP), while the ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system call designed for datagram
connection-less sockets (like UDP). When the ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call returns 0, it means
that the other party closed the connection.
â€¢ ğ’„ğ’ğ’ğ’”ğ’†(ğŸ) and ğ’”ğ’‰ğ’–ğ’•ğ’…ğ’ğ’˜ğ’(ğŸ) â€“ The ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) and ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2) system calls close
the socket. While ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) system call closes the whole socket, the ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2)
system call partially closes the socket for read/write.
 Communication Networks Course
Page | 12
Appendix C â€“ Random data generator
The data that you are going to send in this assignment is randomly generated. You can use
your own file with appropriate size or use the following function (or a function of your own)
to generate the data:
/*
* @brief A random data generator function based on srand() and rand().
* @param size The size of the data to generate (up to 2^32 bytes).
* @return A pointer to the buffer.
*/
char *util_generate_random_data(unsigned int size) {
 char *buffer = NULL;
 // Argument check.
 if (size == 0)
 return NULL;
 buffer = (char *)calloc(size, sizeof(char));
 // Error checking.
 if (buffer == NULL)
 return NULL;
 // Randomize the seed of the random number generator.
 srand(time(NULL));
 for (unsigned int i = 0; i < size; i++)
 *(buffer + i) = ((unsigned int)rand() % 256);
 return buffer;
}
 Communication Networks Course
Page | 13
Appendix D â€“ Checksum function
A checksum is a small-sized block of data derived from another block of digital data for the
purpose of detecting errors that may have been introduced during its transmission or
storage. By themselves, checksums are often used to verify data integrity but are not relied
upon to verify data authenticity.
Below is a simple yet efficient implementation of the checksum function, you can use it for
the assignment, but you can implement your own checksum function.
/*
* @brief A checksum function that returns 16 bit checksum for data.
* @param data The data to do the checksum for.
* @param bytes The length of the data in bytes.
* @return The checksum itself as 16 bit unsigned number.
* @note This function is taken from RFC1071, can be found here:
* @note https://tools.ietf.org/html/rfc1071
* @note It is the simplest way to calculate a checksum and is not very strong.
* However, it is good enough for this assignment.
* @note You are free to use any other checksum function as well.
* You can also use this function as such without any change.
*/
unsigned short int calculate_checksum(void *data, unsigned int bytes) {
 unsigned short int *data_pointer = (unsigned short int *)data;
 unsigned int total_sum = 0;
 // Main summing loop
 while (bytes > 1) {
 total_sum += *data_pointer++;
 bytes -= 2;
 }
 // Add left-over byte, if any
 if (bytes > 0)
 total_sum += *((unsigned char *)data_pointer);
 // Fold 32-bit sum to 16 bits
 while (total_sum >> 16)
 total_sum = (total_sum & 0xFFFF) + (total_sum >> 16);
 return (~((unsigned short int)total_sum));
} Communication Networks Course
Page | 1
Assignment 3 â€“ Transport Layer
Assignment Notes and Instructions
This assignment is to be done in pairs only. You must upload all the necessary files in a ZIP
file named after both of the studentâ€™s ID. For example: ğŸğŸğŸ‘ğŸ’ğŸ“ğŸ”ğŸ•ğŸ–ğŸ—_ğŸ—ğŸ–ğŸ•ğŸ”ğŸ“ğŸ’ğŸ‘ğŸğŸ. ğ’›ğ’Šğ’‘.
1) The assignment must be submitted by the date specified in the submission box.
2) All the assignment files (Code, Wireshark pcap files, PDF) must be submitted in a ZIP file. The
PDF must contain all the necessary screenshots with a description for each one of them.
3) The assignment must be done in pairs only. In exceptional cases, you should send an email to
the course coordinator.
4) You can use any reference material available through the course Moodle website or any
material passed during the exercises.
5) You can use any reference from the web, but copying codes from websites is forbidden; this
includes codes from other GitHub repositories. A student who gets caught in the act will
automatically fail this assignment (score 0). Any website youâ€™ve used to solve the
assignment, every website you used to solve the assignment must be noted in the PDF.
6) No delays in submission without special permission. Lateness without approval will result in
failure of the assignment (score 0).
7) All submissions will be submitted via the course's Moodle website. Email submissions will not
be accepted, resulting in a failure in the assignment.
8) The order and design of the code must be carefully considered. Make sure that the program
output is as clear as possible, comments in the code, and meaningful variable names. You
must also submit a makefile that compiles all the programs.
9) The assignment code must be written in C only.
10) The assignment is personal for each pair, and you should not accept help from other people,
whether outside the university or inside it. You can contact the course staff during reception
hours for help or raise a question in the course forum. Do not transfer code sections
between students, upload solutions or parts of solutions to websites on the Internet or in
various communication groups.
11) Students who copy a solution will receive a 0 in all assignments in the course and a report will
be made to the institutional disciplinary committee.
12) All code files of the assignment are required to both compile and run properly on the Ubuntu
22.04 LTS operating system. This is the operating system where the submissions will be
tested. You mustnâ€™t code it in Windows, as it uses different API for sockets. WSL wonâ€™t work,
as the task needs a tool that works only in a fully Linux environment.
Good Luck!
 Communication Networks Course
Page | 2
Part A â€“ Transmission Control Protocol (TCP) â€“ 30 points
In this part, youâ€™ll write two program files: ğ‘»ğ‘ªğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and ğ‘»ğ‘ªğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
The Sender will send a randomly generated file and the Receiver will receive it and measure
the time it took for his program to receive the file. The file size should be at least 2MB.
When running the Sender and Receiver, they both should support two standard congestion
control algorithms: TCP Reno and TCP Cubic.
Notes:
â€¢ The main goal of this part is to get familiar with the TCP concept of sending
messages between two endpoints.
â€¢ For approaching this part of the assignment, please be sure that you are familiar
with the congestion control algorithms and how to change them using the correct
method in C (see Appendix B for more information).
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). You've
learned that TCP is reliable by design, so you can assume that all the data have been
passed correctly, and thus, no need to recheck.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
Usage:
â€¢ Receiver:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
â€¢ Sender:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port of the Receiver.
â€¢ ğ‘¨ğ‘³ğ‘®ğ‘¶ â€“ The TCP congestion control algorithm that will be used by the party
member (either ğ’“ğ’†ğ’ğ’ for TCP Reno or ğ’„ğ’–ğ’ƒğ’Šğ’„ for TCP Cubic).
 Communication Networks Course
Page | 3
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a TCP socket between the Sender and the
Receiver.
3) Send the file.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a TCP connection between the Receiver and
the Sender.
2) Get a connection from the sender.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./TCP_Receiver -p 1234 -algo reno
Starting Receiver...
Waiting for TCP connection...
Sender connected, beginning to receive file...
File transfer completed.
Waiting for Sender response...
Sender sent exit message.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 4
Part B â€“ Reliable User Datagram Protocol (Reliable UDP or RUDP) â€“ 40 points
Youâ€™ve learned that while TCP is reliable, it lacks speed and has an overhead data of 20 bytes,
compering to UDP that needs only 8 bytes of overhead data.
Reliable UDP or RUDP, is a protocol that uses the UDP protocol for a faster transmission of
data, while adding a reliability layer to it, but without adding too much overhead data like
TCP.
A simple sketch for a RUDP connection would look something like this:
Your task in this part is to implement a Reliable protocol using UDP only. For simplicity, your
implementation should only support a handshake, closing scheme, error checking,
acknowledgment of received packets, and retransmission of lost packets.
Guidance:
â€¢ You can use ğ‘ ğ‘’ğ‘¡ğ‘ ğ‘œğ‘ğ‘˜ğ‘œğ‘ğ‘¡(2) for detecting a timeout.
â€¢ You need to build your own protocol, as Reliable UDP isnâ€™t a standard protocol (see a
draft of RUDP in this link), and no official header is provided. You can use this sketch
for a header, but you can come up with your own protocol, as long as it works.
Where:
o ğ‘³ğ’†ğ’ğ’ˆğ’•ğ’‰ is the length of the data itself, without the RUDP header.
o ğ‘ªğ’‰ğ’†ğ’„ğ’Œğ’”ğ’–ğ’ is a 16bit number that validates the correctness of the data.
o ğ‘­ğ’ğ’‚ğ’ˆğ’” is a special byte where we classify the packet itself (SYN, ACK, etc.).
â€¢ In your PDF, you must explain how your implementation of RUDP works â€“ How does
it detect a timeout to do retransmissions, how does the handshake work, what is the
header overhead, etc.
â€¢ For this part, youâ€™ll write three files: ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¨ğ‘·ğ‘°. ğ’„, ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and
ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
Reliable UDP Header proposed sketch
Byte 0 Byte 1 Byte 2 Byte 3
Length (2 Bytes) Checksum (2 Bytes)
Flags (1 Byte)
Figure 1 - RUDP Protocol Architecture, Geeksforgeeks
 Communication Networks Course
Page | 5
Notes:
â€¢ The Sender will send a random generated file and the Receiver will receive it and
measure the time it took for his program to receive the file. The file size should be at
least 2MB.
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). But, as the
RUDP is based on UDP, itâ€™s not reliable. You must use some form of error checking
(like checksum) to ensure that the packet wasnâ€™t alerted during the transfer.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
â€¢ The RUDP needs support only 1 sender and 1 receiver, for simplicity purposes.
Usage:
â€¢ Receiver:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
â€¢ Sender:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port that both the Sender and the Receiver will use.
The ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„ file will contain all the implementations of the RUDP API functions (That is, to
prevent reusing the same chuck of code both in the Sender and the Receiver.).
The API should support at the bare minimum the following functions (you decide what
parameters to implement, and what are the names of the functions, as long as the API is
explained in the PDF):
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘œğ‘ğ‘˜ğ‘’ğ‘¡() â€“ Creating a RUDP socket and creating a handshake between two
peers.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘’ğ‘›ğ‘‘() â€“ Sending data to the peer. The function should wait for an
acknowledgment packet, and if it didnâ€™t receive any, retransmits the data.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘Ÿğ‘’ğ‘ğ‘£() â€“ Receive data from a peer.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ğ‘™ğ‘œğ‘ ğ‘’() â€“ Closes a connection between peers.
 Communication Networks Course
Page | 6
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a UDP socket between the Sender and the
Receiver.
3) Send the file via the RUDP protocol.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a UDP connection between the Receiver and
the Sender.
2) Get a connection from the sender, by the custom
RUDP protocol youâ€™ve built.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./RUDP_Receiver -p 1234
Starting Receiver...
Waiting for RUDP connection...
Connection request received, sending ACK.
Sender connected, beginning to receive file...
File transfer completed.
ACK sent.
Waiting for Sender response...
Sender sent exit message.
ACK sent.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 7
Part C â€“ Research â€“ 30 points
In this part, youâ€™ll conduct research about your implementations of part A and part B.
In the research itself, each one of the versions (TCP version and UDP version) will be run at
least 5 times (meaning that the file transfer will occur at least 5 times) by the following
conditions:
â€¢ For TCP, youâ€™ll run it in TCP Reno and TCP Cubic, alternating each time, for each
scenario, meaning that you run 5 times with TCP Reno in both Sender and Receiver,
and 5 times with TCP Cubic in both Sender and Receiver.
Bonus (5 points): Create a very large data set â€“ 5 times with TCP Reno in both Sender
and Receiver, 5 times with TCP Reno in Sender and TCP Cubic in Receiver, 5 times
with TCP Cubic in Sender and TCP Reno in Receiver, and 5 times with TCP Cubic in
both Sender and Receiver. This will give you a data set large enough, which allows
you to work with, compare with and to reach a definite conclusion.
â€¢ For RUDP, you will run it 5 times for each scenario.
â€¢ For both TCP and RUDP, you will run them on those scenarios of packet loss:
o 0% packet loss â€“ Control group, simulating perfect connection.
o 2% packet loss â€“ Simulating unstable connection that commonly occur.
o 5% packet loss â€“ Simulating bad connection.
o 10% packet loss â€“ Simulating extremely poor connection.
For each scenario, you must provide a filtered PCAP file and relevant screenshots that
explain each one of the steps in the process. (10 points)
After youâ€™ve gathered the data set for both TCP and Reliable UDP, answer the following
questions:
1) In TCP, which congestion control algorithm gave better results overall? TCP Reno or
TCP Cubic? Which one gave better results on high packet loss? Explain how you came
to this conclusion based on the data set youâ€™ve gathered. (5 points)
2) How did your implementation of Reliable UDP perform overall compared to regular
TCP? Which one is better for high packet loss? (5 points)
3) According to the data youâ€™ve gathered, in which scenarios and applications would we
prefer to use TCP and in which situations would we prefer to use reliable UDP?
Explain your answer. (5 points)
 Communication Networks Course
Page | 8
×¢× ×• ×¢×œ ×”×©××œ×•×ª ×”×‘××•×ª )5 × ×§×•×“×•×ª(:
â— ×‘"×¨×©×ª ×××™× ×”" ×”×›×•×•× ×” ×”×™× ×œ×¨×©×ª ×©×‘×” ××¢×˜ ×××•×“ ×—×‘×™×œ×•×ª ×”×•×œ×›×•×ª ×œ××™×‘×•×“. ×‘"×§×©×¨ ××¨×•×š" ×”×›×•×•× ×” ×”×™×
×œ×§×©×¨ TCP ×©×™×© ×‘×• ×”×¨×‘×” ×××•×“ ××™×“×¢ ×œ×©×œ×•×—. ××•×¦×¢ ×œ×”×’×“×™×œ ×‘ -TCP ××ª SSThreshold ×‘×ª×—×™×œ×ª ×”×§×©×¨.
×‘××™×–×” ××”××§×¨×™× ×”×‘××™× ×”×©×™× ×•×™ ×”×–×” ×¢×©×•×™ ×œ×”×•×¢×™×œ ×‘××™×“×” ×”××™×¨×‘×™×ª? × ××§.
.1 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
.2 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.3 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.4 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.5 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.6 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.7 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.8 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
â— A ×©×•×œ×— ×œ -B ×—×‘×™×œ×•×ª ××™×“×¢ ×‘×××¦×¢×•×ª ×§×©×¨ TCP. × ×ª×•×Ÿ ×›×™ ×”×§×©×¨ ××ª×—×™×œ ×¢× ×—×œ×•×Ÿ ×‘×’×•×“×œ 1MSS. ×”×§×©×¨
××¡×ª×™×™× ×‘×¤×¢× ×”×¨××©×•× ×” ×©×”×•× ××’×™×¢ ×œ -SSthresh. ×‘××”×œ×š ×”×§×©×¨ ×œ× ××•×‘×“×•×ª ×—×‘×™×œ×•×ª. × ×¡××Ÿ ×‘×§×™×¦×•×¨:
.SSthresh=S*MSS
× ×ª×•×Ÿ ×›×™ ×œ××•×¨×š ×›×œ ×”×§×©×¨ rwnd < MSS*S.
××”×™ ×”×ª×¤×•×§×” ×©×œ ×”×§×©×¨ ×-A ×œ-B( ×‘ -sec / Bytes )×‘×–××Ÿ ×”× "×œ? × ××§×™.
]S*MSS / [lg (S) * RTT*2 ×‘×¢×¨×š .1
]S*MSS / [S^0.5 * RTT*2 ×‘×¢×¨×š .2
S*MSS / RTT ×‘×¢×¨×š .3
S^2)*MSS / RTT( ×‘×¢×¨×š .4
â— ×©×ª×™ ×ª×—× ×•×ª ××ª×§×©×¨×•×ª ×‘××•×¤×Ÿ ××œ×—×•×˜×™ ×‘×©×™×˜×ª N Back Go.
× ×¡××Ÿ ×‘-X ××ª ×¡×¤×¨×ª ×”×‘×™×§×•×¨×ª ×©×œ ×”×ª.×–. ×©×œ×š. ×× ×©× ×™ ×©×•×ª×¤×™× ××’×™×©×™× ××ª ×”×ª×¨×’×™×œ ×™×—×“, X ×”×•× ×¡×¤×¨×ª
×”×‘×™×§×•×¨×ª ×‘×¢×œ×ª ×”×¢×¨×š ×”× ××•×š ×™×•×ª×¨ ××‘×™×Ÿ ×”×©×ª×™×™×.
×§×¦×‘ ×”×ª×§×©×•×¨×ª ×”×•× 8Gbps, ×•×’×•×“×œ ×›×œ ×—×‘×™×œ×” ×”×•× KByte*X. ×’×“×œ×™ ×”-headers ×•×” -Acks ×–× ×™×—×™×.
ï¿½ğ‘’ğ‘ ï¿½/ï¿½ï¿½ 8 , ×•×”××¨×—×§ ×‘×™×Ÿ ×”×ª×—× ×•×ª ×”×•× 1Km. ×§×¦×‘ ×”×”×ª×¤×©×˜×•×ª ×”×•× 10 â‹… 2
×–××Ÿ ×¢×™×‘×•×“ ×”× ×ª×•× ×™× ×‘×ª×—× ×•×ª ×–× ×™×—.
××£ ×—×‘×™×œ×” ×•××£ Ack ×œ× ×”×•×œ×›×™× ×œ××™×‘×•×“.
â— ××”×• X ×©×œ×š?
â— ××” ×¦×¨×™×š ×œ×”×™×•×ª ×’×•×“×œ ×—×œ×•×Ÿ ×”××©×œ×•×— ×›×“×™ ×œ×”×‘×˜×™×— ×ª×¤×•×§×” ××§×¡×™××œ×™×ª?
 Communication Networks Course
Page | 9
Bonus â€“ Improving the Reliable UDP â€“ 15 points
Note: This part isnâ€™t mandatory and is a bonus only!
In this part, youâ€™ll improve your RUDP implementation by adding the concepts of flow
control and congestion control from TCP. Youâ€™re free to choose which algorithms to
implement, as long as you explain in your PDF which algorithms youâ€™ve used. Youâ€™ll probably
need to make changes in the original design of the RUDP. Changes only need to be to the API
itself, ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„.
Points distribution:
â€¢ Flow control improvement â€“ 7 Points
â€¢ Congestion control improvement â€“ 8 points.
Guidance:
â€¢ For flow control, you must use one of the Sliding window techniques: stop-and-wait
ARQ, Go-Back-N or Selective repeat.
â€¢ List of known TCP congestion control algorithms, which you can use any one of them
for this bonus task, or makeup your own:
Figure 2 â€“ List of known TCP congestion control algorithms, Wikipedia
 Communication Networks Course
Page | 10
Appendix A â€“ Linux local packet loss tool
To simulate a packet loss in a local network, we'll use a Linux tool that's called Linux Traffic
Control (ğ‘¡ğ‘). This requires a full Linux installation, so working with WSL won't work.
If the tool isn't installed in your machine, you can install it by using the following commands:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’
If the installation didn't work, you can use the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’2
To create a packet loss scenario, type the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘ğ‘‘ğ‘‘ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
After creating a packet loss scenario, you can change the percentage by typing the following
command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘â„ğ‘ğ‘›ğ‘”ğ‘’ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
To remove the packet loss scenario, write the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘‘ğ‘’ğ‘™ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š
 Communication Networks Course
Page | 11
Appendix B â€“ ğ’ğ’‚ğ’(ğŸ) system calls
This appendixâ€™s purpose is to give you a better understanding of socket handling in C.
A recommended reference is Beejâ€™s Guide to Network Programming, by Brian â€œBeej
Jorgensenâ€ Hall, which gives a lot of information about sockets in C and functions.
Functions and documentation links:
â€¢ ğ’”ğ’ğ’„ğ’Œğ’†ğ’•(ğŸ) â€“ A Factory method system call that creates a socket with the given
parameters.
â€¢ ğ’ƒğ’Šğ’ğ’…(ğŸ) â€“ Whenever we create a new socket, we need to bind it to a specific port in
our machine, â€œto catch a portâ€. The port number is managed and used by the kernel
to link incoming packets to the corresponding application socket. The port numbers
are usually fixed. The ğ‘ğ‘‘ğ‘‘ğ‘Ÿ parameter must match the current socket that is used.
â€¢ ğ’ğ’Šğ’”ğ’•ğ’†ğ’(ğŸ) â€“ The ğ‘™ğ‘–ğ‘ ğ‘¡ğ‘’ğ‘›(2) system call doesn't do anything in the mean of
communication but only memory allocation (malloc) for stream sockets only. If we
won't allocate memory, any incoming connection will fail.
â€¢ ğ’„ğ’ğ’ğ’ğ’†ğ’„ğ’•(ğŸ) â€“ The ğ‘ğ‘œğ‘›ğ‘›ğ‘’ğ‘ğ‘¡(2) system call starts the link between a client and a
specific IP address and port number. The connection would complete when the
other side will call the ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call.
â€¢ ğ’‚ğ’„ğ’„ğ’†ğ’‘ğ’•(ğŸ) â€“ The ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call accepts the incoming stream connection
request from the other side, by the listening socket. This system call completes the
three-way handshake of stream socket (like TCP) and opens a new socket that has a
direct communication channel only with the other party in the handshake.
â€¢ ğ’”ğ’†ğ’ğ’…(ğŸ) and ğ’”ğ’†ğ’ğ’…ğ’•ğ’(ğŸ) â€“ The ğ‘ ğ‘’ğ‘›ğ‘‘(2) and ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system calls are an analogy
for the ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’(2) system call, specifcly for sockets, with flags set to 0. Those system
calls return the number of bytes that were sent through the socket itself, as the
number of bytes can vary. The ğ‘ ğ‘’ğ‘›ğ‘‘(2)system call designed for stream sockets (like
TCP), while the ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system call designed for datagram connection-less
sockets (like UDP). When the ğ‘ ğ‘’ğ‘›ğ‘‘(2) system call returns 0, it means that the other
party closed the connection.
â€¢ ğ’“ğ’†ğ’„ğ’—(ğŸ) and ğ’“ğ’†ğ’„ğ’—ğ’‡ğ’“ğ’ğ’(ğŸ) â€“ The ğ‘Ÿğ‘’ğ‘ğ‘£(2) and ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system calls are an
analogy for the ğ‘Ÿğ‘’ğ‘ğ‘‘(2) system call, specifically for sockets, with flags set to 0.
Those system calls return the number of bytes that were received through the socket
itself, as the number of bytes can vary. The ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call designed for stream
sockets (like TCP), while the ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system call designed for datagram
connection-less sockets (like UDP). When the ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call returns 0, it means
that the other party closed the connection.
â€¢ ğ’„ğ’ğ’ğ’”ğ’†(ğŸ) and ğ’”ğ’‰ğ’–ğ’•ğ’…ğ’ğ’˜ğ’(ğŸ) â€“ The ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) and ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2) system calls close
the socket. While ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) system call closes the whole socket, the ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2)
system call partially closes the socket for read/write.
 Communication Networks Course
Page | 12
Appendix C â€“ Random data generator
The data that you are going to send in this assignment is randomly generated. You can use
your own file with appropriate size or use the following function (or a function of your own)
to generate the data:
/*
* @brief A random data generator function based on srand() and rand().
* @param size The size of the data to generate (up to 2^32 bytes).
* @return A pointer to the buffer.
*/
char *util_generate_random_data(unsigned int size) {
 char *buffer = NULL;
 // Argument check.
 if (size == 0)
 return NULL;
 buffer = (char *)calloc(size, sizeof(char));
 // Error checking.
 if (buffer == NULL)
 return NULL;
 // Randomize the seed of the random number generator.
 srand(time(NULL));
 for (unsigned int i = 0; i < size; i++)
 *(buffer + i) = ((unsigned int)rand() % 256);
 return buffer;
}
 Communication Networks Course
Page | 13
Appendix D â€“ Checksum function
A checksum is a small-sized block of data derived from another block of digital data for the
purpose of detecting errors that may have been introduced during its transmission or
storage. By themselves, checksums are often used to verify data integrity but are not relied
upon to verify data authenticity.
Below is a simple yet efficient implementation of the checksum function, you can use it for
the assignment, but you can implement your own checksum function.
/*
* @brief A checksum function that returns 16 bit checksum for data.
* @param data The data to do the checksum for.
* @param bytes The length of the data in bytes.
* @return The checksum itself as 16 bit unsigned number.
* @note This function is taken from RFC1071, can be found here:
* @note https://tools.ietf.org/html/rfc1071
* @note It is the simplest way to calculate a checksum and is not very strong.
* However, it is good enough for this assignment.
* @note You are free to use any other checksum function as well.
* You can also use this function as such without any change.
*/
unsigned short int calculate_checksum(void *data, unsigned int bytes) {
 unsigned short int *data_pointer = (unsigned short int *)data;
 unsigned int total_sum = 0;
 // Main summing loop
 while (bytes > 1) {
 total_sum += *data_pointer++;
 bytes -= 2;
 }
 // Add left-over byte, if any
 if (bytes > 0)
 total_sum += *((unsigned char *)data_pointer);
 // Fold 32-bit sum to 16 bits
 while (total_sum >> 16)
 total_sum = (total_sum & 0xFFFF) + (total_sum >> 16);
 return (~((unsigned short int)total_sum));
} Communication Networks Course
Page | 1
Assignment 3 â€“ Transport Layer
Assignment Notes and Instructions
This assignment is to be done in pairs only. You must upload all the necessary files in a ZIP
file named after both of the studentâ€™s ID. For example: ğŸğŸğŸ‘ğŸ’ğŸ“ğŸ”ğŸ•ğŸ–ğŸ—_ğŸ—ğŸ–ğŸ•ğŸ”ğŸ“ğŸ’ğŸ‘ğŸğŸ. ğ’›ğ’Šğ’‘.
1) The assignment must be submitted by the date specified in the submission box.
2) All the assignment files (Code, Wireshark pcap files, PDF) must be submitted in a ZIP file. The
PDF must contain all the necessary screenshots with a description for each one of them.
3) The assignment must be done in pairs only. In exceptional cases, you should send an email to
the course coordinator.
4) You can use any reference material available through the course Moodle website or any
material passed during the exercises.
5) You can use any reference from the web, but copying codes from websites is forbidden; this
includes codes from other GitHub repositories. A student who gets caught in the act will
automatically fail this assignment (score 0). Any website youâ€™ve used to solve the
assignment, every website you used to solve the assignment must be noted in the PDF.
6) No delays in submission without special permission. Lateness without approval will result in
failure of the assignment (score 0).
7) All submissions will be submitted via the course's Moodle website. Email submissions will not
be accepted, resulting in a failure in the assignment.
8) The order and design of the code must be carefully considered. Make sure that the program
output is as clear as possible, comments in the code, and meaningful variable names. You
must also submit a makefile that compiles all the programs.
9) The assignment code must be written in C only.
10) The assignment is personal for each pair, and you should not accept help from other people,
whether outside the university or inside it. You can contact the course staff during reception
hours for help or raise a question in the course forum. Do not transfer code sections
between students, upload solutions or parts of solutions to websites on the Internet or in
various communication groups.
11) Students who copy a solution will receive a 0 in all assignments in the course and a report will
be made to the institutional disciplinary committee.
12) All code files of the assignment are required to both compile and run properly on the Ubuntu
22.04 LTS operating system. This is the operating system where the submissions will be
tested. You mustnâ€™t code it in Windows, as it uses different API for sockets. WSL wonâ€™t work,
as the task needs a tool that works only in a fully Linux environment.
Good Luck!
 Communication Networks Course
Page | 2
Part A â€“ Transmission Control Protocol (TCP) â€“ 30 points
In this part, youâ€™ll write two program files: ğ‘»ğ‘ªğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and ğ‘»ğ‘ªğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
The Sender will send a randomly generated file and the Receiver will receive it and measure
the time it took for his program to receive the file. The file size should be at least 2MB.
When running the Sender and Receiver, they both should support two standard congestion
control algorithms: TCP Reno and TCP Cubic.
Notes:
â€¢ The main goal of this part is to get familiar with the TCP concept of sending
messages between two endpoints.
â€¢ For approaching this part of the assignment, please be sure that you are familiar
with the congestion control algorithms and how to change them using the correct
method in C (see Appendix B for more information).
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). You've
learned that TCP is reliable by design, so you can assume that all the data have been
passed correctly, and thus, no need to recheck.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
Usage:
â€¢ Receiver:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
â€¢ Sender:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port of the Receiver.
â€¢ ğ‘¨ğ‘³ğ‘®ğ‘¶ â€“ The TCP congestion control algorithm that will be used by the party
member (either ğ’“ğ’†ğ’ğ’ for TCP Reno or ğ’„ğ’–ğ’ƒğ’Šğ’„ for TCP Cubic).
 Communication Networks Course
Page | 3
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a TCP socket between the Sender and the
Receiver.
3) Send the file.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a TCP connection between the Receiver and
the Sender.
2) Get a connection from the sender.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./TCP_Receiver -p 1234 -algo reno
Starting Receiver...
Waiting for TCP connection...
Sender connected, beginning to receive file...
File transfer completed.
Waiting for Sender response...
Sender sent exit message.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 4
Part B â€“ Reliable User Datagram Protocol (Reliable UDP or RUDP) â€“ 40 points
Youâ€™ve learned that while TCP is reliable, it lacks speed and has an overhead data of 20 bytes,
compering to UDP that needs only 8 bytes of overhead data.
Reliable UDP or RUDP, is a protocol that uses the UDP protocol for a faster transmission of
data, while adding a reliability layer to it, but without adding too much overhead data like
TCP.
A simple sketch for a RUDP connection would look something like this:
Your task in this part is to implement a Reliable protocol using UDP only. For simplicity, your
implementation should only support a handshake, closing scheme, error checking,
acknowledgment of received packets, and retransmission of lost packets.
Guidance:
â€¢ You can use ğ‘ ğ‘’ğ‘¡ğ‘ ğ‘œğ‘ğ‘˜ğ‘œğ‘ğ‘¡(2) for detecting a timeout.
â€¢ You need to build your own protocol, as Reliable UDP isnâ€™t a standard protocol (see a
draft of RUDP in this link), and no official header is provided. You can use this sketch
for a header, but you can come up with your own protocol, as long as it works.
Where:
o ğ‘³ğ’†ğ’ğ’ˆğ’•ğ’‰ is the length of the data itself, without the RUDP header.
o ğ‘ªğ’‰ğ’†ğ’„ğ’Œğ’”ğ’–ğ’ is a 16bit number that validates the correctness of the data.
o ğ‘­ğ’ğ’‚ğ’ˆğ’” is a special byte where we classify the packet itself (SYN, ACK, etc.).
â€¢ In your PDF, you must explain how your implementation of RUDP works â€“ How does
it detect a timeout to do retransmissions, how does the handshake work, what is the
header overhead, etc.
â€¢ For this part, youâ€™ll write three files: ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¨ğ‘·ğ‘°. ğ’„, ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and
ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
Reliable UDP Header proposed sketch
Byte 0 Byte 1 Byte 2 Byte 3
Length (2 Bytes) Checksum (2 Bytes)
Flags (1 Byte)
Figure 1 - RUDP Protocol Architecture, Geeksforgeeks
 Communication Networks Course
Page | 5
Notes:
â€¢ The Sender will send a random generated file and the Receiver will receive it and
measure the time it took for his program to receive the file. The file size should be at
least 2MB.
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). But, as the
RUDP is based on UDP, itâ€™s not reliable. You must use some form of error checking
(like checksum) to ensure that the packet wasnâ€™t alerted during the transfer.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
â€¢ The RUDP needs support only 1 sender and 1 receiver, for simplicity purposes.
Usage:
â€¢ Receiver:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
â€¢ Sender:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port that both the Sender and the Receiver will use.
The ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„ file will contain all the implementations of the RUDP API functions (That is, to
prevent reusing the same chuck of code both in the Sender and the Receiver.).
The API should support at the bare minimum the following functions (you decide what
parameters to implement, and what are the names of the functions, as long as the API is
explained in the PDF):
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘œğ‘ğ‘˜ğ‘’ğ‘¡() â€“ Creating a RUDP socket and creating a handshake between two
peers.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘’ğ‘›ğ‘‘() â€“ Sending data to the peer. The function should wait for an
acknowledgment packet, and if it didnâ€™t receive any, retransmits the data.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘Ÿğ‘’ğ‘ğ‘£() â€“ Receive data from a peer.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ğ‘™ğ‘œğ‘ ğ‘’() â€“ Closes a connection between peers.
 Communication Networks Course
Page | 6
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a UDP socket between the Sender and the
Receiver.
3) Send the file via the RUDP protocol.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a UDP connection between the Receiver and
the Sender.
2) Get a connection from the sender, by the custom
RUDP protocol youâ€™ve built.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./RUDP_Receiver -p 1234
Starting Receiver...
Waiting for RUDP connection...
Connection request received, sending ACK.
Sender connected, beginning to receive file...
File transfer completed.
ACK sent.
Waiting for Sender response...
Sender sent exit message.
ACK sent.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 7
Part C â€“ Research â€“ 30 points
In this part, youâ€™ll conduct research about your implementations of part A and part B.
In the research itself, each one of the versions (TCP version and UDP version) will be run at
least 5 times (meaning that the file transfer will occur at least 5 times) by the following
conditions:
â€¢ For TCP, youâ€™ll run it in TCP Reno and TCP Cubic, alternating each time, for each
scenario, meaning that you run 5 times with TCP Reno in both Sender and Receiver,
and 5 times with TCP Cubic in both Sender and Receiver.
Bonus (5 points): Create a very large data set â€“ 5 times with TCP Reno in both Sender
and Receiver, 5 times with TCP Reno in Sender and TCP Cubic in Receiver, 5 times
with TCP Cubic in Sender and TCP Reno in Receiver, and 5 times with TCP Cubic in
both Sender and Receiver. This will give you a data set large enough, which allows
you to work with, compare with and to reach a definite conclusion.
â€¢ For RUDP, you will run it 5 times for each scenario.
â€¢ For both TCP and RUDP, you will run them on those scenarios of packet loss:
o 0% packet loss â€“ Control group, simulating perfect connection.
o 2% packet loss â€“ Simulating unstable connection that commonly occur.
o 5% packet loss â€“ Simulating bad connection.
o 10% packet loss â€“ Simulating extremely poor connection.
For each scenario, you must provide a filtered PCAP file and relevant screenshots that
explain each one of the steps in the process. (10 points)
After youâ€™ve gathered the data set for both TCP and Reliable UDP, answer the following
questions:
1) In TCP, which congestion control algorithm gave better results overall? TCP Reno or
TCP Cubic? Which one gave better results on high packet loss? Explain how you came
to this conclusion based on the data set youâ€™ve gathered. (5 points)
2) How did your implementation of Reliable UDP perform overall compared to regular
TCP? Which one is better for high packet loss? (5 points)
3) According to the data youâ€™ve gathered, in which scenarios and applications would we
prefer to use TCP and in which situations would we prefer to use reliable UDP?
Explain your answer. (5 points)
 Communication Networks Course
Page | 8
×¢× ×• ×¢×œ ×”×©××œ×•×ª ×”×‘××•×ª )5 × ×§×•×“×•×ª(:
â— ×‘"×¨×©×ª ×××™× ×”" ×”×›×•×•× ×” ×”×™× ×œ×¨×©×ª ×©×‘×” ××¢×˜ ×××•×“ ×—×‘×™×œ×•×ª ×”×•×œ×›×•×ª ×œ××™×‘×•×“. ×‘"×§×©×¨ ××¨×•×š" ×”×›×•×•× ×” ×”×™×
×œ×§×©×¨ TCP ×©×™×© ×‘×• ×”×¨×‘×” ×××•×“ ××™×“×¢ ×œ×©×œ×•×—. ××•×¦×¢ ×œ×”×’×“×™×œ ×‘ -TCP ××ª SSThreshold ×‘×ª×—×™×œ×ª ×”×§×©×¨.
×‘××™×–×” ××”××§×¨×™× ×”×‘××™× ×”×©×™× ×•×™ ×”×–×” ×¢×©×•×™ ×œ×”×•×¢×™×œ ×‘××™×“×” ×”××™×¨×‘×™×ª? × ××§.
.1 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
.2 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.3 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.4 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.5 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.6 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.7 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.8 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
â— A ×©×•×œ×— ×œ -B ×—×‘×™×œ×•×ª ××™×“×¢ ×‘×××¦×¢×•×ª ×§×©×¨ TCP. × ×ª×•×Ÿ ×›×™ ×”×§×©×¨ ××ª×—×™×œ ×¢× ×—×œ×•×Ÿ ×‘×’×•×“×œ 1MSS. ×”×§×©×¨
××¡×ª×™×™× ×‘×¤×¢× ×”×¨××©×•× ×” ×©×”×•× ××’×™×¢ ×œ -SSthresh. ×‘××”×œ×š ×”×§×©×¨ ×œ× ××•×‘×“×•×ª ×—×‘×™×œ×•×ª. × ×¡××Ÿ ×‘×§×™×¦×•×¨:
.SSthresh=S*MSS
× ×ª×•×Ÿ ×›×™ ×œ××•×¨×š ×›×œ ×”×§×©×¨ rwnd < MSS*S.
××”×™ ×”×ª×¤×•×§×” ×©×œ ×”×§×©×¨ ×-A ×œ-B( ×‘ -sec / Bytes )×‘×–××Ÿ ×”× "×œ? × ××§×™.
]S*MSS / [lg (S) * RTT*2 ×‘×¢×¨×š .1
]S*MSS / [S^0.5 * RTT*2 ×‘×¢×¨×š .2
S*MSS / RTT ×‘×¢×¨×š .3
S^2)*MSS / RTT( ×‘×¢×¨×š .4
â— ×©×ª×™ ×ª×—× ×•×ª ××ª×§×©×¨×•×ª ×‘××•×¤×Ÿ ××œ×—×•×˜×™ ×‘×©×™×˜×ª N Back Go.
× ×¡××Ÿ ×‘-X ××ª ×¡×¤×¨×ª ×”×‘×™×§×•×¨×ª ×©×œ ×”×ª.×–. ×©×œ×š. ×× ×©× ×™ ×©×•×ª×¤×™× ××’×™×©×™× ××ª ×”×ª×¨×’×™×œ ×™×—×“, X ×”×•× ×¡×¤×¨×ª
×”×‘×™×§×•×¨×ª ×‘×¢×œ×ª ×”×¢×¨×š ×”× ××•×š ×™×•×ª×¨ ××‘×™×Ÿ ×”×©×ª×™×™×.
×§×¦×‘ ×”×ª×§×©×•×¨×ª ×”×•× 8Gbps, ×•×’×•×“×œ ×›×œ ×—×‘×™×œ×” ×”×•× KByte*X. ×’×“×œ×™ ×”-headers ×•×” -Acks ×–× ×™×—×™×.
ï¿½ğ‘’ğ‘ ï¿½/ï¿½ï¿½ 8 , ×•×”××¨×—×§ ×‘×™×Ÿ ×”×ª×—× ×•×ª ×”×•× 1Km. ×§×¦×‘ ×”×”×ª×¤×©×˜×•×ª ×”×•× 10 â‹… 2
×–××Ÿ ×¢×™×‘×•×“ ×”× ×ª×•× ×™× ×‘×ª×—× ×•×ª ×–× ×™×—.
××£ ×—×‘×™×œ×” ×•××£ Ack ×œ× ×”×•×œ×›×™× ×œ××™×‘×•×“.
â— ××”×• X ×©×œ×š?
â— ××” ×¦×¨×™×š ×œ×”×™×•×ª ×’×•×“×œ ×—×œ×•×Ÿ ×”××©×œ×•×— ×›×“×™ ×œ×”×‘×˜×™×— ×ª×¤×•×§×” ××§×¡×™××œ×™×ª?
 Communication Networks Course
Page | 9
Bonus â€“ Improving the Reliable UDP â€“ 15 points
Note: This part isnâ€™t mandatory and is a bonus only!
In this part, youâ€™ll improve your RUDP implementation by adding the concepts of flow
control and congestion control from TCP. Youâ€™re free to choose which algorithms to
implement, as long as you explain in your PDF which algorithms youâ€™ve used. Youâ€™ll probably
need to make changes in the original design of the RUDP. Changes only need to be to the API
itself, ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„.
Points distribution:
â€¢ Flow control improvement â€“ 7 Points
â€¢ Congestion control improvement â€“ 8 points.
Guidance:
â€¢ For flow control, you must use one of the Sliding window techniques: stop-and-wait
ARQ, Go-Back-N or Selective repeat.
â€¢ List of known TCP congestion control algorithms, which you can use any one of them
for this bonus task, or makeup your own:
Figure 2 â€“ List of known TCP congestion control algorithms, Wikipedia
 Communication Networks Course
Page | 10
Appendix A â€“ Linux local packet loss tool
To simulate a packet loss in a local network, we'll use a Linux tool that's called Linux Traffic
Control (ğ‘¡ğ‘). This requires a full Linux installation, so working with WSL won't work.
If the tool isn't installed in your machine, you can install it by using the following commands:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’
If the installation didn't work, you can use the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’2
To create a packet loss scenario, type the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘ğ‘‘ğ‘‘ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
After creating a packet loss scenario, you can change the percentage by typing the following
command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘â„ğ‘ğ‘›ğ‘”ğ‘’ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
To remove the packet loss scenario, write the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘‘ğ‘’ğ‘™ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š
 Communication Networks Course
Page | 11
Appendix B â€“ ğ’ğ’‚ğ’(ğŸ) system calls
This appendixâ€™s purpose is to give you a better understanding of socket handling in C.
A recommended reference is Beejâ€™s Guide to Network Programming, by Brian â€œBeej
Jorgensenâ€ Hall, which gives a lot of information about sockets in C and functions.
Functions and documentation links:
â€¢ ğ’”ğ’ğ’„ğ’Œğ’†ğ’•(ğŸ) â€“ A Factory method system call that creates a socket with the given
parameters.
â€¢ ğ’ƒğ’Šğ’ğ’…(ğŸ) â€“ Whenever we create a new socket, we need to bind it to a specific port in
our machine, â€œto catch a portâ€. The port number is managed and used by the kernel
to link incoming packets to the corresponding application socket. The port numbers
are usually fixed. The ğ‘ğ‘‘ğ‘‘ğ‘Ÿ parameter must match the current socket that is used.
â€¢ ğ’ğ’Šğ’”ğ’•ğ’†ğ’(ğŸ) â€“ The ğ‘™ğ‘–ğ‘ ğ‘¡ğ‘’ğ‘›(2) system call doesn't do anything in the mean of
communication but only memory allocation (malloc) for stream sockets only. If we
won't allocate memory, any incoming connection will fail.
â€¢ ğ’„ğ’ğ’ğ’ğ’†ğ’„ğ’•(ğŸ) â€“ The ğ‘ğ‘œğ‘›ğ‘›ğ‘’ğ‘ğ‘¡(2) system call starts the link between a client and a
specific IP address and port number. The connection would complete when the
other side will call the ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call.
â€¢ ğ’‚ğ’„ğ’„ğ’†ğ’‘ğ’•(ğŸ) â€“ The ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call accepts the incoming stream connection
request from the other side, by the listening socket. This system call completes the
three-way handshake of stream socket (like TCP) and opens a new socket that has a
direct communication channel only with the other party in the handshake.
â€¢ ğ’”ğ’†ğ’ğ’…(ğŸ) and ğ’”ğ’†ğ’ğ’…ğ’•ğ’(ğŸ) â€“ The ğ‘ ğ‘’ğ‘›ğ‘‘(2) and ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system calls are an analogy
for the ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’(2) system call, specifcly for sockets, with flags set to 0. Those system
calls return the number of bytes that were sent through the socket itself, as the
number of bytes can vary. The ğ‘ ğ‘’ğ‘›ğ‘‘(2)system call designed for stream sockets (like
TCP), while the ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system call designed for datagram connection-less
sockets (like UDP). When the ğ‘ ğ‘’ğ‘›ğ‘‘(2) system call returns 0, it means that the other
party closed the connection.
â€¢ ğ’“ğ’†ğ’„ğ’—(ğŸ) and ğ’“ğ’†ğ’„ğ’—ğ’‡ğ’“ğ’ğ’(ğŸ) â€“ The ğ‘Ÿğ‘’ğ‘ğ‘£(2) and ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system calls are an
analogy for the ğ‘Ÿğ‘’ğ‘ğ‘‘(2) system call, specifically for sockets, with flags set to 0.
Those system calls return the number of bytes that were received through the socket
itself, as the number of bytes can vary. The ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call designed for stream
sockets (like TCP), while the ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system call designed for datagram
connection-less sockets (like UDP). When the ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call returns 0, it means
that the other party closed the connection.
â€¢ ğ’„ğ’ğ’ğ’”ğ’†(ğŸ) and ğ’”ğ’‰ğ’–ğ’•ğ’…ğ’ğ’˜ğ’(ğŸ) â€“ The ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) and ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2) system calls close
the socket. While ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) system call closes the whole socket, the ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2)
system call partially closes the socket for read/write.
 Communication Networks Course
Page | 12
Appendix C â€“ Random data generator
The data that you are going to send in this assignment is randomly generated. You can use
your own file with appropriate size or use the following function (or a function of your own)
to generate the data:
/*
* @brief A random data generator function based on srand() and rand().
* @param size The size of the data to generate (up to 2^32 bytes).
* @return A pointer to the buffer.
*/
char *util_generate_random_data(unsigned int size) {
 char *buffer = NULL;
 // Argument check.
 if (size == 0)
 return NULL;
 buffer = (char *)calloc(size, sizeof(char));
 // Error checking.
 if (buffer == NULL)
 return NULL;
 // Randomize the seed of the random number generator.
 srand(time(NULL));
 for (unsigned int i = 0; i < size; i++)
 *(buffer + i) = ((unsigned int)rand() % 256);
 return buffer;
}
 Communication Networks Course
Page | 13
Appendix D â€“ Checksum function
A checksum is a small-sized block of data derived from another block of digital data for the
purpose of detecting errors that may have been introduced during its transmission or
storage. By themselves, checksums are often used to verify data integrity but are not relied
upon to verify data authenticity.
Below is a simple yet efficient implementation of the checksum function, you can use it for
the assignment, but you can implement your own checksum function.
/*
* @brief A checksum function that returns 16 bit checksum for data.
* @param data The data to do the checksum for.
* @param bytes The length of the data in bytes.
* @return The checksum itself as 16 bit unsigned number.
* @note This function is taken from RFC1071, can be found here:
* @note https://tools.ietf.org/html/rfc1071
* @note It is the simplest way to calculate a checksum and is not very strong.
* However, it is good enough for this assignment.
* @note You are free to use any other checksum function as well.
* You can also use this function as such without any change.
*/
unsigned short int calculate_checksum(void *data, unsigned int bytes) {
 unsigned short int *data_pointer = (unsigned short int *)data;
 unsigned int total_sum = 0;
 // Main summing loop
 while (bytes > 1) {
 total_sum += *data_pointer++;
 bytes -= 2;
 }
 // Add left-over byte, if any
 if (bytes > 0)
 total_sum += *((unsigned char *)data_pointer);
 // Fold 32-bit sum to 16 bits
 while (total_sum >> 16)
 total_sum = (total_sum & 0xFFFF) + (total_sum >> 16);
 return (~((unsigned short int)total_sum));
} Communication Networks Course
Page | 1
Assignment 3 â€“ Transport Layer
Assignment Notes and Instructions
This assignment is to be done in pairs only. You must upload all the necessary files in a ZIP
file named after both of the studentâ€™s ID. For example: ğŸğŸğŸ‘ğŸ’ğŸ“ğŸ”ğŸ•ğŸ–ğŸ—_ğŸ—ğŸ–ğŸ•ğŸ”ğŸ“ğŸ’ğŸ‘ğŸğŸ. ğ’›ğ’Šğ’‘.
1) The assignment must be submitted by the date specified in the submission box.
2) All the assignment files (Code, Wireshark pcap files, PDF) must be submitted in a ZIP file. The
PDF must contain all the necessary screenshots with a description for each one of them.
3) The assignment must be done in pairs only. In exceptional cases, you should send an email to
the course coordinator.
4) You can use any reference material available through the course Moodle website or any
material passed during the exercises.
5) You can use any reference from the web, but copying codes from websites is forbidden; this
includes codes from other GitHub repositories. A student who gets caught in the act will
automatically fail this assignment (score 0). Any website youâ€™ve used to solve the
assignment, every website you used to solve the assignment must be noted in the PDF.
6) No delays in submission without special permission. Lateness without approval will result in
failure of the assignment (score 0).
7) All submissions will be submitted via the course's Moodle website. Email submissions will not
be accepted, resulting in a failure in the assignment.
8) The order and design of the code must be carefully considered. Make sure that the program
output is as clear as possible, comments in the code, and meaningful variable names. You
must also submit a makefile that compiles all the programs.
9) The assignment code must be written in C only.
10) The assignment is personal for each pair, and you should not accept help from other people,
whether outside the university or inside it. You can contact the course staff during reception
hours for help or raise a question in the course forum. Do not transfer code sections
between students, upload solutions or parts of solutions to websites on the Internet or in
various communication groups.
11) Students who copy a solution will receive a 0 in all assignments in the course and a report will
be made to the institutional disciplinary committee.
12) All code files of the assignment are required to both compile and run properly on the Ubuntu
22.04 LTS operating system. This is the operating system where the submissions will be
tested. You mustnâ€™t code it in Windows, as it uses different API for sockets. WSL wonâ€™t work,
as the task needs a tool that works only in a fully Linux environment.
Good Luck!
 Communication Networks Course
Page | 2
Part A â€“ Transmission Control Protocol (TCP) â€“ 30 points
In this part, youâ€™ll write two program files: ğ‘»ğ‘ªğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and ğ‘»ğ‘ªğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
The Sender will send a randomly generated file and the Receiver will receive it and measure
the time it took for his program to receive the file. The file size should be at least 2MB.
When running the Sender and Receiver, they both should support two standard congestion
control algorithms: TCP Reno and TCP Cubic.
Notes:
â€¢ The main goal of this part is to get familiar with the TCP concept of sending
messages between two endpoints.
â€¢ For approaching this part of the assignment, please be sure that you are familiar
with the congestion control algorithms and how to change them using the correct
method in C (see Appendix B for more information).
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). You've
learned that TCP is reliable by design, so you can assume that all the data have been
passed correctly, and thus, no need to recheck.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
Usage:
â€¢ Receiver:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
â€¢ Sender:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port of the Receiver.
â€¢ ğ‘¨ğ‘³ğ‘®ğ‘¶ â€“ The TCP congestion control algorithm that will be used by the party
member (either ğ’“ğ’†ğ’ğ’ for TCP Reno or ğ’„ğ’–ğ’ƒğ’Šğ’„ for TCP Cubic).
 Communication Networks Course
Page | 3
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a TCP socket between the Sender and the
Receiver.
3) Send the file.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a TCP connection between the Receiver and
the Sender.
2) Get a connection from the sender.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./TCP_Receiver -p 1234 -algo reno
Starting Receiver...
Waiting for TCP connection...
Sender connected, beginning to receive file...
File transfer completed.
Waiting for Sender response...
Sender sent exit message.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 4
Part B â€“ Reliable User Datagram Protocol (Reliable UDP or RUDP) â€“ 40 points
Youâ€™ve learned that while TCP is reliable, it lacks speed and has an overhead data of 20 bytes,
compering to UDP that needs only 8 bytes of overhead data.
Reliable UDP or RUDP, is a protocol that uses the UDP protocol for a faster transmission of
data, while adding a reliability layer to it, but without adding too much overhead data like
TCP.
A simple sketch for a RUDP connection would look something like this:
Your task in this part is to implement a Reliable protocol using UDP only. For simplicity, your
implementation should only support a handshake, closing scheme, error checking,
acknowledgment of received packets, and retransmission of lost packets.
Guidance:
â€¢ You can use ğ‘ ğ‘’ğ‘¡ğ‘ ğ‘œğ‘ğ‘˜ğ‘œğ‘ğ‘¡(2) for detecting a timeout.
â€¢ You need to build your own protocol, as Reliable UDP isnâ€™t a standard protocol (see a
draft of RUDP in this link), and no official header is provided. You can use this sketch
for a header, but you can come up with your own protocol, as long as it works.
Where:
o ğ‘³ğ’†ğ’ğ’ˆğ’•ğ’‰ is the length of the data itself, without the RUDP header.
o ğ‘ªğ’‰ğ’†ğ’„ğ’Œğ’”ğ’–ğ’ is a 16bit number that validates the correctness of the data.
o ğ‘­ğ’ğ’‚ğ’ˆğ’” is a special byte where we classify the packet itself (SYN, ACK, etc.).
â€¢ In your PDF, you must explain how your implementation of RUDP works â€“ How does
it detect a timeout to do retransmissions, how does the handshake work, what is the
header overhead, etc.
â€¢ For this part, youâ€™ll write three files: ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¨ğ‘·ğ‘°. ğ’„, ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and
ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
Reliable UDP Header proposed sketch
Byte 0 Byte 1 Byte 2 Byte 3
Length (2 Bytes) Checksum (2 Bytes)
Flags (1 Byte)
Figure 1 - RUDP Protocol Architecture, Geeksforgeeks
 Communication Networks Course
Page | 5
Notes:
â€¢ The Sender will send a random generated file and the Receiver will receive it and
measure the time it took for his program to receive the file. The file size should be at
least 2MB.
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). But, as the
RUDP is based on UDP, itâ€™s not reliable. You must use some form of error checking
(like checksum) to ensure that the packet wasnâ€™t alerted during the transfer.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
â€¢ The RUDP needs support only 1 sender and 1 receiver, for simplicity purposes.
Usage:
â€¢ Receiver:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
â€¢ Sender:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port that both the Sender and the Receiver will use.
The ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„ file will contain all the implementations of the RUDP API functions (That is, to
prevent reusing the same chuck of code both in the Sender and the Receiver.).
The API should support at the bare minimum the following functions (you decide what
parameters to implement, and what are the names of the functions, as long as the API is
explained in the PDF):
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘œğ‘ğ‘˜ğ‘’ğ‘¡() â€“ Creating a RUDP socket and creating a handshake between two
peers.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘’ğ‘›ğ‘‘() â€“ Sending data to the peer. The function should wait for an
acknowledgment packet, and if it didnâ€™t receive any, retransmits the data.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘Ÿğ‘’ğ‘ğ‘£() â€“ Receive data from a peer.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ğ‘™ğ‘œğ‘ ğ‘’() â€“ Closes a connection between peers.
 Communication Networks Course
Page | 6
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a UDP socket between the Sender and the
Receiver.
3) Send the file via the RUDP protocol.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a UDP connection between the Receiver and
the Sender.
2) Get a connection from the sender, by the custom
RUDP protocol youâ€™ve built.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./RUDP_Receiver -p 1234
Starting Receiver...
Waiting for RUDP connection...
Connection request received, sending ACK.
Sender connected, beginning to receive file...
File transfer completed.
ACK sent.
Waiting for Sender response...
Sender sent exit message.
ACK sent.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 7
Part C â€“ Research â€“ 30 points
In this part, youâ€™ll conduct research about your implementations of part A and part B.
In the research itself, each one of the versions (TCP version and UDP version) will be run at
least 5 times (meaning that the file transfer will occur at least 5 times) by the following
conditions:
â€¢ For TCP, youâ€™ll run it in TCP Reno and TCP Cubic, alternating each time, for each
scenario, meaning that you run 5 times with TCP Reno in both Sender and Receiver,
and 5 times with TCP Cubic in both Sender and Receiver.
Bonus (5 points): Create a very large data set â€“ 5 times with TCP Reno in both Sender
and Receiver, 5 times with TCP Reno in Sender and TCP Cubic in Receiver, 5 times
with TCP Cubic in Sender and TCP Reno in Receiver, and 5 times with TCP Cubic in
both Sender and Receiver. This will give you a data set large enough, which allows
you to work with, compare with and to reach a definite conclusion.
â€¢ For RUDP, you will run it 5 times for each scenario.
â€¢ For both TCP and RUDP, you will run them on those scenarios of packet loss:
o 0% packet loss â€“ Control group, simulating perfect connection.
o 2% packet loss â€“ Simulating unstable connection that commonly occur.
o 5% packet loss â€“ Simulating bad connection.
o 10% packet loss â€“ Simulating extremely poor connection.
For each scenario, you must provide a filtered PCAP file and relevant screenshots that
explain each one of the steps in the process. (10 points)
After youâ€™ve gathered the data set for both TCP and Reliable UDP, answer the following
questions:
1) In TCP, which congestion control algorithm gave better results overall? TCP Reno or
TCP Cubic? Which one gave better results on high packet loss? Explain how you came
to this conclusion based on the data set youâ€™ve gathered. (5 points)
2) How did your implementation of Reliable UDP perform overall compared to regular
TCP? Which one is better for high packet loss? (5 points)
3) According to the data youâ€™ve gathered, in which scenarios and applications would we
prefer to use TCP and in which situations would we prefer to use reliable UDP?
Explain your answer. (5 points)
 Communication Networks Course
Page | 8
×¢× ×• ×¢×œ ×”×©××œ×•×ª ×”×‘××•×ª )5 × ×§×•×“×•×ª(:
â— ×‘"×¨×©×ª ×××™× ×”" ×”×›×•×•× ×” ×”×™× ×œ×¨×©×ª ×©×‘×” ××¢×˜ ×××•×“ ×—×‘×™×œ×•×ª ×”×•×œ×›×•×ª ×œ××™×‘×•×“. ×‘"×§×©×¨ ××¨×•×š" ×”×›×•×•× ×” ×”×™×
×œ×§×©×¨ TCP ×©×™×© ×‘×• ×”×¨×‘×” ×××•×“ ××™×“×¢ ×œ×©×œ×•×—. ××•×¦×¢ ×œ×”×’×“×™×œ ×‘ -TCP ××ª SSThreshold ×‘×ª×—×™×œ×ª ×”×§×©×¨.
×‘××™×–×” ××”××§×¨×™× ×”×‘××™× ×”×©×™× ×•×™ ×”×–×” ×¢×©×•×™ ×œ×”×•×¢×™×œ ×‘××™×“×” ×”××™×¨×‘×™×ª? × ××§.
.1 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
.2 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.3 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.4 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.5 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.6 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.7 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.8 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
â— A ×©×•×œ×— ×œ -B ×—×‘×™×œ×•×ª ××™×“×¢ ×‘×××¦×¢×•×ª ×§×©×¨ TCP. × ×ª×•×Ÿ ×›×™ ×”×§×©×¨ ××ª×—×™×œ ×¢× ×—×œ×•×Ÿ ×‘×’×•×“×œ 1MSS. ×”×§×©×¨
××¡×ª×™×™× ×‘×¤×¢× ×”×¨××©×•× ×” ×©×”×•× ××’×™×¢ ×œ -SSthresh. ×‘××”×œ×š ×”×§×©×¨ ×œ× ××•×‘×“×•×ª ×—×‘×™×œ×•×ª. × ×¡××Ÿ ×‘×§×™×¦×•×¨:
.SSthresh=S*MSS
× ×ª×•×Ÿ ×›×™ ×œ××•×¨×š ×›×œ ×”×§×©×¨ rwnd < MSS*S.
××”×™ ×”×ª×¤×•×§×” ×©×œ ×”×§×©×¨ ×-A ×œ-B( ×‘ -sec / Bytes )×‘×–××Ÿ ×”× "×œ? × ××§×™.
]S*MSS / [lg (S) * RTT*2 ×‘×¢×¨×š .1
]S*MSS / [S^0.5 * RTT*2 ×‘×¢×¨×š .2
S*MSS / RTT ×‘×¢×¨×š .3
S^2)*MSS / RTT( ×‘×¢×¨×š .4
â— ×©×ª×™ ×ª×—× ×•×ª ××ª×§×©×¨×•×ª ×‘××•×¤×Ÿ ××œ×—×•×˜×™ ×‘×©×™×˜×ª N Back Go.
× ×¡××Ÿ ×‘-X ××ª ×¡×¤×¨×ª ×”×‘×™×§×•×¨×ª ×©×œ ×”×ª.×–. ×©×œ×š. ×× ×©× ×™ ×©×•×ª×¤×™× ××’×™×©×™× ××ª ×”×ª×¨×’×™×œ ×™×—×“, X ×”×•× ×¡×¤×¨×ª
×”×‘×™×§×•×¨×ª ×‘×¢×œ×ª ×”×¢×¨×š ×”× ××•×š ×™×•×ª×¨ ××‘×™×Ÿ ×”×©×ª×™×™×.
×§×¦×‘ ×”×ª×§×©×•×¨×ª ×”×•× 8Gbps, ×•×’×•×“×œ ×›×œ ×—×‘×™×œ×” ×”×•× KByte*X. ×’×“×œ×™ ×”-headers ×•×” -Acks ×–× ×™×—×™×.
ï¿½ğ‘’ğ‘ ï¿½/ï¿½ï¿½ 8 , ×•×”××¨×—×§ ×‘×™×Ÿ ×”×ª×—× ×•×ª ×”×•× 1Km. ×§×¦×‘ ×”×”×ª×¤×©×˜×•×ª ×”×•× 10 â‹… 2
×–××Ÿ ×¢×™×‘×•×“ ×”× ×ª×•× ×™× ×‘×ª×—× ×•×ª ×–× ×™×—.
××£ ×—×‘×™×œ×” ×•××£ Ack ×œ× ×”×•×œ×›×™× ×œ××™×‘×•×“.
â— ××”×• X ×©×œ×š?
â— ××” ×¦×¨×™×š ×œ×”×™×•×ª ×’×•×“×œ ×—×œ×•×Ÿ ×”××©×œ×•×— ×›×“×™ ×œ×”×‘×˜×™×— ×ª×¤×•×§×” ××§×¡×™××œ×™×ª?
 Communication Networks Course
Page | 9
Bonus â€“ Improving the Reliable UDP â€“ 15 points
Note: This part isnâ€™t mandatory and is a bonus only!
In this part, youâ€™ll improve your RUDP implementation by adding the concepts of flow
control and congestion control from TCP. Youâ€™re free to choose which algorithms to
implement, as long as you explain in your PDF which algorithms youâ€™ve used. Youâ€™ll probably
need to make changes in the original design of the RUDP. Changes only need to be to the API
itself, ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„.
Points distribution:
â€¢ Flow control improvement â€“ 7 Points
â€¢ Congestion control improvement â€“ 8 points.
Guidance:
â€¢ For flow control, you must use one of the Sliding window techniques: stop-and-wait
ARQ, Go-Back-N or Selective repeat.
â€¢ List of known TCP congestion control algorithms, which you can use any one of them
for this bonus task, or makeup your own:
Figure 2 â€“ List of known TCP congestion control algorithms, Wikipedia
 Communication Networks Course
Page | 10
Appendix A â€“ Linux local packet loss tool
To simulate a packet loss in a local network, we'll use a Linux tool that's called Linux Traffic
Control (ğ‘¡ğ‘). This requires a full Linux installation, so working with WSL won't work.
If the tool isn't installed in your machine, you can install it by using the following commands:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’
If the installation didn't work, you can use the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’2
To create a packet loss scenario, type the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘ğ‘‘ğ‘‘ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
After creating a packet loss scenario, you can change the percentage by typing the following
command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘â„ğ‘ğ‘›ğ‘”ğ‘’ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
To remove the packet loss scenario, write the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘‘ğ‘’ğ‘™ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š
 Communication Networks Course
Page | 11
Appendix B â€“ ğ’ğ’‚ğ’(ğŸ) system calls
This appendixâ€™s purpose is to give you a better understanding of socket handling in C.
A recommended reference is Beejâ€™s Guide to Network Programming, by Brian â€œBeej
Jorgensenâ€ Hall, which gives a lot of information about sockets in C and functions.
Functions and documentation links:
â€¢ ğ’”ğ’ğ’„ğ’Œğ’†ğ’•(ğŸ) â€“ A Factory method system call that creates a socket with the given
parameters.
â€¢ ğ’ƒğ’Šğ’ğ’…(ğŸ) â€“ Whenever we create a new socket, we need to bind it to a specific port in
our machine, â€œto catch a portâ€. The port number is managed and used by the kernel
to link incoming packets to the corresponding application socket. The port numbers
are usually fixed. The ğ‘ğ‘‘ğ‘‘ğ‘Ÿ parameter must match the current socket that is used.
â€¢ ğ’ğ’Šğ’”ğ’•ğ’†ğ’(ğŸ) â€“ The ğ‘™ğ‘–ğ‘ ğ‘¡ğ‘’ğ‘›(2) system call doesn't do anything in the mean of
communication but only memory allocation (malloc) for stream sockets only. If we
won't allocate memory, any incoming connection will fail.
â€¢ ğ’„ğ’ğ’ğ’ğ’†ğ’„ğ’•(ğŸ) â€“ The ğ‘ğ‘œğ‘›ğ‘›ğ‘’ğ‘ğ‘¡(2) system call starts the link between a client and a
specific IP address and port number. The connection would complete when the
other side will call the ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call.
â€¢ ğ’‚ğ’„ğ’„ğ’†ğ’‘ğ’•(ğŸ) â€“ The ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call accepts the incoming stream connection
request from the other side, by the listening socket. This system call completes the
three-way handshake of stream socket (like TCP) and opens a new socket that has a
direct communication channel only with the other party in the handshake.
â€¢ ğ’”ğ’†ğ’ğ’…(ğŸ) and ğ’”ğ’†ğ’ğ’…ğ’•ğ’(ğŸ) â€“ The ğ‘ ğ‘’ğ‘›ğ‘‘(2) and ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system calls are an analogy
for the ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’(2) system call, specifcly for sockets, with flags set to 0. Those system
calls return the number of bytes that were sent through the socket itself, as the
number of bytes can vary. The ğ‘ ğ‘’ğ‘›ğ‘‘(2)system call designed for stream sockets (like
TCP), while the ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system call designed for datagram connection-less
sockets (like UDP). When the ğ‘ ğ‘’ğ‘›ğ‘‘(2) system call returns 0, it means that the other
party closed the connection.
â€¢ ğ’“ğ’†ğ’„ğ’—(ğŸ) and ğ’“ğ’†ğ’„ğ’—ğ’‡ğ’“ğ’ğ’(ğŸ) â€“ The ğ‘Ÿğ‘’ğ‘ğ‘£(2) and ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system calls are an
analogy for the ğ‘Ÿğ‘’ğ‘ğ‘‘(2) system call, specifically for sockets, with flags set to 0.
Those system calls return the number of bytes that were received through the socket
itself, as the number of bytes can vary. The ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call designed for stream
sockets (like TCP), while the ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system call designed for datagram
connection-less sockets (like UDP). When the ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call returns 0, it means
that the other party closed the connection.
â€¢ ğ’„ğ’ğ’ğ’”ğ’†(ğŸ) and ğ’”ğ’‰ğ’–ğ’•ğ’…ğ’ğ’˜ğ’(ğŸ) â€“ The ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) and ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2) system calls close
the socket. While ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) system call closes the whole socket, the ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2)
system call partially closes the socket for read/write.
 Communication Networks Course
Page | 12
Appendix C â€“ Random data generator
The data that you are going to send in this assignment is randomly generated. You can use
your own file with appropriate size or use the following function (or a function of your own)
to generate the data:
/*
* @brief A random data generator function based on srand() and rand().
* @param size The size of the data to generate (up to 2^32 bytes).
* @return A pointer to the buffer.
*/
char *util_generate_random_data(unsigned int size) {
 char *buffer = NULL;
 // Argument check.
 if (size == 0)
 return NULL;
 buffer = (char *)calloc(size, sizeof(char));
 // Error checking.
 if (buffer == NULL)
 return NULL;
 // Randomize the seed of the random number generator.
 srand(time(NULL));
 for (unsigned int i = 0; i < size; i++)
 *(buffer + i) = ((unsigned int)rand() % 256);
 return buffer;
}
 Communication Networks Course
Page | 13
Appendix D â€“ Checksum function
A checksum is a small-sized block of data derived from another block of digital data for the
purpose of detecting errors that may have been introduced during its transmission or
storage. By themselves, checksums are often used to verify data integrity but are not relied
upon to verify data authenticity.
Below is a simple yet efficient implementation of the checksum function, you can use it for
the assignment, but you can implement your own checksum function.
/*
* @brief A checksum function that returns 16 bit checksum for data.
* @param data The data to do the checksum for.
* @param bytes The length of the data in bytes.
* @return The checksum itself as 16 bit unsigned number.
* @note This function is taken from RFC1071, can be found here:
* @note https://tools.ietf.org/html/rfc1071
* @note It is the simplest way to calculate a checksum and is not very strong.
* However, it is good enough for this assignment.
* @note You are free to use any other checksum function as well.
* You can also use this function as such without any change.
*/
unsigned short int calculate_checksum(void *data, unsigned int bytes) {
 unsigned short int *data_pointer = (unsigned short int *)data;
 unsigned int total_sum = 0;
 // Main summing loop
 while (bytes > 1) {
 total_sum += *data_pointer++;
 bytes -= 2;
 }
 // Add left-over byte, if any
 if (bytes > 0)
 total_sum += *((unsigned char *)data_pointer);
 // Fold 32-bit sum to 16 bits
 while (total_sum >> 16)
 total_sum = (total_sum & 0xFFFF) + (total_sum >> 16);
 return (~((unsigned short int)total_sum));
} Communication Networks Course
Page | 1
Assignment 3 â€“ Transport Layer
Assignment Notes and Instructions
This assignment is to be done in pairs only. You must upload all the necessary files in a ZIP
file named after both of the studentâ€™s ID. For example: ğŸğŸğŸ‘ğŸ’ğŸ“ğŸ”ğŸ•ğŸ–ğŸ—_ğŸ—ğŸ–ğŸ•ğŸ”ğŸ“ğŸ’ğŸ‘ğŸğŸ. ğ’›ğ’Šğ’‘.
1) The assignment must be submitted by the date specified in the submission box.
2) All the assignment files (Code, Wireshark pcap files, PDF) must be submitted in a ZIP file. The
PDF must contain all the necessary screenshots with a description for each one of them.
3) The assignment must be done in pairs only. In exceptional cases, you should send an email to
the course coordinator.
4) You can use any reference material available through the course Moodle website or any
material passed during the exercises.
5) You can use any reference from the web, but copying codes from websites is forbidden; this
includes codes from other GitHub repositories. A student who gets caught in the act will
automatically fail this assignment (score 0). Any website youâ€™ve used to solve the
assignment, every website you used to solve the assignment must be noted in the PDF.
6) No delays in submission without special permission. Lateness without approval will result in
failure of the assignment (score 0).
7) All submissions will be submitted via the course's Moodle website. Email submissions will not
be accepted, resulting in a failure in the assignment.
8) The order and design of the code must be carefully considered. Make sure that the program
output is as clear as possible, comments in the code, and meaningful variable names. You
must also submit a makefile that compiles all the programs.
9) The assignment code must be written in C only.
10) The assignment is personal for each pair, and you should not accept help from other people,
whether outside the university or inside it. You can contact the course staff during reception
hours for help or raise a question in the course forum. Do not transfer code sections
between students, upload solutions or parts of solutions to websites on the Internet or in
various communication groups.
11) Students who copy a solution will receive a 0 in all assignments in the course and a report will
be made to the institutional disciplinary committee.
12) All code files of the assignment are required to both compile and run properly on the Ubuntu
22.04 LTS operating system. This is the operating system where the submissions will be
tested. You mustnâ€™t code it in Windows, as it uses different API for sockets. WSL wonâ€™t work,
as the task needs a tool that works only in a fully Linux environment.
Good Luck!
 Communication Networks Course
Page | 2
Part A â€“ Transmission Control Protocol (TCP) â€“ 30 points
In this part, youâ€™ll write two program files: ğ‘»ğ‘ªğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and ğ‘»ğ‘ªğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
The Sender will send a randomly generated file and the Receiver will receive it and measure
the time it took for his program to receive the file. The file size should be at least 2MB.
When running the Sender and Receiver, they both should support two standard congestion
control algorithms: TCP Reno and TCP Cubic.
Notes:
â€¢ The main goal of this part is to get familiar with the TCP concept of sending
messages between two endpoints.
â€¢ For approaching this part of the assignment, please be sure that you are familiar
with the congestion control algorithms and how to change them using the correct
method in C (see Appendix B for more information).
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). You've
learned that TCP is reliable by design, so you can assume that all the data have been
passed correctly, and thus, no need to recheck.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
Usage:
â€¢ Receiver:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
â€¢ Sender:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port of the Receiver.
â€¢ ğ‘¨ğ‘³ğ‘®ğ‘¶ â€“ The TCP congestion control algorithm that will be used by the party
member (either ğ’“ğ’†ğ’ğ’ for TCP Reno or ğ’„ğ’–ğ’ƒğ’Šğ’„ for TCP Cubic).
 Communication Networks Course
Page | 3
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a TCP socket between the Sender and the
Receiver.
3) Send the file.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a TCP connection between the Receiver and
the Sender.
2) Get a connection from the sender.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./TCP_Receiver -p 1234 -algo reno
Starting Receiver...
Waiting for TCP connection...
Sender connected, beginning to receive file...
File transfer completed.
Waiting for Sender response...
Sender sent exit message.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 4
Part B â€“ Reliable User Datagram Protocol (Reliable UDP or RUDP) â€“ 40 points
Youâ€™ve learned that while TCP is reliable, it lacks speed and has an overhead data of 20 bytes,
compering to UDP that needs only 8 bytes of overhead data.
Reliable UDP or RUDP, is a protocol that uses the UDP protocol for a faster transmission of
data, while adding a reliability layer to it, but without adding too much overhead data like
TCP.
A simple sketch for a RUDP connection would look something like this:
Your task in this part is to implement a Reliable protocol using UDP only. For simplicity, your
implementation should only support a handshake, closing scheme, error checking,
acknowledgment of received packets, and retransmission of lost packets.
Guidance:
â€¢ You can use ğ‘ ğ‘’ğ‘¡ğ‘ ğ‘œğ‘ğ‘˜ğ‘œğ‘ğ‘¡(2) for detecting a timeout.
â€¢ You need to build your own protocol, as Reliable UDP isnâ€™t a standard protocol (see a
draft of RUDP in this link), and no official header is provided. You can use this sketch
for a header, but you can come up with your own protocol, as long as it works.
Where:
o ğ‘³ğ’†ğ’ğ’ˆğ’•ğ’‰ is the length of the data itself, without the RUDP header.
o ğ‘ªğ’‰ğ’†ğ’„ğ’Œğ’”ğ’–ğ’ is a 16bit number that validates the correctness of the data.
o ğ‘­ğ’ğ’‚ğ’ˆğ’” is a special byte where we classify the packet itself (SYN, ACK, etc.).
â€¢ In your PDF, you must explain how your implementation of RUDP works â€“ How does
it detect a timeout to do retransmissions, how does the handshake work, what is the
header overhead, etc.
â€¢ For this part, youâ€™ll write three files: ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¨ğ‘·ğ‘°. ğ’„, ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and
ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
Reliable UDP Header proposed sketch
Byte 0 Byte 1 Byte 2 Byte 3
Length (2 Bytes) Checksum (2 Bytes)
Flags (1 Byte)
Figure 1 - RUDP Protocol Architecture, Geeksforgeeks
 Communication Networks Course
Page | 5
Notes:
â€¢ The Sender will send a random generated file and the Receiver will receive it and
measure the time it took for his program to receive the file. The file size should be at
least 2MB.
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). But, as the
RUDP is based on UDP, itâ€™s not reliable. You must use some form of error checking
(like checksum) to ensure that the packet wasnâ€™t alerted during the transfer.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
â€¢ The RUDP needs support only 1 sender and 1 receiver, for simplicity purposes.
Usage:
â€¢ Receiver:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
â€¢ Sender:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port that both the Sender and the Receiver will use.
The ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„ file will contain all the implementations of the RUDP API functions (That is, to
prevent reusing the same chuck of code both in the Sender and the Receiver.).
The API should support at the bare minimum the following functions (you decide what
parameters to implement, and what are the names of the functions, as long as the API is
explained in the PDF):
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘œğ‘ğ‘˜ğ‘’ğ‘¡() â€“ Creating a RUDP socket and creating a handshake between two
peers.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘’ğ‘›ğ‘‘() â€“ Sending data to the peer. The function should wait for an
acknowledgment packet, and if it didnâ€™t receive any, retransmits the data.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘Ÿğ‘’ğ‘ğ‘£() â€“ Receive data from a peer.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ğ‘™ğ‘œğ‘ ğ‘’() â€“ Closes a connection between peers.
 Communication Networks Course
Page | 6
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a UDP socket between the Sender and the
Receiver.
3) Send the file via the RUDP protocol.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a UDP connection between the Receiver and
the Sender.
2) Get a connection from the sender, by the custom
RUDP protocol youâ€™ve built.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./RUDP_Receiver -p 1234
Starting Receiver...
Waiting for RUDP connection...
Connection request received, sending ACK.
Sender connected, beginning to receive file...
File transfer completed.
ACK sent.
Waiting for Sender response...
Sender sent exit message.
ACK sent.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 7
Part C â€“ Research â€“ 30 points
In this part, youâ€™ll conduct research about your implementations of part A and part B.
In the research itself, each one of the versions (TCP version and UDP version) will be run at
least 5 times (meaning that the file transfer will occur at least 5 times) by the following
conditions:
â€¢ For TCP, youâ€™ll run it in TCP Reno and TCP Cubic, alternating each time, for each
scenario, meaning that you run 5 times with TCP Reno in both Sender and Receiver,
and 5 times with TCP Cubic in both Sender and Receiver.
Bonus (5 points): Create a very large data set â€“ 5 times with TCP Reno in both Sender
and Receiver, 5 times with TCP Reno in Sender and TCP Cubic in Receiver, 5 times
with TCP Cubic in Sender and TCP Reno in Receiver, and 5 times with TCP Cubic in
both Sender and Receiver. This will give you a data set large enough, which allows
you to work with, compare with and to reach a definite conclusion.
â€¢ For RUDP, you will run it 5 times for each scenario.
â€¢ For both TCP and RUDP, you will run them on those scenarios of packet loss:
o 0% packet loss â€“ Control group, simulating perfect connection.
o 2% packet loss â€“ Simulating unstable connection that commonly occur.
o 5% packet loss â€“ Simulating bad connection.
o 10% packet loss â€“ Simulating extremely poor connection.
For each scenario, you must provide a filtered PCAP file and relevant screenshots that
explain each one of the steps in the process. (10 points)
After youâ€™ve gathered the data set for both TCP and Reliable UDP, answer the following
questions:
1) In TCP, which congestion control algorithm gave better results overall? TCP Reno or
TCP Cubic? Which one gave better results on high packet loss? Explain how you came
to this conclusion based on the data set youâ€™ve gathered. (5 points)
2) How did your implementation of Reliable UDP perform overall compared to regular
TCP? Which one is better for high packet loss? (5 points)
3) According to the data youâ€™ve gathered, in which scenarios and applications would we
prefer to use TCP and in which situations would we prefer to use reliable UDP?
Explain your answer. (5 points)
 Communication Networks Course
Page | 8
×¢× ×• ×¢×œ ×”×©××œ×•×ª ×”×‘××•×ª )5 × ×§×•×“×•×ª(:
â— ×‘"×¨×©×ª ×××™× ×”" ×”×›×•×•× ×” ×”×™× ×œ×¨×©×ª ×©×‘×” ××¢×˜ ×××•×“ ×—×‘×™×œ×•×ª ×”×•×œ×›×•×ª ×œ××™×‘×•×“. ×‘"×§×©×¨ ××¨×•×š" ×”×›×•×•× ×” ×”×™×
×œ×§×©×¨ TCP ×©×™×© ×‘×• ×”×¨×‘×” ×××•×“ ××™×“×¢ ×œ×©×œ×•×—. ××•×¦×¢ ×œ×”×’×“×™×œ ×‘ -TCP ××ª SSThreshold ×‘×ª×—×™×œ×ª ×”×§×©×¨.
×‘××™×–×” ××”××§×¨×™× ×”×‘××™× ×”×©×™× ×•×™ ×”×–×” ×¢×©×•×™ ×œ×”×•×¢×™×œ ×‘××™×“×” ×”××™×¨×‘×™×ª? × ××§.
.1 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
.2 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.3 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.4 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.5 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.6 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.7 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.8 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
â— A ×©×•×œ×— ×œ -B ×—×‘×™×œ×•×ª ××™×“×¢ ×‘×××¦×¢×•×ª ×§×©×¨ TCP. × ×ª×•×Ÿ ×›×™ ×”×§×©×¨ ××ª×—×™×œ ×¢× ×—×œ×•×Ÿ ×‘×’×•×“×œ 1MSS. ×”×§×©×¨
××¡×ª×™×™× ×‘×¤×¢× ×”×¨××©×•× ×” ×©×”×•× ××’×™×¢ ×œ -SSthresh. ×‘××”×œ×š ×”×§×©×¨ ×œ× ××•×‘×“×•×ª ×—×‘×™×œ×•×ª. × ×¡××Ÿ ×‘×§×™×¦×•×¨:
.SSthresh=S*MSS
× ×ª×•×Ÿ ×›×™ ×œ××•×¨×š ×›×œ ×”×§×©×¨ rwnd < MSS*S.
××”×™ ×”×ª×¤×•×§×” ×©×œ ×”×§×©×¨ ×-A ×œ-B( ×‘ -sec / Bytes )×‘×–××Ÿ ×”× "×œ? × ××§×™.
]S*MSS / [lg (S) * RTT*2 ×‘×¢×¨×š .1
]S*MSS / [S^0.5 * RTT*2 ×‘×¢×¨×š .2
S*MSS / RTT ×‘×¢×¨×š .3
S^2)*MSS / RTT( ×‘×¢×¨×š .4
â— ×©×ª×™ ×ª×—× ×•×ª ××ª×§×©×¨×•×ª ×‘××•×¤×Ÿ ××œ×—×•×˜×™ ×‘×©×™×˜×ª N Back Go.
× ×¡××Ÿ ×‘-X ××ª ×¡×¤×¨×ª ×”×‘×™×§×•×¨×ª ×©×œ ×”×ª.×–. ×©×œ×š. ×× ×©× ×™ ×©×•×ª×¤×™× ××’×™×©×™× ××ª ×”×ª×¨×’×™×œ ×™×—×“, X ×”×•× ×¡×¤×¨×ª
×”×‘×™×§×•×¨×ª ×‘×¢×œ×ª ×”×¢×¨×š ×”× ××•×š ×™×•×ª×¨ ××‘×™×Ÿ ×”×©×ª×™×™×.
×§×¦×‘ ×”×ª×§×©×•×¨×ª ×”×•× 8Gbps, ×•×’×•×“×œ ×›×œ ×—×‘×™×œ×” ×”×•× KByte*X. ×’×“×œ×™ ×”-headers ×•×” -Acks ×–× ×™×—×™×.
ï¿½ğ‘’ğ‘ ï¿½/ï¿½ï¿½ 8 , ×•×”××¨×—×§ ×‘×™×Ÿ ×”×ª×—× ×•×ª ×”×•× 1Km. ×§×¦×‘ ×”×”×ª×¤×©×˜×•×ª ×”×•× 10 â‹… 2
×–××Ÿ ×¢×™×‘×•×“ ×”× ×ª×•× ×™× ×‘×ª×—× ×•×ª ×–× ×™×—.
××£ ×—×‘×™×œ×” ×•××£ Ack ×œ× ×”×•×œ×›×™× ×œ××™×‘×•×“.
â— ××”×• X ×©×œ×š?
â— ××” ×¦×¨×™×š ×œ×”×™×•×ª ×’×•×“×œ ×—×œ×•×Ÿ ×”××©×œ×•×— ×›×“×™ ×œ×”×‘×˜×™×— ×ª×¤×•×§×” ××§×¡×™××œ×™×ª?
 Communication Networks Course
Page | 9
Bonus â€“ Improving the Reliable UDP â€“ 15 points
Note: This part isnâ€™t mandatory and is a bonus only!
In this part, youâ€™ll improve your RUDP implementation by adding the concepts of flow
control and congestion control from TCP. Youâ€™re free to choose which algorithms to
implement, as long as you explain in your PDF which algorithms youâ€™ve used. Youâ€™ll probably
need to make changes in the original design of the RUDP. Changes only need to be to the API
itself, ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„.
Points distribution:
â€¢ Flow control improvement â€“ 7 Points
â€¢ Congestion control improvement â€“ 8 points.
Guidance:
â€¢ For flow control, you must use one of the Sliding window techniques: stop-and-wait
ARQ, Go-Back-N or Selective repeat.
â€¢ List of known TCP congestion control algorithms, which you can use any one of them
for this bonus task, or makeup your own:
Figure 2 â€“ List of known TCP congestion control algorithms, Wikipedia
 Communication Networks Course
Page | 10
Appendix A â€“ Linux local packet loss tool
To simulate a packet loss in a local network, we'll use a Linux tool that's called Linux Traffic
Control (ğ‘¡ğ‘). This requires a full Linux installation, so working with WSL won't work.
If the tool isn't installed in your machine, you can install it by using the following commands:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’
If the installation didn't work, you can use the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’2
To create a packet loss scenario, type the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘ğ‘‘ğ‘‘ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
After creating a packet loss scenario, you can change the percentage by typing the following
command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘â„ğ‘ğ‘›ğ‘”ğ‘’ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
To remove the packet loss scenario, write the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘‘ğ‘’ğ‘™ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š
 Communication Networks Course
Page | 11
Appendix B â€“ ğ’ğ’‚ğ’(ğŸ) system calls
This appendixâ€™s purpose is to give you a better understanding of socket handling in C.
A recommended reference is Beejâ€™s Guide to Network Programming, by Brian â€œBeej
Jorgensenâ€ Hall, which gives a lot of information about sockets in C and functions.
Functions and documentation links:
â€¢ ğ’”ğ’ğ’„ğ’Œğ’†ğ’•(ğŸ) â€“ A Factory method system call that creates a socket with the given
parameters.
â€¢ ğ’ƒğ’Šğ’ğ’…(ğŸ) â€“ Whenever we create a new socket, we need to bind it to a specific port in
our machine, â€œto catch a portâ€. The port number is managed and used by the kernel
to link incoming packets to the corresponding application socket. The port numbers
are usually fixed. The ğ‘ğ‘‘ğ‘‘ğ‘Ÿ parameter must match the current socket that is used.
â€¢ ğ’ğ’Šğ’”ğ’•ğ’†ğ’(ğŸ) â€“ The ğ‘™ğ‘–ğ‘ ğ‘¡ğ‘’ğ‘›(2) system call doesn't do anything in the mean of
communication but only memory allocation (malloc) for stream sockets only. If we
won't allocate memory, any incoming connection will fail.
â€¢ ğ’„ğ’ğ’ğ’ğ’†ğ’„ğ’•(ğŸ) â€“ The ğ‘ğ‘œğ‘›ğ‘›ğ‘’ğ‘ğ‘¡(2) system call starts the link between a client and a
specific IP address and port number. The connection would complete when the
other side will call the ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call.
â€¢ ğ’‚ğ’„ğ’„ğ’†ğ’‘ğ’•(ğŸ) â€“ The ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call accepts the incoming stream connection
request from the other side, by the listening socket. This system call completes the
three-way handshake of stream socket (like TCP) and opens a new socket that has a
direct communication channel only with the other party in the handshake.
â€¢ ğ’”ğ’†ğ’ğ’…(ğŸ) and ğ’”ğ’†ğ’ğ’…ğ’•ğ’(ğŸ) â€“ The ğ‘ ğ‘’ğ‘›ğ‘‘(2) and ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system calls are an analogy
for the ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’(2) system call, specifcly for sockets, with flags set to 0. Those system
calls return the number of bytes that were sent through the socket itself, as the
number of bytes can vary. The ğ‘ ğ‘’ğ‘›ğ‘‘(2)system call designed for stream sockets (like
TCP), while the ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system call designed for datagram connection-less
sockets (like UDP). When the ğ‘ ğ‘’ğ‘›ğ‘‘(2) system call returns 0, it means that the other
party closed the connection.
â€¢ ğ’“ğ’†ğ’„ğ’—(ğŸ) and ğ’“ğ’†ğ’„ğ’—ğ’‡ğ’“ğ’ğ’(ğŸ) â€“ The ğ‘Ÿğ‘’ğ‘ğ‘£(2) and ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system calls are an
analogy for the ğ‘Ÿğ‘’ğ‘ğ‘‘(2) system call, specifically for sockets, with flags set to 0.
Those system calls return the number of bytes that were received through the socket
itself, as the number of bytes can vary. The ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call designed for stream
sockets (like TCP), while the ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system call designed for datagram
connection-less sockets (like UDP). When the ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call returns 0, it means
that the other party closed the connection.
â€¢ ğ’„ğ’ğ’ğ’”ğ’†(ğŸ) and ğ’”ğ’‰ğ’–ğ’•ğ’…ğ’ğ’˜ğ’(ğŸ) â€“ The ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) and ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2) system calls close
the socket. While ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) system call closes the whole socket, the ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2)
system call partially closes the socket for read/write.
 Communication Networks Course
Page | 12
Appendix C â€“ Random data generator
The data that you are going to send in this assignment is randomly generated. You can use
your own file with appropriate size or use the following function (or a function of your own)
to generate the data:
/*
* @brief A random data generator function based on srand() and rand().
* @param size The size of the data to generate (up to 2^32 bytes).
* @return A pointer to the buffer.
*/
char *util_generate_random_data(unsigned int size) {
 char *buffer = NULL;
 // Argument check.
 if (size == 0)
 return NULL;
 buffer = (char *)calloc(size, sizeof(char));
 // Error checking.
 if (buffer == NULL)
 return NULL;
 // Randomize the seed of the random number generator.
 srand(time(NULL));
 for (unsigned int i = 0; i < size; i++)
 *(buffer + i) = ((unsigned int)rand() % 256);
 return buffer;
}
 Communication Networks Course
Page | 13
Appendix D â€“ Checksum function
A checksum is a small-sized block of data derived from another block of digital data for the
purpose of detecting errors that may have been introduced during its transmission or
storage. By themselves, checksums are often used to verify data integrity but are not relied
upon to verify data authenticity.
Below is a simple yet efficient implementation of the checksum function, you can use it for
the assignment, but you can implement your own checksum function.
/*
* @brief A checksum function that returns 16 bit checksum for data.
* @param data The data to do the checksum for.
* @param bytes The length of the data in bytes.
* @return The checksum itself as 16 bit unsigned number.
* @note This function is taken from RFC1071, can be found here:
* @note https://tools.ietf.org/html/rfc1071
* @note It is the simplest way to calculate a checksum and is not very strong.
* However, it is good enough for this assignment.
* @note You are free to use any other checksum function as well.
* You can also use this function as such without any change.
*/
unsigned short int calculate_checksum(void *data, unsigned int bytes) {
 unsigned short int *data_pointer = (unsigned short int *)data;
 unsigned int total_sum = 0;
 // Main summing loop
 while (bytes > 1) {
 total_sum += *data_pointer++;
 bytes -= 2;
 }
 // Add left-over byte, if any
 if (bytes > 0)
 total_sum += *((unsigned char *)data_pointer);
 // Fold 32-bit sum to 16 bits
 while (total_sum >> 16)
 total_sum = (total_sum & 0xFFFF) + (total_sum >> 16);
 return (~((unsigned short int)total_sum));
} Communication Networks Course
Page | 1
Assignment 3 â€“ Transport Layer
Assignment Notes and Instructions
This assignment is to be done in pairs only. You must upload all the necessary files in a ZIP
file named after both of the studentâ€™s ID. For example: ğŸğŸğŸ‘ğŸ’ğŸ“ğŸ”ğŸ•ğŸ–ğŸ—_ğŸ—ğŸ–ğŸ•ğŸ”ğŸ“ğŸ’ğŸ‘ğŸğŸ. ğ’›ğ’Šğ’‘.
1) The assignment must be submitted by the date specified in the submission box.
2) All the assignment files (Code, Wireshark pcap files, PDF) must be submitted in a ZIP file. The
PDF must contain all the necessary screenshots with a description for each one of them.
3) The assignment must be done in pairs only. In exceptional cases, you should send an email to
the course coordinator.
4) You can use any reference material available through the course Moodle website or any
material passed during the exercises.
5) You can use any reference from the web, but copying codes from websites is forbidden; this
includes codes from other GitHub repositories. A student who gets caught in the act will
automatically fail this assignment (score 0). Any website youâ€™ve used to solve the
assignment, every website you used to solve the assignment must be noted in the PDF.
6) No delays in submission without special permission. Lateness without approval will result in
failure of the assignment (score 0).
7) All submissions will be submitted via the course's Moodle website. Email submissions will not
be accepted, resulting in a failure in the assignment.
8) The order and design of the code must be carefully considered. Make sure that the program
output is as clear as possible, comments in the code, and meaningful variable names. You
must also submit a makefile that compiles all the programs.
9) The assignment code must be written in C only.
10) The assignment is personal for each pair, and you should not accept help from other people,
whether outside the university or inside it. You can contact the course staff during reception
hours for help or raise a question in the course forum. Do not transfer code sections
between students, upload solutions or parts of solutions to websites on the Internet or in
various communication groups.
11) Students who copy a solution will receive a 0 in all assignments in the course and a report will
be made to the institutional disciplinary committee.
12) All code files of the assignment are required to both compile and run properly on the Ubuntu
22.04 LTS operating system. This is the operating system where the submissions will be
tested. You mustnâ€™t code it in Windows, as it uses different API for sockets. WSL wonâ€™t work,
as the task needs a tool that works only in a fully Linux environment.
Good Luck!
 Communication Networks Course
Page | 2
Part A â€“ Transmission Control Protocol (TCP) â€“ 30 points
In this part, youâ€™ll write two program files: ğ‘»ğ‘ªğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and ğ‘»ğ‘ªğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
The Sender will send a randomly generated file and the Receiver will receive it and measure
the time it took for his program to receive the file. The file size should be at least 2MB.
When running the Sender and Receiver, they both should support two standard congestion
control algorithms: TCP Reno and TCP Cubic.
Notes:
â€¢ The main goal of this part is to get familiar with the TCP concept of sending
messages between two endpoints.
â€¢ For approaching this part of the assignment, please be sure that you are familiar
with the congestion control algorithms and how to change them using the correct
method in C (see Appendix B for more information).
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). You've
learned that TCP is reliable by design, so you can assume that all the data have been
passed correctly, and thus, no need to recheck.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
Usage:
â€¢ Receiver:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
â€¢ Sender:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port of the Receiver.
â€¢ ğ‘¨ğ‘³ğ‘®ğ‘¶ â€“ The TCP congestion control algorithm that will be used by the party
member (either ğ’“ğ’†ğ’ğ’ for TCP Reno or ğ’„ğ’–ğ’ƒğ’Šğ’„ for TCP Cubic).
 Communication Networks Course
Page | 3
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a TCP socket between the Sender and the
Receiver.
3) Send the file.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a TCP connection between the Receiver and
the Sender.
2) Get a connection from the sender.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./TCP_Receiver -p 1234 -algo reno
Starting Receiver...
Waiting for TCP connection...
Sender connected, beginning to receive file...
File transfer completed.
Waiting for Sender response...
Sender sent exit message.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 4
Part B â€“ Reliable User Datagram Protocol (Reliable UDP or RUDP) â€“ 40 points
Youâ€™ve learned that while TCP is reliable, it lacks speed and has an overhead data of 20 bytes,
compering to UDP that needs only 8 bytes of overhead data.
Reliable UDP or RUDP, is a protocol that uses the UDP protocol for a faster transmission of
data, while adding a reliability layer to it, but without adding too much overhead data like
TCP.
A simple sketch for a RUDP connection would look something like this:
Your task in this part is to implement a Reliable protocol using UDP only. For simplicity, your
implementation should only support a handshake, closing scheme, error checking,
acknowledgment of received packets, and retransmission of lost packets.
Guidance:
â€¢ You can use ğ‘ ğ‘’ğ‘¡ğ‘ ğ‘œğ‘ğ‘˜ğ‘œğ‘ğ‘¡(2) for detecting a timeout.
â€¢ You need to build your own protocol, as Reliable UDP isnâ€™t a standard protocol (see a
draft of RUDP in this link), and no official header is provided. You can use this sketch
for a header, but you can come up with your own protocol, as long as it works.
Where:
o ğ‘³ğ’†ğ’ğ’ˆğ’•ğ’‰ is the length of the data itself, without the RUDP header.
o ğ‘ªğ’‰ğ’†ğ’„ğ’Œğ’”ğ’–ğ’ is a 16bit number that validates the correctness of the data.
o ğ‘­ğ’ğ’‚ğ’ˆğ’” is a special byte where we classify the packet itself (SYN, ACK, etc.).
â€¢ In your PDF, you must explain how your implementation of RUDP works â€“ How does
it detect a timeout to do retransmissions, how does the handshake work, what is the
header overhead, etc.
â€¢ For this part, youâ€™ll write three files: ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¨ğ‘·ğ‘°. ğ’„, ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and
ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
Reliable UDP Header proposed sketch
Byte 0 Byte 1 Byte 2 Byte 3
Length (2 Bytes) Checksum (2 Bytes)
Flags (1 Byte)
Figure 1 - RUDP Protocol Architecture, Geeksforgeeks
 Communication Networks Course
Page | 5
Notes:
â€¢ The Sender will send a random generated file and the Receiver will receive it and
measure the time it took for his program to receive the file. The file size should be at
least 2MB.
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). But, as the
RUDP is based on UDP, itâ€™s not reliable. You must use some form of error checking
(like checksum) to ensure that the packet wasnâ€™t alerted during the transfer.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
â€¢ The RUDP needs support only 1 sender and 1 receiver, for simplicity purposes.
Usage:
â€¢ Receiver:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
â€¢ Sender:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port that both the Sender and the Receiver will use.
The ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„ file will contain all the implementations of the RUDP API functions (That is, to
prevent reusing the same chuck of code both in the Sender and the Receiver.).
The API should support at the bare minimum the following functions (you decide what
parameters to implement, and what are the names of the functions, as long as the API is
explained in the PDF):
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘œğ‘ğ‘˜ğ‘’ğ‘¡() â€“ Creating a RUDP socket and creating a handshake between two
peers.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘’ğ‘›ğ‘‘() â€“ Sending data to the peer. The function should wait for an
acknowledgment packet, and if it didnâ€™t receive any, retransmits the data.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘Ÿğ‘’ğ‘ğ‘£() â€“ Receive data from a peer.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ğ‘™ğ‘œğ‘ ğ‘’() â€“ Closes a connection between peers.
 Communication Networks Course
Page | 6
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a UDP socket between the Sender and the
Receiver.
3) Send the file via the RUDP protocol.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a UDP connection between the Receiver and
the Sender.
2) Get a connection from the sender, by the custom
RUDP protocol youâ€™ve built.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./RUDP_Receiver -p 1234
Starting Receiver...
Waiting for RUDP connection...
Connection request received, sending ACK.
Sender connected, beginning to receive file...
File transfer completed.
ACK sent.
Waiting for Sender response...
Sender sent exit message.
ACK sent.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 7
Part C â€“ Research â€“ 30 points
In this part, youâ€™ll conduct research about your implementations of part A and part B.
In the research itself, each one of the versions (TCP version and UDP version) will be run at
least 5 times (meaning that the file transfer will occur at least 5 times) by the following
conditions:
â€¢ For TCP, youâ€™ll run it in TCP Reno and TCP Cubic, alternating each time, for each
scenario, meaning that you run 5 times with TCP Reno in both Sender and Receiver,
and 5 times with TCP Cubic in both Sender and Receiver.
Bonus (5 points): Create a very large data set â€“ 5 times with TCP Reno in both Sender
and Receiver, 5 times with TCP Reno in Sender and TCP Cubic in Receiver, 5 times
with TCP Cubic in Sender and TCP Reno in Receiver, and 5 times with TCP Cubic in
both Sender and Receiver. This will give you a data set large enough, which allows
you to work with, compare with and to reach a definite conclusion.
â€¢ For RUDP, you will run it 5 times for each scenario.
â€¢ For both TCP and RUDP, you will run them on those scenarios of packet loss:
o 0% packet loss â€“ Control group, simulating perfect connection.
o 2% packet loss â€“ Simulating unstable connection that commonly occur.
o 5% packet loss â€“ Simulating bad connection.
o 10% packet loss â€“ Simulating extremely poor connection.
For each scenario, you must provide a filtered PCAP file and relevant screenshots that
explain each one of the steps in the process. (10 points)
After youâ€™ve gathered the data set for both TCP and Reliable UDP, answer the following
questions:
1) In TCP, which congestion control algorithm gave better results overall? TCP Reno or
TCP Cubic? Which one gave better results on high packet loss? Explain how you came
to this conclusion based on the data set youâ€™ve gathered. (5 points)
2) How did your implementation of Reliable UDP perform overall compared to regular
TCP? Which one is better for high packet loss? (5 points)
3) According to the data youâ€™ve gathered, in which scenarios and applications would we
prefer to use TCP and in which situations would we prefer to use reliable UDP?
Explain your answer. (5 points)
 Communication Networks Course
Page | 8
×¢× ×• ×¢×œ ×”×©××œ×•×ª ×”×‘××•×ª )5 × ×§×•×“×•×ª(:
â— ×‘"×¨×©×ª ×××™× ×”" ×”×›×•×•× ×” ×”×™× ×œ×¨×©×ª ×©×‘×” ××¢×˜ ×××•×“ ×—×‘×™×œ×•×ª ×”×•×œ×›×•×ª ×œ××™×‘×•×“. ×‘"×§×©×¨ ××¨×•×š" ×”×›×•×•× ×” ×”×™×
×œ×§×©×¨ TCP ×©×™×© ×‘×• ×”×¨×‘×” ×××•×“ ××™×“×¢ ×œ×©×œ×•×—. ××•×¦×¢ ×œ×”×’×“×™×œ ×‘ -TCP ××ª SSThreshold ×‘×ª×—×™×œ×ª ×”×§×©×¨.
×‘××™×–×” ××”××§×¨×™× ×”×‘××™× ×”×©×™× ×•×™ ×”×–×” ×¢×©×•×™ ×œ×”×•×¢×™×œ ×‘××™×“×” ×”××™×¨×‘×™×ª? × ××§.
.1 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
.2 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.3 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.4 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.5 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.6 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.7 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.8 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
â— A ×©×•×œ×— ×œ -B ×—×‘×™×œ×•×ª ××™×“×¢ ×‘×××¦×¢×•×ª ×§×©×¨ TCP. × ×ª×•×Ÿ ×›×™ ×”×§×©×¨ ××ª×—×™×œ ×¢× ×—×œ×•×Ÿ ×‘×’×•×“×œ 1MSS. ×”×§×©×¨
××¡×ª×™×™× ×‘×¤×¢× ×”×¨××©×•× ×” ×©×”×•× ××’×™×¢ ×œ -SSthresh. ×‘××”×œ×š ×”×§×©×¨ ×œ× ××•×‘×“×•×ª ×—×‘×™×œ×•×ª. × ×¡××Ÿ ×‘×§×™×¦×•×¨:
.SSthresh=S*MSS
× ×ª×•×Ÿ ×›×™ ×œ××•×¨×š ×›×œ ×”×§×©×¨ rwnd < MSS*S.
××”×™ ×”×ª×¤×•×§×” ×©×œ ×”×§×©×¨ ×-A ×œ-B( ×‘ -sec / Bytes )×‘×–××Ÿ ×”× "×œ? × ××§×™.
]S*MSS / [lg (S) * RTT*2 ×‘×¢×¨×š .1
]S*MSS / [S^0.5 * RTT*2 ×‘×¢×¨×š .2
S*MSS / RTT ×‘×¢×¨×š .3
S^2)*MSS / RTT( ×‘×¢×¨×š .4
â— ×©×ª×™ ×ª×—× ×•×ª ××ª×§×©×¨×•×ª ×‘××•×¤×Ÿ ××œ×—×•×˜×™ ×‘×©×™×˜×ª N Back Go.
× ×¡××Ÿ ×‘-X ××ª ×¡×¤×¨×ª ×”×‘×™×§×•×¨×ª ×©×œ ×”×ª.×–. ×©×œ×š. ×× ×©× ×™ ×©×•×ª×¤×™× ××’×™×©×™× ××ª ×”×ª×¨×’×™×œ ×™×—×“, X ×”×•× ×¡×¤×¨×ª
×”×‘×™×§×•×¨×ª ×‘×¢×œ×ª ×”×¢×¨×š ×”× ××•×š ×™×•×ª×¨ ××‘×™×Ÿ ×”×©×ª×™×™×.
×§×¦×‘ ×”×ª×§×©×•×¨×ª ×”×•× 8Gbps, ×•×’×•×“×œ ×›×œ ×—×‘×™×œ×” ×”×•× KByte*X. ×’×“×œ×™ ×”-headers ×•×” -Acks ×–× ×™×—×™×.
ï¿½ğ‘’ğ‘ ï¿½/ï¿½ï¿½ 8 , ×•×”××¨×—×§ ×‘×™×Ÿ ×”×ª×—× ×•×ª ×”×•× 1Km. ×§×¦×‘ ×”×”×ª×¤×©×˜×•×ª ×”×•× 10 â‹… 2
×–××Ÿ ×¢×™×‘×•×“ ×”× ×ª×•× ×™× ×‘×ª×—× ×•×ª ×–× ×™×—.
××£ ×—×‘×™×œ×” ×•××£ Ack ×œ× ×”×•×œ×›×™× ×œ××™×‘×•×“.
â— ××”×• X ×©×œ×š?
â— ××” ×¦×¨×™×š ×œ×”×™×•×ª ×’×•×“×œ ×—×œ×•×Ÿ ×”××©×œ×•×— ×›×“×™ ×œ×”×‘×˜×™×— ×ª×¤×•×§×” ××§×¡×™××œ×™×ª?
 Communication Networks Course
Page | 9
Bonus â€“ Improving the Reliable UDP â€“ 15 points
Note: This part isnâ€™t mandatory and is a bonus only!
In this part, youâ€™ll improve your RUDP implementation by adding the concepts of flow
control and congestion control from TCP. Youâ€™re free to choose which algorithms to
implement, as long as you explain in your PDF which algorithms youâ€™ve used. Youâ€™ll probably
need to make changes in the original design of the RUDP. Changes only need to be to the API
itself, ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„.
Points distribution:
â€¢ Flow control improvement â€“ 7 Points
â€¢ Congestion control improvement â€“ 8 points.
Guidance:
â€¢ For flow control, you must use one of the Sliding window techniques: stop-and-wait
ARQ, Go-Back-N or Selective repeat.
â€¢ List of known TCP congestion control algorithms, which you can use any one of them
for this bonus task, or makeup your own:
Figure 2 â€“ List of known TCP congestion control algorithms, Wikipedia
 Communication Networks Course
Page | 10
Appendix A â€“ Linux local packet loss tool
To simulate a packet loss in a local network, we'll use a Linux tool that's called Linux Traffic
Control (ğ‘¡ğ‘). This requires a full Linux installation, so working with WSL won't work.
If the tool isn't installed in your machine, you can install it by using the following commands:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’
If the installation didn't work, you can use the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’2
To create a packet loss scenario, type the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘ğ‘‘ğ‘‘ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
After creating a packet loss scenario, you can change the percentage by typing the following
command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘â„ğ‘ğ‘›ğ‘”ğ‘’ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
To remove the packet loss scenario, write the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘‘ğ‘’ğ‘™ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š
 Communication Networks Course
Page | 11
Appendix B â€“ ğ’ğ’‚ğ’(ğŸ) system calls
This appendixâ€™s purpose is to give you a better understanding of socket handling in C.
A recommended reference is Beejâ€™s Guide to Network Programming, by Brian â€œBeej
Jorgensenâ€ Hall, which gives a lot of information about sockets in C and functions.
Functions and documentation links:
â€¢ ğ’”ğ’ğ’„ğ’Œğ’†ğ’•(ğŸ) â€“ A Factory method system call that creates a socket with the given
parameters.
â€¢ ğ’ƒğ’Šğ’ğ’…(ğŸ) â€“ Whenever we create a new socket, we need to bind it to a specific port in
our machine, â€œto catch a portâ€. The port number is managed and used by the kernel
to link incoming packets to the corresponding application socket. The port numbers
are usually fixed. The ğ‘ğ‘‘ğ‘‘ğ‘Ÿ parameter must match the current socket that is used.
â€¢ ğ’ğ’Šğ’”ğ’•ğ’†ğ’(ğŸ) â€“ The ğ‘™ğ‘–ğ‘ ğ‘¡ğ‘’ğ‘›(2) system call doesn't do anything in the mean of
communication but only memory allocation (malloc) for stream sockets only. If we
won't allocate memory, any incoming connection will fail.
â€¢ ğ’„ğ’ğ’ğ’ğ’†ğ’„ğ’•(ğŸ) â€“ The ğ‘ğ‘œğ‘›ğ‘›ğ‘’ğ‘ğ‘¡(2) system call starts the link between a client and a
specific IP address and port number. The connection would complete when the
other side will call the ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call.
â€¢ ğ’‚ğ’„ğ’„ğ’†ğ’‘ğ’•(ğŸ) â€“ The ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call accepts the incoming stream connection
request from the other side, by the listening socket. This system call completes the
three-way handshake of stream socket (like TCP) and opens a new socket that has a
direct communication channel only with the other party in the handshake.
â€¢ ğ’”ğ’†ğ’ğ’…(ğŸ) and ğ’”ğ’†ğ’ğ’…ğ’•ğ’(ğŸ) â€“ The ğ‘ ğ‘’ğ‘›ğ‘‘(2) and ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system calls are an analogy
for the ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’(2) system call, specifcly for sockets, with flags set to 0. Those system
calls return the number of bytes that were sent through the socket itself, as the
number of bytes can vary. The ğ‘ ğ‘’ğ‘›ğ‘‘(2)system call designed for stream sockets (like
TCP), while the ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system call designed for datagram connection-less
sockets (like UDP). When the ğ‘ ğ‘’ğ‘›ğ‘‘(2) system call returns 0, it means that the other
party closed the connection.
â€¢ ğ’“ğ’†ğ’„ğ’—(ğŸ) and ğ’“ğ’†ğ’„ğ’—ğ’‡ğ’“ğ’ğ’(ğŸ) â€“ The ğ‘Ÿğ‘’ğ‘ğ‘£(2) and ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system calls are an
analogy for the ğ‘Ÿğ‘’ğ‘ğ‘‘(2) system call, specifically for sockets, with flags set to 0.
Those system calls return the number of bytes that were received through the socket
itself, as the number of bytes can vary. The ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call designed for stream
sockets (like TCP), while the ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system call designed for datagram
connection-less sockets (like UDP). When the ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call returns 0, it means
that the other party closed the connection.
â€¢ ğ’„ğ’ğ’ğ’”ğ’†(ğŸ) and ğ’”ğ’‰ğ’–ğ’•ğ’…ğ’ğ’˜ğ’(ğŸ) â€“ The ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) and ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2) system calls close
the socket. While ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) system call closes the whole socket, the ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2)
system call partially closes the socket for read/write.
 Communication Networks Course
Page | 12
Appendix C â€“ Random data generator
The data that you are going to send in this assignment is randomly generated. You can use
your own file with appropriate size or use the following function (or a function of your own)
to generate the data:
/*
* @brief A random data generator function based on srand() and rand().
* @param size The size of the data to generate (up to 2^32 bytes).
* @return A pointer to the buffer.
*/
char *util_generate_random_data(unsigned int size) {
 char *buffer = NULL;
 // Argument check.
 if (size == 0)
 return NULL;
 buffer = (char *)calloc(size, sizeof(char));
 // Error checking.
 if (buffer == NULL)
 return NULL;
 // Randomize the seed of the random number generator.
 srand(time(NULL));
 for (unsigned int i = 0; i < size; i++)
 *(buffer + i) = ((unsigned int)rand() % 256);
 return buffer;
}
 Communication Networks Course
Page | 13
Appendix D â€“ Checksum function
A checksum is a small-sized block of data derived from another block of digital data for the
purpose of detecting errors that may have been introduced during its transmission or
storage. By themselves, checksums are often used to verify data integrity but are not relied
upon to verify data authenticity.
Below is a simple yet efficient implementation of the checksum function, you can use it for
the assignment, but you can implement your own checksum function.
/*
* @brief A checksum function that returns 16 bit checksum for data.
* @param data The data to do the checksum for.
* @param bytes The length of the data in bytes.
* @return The checksum itself as 16 bit unsigned number.
* @note This function is taken from RFC1071, can be found here:
* @note https://tools.ietf.org/html/rfc1071
* @note It is the simplest way to calculate a checksum and is not very strong.
* However, it is good enough for this assignment.
* @note You are free to use any other checksum function as well.
* You can also use this function as such without any change.
*/
unsigned short int calculate_checksum(void *data, unsigned int bytes) {
 unsigned short int *data_pointer = (unsigned short int *)data;
 unsigned int total_sum = 0;
 // Main summing loop
 while (bytes > 1) {
 total_sum += *data_pointer++;
 bytes -= 2;
 }
 // Add left-over byte, if any
 if (bytes > 0)
 total_sum += *((unsigned char *)data_pointer);
 // Fold 32-bit sum to 16 bits
 while (total_sum >> 16)
 total_sum = (total_sum & 0xFFFF) + (total_sum >> 16);
 return (~((unsigned short int)total_sum));
} Communication Networks Course
Page | 1
Assignment 3 â€“ Transport Layer
Assignment Notes and Instructions
This assignment is to be done in pairs only. You must upload all the necessary files in a ZIP
file named after both of the studentâ€™s ID. For example: ğŸğŸğŸ‘ğŸ’ğŸ“ğŸ”ğŸ•ğŸ–ğŸ—_ğŸ—ğŸ–ğŸ•ğŸ”ğŸ“ğŸ’ğŸ‘ğŸğŸ. ğ’›ğ’Šğ’‘.
1) The assignment must be submitted by the date specified in the submission box.
2) All the assignment files (Code, Wireshark pcap files, PDF) must be submitted in a ZIP file. The
PDF must contain all the necessary screenshots with a description for each one of them.
3) The assignment must be done in pairs only. In exceptional cases, you should send an email to
the course coordinator.
4) You can use any reference material available through the course Moodle website or any
material passed during the exercises.
5) You can use any reference from the web, but copying codes from websites is forbidden; this
includes codes from other GitHub repositories. A student who gets caught in the act will
automatically fail this assignment (score 0). Any website youâ€™ve used to solve the
assignment, every website you used to solve the assignment must be noted in the PDF.
6) No delays in submission without special permission. Lateness without approval will result in
failure of the assignment (score 0).
7) All submissions will be submitted via the course's Moodle website. Email submissions will not
be accepted, resulting in a failure in the assignment.
8) The order and design of the code must be carefully considered. Make sure that the program
output is as clear as possible, comments in the code, and meaningful variable names. You
must also submit a makefile that compiles all the programs.
9) The assignment code must be written in C only.
10) The assignment is personal for each pair, and you should not accept help from other people,
whether outside the university or inside it. You can contact the course staff during reception
hours for help or raise a question in the course forum. Do not transfer code sections
between students, upload solutions or parts of solutions to websites on the Internet or in
various communication groups.
11) Students who copy a solution will receive a 0 in all assignments in the course and a report will
be made to the institutional disciplinary committee.
12) All code files of the assignment are required to both compile and run properly on the Ubuntu
22.04 LTS operating system. This is the operating system where the submissions will be
tested. You mustnâ€™t code it in Windows, as it uses different API for sockets. WSL wonâ€™t work,
as the task needs a tool that works only in a fully Linux environment.
Good Luck!
 Communication Networks Course
Page | 2
Part A â€“ Transmission Control Protocol (TCP) â€“ 30 points
In this part, youâ€™ll write two program files: ğ‘»ğ‘ªğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and ğ‘»ğ‘ªğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
The Sender will send a randomly generated file and the Receiver will receive it and measure
the time it took for his program to receive the file. The file size should be at least 2MB.
When running the Sender and Receiver, they both should support two standard congestion
control algorithms: TCP Reno and TCP Cubic.
Notes:
â€¢ The main goal of this part is to get familiar with the TCP concept of sending
messages between two endpoints.
â€¢ For approaching this part of the assignment, please be sure that you are familiar
with the congestion control algorithms and how to change them using the correct
method in C (see Appendix B for more information).
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). You've
learned that TCP is reliable by design, so you can assume that all the data have been
passed correctly, and thus, no need to recheck.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
Usage:
â€¢ Receiver:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
â€¢ Sender:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port of the Receiver.
â€¢ ğ‘¨ğ‘³ğ‘®ğ‘¶ â€“ The TCP congestion control algorithm that will be used by the party
member (either ğ’“ğ’†ğ’ğ’ for TCP Reno or ğ’„ğ’–ğ’ƒğ’Šğ’„ for TCP Cubic).
 Communication Networks Course
Page | 3
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a TCP socket between the Sender and the
Receiver.
3) Send the file.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a TCP connection between the Receiver and
the Sender.
2) Get a connection from the sender.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./TCP_Receiver -p 1234 -algo reno
Starting Receiver...
Waiting for TCP connection...
Sender connected, beginning to receive file...
File transfer completed.
Waiting for Sender response...
Sender sent exit message.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 4
Part B â€“ Reliable User Datagram Protocol (Reliable UDP or RUDP) â€“ 40 points
Youâ€™ve learned that while TCP is reliable, it lacks speed and has an overhead data of 20 bytes,
compering to UDP that needs only 8 bytes of overhead data.
Reliable UDP or RUDP, is a protocol that uses the UDP protocol for a faster transmission of
data, while adding a reliability layer to it, but without adding too much overhead data like
TCP.
A simple sketch for a RUDP connection would look something like this:
Your task in this part is to implement a Reliable protocol using UDP only. For simplicity, your
implementation should only support a handshake, closing scheme, error checking,
acknowledgment of received packets, and retransmission of lost packets.
Guidance:
â€¢ You can use ğ‘ ğ‘’ğ‘¡ğ‘ ğ‘œğ‘ğ‘˜ğ‘œğ‘ğ‘¡(2) for detecting a timeout.
â€¢ You need to build your own protocol, as Reliable UDP isnâ€™t a standard protocol (see a
draft of RUDP in this link), and no official header is provided. You can use this sketch
for a header, but you can come up with your own protocol, as long as it works.
Where:
o ğ‘³ğ’†ğ’ğ’ˆğ’•ğ’‰ is the length of the data itself, without the RUDP header.
o ğ‘ªğ’‰ğ’†ğ’„ğ’Œğ’”ğ’–ğ’ is a 16bit number that validates the correctness of the data.
o ğ‘­ğ’ğ’‚ğ’ˆğ’” is a special byte where we classify the packet itself (SYN, ACK, etc.).
â€¢ In your PDF, you must explain how your implementation of RUDP works â€“ How does
it detect a timeout to do retransmissions, how does the handshake work, what is the
header overhead, etc.
â€¢ For this part, youâ€™ll write three files: ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¨ğ‘·ğ‘°. ğ’„, ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and
ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
Reliable UDP Header proposed sketch
Byte 0 Byte 1 Byte 2 Byte 3
Length (2 Bytes) Checksum (2 Bytes)
Flags (1 Byte)
Figure 1 - RUDP Protocol Architecture, Geeksforgeeks
 Communication Networks Course
Page | 5
Notes:
â€¢ The Sender will send a random generated file and the Receiver will receive it and
measure the time it took for his program to receive the file. The file size should be at
least 2MB.
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). But, as the
RUDP is based on UDP, itâ€™s not reliable. You must use some form of error checking
(like checksum) to ensure that the packet wasnâ€™t alerted during the transfer.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
â€¢ The RUDP needs support only 1 sender and 1 receiver, for simplicity purposes.
Usage:
â€¢ Receiver:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
â€¢ Sender:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port that both the Sender and the Receiver will use.
The ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„ file will contain all the implementations of the RUDP API functions (That is, to
prevent reusing the same chuck of code both in the Sender and the Receiver.).
The API should support at the bare minimum the following functions (you decide what
parameters to implement, and what are the names of the functions, as long as the API is
explained in the PDF):
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘œğ‘ğ‘˜ğ‘’ğ‘¡() â€“ Creating a RUDP socket and creating a handshake between two
peers.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘’ğ‘›ğ‘‘() â€“ Sending data to the peer. The function should wait for an
acknowledgment packet, and if it didnâ€™t receive any, retransmits the data.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘Ÿğ‘’ğ‘ğ‘£() â€“ Receive data from a peer.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ğ‘™ğ‘œğ‘ ğ‘’() â€“ Closes a connection between peers.
 Communication Networks Course
Page | 6
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a UDP socket between the Sender and the
Receiver.
3) Send the file via the RUDP protocol.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a UDP connection between the Receiver and
the Sender.
2) Get a connection from the sender, by the custom
RUDP protocol youâ€™ve built.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./RUDP_Receiver -p 1234
Starting Receiver...
Waiting for RUDP connection...
Connection request received, sending ACK.
Sender connected, beginning to receive file...
File transfer completed.
ACK sent.
Waiting for Sender response...
Sender sent exit message.
ACK sent.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 7
Part C â€“ Research â€“ 30 points
In this part, youâ€™ll conduct research about your implementations of part A and part B.
In the research itself, each one of the versions (TCP version and UDP version) will be run at
least 5 times (meaning that the file transfer will occur at least 5 times) by the following
conditions:
â€¢ For TCP, youâ€™ll run it in TCP Reno and TCP Cubic, alternating each time, for each
scenario, meaning that you run 5 times with TCP Reno in both Sender and Receiver,
and 5 times with TCP Cubic in both Sender and Receiver.
Bonus (5 points): Create a very large data set â€“ 5 times with TCP Reno in both Sender
and Receiver, 5 times with TCP Reno in Sender and TCP Cubic in Receiver, 5 times
with TCP Cubic in Sender and TCP Reno in Receiver, and 5 times with TCP Cubic in
both Sender and Receiver. This will give you a data set large enough, which allows
you to work with, compare with and to reach a definite conclusion.
â€¢ For RUDP, you will run it 5 times for each scenario.
â€¢ For both TCP and RUDP, you will run them on those scenarios of packet loss:
o 0% packet loss â€“ Control group, simulating perfect connection.
o 2% packet loss â€“ Simulating unstable connection that commonly occur.
o 5% packet loss â€“ Simulating bad connection.
o 10% packet loss â€“ Simulating extremely poor connection.
For each scenario, you must provide a filtered PCAP file and relevant screenshots that
explain each one of the steps in the process. (10 points)
After youâ€™ve gathered the data set for both TCP and Reliable UDP, answer the following
questions:
1) In TCP, which congestion control algorithm gave better results overall? TCP Reno or
TCP Cubic? Which one gave better results on high packet loss? Explain how you came
to this conclusion based on the data set youâ€™ve gathered. (5 points)
2) How did your implementation of Reliable UDP perform overall compared to regular
TCP? Which one is better for high packet loss? (5 points)
3) According to the data youâ€™ve gathered, in which scenarios and applications would we
prefer to use TCP and in which situations would we prefer to use reliable UDP?
Explain your answer. (5 points)
 Communication Networks Course
Page | 8
×¢× ×• ×¢×œ ×”×©××œ×•×ª ×”×‘××•×ª )5 × ×§×•×“×•×ª(:
â— ×‘"×¨×©×ª ×××™× ×”" ×”×›×•×•× ×” ×”×™× ×œ×¨×©×ª ×©×‘×” ××¢×˜ ×××•×“ ×—×‘×™×œ×•×ª ×”×•×œ×›×•×ª ×œ××™×‘×•×“. ×‘"×§×©×¨ ××¨×•×š" ×”×›×•×•× ×” ×”×™×
×œ×§×©×¨ TCP ×©×™×© ×‘×• ×”×¨×‘×” ×××•×“ ××™×“×¢ ×œ×©×œ×•×—. ××•×¦×¢ ×œ×”×’×“×™×œ ×‘ -TCP ××ª SSThreshold ×‘×ª×—×™×œ×ª ×”×§×©×¨.
×‘××™×–×” ××”××§×¨×™× ×”×‘××™× ×”×©×™× ×•×™ ×”×–×” ×¢×©×•×™ ×œ×”×•×¢×™×œ ×‘××™×“×” ×”××™×¨×‘×™×ª? × ××§.
.1 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
.2 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.3 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.4 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.5 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.6 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.7 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.8 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
â— A ×©×•×œ×— ×œ -B ×—×‘×™×œ×•×ª ××™×“×¢ ×‘×××¦×¢×•×ª ×§×©×¨ TCP. × ×ª×•×Ÿ ×›×™ ×”×§×©×¨ ××ª×—×™×œ ×¢× ×—×œ×•×Ÿ ×‘×’×•×“×œ 1MSS. ×”×§×©×¨
××¡×ª×™×™× ×‘×¤×¢× ×”×¨××©×•× ×” ×©×”×•× ××’×™×¢ ×œ -SSthresh. ×‘××”×œ×š ×”×§×©×¨ ×œ× ××•×‘×“×•×ª ×—×‘×™×œ×•×ª. × ×¡××Ÿ ×‘×§×™×¦×•×¨:
.SSthresh=S*MSS
× ×ª×•×Ÿ ×›×™ ×œ××•×¨×š ×›×œ ×”×§×©×¨ rwnd < MSS*S.
××”×™ ×”×ª×¤×•×§×” ×©×œ ×”×§×©×¨ ×-A ×œ-B( ×‘ -sec / Bytes )×‘×–××Ÿ ×”× "×œ? × ××§×™.
]S*MSS / [lg (S) * RTT*2 ×‘×¢×¨×š .1
]S*MSS / [S^0.5 * RTT*2 ×‘×¢×¨×š .2
S*MSS / RTT ×‘×¢×¨×š .3
S^2)*MSS / RTT( ×‘×¢×¨×š .4
â— ×©×ª×™ ×ª×—× ×•×ª ××ª×§×©×¨×•×ª ×‘××•×¤×Ÿ ××œ×—×•×˜×™ ×‘×©×™×˜×ª N Back Go.
× ×¡××Ÿ ×‘-X ××ª ×¡×¤×¨×ª ×”×‘×™×§×•×¨×ª ×©×œ ×”×ª.×–. ×©×œ×š. ×× ×©× ×™ ×©×•×ª×¤×™× ××’×™×©×™× ××ª ×”×ª×¨×’×™×œ ×™×—×“, X ×”×•× ×¡×¤×¨×ª
×”×‘×™×§×•×¨×ª ×‘×¢×œ×ª ×”×¢×¨×š ×”× ××•×š ×™×•×ª×¨ ××‘×™×Ÿ ×”×©×ª×™×™×.
×§×¦×‘ ×”×ª×§×©×•×¨×ª ×”×•× 8Gbps, ×•×’×•×“×œ ×›×œ ×—×‘×™×œ×” ×”×•× KByte*X. ×’×“×œ×™ ×”-headers ×•×” -Acks ×–× ×™×—×™×.
ï¿½ğ‘’ğ‘ ï¿½/ï¿½ï¿½ 8 , ×•×”××¨×—×§ ×‘×™×Ÿ ×”×ª×—× ×•×ª ×”×•× 1Km. ×§×¦×‘ ×”×”×ª×¤×©×˜×•×ª ×”×•× 10 â‹… 2
×–××Ÿ ×¢×™×‘×•×“ ×”× ×ª×•× ×™× ×‘×ª×—× ×•×ª ×–× ×™×—.
××£ ×—×‘×™×œ×” ×•××£ Ack ×œ× ×”×•×œ×›×™× ×œ××™×‘×•×“.
â— ××”×• X ×©×œ×š?
â— ××” ×¦×¨×™×š ×œ×”×™×•×ª ×’×•×“×œ ×—×œ×•×Ÿ ×”××©×œ×•×— ×›×“×™ ×œ×”×‘×˜×™×— ×ª×¤×•×§×” ××§×¡×™××œ×™×ª?
 Communication Networks Course
Page | 9
Bonus â€“ Improving the Reliable UDP â€“ 15 points
Note: This part isnâ€™t mandatory and is a bonus only!
In this part, youâ€™ll improve your RUDP implementation by adding the concepts of flow
control and congestion control from TCP. Youâ€™re free to choose which algorithms to
implement, as long as you explain in your PDF which algorithms youâ€™ve used. Youâ€™ll probably
need to make changes in the original design of the RUDP. Changes only need to be to the API
itself, ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„.
Points distribution:
â€¢ Flow control improvement â€“ 7 Points
â€¢ Congestion control improvement â€“ 8 points.
Guidance:
â€¢ For flow control, you must use one of the Sliding window techniques: stop-and-wait
ARQ, Go-Back-N or Selective repeat.
â€¢ List of known TCP congestion control algorithms, which you can use any one of them
for this bonus task, or makeup your own:
Figure 2 â€“ List of known TCP congestion control algorithms, Wikipedia
 Communication Networks Course
Page | 10
Appendix A â€“ Linux local packet loss tool
To simulate a packet loss in a local network, we'll use a Linux tool that's called Linux Traffic
Control (ğ‘¡ğ‘). This requires a full Linux installation, so working with WSL won't work.
If the tool isn't installed in your machine, you can install it by using the following commands:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’
If the installation didn't work, you can use the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’2
To create a packet loss scenario, type the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘ğ‘‘ğ‘‘ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
After creating a packet loss scenario, you can change the percentage by typing the following
command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘â„ğ‘ğ‘›ğ‘”ğ‘’ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
To remove the packet loss scenario, write the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘‘ğ‘’ğ‘™ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š
 Communication Networks Course
Page | 11
Appendix B â€“ ğ’ğ’‚ğ’(ğŸ) system calls
This appendixâ€™s purpose is to give you a better understanding of socket handling in C.
A recommended reference is Beejâ€™s Guide to Network Programming, by Brian â€œBeej
Jorgensenâ€ Hall, which gives a lot of information about sockets in C and functions.
Functions and documentation links:
â€¢ ğ’”ğ’ğ’„ğ’Œğ’†ğ’•(ğŸ) â€“ A Factory method system call that creates a socket with the given
parameters.
â€¢ ğ’ƒğ’Šğ’ğ’…(ğŸ) â€“ Whenever we create a new socket, we need to bind it to a specific port in
our machine, â€œto catch a portâ€. The port number is managed and used by the kernel
to link incoming packets to the corresponding application socket. The port numbers
are usually fixed. The ğ‘ğ‘‘ğ‘‘ğ‘Ÿ parameter must match the current socket that is used.
â€¢ ğ’ğ’Šğ’”ğ’•ğ’†ğ’(ğŸ) â€“ The ğ‘™ğ‘–ğ‘ ğ‘¡ğ‘’ğ‘›(2) system call doesn't do anything in the mean of
communication but only memory allocation (malloc) for stream sockets only. If we
won't allocate memory, any incoming connection will fail.
â€¢ ğ’„ğ’ğ’ğ’ğ’†ğ’„ğ’•(ğŸ) â€“ The ğ‘ğ‘œğ‘›ğ‘›ğ‘’ğ‘ğ‘¡(2) system call starts the link between a client and a
specific IP address and port number. The connection would complete when the
other side will call the ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call.
â€¢ ğ’‚ğ’„ğ’„ğ’†ğ’‘ğ’•(ğŸ) â€“ The ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call accepts the incoming stream connection
request from the other side, by the listening socket. This system call completes the
three-way handshake of stream socket (like TCP) and opens a new socket that has a
direct communication channel only with the other party in the handshake.
â€¢ ğ’”ğ’†ğ’ğ’…(ğŸ) and ğ’”ğ’†ğ’ğ’…ğ’•ğ’(ğŸ) â€“ The ğ‘ ğ‘’ğ‘›ğ‘‘(2) and ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system calls are an analogy
for the ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’(2) system call, specifcly for sockets, with flags set to 0. Those system
calls return the number of bytes that were sent through the socket itself, as the
number of bytes can vary. The ğ‘ ğ‘’ğ‘›ğ‘‘(2)system call designed for stream sockets (like
TCP), while the ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system call designed for datagram connection-less
sockets (like UDP). When the ğ‘ ğ‘’ğ‘›ğ‘‘(2) system call returns 0, it means that the other
party closed the connection.
â€¢ ğ’“ğ’†ğ’„ğ’—(ğŸ) and ğ’“ğ’†ğ’„ğ’—ğ’‡ğ’“ğ’ğ’(ğŸ) â€“ The ğ‘Ÿğ‘’ğ‘ğ‘£(2) and ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system calls are an
analogy for the ğ‘Ÿğ‘’ğ‘ğ‘‘(2) system call, specifically for sockets, with flags set to 0.
Those system calls return the number of bytes that were received through the socket
itself, as the number of bytes can vary. The ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call designed for stream
sockets (like TCP), while the ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system call designed for datagram
connection-less sockets (like UDP). When the ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call returns 0, it means
that the other party closed the connection.
â€¢ ğ’„ğ’ğ’ğ’”ğ’†(ğŸ) and ğ’”ğ’‰ğ’–ğ’•ğ’…ğ’ğ’˜ğ’(ğŸ) â€“ The ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) and ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2) system calls close
the socket. While ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) system call closes the whole socket, the ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2)
system call partially closes the socket for read/write.
 Communication Networks Course
Page | 12
Appendix C â€“ Random data generator
The data that you are going to send in this assignment is randomly generated. You can use
your own file with appropriate size or use the following function (or a function of your own)
to generate the data:
/*
* @brief A random data generator function based on srand() and rand().
* @param size The size of the data to generate (up to 2^32 bytes).
* @return A pointer to the buffer.
*/
char *util_generate_random_data(unsigned int size) {
 char *buffer = NULL;
 // Argument check.
 if (size == 0)
 return NULL;
 buffer = (char *)calloc(size, sizeof(char));
 // Error checking.
 if (buffer == NULL)
 return NULL;
 // Randomize the seed of the random number generator.
 srand(time(NULL));
 for (unsigned int i = 0; i < size; i++)
 *(buffer + i) = ((unsigned int)rand() % 256);
 return buffer;
}
 Communication Networks Course
Page | 13
Appendix D â€“ Checksum function
A checksum is a small-sized block of data derived from another block of digital data for the
purpose of detecting errors that may have been introduced during its transmission or
storage. By themselves, checksums are often used to verify data integrity but are not relied
upon to verify data authenticity.
Below is a simple yet efficient implementation of the checksum function, you can use it for
the assignment, but you can implement your own checksum function.
/*
* @brief A checksum function that returns 16 bit checksum for data.
* @param data The data to do the checksum for.
* @param bytes The length of the data in bytes.
* @return The checksum itself as 16 bit unsigned number.
* @note This function is taken from RFC1071, can be found here:
* @note https://tools.ietf.org/html/rfc1071
* @note It is the simplest way to calculate a checksum and is not very strong.
* However, it is good enough for this assignment.
* @note You are free to use any other checksum function as well.
* You can also use this function as such without any change.
*/
unsigned short int calculate_checksum(void *data, unsigned int bytes) {
 unsigned short int *data_pointer = (unsigned short int *)data;
 unsigned int total_sum = 0;
 // Main summing loop
 while (bytes > 1) {
 total_sum += *data_pointer++;
 bytes -= 2;
 }
 // Add left-over byte, if any
 if (bytes > 0)
 total_sum += *((unsigned char *)data_pointer);
 // Fold 32-bit sum to 16 bits
 while (total_sum >> 16)
 total_sum = (total_sum & 0xFFFF) + (total_sum >> 16);
 return (~((unsigned short int)total_sum));
} Communication Networks Course
Page | 1
Assignment 3 â€“ Transport Layer
Assignment Notes and Instructions
This assignment is to be done in pairs only. You must upload all the necessary files in a ZIP
file named after both of the studentâ€™s ID. For example: ğŸğŸğŸ‘ğŸ’ğŸ“ğŸ”ğŸ•ğŸ–ğŸ—_ğŸ—ğŸ–ğŸ•ğŸ”ğŸ“ğŸ’ğŸ‘ğŸğŸ. ğ’›ğ’Šğ’‘.
1) The assignment must be submitted by the date specified in the submission box.
2) All the assignment files (Code, Wireshark pcap files, PDF) must be submitted in a ZIP file. The
PDF must contain all the necessary screenshots with a description for each one of them.
3) The assignment must be done in pairs only. In exceptional cases, you should send an email to
the course coordinator.
4) You can use any reference material available through the course Moodle website or any
material passed during the exercises.
5) You can use any reference from the web, but copying codes from websites is forbidden; this
includes codes from other GitHub repositories. A student who gets caught in the act will
automatically fail this assignment (score 0). Any website youâ€™ve used to solve the
assignment, every website you used to solve the assignment must be noted in the PDF.
6) No delays in submission without special permission. Lateness without approval will result in
failure of the assignment (score 0).
7) All submissions will be submitted via the course's Moodle website. Email submissions will not
be accepted, resulting in a failure in the assignment.
8) The order and design of the code must be carefully considered. Make sure that the program
output is as clear as possible, comments in the code, and meaningful variable names. You
must also submit a makefile that compiles all the programs.
9) The assignment code must be written in C only.
10) The assignment is personal for each pair, and you should not accept help from other people,
whether outside the university or inside it. You can contact the course staff during reception
hours for help or raise a question in the course forum. Do not transfer code sections
between students, upload solutions or parts of solutions to websites on the Internet or in
various communication groups.
11) Students who copy a solution will receive a 0 in all assignments in the course and a report will
be made to the institutional disciplinary committee.
12) All code files of the assignment are required to both compile and run properly on the Ubuntu
22.04 LTS operating system. This is the operating system where the submissions will be
tested. You mustnâ€™t code it in Windows, as it uses different API for sockets. WSL wonâ€™t work,
as the task needs a tool that works only in a fully Linux environment.
Good Luck!
 Communication Networks Course
Page | 2
Part A â€“ Transmission Control Protocol (TCP) â€“ 30 points
In this part, youâ€™ll write two program files: ğ‘»ğ‘ªğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and ğ‘»ğ‘ªğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
The Sender will send a randomly generated file and the Receiver will receive it and measure
the time it took for his program to receive the file. The file size should be at least 2MB.
When running the Sender and Receiver, they both should support two standard congestion
control algorithms: TCP Reno and TCP Cubic.
Notes:
â€¢ The main goal of this part is to get familiar with the TCP concept of sending
messages between two endpoints.
â€¢ For approaching this part of the assignment, please be sure that you are familiar
with the congestion control algorithms and how to change them using the correct
method in C (see Appendix B for more information).
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). You've
learned that TCP is reliable by design, so you can assume that all the data have been
passed correctly, and thus, no need to recheck.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
Usage:
â€¢ Receiver:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
â€¢ Sender:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port of the Receiver.
â€¢ ğ‘¨ğ‘³ğ‘®ğ‘¶ â€“ The TCP congestion control algorithm that will be used by the party
member (either ğ’“ğ’†ğ’ğ’ for TCP Reno or ğ’„ğ’–ğ’ƒğ’Šğ’„ for TCP Cubic).
 Communication Networks Course
Page | 3
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a TCP socket between the Sender and the
Receiver.
3) Send the file.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a TCP connection between the Receiver and
the Sender.
2) Get a connection from the sender.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./TCP_Receiver -p 1234 -algo reno
Starting Receiver...
Waiting for TCP connection...
Sender connected, beginning to receive file...
File transfer completed.
Waiting for Sender response...
Sender sent exit message.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 4
Part B â€“ Reliable User Datagram Protocol (Reliable UDP or RUDP) â€“ 40 points
Youâ€™ve learned that while TCP is reliable, it lacks speed and has an overhead data of 20 bytes,
compering to UDP that needs only 8 bytes of overhead data.
Reliable UDP or RUDP, is a protocol that uses the UDP protocol for a faster transmission of
data, while adding a reliability layer to it, but without adding too much overhead data like
TCP.
A simple sketch for a RUDP connection would look something like this:
Your task in this part is to implement a Reliable protocol using UDP only. For simplicity, your
implementation should only support a handshake, closing scheme, error checking,
acknowledgment of received packets, and retransmission of lost packets.
Guidance:
â€¢ You can use ğ‘ ğ‘’ğ‘¡ğ‘ ğ‘œğ‘ğ‘˜ğ‘œğ‘ğ‘¡(2) for detecting a timeout.
â€¢ You need to build your own protocol, as Reliable UDP isnâ€™t a standard protocol (see a
draft of RUDP in this link), and no official header is provided. You can use this sketch
for a header, but you can come up with your own protocol, as long as it works.
Where:
o ğ‘³ğ’†ğ’ğ’ˆğ’•ğ’‰ is the length of the data itself, without the RUDP header.
o ğ‘ªğ’‰ğ’†ğ’„ğ’Œğ’”ğ’–ğ’ is a 16bit number that validates the correctness of the data.
o ğ‘­ğ’ğ’‚ğ’ˆğ’” is a special byte where we classify the packet itself (SYN, ACK, etc.).
â€¢ In your PDF, you must explain how your implementation of RUDP works â€“ How does
it detect a timeout to do retransmissions, how does the handshake work, what is the
header overhead, etc.
â€¢ For this part, youâ€™ll write three files: ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¨ğ‘·ğ‘°. ğ’„, ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and
ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
Reliable UDP Header proposed sketch
Byte 0 Byte 1 Byte 2 Byte 3
Length (2 Bytes) Checksum (2 Bytes)
Flags (1 Byte)
Figure 1 - RUDP Protocol Architecture, Geeksforgeeks
 Communication Networks Course
Page | 5
Notes:
â€¢ The Sender will send a random generated file and the Receiver will receive it and
measure the time it took for his program to receive the file. The file size should be at
least 2MB.
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). But, as the
RUDP is based on UDP, itâ€™s not reliable. You must use some form of error checking
(like checksum) to ensure that the packet wasnâ€™t alerted during the transfer.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
â€¢ The RUDP needs support only 1 sender and 1 receiver, for simplicity purposes.
Usage:
â€¢ Receiver:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
â€¢ Sender:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port that both the Sender and the Receiver will use.
The ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„ file will contain all the implementations of the RUDP API functions (That is, to
prevent reusing the same chuck of code both in the Sender and the Receiver.).
The API should support at the bare minimum the following functions (you decide what
parameters to implement, and what are the names of the functions, as long as the API is
explained in the PDF):
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘œğ‘ğ‘˜ğ‘’ğ‘¡() â€“ Creating a RUDP socket and creating a handshake between two
peers.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘’ğ‘›ğ‘‘() â€“ Sending data to the peer. The function should wait for an
acknowledgment packet, and if it didnâ€™t receive any, retransmits the data.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘Ÿğ‘’ğ‘ğ‘£() â€“ Receive data from a peer.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ğ‘™ğ‘œğ‘ ğ‘’() â€“ Closes a connection between peers.
 Communication Networks Course
Page | 6
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a UDP socket between the Sender and the
Receiver.
3) Send the file via the RUDP protocol.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a UDP connection between the Receiver and
the Sender.
2) Get a connection from the sender, by the custom
RUDP protocol youâ€™ve built.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./RUDP_Receiver -p 1234
Starting Receiver...
Waiting for RUDP connection...
Connection request received, sending ACK.
Sender connected, beginning to receive file...
File transfer completed.
ACK sent.
Waiting for Sender response...
Sender sent exit message.
ACK sent.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 7
Part C â€“ Research â€“ 30 points
In this part, youâ€™ll conduct research about your implementations of part A and part B.
In the research itself, each one of the versions (TCP version and UDP version) will be run at
least 5 times (meaning that the file transfer will occur at least 5 times) by the following
conditions:
â€¢ For TCP, youâ€™ll run it in TCP Reno and TCP Cubic, alternating each time, for each
scenario, meaning that you run 5 times with TCP Reno in both Sender and Receiver,
and 5 times with TCP Cubic in both Sender and Receiver.
Bonus (5 points): Create a very large data set â€“ 5 times with TCP Reno in both Sender
and Receiver, 5 times with TCP Reno in Sender and TCP Cubic in Receiver, 5 times
with TCP Cubic in Sender and TCP Reno in Receiver, and 5 times with TCP Cubic in
both Sender and Receiver. This will give you a data set large enough, which allows
you to work with, compare with and to reach a definite conclusion.
â€¢ For RUDP, you will run it 5 times for each scenario.
â€¢ For both TCP and RUDP, you will run them on those scenarios of packet loss:
o 0% packet loss â€“ Control group, simulating perfect connection.
o 2% packet loss â€“ Simulating unstable connection that commonly occur.
o 5% packet loss â€“ Simulating bad connection.
o 10% packet loss â€“ Simulating extremely poor connection.
For each scenario, you must provide a filtered PCAP file and relevant screenshots that
explain each one of the steps in the process. (10 points)
After youâ€™ve gathered the data set for both TCP and Reliable UDP, answer the following
questions:
1) In TCP, which congestion control algorithm gave better results overall? TCP Reno or
TCP Cubic? Which one gave better results on high packet loss? Explain how you came
to this conclusion based on the data set youâ€™ve gathered. (5 points)
2) How did your implementation of Reliable UDP perform overall compared to regular
TCP? Which one is better for high packet loss? (5 points)
3) According to the data youâ€™ve gathered, in which scenarios and applications would we
prefer to use TCP and in which situations would we prefer to use reliable UDP?
Explain your answer. (5 points)
 Communication Networks Course
Page | 8
×¢× ×• ×¢×œ ×”×©××œ×•×ª ×”×‘××•×ª )5 × ×§×•×“×•×ª(:
â— ×‘"×¨×©×ª ×××™× ×”" ×”×›×•×•× ×” ×”×™× ×œ×¨×©×ª ×©×‘×” ××¢×˜ ×××•×“ ×—×‘×™×œ×•×ª ×”×•×œ×›×•×ª ×œ××™×‘×•×“. ×‘"×§×©×¨ ××¨×•×š" ×”×›×•×•× ×” ×”×™×
×œ×§×©×¨ TCP ×©×™×© ×‘×• ×”×¨×‘×” ×××•×“ ××™×“×¢ ×œ×©×œ×•×—. ××•×¦×¢ ×œ×”×’×“×™×œ ×‘ -TCP ××ª SSThreshold ×‘×ª×—×™×œ×ª ×”×§×©×¨.
×‘××™×–×” ××”××§×¨×™× ×”×‘××™× ×”×©×™× ×•×™ ×”×–×” ×¢×©×•×™ ×œ×”×•×¢×™×œ ×‘××™×“×” ×”××™×¨×‘×™×ª? × ××§.
.1 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
.2 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.3 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.4 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.5 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.6 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.7 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.8 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
â— A ×©×•×œ×— ×œ -B ×—×‘×™×œ×•×ª ××™×“×¢ ×‘×××¦×¢×•×ª ×§×©×¨ TCP. × ×ª×•×Ÿ ×›×™ ×”×§×©×¨ ××ª×—×™×œ ×¢× ×—×œ×•×Ÿ ×‘×’×•×“×œ 1MSS. ×”×§×©×¨
××¡×ª×™×™× ×‘×¤×¢× ×”×¨××©×•× ×” ×©×”×•× ××’×™×¢ ×œ -SSthresh. ×‘××”×œ×š ×”×§×©×¨ ×œ× ××•×‘×“×•×ª ×—×‘×™×œ×•×ª. × ×¡××Ÿ ×‘×§×™×¦×•×¨:
.SSthresh=S*MSS
× ×ª×•×Ÿ ×›×™ ×œ××•×¨×š ×›×œ ×”×§×©×¨ rwnd < MSS*S.
××”×™ ×”×ª×¤×•×§×” ×©×œ ×”×§×©×¨ ×-A ×œ-B( ×‘ -sec / Bytes )×‘×–××Ÿ ×”× "×œ? × ××§×™.
]S*MSS / [lg (S) * RTT*2 ×‘×¢×¨×š .1
]S*MSS / [S^0.5 * RTT*2 ×‘×¢×¨×š .2
S*MSS / RTT ×‘×¢×¨×š .3
S^2)*MSS / RTT( ×‘×¢×¨×š .4
â— ×©×ª×™ ×ª×—× ×•×ª ××ª×§×©×¨×•×ª ×‘××•×¤×Ÿ ××œ×—×•×˜×™ ×‘×©×™×˜×ª N Back Go.
× ×¡××Ÿ ×‘-X ××ª ×¡×¤×¨×ª ×”×‘×™×§×•×¨×ª ×©×œ ×”×ª.×–. ×©×œ×š. ×× ×©× ×™ ×©×•×ª×¤×™× ××’×™×©×™× ××ª ×”×ª×¨×’×™×œ ×™×—×“, X ×”×•× ×¡×¤×¨×ª
×”×‘×™×§×•×¨×ª ×‘×¢×œ×ª ×”×¢×¨×š ×”× ××•×š ×™×•×ª×¨ ××‘×™×Ÿ ×”×©×ª×™×™×.
×§×¦×‘ ×”×ª×§×©×•×¨×ª ×”×•× 8Gbps, ×•×’×•×“×œ ×›×œ ×—×‘×™×œ×” ×”×•× KByte*X. ×’×“×œ×™ ×”-headers ×•×” -Acks ×–× ×™×—×™×.
ï¿½ğ‘’ğ‘ ï¿½/ï¿½ï¿½ 8 , ×•×”××¨×—×§ ×‘×™×Ÿ ×”×ª×—× ×•×ª ×”×•× 1Km. ×§×¦×‘ ×”×”×ª×¤×©×˜×•×ª ×”×•× 10 â‹… 2
×–××Ÿ ×¢×™×‘×•×“ ×”× ×ª×•× ×™× ×‘×ª×—× ×•×ª ×–× ×™×—.
××£ ×—×‘×™×œ×” ×•××£ Ack ×œ× ×”×•×œ×›×™× ×œ××™×‘×•×“.
â— ××”×• X ×©×œ×š?
â— ××” ×¦×¨×™×š ×œ×”×™×•×ª ×’×•×“×œ ×—×œ×•×Ÿ ×”××©×œ×•×— ×›×“×™ ×œ×”×‘×˜×™×— ×ª×¤×•×§×” ××§×¡×™××œ×™×ª?
 Communication Networks Course
Page | 9
Bonus â€“ Improving the Reliable UDP â€“ 15 points
Note: This part isnâ€™t mandatory and is a bonus only!
In this part, youâ€™ll improve your RUDP implementation by adding the concepts of flow
control and congestion control from TCP. Youâ€™re free to choose which algorithms to
implement, as long as you explain in your PDF which algorithms youâ€™ve used. Youâ€™ll probably
need to make changes in the original design of the RUDP. Changes only need to be to the API
itself, ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„.
Points distribution:
â€¢ Flow control improvement â€“ 7 Points
â€¢ Congestion control improvement â€“ 8 points.
Guidance:
â€¢ For flow control, you must use one of the Sliding window techniques: stop-and-wait
ARQ, Go-Back-N or Selective repeat.
â€¢ List of known TCP congestion control algorithms, which you can use any one of them
for this bonus task, or makeup your own:
Figure 2 â€“ List of known TCP congestion control algorithms, Wikipedia
 Communication Networks Course
Page | 10
Appendix A â€“ Linux local packet loss tool
To simulate a packet loss in a local network, we'll use a Linux tool that's called Linux Traffic
Control (ğ‘¡ğ‘). This requires a full Linux installation, so working with WSL won't work.
If the tool isn't installed in your machine, you can install it by using the following commands:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’
If the installation didn't work, you can use the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’2
To create a packet loss scenario, type the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘ğ‘‘ğ‘‘ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
After creating a packet loss scenario, you can change the percentage by typing the following
command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘â„ğ‘ğ‘›ğ‘”ğ‘’ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
To remove the packet loss scenario, write the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘‘ğ‘’ğ‘™ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š
 Communication Networks Course
Page | 11
Appendix B â€“ ğ’ğ’‚ğ’(ğŸ) system calls
This appendixâ€™s purpose is to give you a better understanding of socket handling in C.
A recommended reference is Beejâ€™s Guide to Network Programming, by Brian â€œBeej
Jorgensenâ€ Hall, which gives a lot of information about sockets in C and functions.
Functions and documentation links:
â€¢ ğ’”ğ’ğ’„ğ’Œğ’†ğ’•(ğŸ) â€“ A Factory method system call that creates a socket with the given
parameters.
â€¢ ğ’ƒğ’Šğ’ğ’…(ğŸ) â€“ Whenever we create a new socket, we need to bind it to a specific port in
our machine, â€œto catch a portâ€. The port number is managed and used by the kernel
to link incoming packets to the corresponding application socket. The port numbers
are usually fixed. The ğ‘ğ‘‘ğ‘‘ğ‘Ÿ parameter must match the current socket that is used.
â€¢ ğ’ğ’Šğ’”ğ’•ğ’†ğ’(ğŸ) â€“ The ğ‘™ğ‘–ğ‘ ğ‘¡ğ‘’ğ‘›(2) system call doesn't do anything in the mean of
communication but only memory allocation (malloc) for stream sockets only. If we
won't allocate memory, any incoming connection will fail.
â€¢ ğ’„ğ’ğ’ğ’ğ’†ğ’„ğ’•(ğŸ) â€“ The ğ‘ğ‘œğ‘›ğ‘›ğ‘’ğ‘ğ‘¡(2) system call starts the link between a client and a
specific IP address and port number. The connection would complete when the
other side will call the ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call.
â€¢ ğ’‚ğ’„ğ’„ğ’†ğ’‘ğ’•(ğŸ) â€“ The ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call accepts the incoming stream connection
request from the other side, by the listening socket. This system call completes the
three-way handshake of stream socket (like TCP) and opens a new socket that has a
direct communication channel only with the other party in the handshake.
â€¢ ğ’”ğ’†ğ’ğ’…(ğŸ) and ğ’”ğ’†ğ’ğ’…ğ’•ğ’(ğŸ) â€“ The ğ‘ ğ‘’ğ‘›ğ‘‘(2) and ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system calls are an analogy
for the ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’(2) system call, specifcly for sockets, with flags set to 0. Those system
calls return the number of bytes that were sent through the socket itself, as the
number of bytes can vary. The ğ‘ ğ‘’ğ‘›ğ‘‘(2)system call designed for stream sockets (like
TCP), while the ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system call designed for datagram connection-less
sockets (like UDP). When the ğ‘ ğ‘’ğ‘›ğ‘‘(2) system call returns 0, it means that the other
party closed the connection.
â€¢ ğ’“ğ’†ğ’„ğ’—(ğŸ) and ğ’“ğ’†ğ’„ğ’—ğ’‡ğ’“ğ’ğ’(ğŸ) â€“ The ğ‘Ÿğ‘’ğ‘ğ‘£(2) and ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system calls are an
analogy for the ğ‘Ÿğ‘’ğ‘ğ‘‘(2) system call, specifically for sockets, with flags set to 0.
Those system calls return the number of bytes that were received through the socket
itself, as the number of bytes can vary. The ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call designed for stream
sockets (like TCP), while the ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system call designed for datagram
connection-less sockets (like UDP). When the ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call returns 0, it means
that the other party closed the connection.
â€¢ ğ’„ğ’ğ’ğ’”ğ’†(ğŸ) and ğ’”ğ’‰ğ’–ğ’•ğ’…ğ’ğ’˜ğ’(ğŸ) â€“ The ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) and ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2) system calls close
the socket. While ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) system call closes the whole socket, the ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2)
system call partially closes the socket for read/write.
 Communication Networks Course
Page | 12
Appendix C â€“ Random data generator
The data that you are going to send in this assignment is randomly generated. You can use
your own file with appropriate size or use the following function (or a function of your own)
to generate the data:
/*
* @brief A random data generator function based on srand() and rand().
* @param size The size of the data to generate (up to 2^32 bytes).
* @return A pointer to the buffer.
*/
char *util_generate_random_data(unsigned int size) {
 char *buffer = NULL;
 // Argument check.
 if (size == 0)
 return NULL;
 buffer = (char *)calloc(size, sizeof(char));
 // Error checking.
 if (buffer == NULL)
 return NULL;
 // Randomize the seed of the random number generator.
 srand(time(NULL));
 for (unsigned int i = 0; i < size; i++)
 *(buffer + i) = ((unsigned int)rand() % 256);
 return buffer;
}
 Communication Networks Course
Page | 13
Appendix D â€“ Checksum function
A checksum is a small-sized block of data derived from another block of digital data for the
purpose of detecting errors that may have been introduced during its transmission or
storage. By themselves, checksums are often used to verify data integrity but are not relied
upon to verify data authenticity.
Below is a simple yet efficient implementation of the checksum function, you can use it for
the assignment, but you can implement your own checksum function.
/*
* @brief A checksum function that returns 16 bit checksum for data.
* @param data The data to do the checksum for.
* @param bytes The length of the data in bytes.
* @return The checksum itself as 16 bit unsigned number.
* @note This function is taken from RFC1071, can be found here:
* @note https://tools.ietf.org/html/rfc1071
* @note It is the simplest way to calculate a checksum and is not very strong.
* However, it is good enough for this assignment.
* @note You are free to use any other checksum function as well.
* You can also use this function as such without any change.
*/
unsigned short int calculate_checksum(void *data, unsigned int bytes) {
 unsigned short int *data_pointer = (unsigned short int *)data;
 unsigned int total_sum = 0;
 // Main summing loop
 while (bytes > 1) {
 total_sum += *data_pointer++;
 bytes -= 2;
 }
 // Add left-over byte, if any
 if (bytes > 0)
 total_sum += *((unsigned char *)data_pointer);
 // Fold 32-bit sum to 16 bits
 while (total_sum >> 16)
 total_sum = (total_sum & 0xFFFF) + (total_sum >> 16);
 return (~((unsigned short int)total_sum));
} Communication Networks Course
Page | 1
Assignment 3 â€“ Transport Layer
Assignment Notes and Instructions
This assignment is to be done in pairs only. You must upload all the necessary files in a ZIP
file named after both of the studentâ€™s ID. For example: ğŸğŸğŸ‘ğŸ’ğŸ“ğŸ”ğŸ•ğŸ–ğŸ—_ğŸ—ğŸ–ğŸ•ğŸ”ğŸ“ğŸ’ğŸ‘ğŸğŸ. ğ’›ğ’Šğ’‘.
1) The assignment must be submitted by the date specified in the submission box.
2) All the assignment files (Code, Wireshark pcap files, PDF) must be submitted in a ZIP file. The
PDF must contain all the necessary screenshots with a description for each one of them.
3) The assignment must be done in pairs only. In exceptional cases, you should send an email to
the course coordinator.
4) You can use any reference material available through the course Moodle website or any
material passed during the exercises.
5) You can use any reference from the web, but copying codes from websites is forbidden; this
includes codes from other GitHub repositories. A student who gets caught in the act will
automatically fail this assignment (score 0). Any website youâ€™ve used to solve the
assignment, every website you used to solve the assignment must be noted in the PDF.
6) No delays in submission without special permission. Lateness without approval will result in
failure of the assignment (score 0).
7) All submissions will be submitted via the course's Moodle website. Email submissions will not
be accepted, resulting in a failure in the assignment.
8) The order and design of the code must be carefully considered. Make sure that the program
output is as clear as possible, comments in the code, and meaningful variable names. You
must also submit a makefile that compiles all the programs.
9) The assignment code must be written in C only.
10) The assignment is personal for each pair, and you should not accept help from other people,
whether outside the university or inside it. You can contact the course staff during reception
hours for help or raise a question in the course forum. Do not transfer code sections
between students, upload solutions or parts of solutions to websites on the Internet or in
various communication groups.
11) Students who copy a solution will receive a 0 in all assignments in the course and a report will
be made to the institutional disciplinary committee.
12) All code files of the assignment are required to both compile and run properly on the Ubuntu
22.04 LTS operating system. This is the operating system where the submissions will be
tested. You mustnâ€™t code it in Windows, as it uses different API for sockets. WSL wonâ€™t work,
as the task needs a tool that works only in a fully Linux environment.
Good Luck!
 Communication Networks Course
Page | 2
Part A â€“ Transmission Control Protocol (TCP) â€“ 30 points
In this part, youâ€™ll write two program files: ğ‘»ğ‘ªğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and ğ‘»ğ‘ªğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
The Sender will send a randomly generated file and the Receiver will receive it and measure
the time it took for his program to receive the file. The file size should be at least 2MB.
When running the Sender and Receiver, they both should support two standard congestion
control algorithms: TCP Reno and TCP Cubic.
Notes:
â€¢ The main goal of this part is to get familiar with the TCP concept of sending
messages between two endpoints.
â€¢ For approaching this part of the assignment, please be sure that you are familiar
with the congestion control algorithms and how to change them using the correct
method in C (see Appendix B for more information).
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). You've
learned that TCP is reliable by design, so you can assume that all the data have been
passed correctly, and thus, no need to recheck.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
Usage:
â€¢ Receiver:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
â€¢ Sender:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port of the Receiver.
â€¢ ğ‘¨ğ‘³ğ‘®ğ‘¶ â€“ The TCP congestion control algorithm that will be used by the party
member (either ğ’“ğ’†ğ’ğ’ for TCP Reno or ğ’„ğ’–ğ’ƒğ’Šğ’„ for TCP Cubic).
 Communication Networks Course
Page | 3
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a TCP socket between the Sender and the
Receiver.
3) Send the file.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a TCP connection between the Receiver and
the Sender.
2) Get a connection from the sender.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./TCP_Receiver -p 1234 -algo reno
Starting Receiver...
Waiting for TCP connection...
Sender connected, beginning to receive file...
File transfer completed.
Waiting for Sender response...
Sender sent exit message.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 4
Part B â€“ Reliable User Datagram Protocol (Reliable UDP or RUDP) â€“ 40 points
Youâ€™ve learned that while TCP is reliable, it lacks speed and has an overhead data of 20 bytes,
compering to UDP that needs only 8 bytes of overhead data.
Reliable UDP or RUDP, is a protocol that uses the UDP protocol for a faster transmission of
data, while adding a reliability layer to it, but without adding too much overhead data like
TCP.
A simple sketch for a RUDP connection would look something like this:
Your task in this part is to implement a Reliable protocol using UDP only. For simplicity, your
implementation should only support a handshake, closing scheme, error checking,
acknowledgment of received packets, and retransmission of lost packets.
Guidance:
â€¢ You can use ğ‘ ğ‘’ğ‘¡ğ‘ ğ‘œğ‘ğ‘˜ğ‘œğ‘ğ‘¡(2) for detecting a timeout.
â€¢ You need to build your own protocol, as Reliable UDP isnâ€™t a standard protocol (see a
draft of RUDP in this link), and no official header is provided. You can use this sketch
for a header, but you can come up with your own protocol, as long as it works.
Where:
o ğ‘³ğ’†ğ’ğ’ˆğ’•ğ’‰ is the length of the data itself, without the RUDP header.
o ğ‘ªğ’‰ğ’†ğ’„ğ’Œğ’”ğ’–ğ’ is a 16bit number that validates the correctness of the data.
o ğ‘­ğ’ğ’‚ğ’ˆğ’” is a special byte where we classify the packet itself (SYN, ACK, etc.).
â€¢ In your PDF, you must explain how your implementation of RUDP works â€“ How does
it detect a timeout to do retransmissions, how does the handshake work, what is the
header overhead, etc.
â€¢ For this part, youâ€™ll write three files: ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¨ğ‘·ğ‘°. ğ’„, ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and
ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
Reliable UDP Header proposed sketch
Byte 0 Byte 1 Byte 2 Byte 3
Length (2 Bytes) Checksum (2 Bytes)
Flags (1 Byte)
Figure 1 - RUDP Protocol Architecture, Geeksforgeeks
 Communication Networks Course
Page | 5
Notes:
â€¢ The Sender will send a random generated file and the Receiver will receive it and
measure the time it took for his program to receive the file. The file size should be at
least 2MB.
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). But, as the
RUDP is based on UDP, itâ€™s not reliable. You must use some form of error checking
(like checksum) to ensure that the packet wasnâ€™t alerted during the transfer.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
â€¢ The RUDP needs support only 1 sender and 1 receiver, for simplicity purposes.
Usage:
â€¢ Receiver:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
â€¢ Sender:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port that both the Sender and the Receiver will use.
The ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„ file will contain all the implementations of the RUDP API functions (That is, to
prevent reusing the same chuck of code both in the Sender and the Receiver.).
The API should support at the bare minimum the following functions (you decide what
parameters to implement, and what are the names of the functions, as long as the API is
explained in the PDF):
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘œğ‘ğ‘˜ğ‘’ğ‘¡() â€“ Creating a RUDP socket and creating a handshake between two
peers.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘’ğ‘›ğ‘‘() â€“ Sending data to the peer. The function should wait for an
acknowledgment packet, and if it didnâ€™t receive any, retransmits the data.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘Ÿğ‘’ğ‘ğ‘£() â€“ Receive data from a peer.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ğ‘™ğ‘œğ‘ ğ‘’() â€“ Closes a connection between peers.
 Communication Networks Course
Page | 6
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a UDP socket between the Sender and the
Receiver.
3) Send the file via the RUDP protocol.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a UDP connection between the Receiver and
the Sender.
2) Get a connection from the sender, by the custom
RUDP protocol youâ€™ve built.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./RUDP_Receiver -p 1234
Starting Receiver...
Waiting for RUDP connection...
Connection request received, sending ACK.
Sender connected, beginning to receive file...
File transfer completed.
ACK sent.
Waiting for Sender response...
Sender sent exit message.
ACK sent.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 7
Part C â€“ Research â€“ 30 points
In this part, youâ€™ll conduct research about your implementations of part A and part B.
In the research itself, each one of the versions (TCP version and UDP version) will be run at
least 5 times (meaning that the file transfer will occur at least 5 times) by the following
conditions:
â€¢ For TCP, youâ€™ll run it in TCP Reno and TCP Cubic, alternating each time, for each
scenario, meaning that you run 5 times with TCP Reno in both Sender and Receiver,
and 5 times with TCP Cubic in both Sender and Receiver.
Bonus (5 points): Create a very large data set â€“ 5 times with TCP Reno in both Sender
and Receiver, 5 times with TCP Reno in Sender and TCP Cubic in Receiver, 5 times
with TCP Cubic in Sender and TCP Reno in Receiver, and 5 times with TCP Cubic in
both Sender and Receiver. This will give you a data set large enough, which allows
you to work with, compare with and to reach a definite conclusion.
â€¢ For RUDP, you will run it 5 times for each scenario.
â€¢ For both TCP and RUDP, you will run them on those scenarios of packet loss:
o 0% packet loss â€“ Control group, simulating perfect connection.
o 2% packet loss â€“ Simulating unstable connection that commonly occur.
o 5% packet loss â€“ Simulating bad connection.
o 10% packet loss â€“ Simulating extremely poor connection.
For each scenario, you must provide a filtered PCAP file and relevant screenshots that
explain each one of the steps in the process. (10 points)
After youâ€™ve gathered the data set for both TCP and Reliable UDP, answer the following
questions:
1) In TCP, which congestion control algorithm gave better results overall? TCP Reno or
TCP Cubic? Which one gave better results on high packet loss? Explain how you came
to this conclusion based on the data set youâ€™ve gathered. (5 points)
2) How did your implementation of Reliable UDP perform overall compared to regular
TCP? Which one is better for high packet loss? (5 points)
3) According to the data youâ€™ve gathered, in which scenarios and applications would we
prefer to use TCP and in which situations would we prefer to use reliable UDP?
Explain your answer. (5 points)
 Communication Networks Course
Page | 8
×¢× ×• ×¢×œ ×”×©××œ×•×ª ×”×‘××•×ª )5 × ×§×•×“×•×ª(:
â— ×‘"×¨×©×ª ×××™× ×”" ×”×›×•×•× ×” ×”×™× ×œ×¨×©×ª ×©×‘×” ××¢×˜ ×××•×“ ×—×‘×™×œ×•×ª ×”×•×œ×›×•×ª ×œ××™×‘×•×“. ×‘"×§×©×¨ ××¨×•×š" ×”×›×•×•× ×” ×”×™×
×œ×§×©×¨ TCP ×©×™×© ×‘×• ×”×¨×‘×” ×××•×“ ××™×“×¢ ×œ×©×œ×•×—. ××•×¦×¢ ×œ×”×’×“×™×œ ×‘ -TCP ××ª SSThreshold ×‘×ª×—×™×œ×ª ×”×§×©×¨.
×‘××™×–×” ××”××§×¨×™× ×”×‘××™× ×”×©×™× ×•×™ ×”×–×” ×¢×©×•×™ ×œ×”×•×¢×™×œ ×‘××™×“×” ×”××™×¨×‘×™×ª? × ××§.
.1 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
.2 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.3 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.4 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.5 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.6 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.7 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.8 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
â— A ×©×•×œ×— ×œ -B ×—×‘×™×œ×•×ª ××™×“×¢ ×‘×××¦×¢×•×ª ×§×©×¨ TCP. × ×ª×•×Ÿ ×›×™ ×”×§×©×¨ ××ª×—×™×œ ×¢× ×—×œ×•×Ÿ ×‘×’×•×“×œ 1MSS. ×”×§×©×¨
××¡×ª×™×™× ×‘×¤×¢× ×”×¨××©×•× ×” ×©×”×•× ××’×™×¢ ×œ -SSthresh. ×‘××”×œ×š ×”×§×©×¨ ×œ× ××•×‘×“×•×ª ×—×‘×™×œ×•×ª. × ×¡××Ÿ ×‘×§×™×¦×•×¨:
.SSthresh=S*MSS
× ×ª×•×Ÿ ×›×™ ×œ××•×¨×š ×›×œ ×”×§×©×¨ rwnd < MSS*S.
××”×™ ×”×ª×¤×•×§×” ×©×œ ×”×§×©×¨ ×-A ×œ-B( ×‘ -sec / Bytes )×‘×–××Ÿ ×”× "×œ? × ××§×™.
]S*MSS / [lg (S) * RTT*2 ×‘×¢×¨×š .1
]S*MSS / [S^0.5 * RTT*2 ×‘×¢×¨×š .2
S*MSS / RTT ×‘×¢×¨×š .3
S^2)*MSS / RTT( ×‘×¢×¨×š .4
â— ×©×ª×™ ×ª×—× ×•×ª ××ª×§×©×¨×•×ª ×‘××•×¤×Ÿ ××œ×—×•×˜×™ ×‘×©×™×˜×ª N Back Go.
× ×¡××Ÿ ×‘-X ××ª ×¡×¤×¨×ª ×”×‘×™×§×•×¨×ª ×©×œ ×”×ª.×–. ×©×œ×š. ×× ×©× ×™ ×©×•×ª×¤×™× ××’×™×©×™× ××ª ×”×ª×¨×’×™×œ ×™×—×“, X ×”×•× ×¡×¤×¨×ª
×”×‘×™×§×•×¨×ª ×‘×¢×œ×ª ×”×¢×¨×š ×”× ××•×š ×™×•×ª×¨ ××‘×™×Ÿ ×”×©×ª×™×™×.
×§×¦×‘ ×”×ª×§×©×•×¨×ª ×”×•× 8Gbps, ×•×’×•×“×œ ×›×œ ×—×‘×™×œ×” ×”×•× KByte*X. ×’×“×œ×™ ×”-headers ×•×” -Acks ×–× ×™×—×™×.
ï¿½ğ‘’ğ‘ ï¿½/ï¿½ï¿½ 8 , ×•×”××¨×—×§ ×‘×™×Ÿ ×”×ª×—× ×•×ª ×”×•× 1Km. ×§×¦×‘ ×”×”×ª×¤×©×˜×•×ª ×”×•× 10 â‹… 2
×–××Ÿ ×¢×™×‘×•×“ ×”× ×ª×•× ×™× ×‘×ª×—× ×•×ª ×–× ×™×—.
××£ ×—×‘×™×œ×” ×•××£ Ack ×œ× ×”×•×œ×›×™× ×œ××™×‘×•×“.
â— ××”×• X ×©×œ×š?
â— ××” ×¦×¨×™×š ×œ×”×™×•×ª ×’×•×“×œ ×—×œ×•×Ÿ ×”××©×œ×•×— ×›×“×™ ×œ×”×‘×˜×™×— ×ª×¤×•×§×” ××§×¡×™××œ×™×ª?
 Communication Networks Course
Page | 9
Bonus â€“ Improving the Reliable UDP â€“ 15 points
Note: This part isnâ€™t mandatory and is a bonus only!
In this part, youâ€™ll improve your RUDP implementation by adding the concepts of flow
control and congestion control from TCP. Youâ€™re free to choose which algorithms to
implement, as long as you explain in your PDF which algorithms youâ€™ve used. Youâ€™ll probably
need to make changes in the original design of the RUDP. Changes only need to be to the API
itself, ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„.
Points distribution:
â€¢ Flow control improvement â€“ 7 Points
â€¢ Congestion control improvement â€“ 8 points.
Guidance:
â€¢ For flow control, you must use one of the Sliding window techniques: stop-and-wait
ARQ, Go-Back-N or Selective repeat.
â€¢ List of known TCP congestion control algorithms, which you can use any one of them
for this bonus task, or makeup your own:
Figure 2 â€“ List of known TCP congestion control algorithms, Wikipedia
 Communication Networks Course
Page | 10
Appendix A â€“ Linux local packet loss tool
To simulate a packet loss in a local network, we'll use a Linux tool that's called Linux Traffic
Control (ğ‘¡ğ‘). This requires a full Linux installation, so working with WSL won't work.
If the tool isn't installed in your machine, you can install it by using the following commands:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’
If the installation didn't work, you can use the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’2
To create a packet loss scenario, type the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘ğ‘‘ğ‘‘ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
After creating a packet loss scenario, you can change the percentage by typing the following
command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘â„ğ‘ğ‘›ğ‘”ğ‘’ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
To remove the packet loss scenario, write the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘‘ğ‘’ğ‘™ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š
 Communication Networks Course
Page | 11
Appendix B â€“ ğ’ğ’‚ğ’(ğŸ) system calls
This appendixâ€™s purpose is to give you a better understanding of socket handling in C.
A recommended reference is Beejâ€™s Guide to Network Programming, by Brian â€œBeej
Jorgensenâ€ Hall, which gives a lot of information about sockets in C and functions.
Functions and documentation links:
â€¢ ğ’”ğ’ğ’„ğ’Œğ’†ğ’•(ğŸ) â€“ A Factory method system call that creates a socket with the given
parameters.
â€¢ ğ’ƒğ’Šğ’ğ’…(ğŸ) â€“ Whenever we create a new socket, we need to bind it to a specific port in
our machine, â€œto catch a portâ€. The port number is managed and used by the kernel
to link incoming packets to the corresponding application socket. The port numbers
are usually fixed. The ğ‘ğ‘‘ğ‘‘ğ‘Ÿ parameter must match the current socket that is used.
â€¢ ğ’ğ’Šğ’”ğ’•ğ’†ğ’(ğŸ) â€“ The ğ‘™ğ‘–ğ‘ ğ‘¡ğ‘’ğ‘›(2) system call doesn't do anything in the mean of
communication but only memory allocation (malloc) for stream sockets only. If we
won't allocate memory, any incoming connection will fail.
â€¢ ğ’„ğ’ğ’ğ’ğ’†ğ’„ğ’•(ğŸ) â€“ The ğ‘ğ‘œğ‘›ğ‘›ğ‘’ğ‘ğ‘¡(2) system call starts the link between a client and a
specific IP address and port number. The connection would complete when the
other side will call the ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call.
â€¢ ğ’‚ğ’„ğ’„ğ’†ğ’‘ğ’•(ğŸ) â€“ The ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call accepts the incoming stream connection
request from the other side, by the listening socket. This system call completes the
three-way handshake of stream socket (like TCP) and opens a new socket that has a
direct communication channel only with the other party in the handshake.
â€¢ ğ’”ğ’†ğ’ğ’…(ğŸ) and ğ’”ğ’†ğ’ğ’…ğ’•ğ’(ğŸ) â€“ The ğ‘ ğ‘’ğ‘›ğ‘‘(2) and ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system calls are an analogy
for the ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’(2) system call, specifcly for sockets, with flags set to 0. Those system
calls return the number of bytes that were sent through the socket itself, as the
number of bytes can vary. The ğ‘ ğ‘’ğ‘›ğ‘‘(2)system call designed for stream sockets (like
TCP), while the ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system call designed for datagram connection-less
sockets (like UDP). When the ğ‘ ğ‘’ğ‘›ğ‘‘(2) system call returns 0, it means that the other
party closed the connection.
â€¢ ğ’“ğ’†ğ’„ğ’—(ğŸ) and ğ’“ğ’†ğ’„ğ’—ğ’‡ğ’“ğ’ğ’(ğŸ) â€“ The ğ‘Ÿğ‘’ğ‘ğ‘£(2) and ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system calls are an
analogy for the ğ‘Ÿğ‘’ğ‘ğ‘‘(2) system call, specifically for sockets, with flags set to 0.
Those system calls return the number of bytes that were received through the socket
itself, as the number of bytes can vary. The ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call designed for stream
sockets (like TCP), while the ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system call designed for datagram
connection-less sockets (like UDP). When the ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call returns 0, it means
that the other party closed the connection.
â€¢ ğ’„ğ’ğ’ğ’”ğ’†(ğŸ) and ğ’”ğ’‰ğ’–ğ’•ğ’…ğ’ğ’˜ğ’(ğŸ) â€“ The ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) and ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2) system calls close
the socket. While ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) system call closes the whole socket, the ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2)
system call partially closes the socket for read/write.
 Communication Networks Course
Page | 12
Appendix C â€“ Random data generator
The data that you are going to send in this assignment is randomly generated. You can use
your own file with appropriate size or use the following function (or a function of your own)
to generate the data:
/*
* @brief A random data generator function based on srand() and rand().
* @param size The size of the data to generate (up to 2^32 bytes).
* @return A pointer to the buffer.
*/
char *util_generate_random_data(unsigned int size) {
 char *buffer = NULL;
 // Argument check.
 if (size == 0)
 return NULL;
 buffer = (char *)calloc(size, sizeof(char));
 // Error checking.
 if (buffer == NULL)
 return NULL;
 // Randomize the seed of the random number generator.
 srand(time(NULL));
 for (unsigned int i = 0; i < size; i++)
 *(buffer + i) = ((unsigned int)rand() % 256);
 return buffer;
}
 Communication Networks Course
Page | 13
Appendix D â€“ Checksum function
A checksum is a small-sized block of data derived from another block of digital data for the
purpose of detecting errors that may have been introduced during its transmission or
storage. By themselves, checksums are often used to verify data integrity but are not relied
upon to verify data authenticity.
Below is a simple yet efficient implementation of the checksum function, you can use it for
the assignment, but you can implement your own checksum function.
/*
* @brief A checksum function that returns 16 bit checksum for data.
* @param data The data to do the checksum for.
* @param bytes The length of the data in bytes.
* @return The checksum itself as 16 bit unsigned number.
* @note This function is taken from RFC1071, can be found here:
* @note https://tools.ietf.org/html/rfc1071
* @note It is the simplest way to calculate a checksum and is not very strong.
* However, it is good enough for this assignment.
* @note You are free to use any other checksum function as well.
* You can also use this function as such without any change.
*/
unsigned short int calculate_checksum(void *data, unsigned int bytes) {
 unsigned short int *data_pointer = (unsigned short int *)data;
 unsigned int total_sum = 0;
 // Main summing loop
 while (bytes > 1) {
 total_sum += *data_pointer++;
 bytes -= 2;
 }
 // Add left-over byte, if any
 if (bytes > 0)
 total_sum += *((unsigned char *)data_pointer);
 // Fold 32-bit sum to 16 bits
 while (total_sum >> 16)
 total_sum = (total_sum & 0xFFFF) + (total_sum >> 16);
 return (~((unsigned short int)total_sum));
} Communication Networks Course
Page | 1
Assignment 3 â€“ Transport Layer
Assignment Notes and Instructions
This assignment is to be done in pairs only. You must upload all the necessary files in a ZIP
file named after both of the studentâ€™s ID. For example: ğŸğŸğŸ‘ğŸ’ğŸ“ğŸ”ğŸ•ğŸ–ğŸ—_ğŸ—ğŸ–ğŸ•ğŸ”ğŸ“ğŸ’ğŸ‘ğŸğŸ. ğ’›ğ’Šğ’‘.
1) The assignment must be submitted by the date specified in the submission box.
2) All the assignment files (Code, Wireshark pcap files, PDF) must be submitted in a ZIP file. The
PDF must contain all the necessary screenshots with a description for each one of them.
3) The assignment must be done in pairs only. In exceptional cases, you should send an email to
the course coordinator.
4) You can use any reference material available through the course Moodle website or any
material passed during the exercises.
5) You can use any reference from the web, but copying codes from websites is forbidden; this
includes codes from other GitHub repositories. A student who gets caught in the act will
automatically fail this assignment (score 0). Any website youâ€™ve used to solve the
assignment, every website you used to solve the assignment must be noted in the PDF.
6) No delays in submission without special permission. Lateness without approval will result in
failure of the assignment (score 0).
7) All submissions will be submitted via the course's Moodle website. Email submissions will not
be accepted, resulting in a failure in the assignment.
8) The order and design of the code must be carefully considered. Make sure that the program
output is as clear as possible, comments in the code, and meaningful variable names. You
must also submit a makefile that compiles all the programs.
9) The assignment code must be written in C only.
10) The assignment is personal for each pair, and you should not accept help from other people,
whether outside the university or inside it. You can contact the course staff during reception
hours for help or raise a question in the course forum. Do not transfer code sections
between students, upload solutions or parts of solutions to websites on the Internet or in
various communication groups.
11) Students who copy a solution will receive a 0 in all assignments in the course and a report will
be made to the institutional disciplinary committee.
12) All code files of the assignment are required to both compile and run properly on the Ubuntu
22.04 LTS operating system. This is the operating system where the submissions will be
tested. You mustnâ€™t code it in Windows, as it uses different API for sockets. WSL wonâ€™t work,
as the task needs a tool that works only in a fully Linux environment.
Good Luck!
 Communication Networks Course
Page | 2
Part A â€“ Transmission Control Protocol (TCP) â€“ 30 points
In this part, youâ€™ll write two program files: ğ‘»ğ‘ªğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and ğ‘»ğ‘ªğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
The Sender will send a randomly generated file and the Receiver will receive it and measure
the time it took for his program to receive the file. The file size should be at least 2MB.
When running the Sender and Receiver, they both should support two standard congestion
control algorithms: TCP Reno and TCP Cubic.
Notes:
â€¢ The main goal of this part is to get familiar with the TCP concept of sending
messages between two endpoints.
â€¢ For approaching this part of the assignment, please be sure that you are familiar
with the congestion control algorithms and how to change them using the correct
method in C (see Appendix B for more information).
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). You've
learned that TCP is reliable by design, so you can assume that all the data have been
passed correctly, and thus, no need to recheck.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
Usage:
â€¢ Receiver:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
â€¢ Sender:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port of the Receiver.
â€¢ ğ‘¨ğ‘³ğ‘®ğ‘¶ â€“ The TCP congestion control algorithm that will be used by the party
member (either ğ’“ğ’†ğ’ğ’ for TCP Reno or ğ’„ğ’–ğ’ƒğ’Šğ’„ for TCP Cubic).
 Communication Networks Course
Page | 3
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a TCP socket between the Sender and the
Receiver.
3) Send the file.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a TCP connection between the Receiver and
the Sender.
2) Get a connection from the sender.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./TCP_Receiver -p 1234 -algo reno
Starting Receiver...
Waiting for TCP connection...
Sender connected, beginning to receive file...
File transfer completed.
Waiting for Sender response...
Sender sent exit message.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 4
Part B â€“ Reliable User Datagram Protocol (Reliable UDP or RUDP) â€“ 40 points
Youâ€™ve learned that while TCP is reliable, it lacks speed and has an overhead data of 20 bytes,
compering to UDP that needs only 8 bytes of overhead data.
Reliable UDP or RUDP, is a protocol that uses the UDP protocol for a faster transmission of
data, while adding a reliability layer to it, but without adding too much overhead data like
TCP.
A simple sketch for a RUDP connection would look something like this:
Your task in this part is to implement a Reliable protocol using UDP only. For simplicity, your
implementation should only support a handshake, closing scheme, error checking,
acknowledgment of received packets, and retransmission of lost packets.
Guidance:
â€¢ You can use ğ‘ ğ‘’ğ‘¡ğ‘ ğ‘œğ‘ğ‘˜ğ‘œğ‘ğ‘¡(2) for detecting a timeout.
â€¢ You need to build your own protocol, as Reliable UDP isnâ€™t a standard protocol (see a
draft of RUDP in this link), and no official header is provided. You can use this sketch
for a header, but you can come up with your own protocol, as long as it works.
Where:
o ğ‘³ğ’†ğ’ğ’ˆğ’•ğ’‰ is the length of the data itself, without the RUDP header.
o ğ‘ªğ’‰ğ’†ğ’„ğ’Œğ’”ğ’–ğ’ is a 16bit number that validates the correctness of the data.
o ğ‘­ğ’ğ’‚ğ’ˆğ’” is a special byte where we classify the packet itself (SYN, ACK, etc.).
â€¢ In your PDF, you must explain how your implementation of RUDP works â€“ How does
it detect a timeout to do retransmissions, how does the handshake work, what is the
header overhead, etc.
â€¢ For this part, youâ€™ll write three files: ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¨ğ‘·ğ‘°. ğ’„, ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and
ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
Reliable UDP Header proposed sketch
Byte 0 Byte 1 Byte 2 Byte 3
Length (2 Bytes) Checksum (2 Bytes)
Flags (1 Byte)
Figure 1 - RUDP Protocol Architecture, Geeksforgeeks
 Communication Networks Course
Page | 5
Notes:
â€¢ The Sender will send a random generated file and the Receiver will receive it and
measure the time it took for his program to receive the file. The file size should be at
least 2MB.
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). But, as the
RUDP is based on UDP, itâ€™s not reliable. You must use some form of error checking
(like checksum) to ensure that the packet wasnâ€™t alerted during the transfer.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
â€¢ The RUDP needs support only 1 sender and 1 receiver, for simplicity purposes.
Usage:
â€¢ Receiver:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
â€¢ Sender:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port that both the Sender and the Receiver will use.
The ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„ file will contain all the implementations of the RUDP API functions (That is, to
prevent reusing the same chuck of code both in the Sender and the Receiver.).
The API should support at the bare minimum the following functions (you decide what
parameters to implement, and what are the names of the functions, as long as the API is
explained in the PDF):
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘œğ‘ğ‘˜ğ‘’ğ‘¡() â€“ Creating a RUDP socket and creating a handshake between two
peers.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘’ğ‘›ğ‘‘() â€“ Sending data to the peer. The function should wait for an
acknowledgment packet, and if it didnâ€™t receive any, retransmits the data.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘Ÿğ‘’ğ‘ğ‘£() â€“ Receive data from a peer.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ğ‘™ğ‘œğ‘ ğ‘’() â€“ Closes a connection between peers.
 Communication Networks Course
Page | 6
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a UDP socket between the Sender and the
Receiver.
3) Send the file via the RUDP protocol.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a UDP connection between the Receiver and
the Sender.
2) Get a connection from the sender, by the custom
RUDP protocol youâ€™ve built.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./RUDP_Receiver -p 1234
Starting Receiver...
Waiting for RUDP connection...
Connection request received, sending ACK.
Sender connected, beginning to receive file...
File transfer completed.
ACK sent.
Waiting for Sender response...
Sender sent exit message.
ACK sent.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 7
Part C â€“ Research â€“ 30 points
In this part, youâ€™ll conduct research about your implementations of part A and part B.
In the research itself, each one of the versions (TCP version and UDP version) will be run at
least 5 times (meaning that the file transfer will occur at least 5 times) by the following
conditions:
â€¢ For TCP, youâ€™ll run it in TCP Reno and TCP Cubic, alternating each time, for each
scenario, meaning that you run 5 times with TCP Reno in both Sender and Receiver,
and 5 times with TCP Cubic in both Sender and Receiver.
Bonus (5 points): Create a very large data set â€“ 5 times with TCP Reno in both Sender
and Receiver, 5 times with TCP Reno in Sender and TCP Cubic in Receiver, 5 times
with TCP Cubic in Sender and TCP Reno in Receiver, and 5 times with TCP Cubic in
both Sender and Receiver. This will give you a data set large enough, which allows
you to work with, compare with and to reach a definite conclusion.
â€¢ For RUDP, you will run it 5 times for each scenario.
â€¢ For both TCP and RUDP, you will run them on those scenarios of packet loss:
o 0% packet loss â€“ Control group, simulating perfect connection.
o 2% packet loss â€“ Simulating unstable connection that commonly occur.
o 5% packet loss â€“ Simulating bad connection.
o 10% packet loss â€“ Simulating extremely poor connection.
For each scenario, you must provide a filtered PCAP file and relevant screenshots that
explain each one of the steps in the process. (10 points)
After youâ€™ve gathered the data set for both TCP and Reliable UDP, answer the following
questions:
1) In TCP, which congestion control algorithm gave better results overall? TCP Reno or
TCP Cubic? Which one gave better results on high packet loss? Explain how you came
to this conclusion based on the data set youâ€™ve gathered. (5 points)
2) How did your implementation of Reliable UDP perform overall compared to regular
TCP? Which one is better for high packet loss? (5 points)
3) According to the data youâ€™ve gathered, in which scenarios and applications would we
prefer to use TCP and in which situations would we prefer to use reliable UDP?
Explain your answer. (5 points)
 Communication Networks Course
Page | 8
×¢× ×• ×¢×œ ×”×©××œ×•×ª ×”×‘××•×ª )5 × ×§×•×“×•×ª(:
â— ×‘"×¨×©×ª ×××™× ×”" ×”×›×•×•× ×” ×”×™× ×œ×¨×©×ª ×©×‘×” ××¢×˜ ×××•×“ ×—×‘×™×œ×•×ª ×”×•×œ×›×•×ª ×œ××™×‘×•×“. ×‘"×§×©×¨ ××¨×•×š" ×”×›×•×•× ×” ×”×™×
×œ×§×©×¨ TCP ×©×™×© ×‘×• ×”×¨×‘×” ×××•×“ ××™×“×¢ ×œ×©×œ×•×—. ××•×¦×¢ ×œ×”×’×“×™×œ ×‘ -TCP ××ª SSThreshold ×‘×ª×—×™×œ×ª ×”×§×©×¨.
×‘××™×–×” ××”××§×¨×™× ×”×‘××™× ×”×©×™× ×•×™ ×”×–×” ×¢×©×•×™ ×œ×”×•×¢×™×œ ×‘××™×“×” ×”××™×¨×‘×™×ª? × ××§.
.1 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
.2 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.3 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.4 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.5 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.6 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.7 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.8 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
â— A ×©×•×œ×— ×œ -B ×—×‘×™×œ×•×ª ××™×“×¢ ×‘×××¦×¢×•×ª ×§×©×¨ TCP. × ×ª×•×Ÿ ×›×™ ×”×§×©×¨ ××ª×—×™×œ ×¢× ×—×œ×•×Ÿ ×‘×’×•×“×œ 1MSS. ×”×§×©×¨
××¡×ª×™×™× ×‘×¤×¢× ×”×¨××©×•× ×” ×©×”×•× ××’×™×¢ ×œ -SSthresh. ×‘××”×œ×š ×”×§×©×¨ ×œ× ××•×‘×“×•×ª ×—×‘×™×œ×•×ª. × ×¡××Ÿ ×‘×§×™×¦×•×¨:
.SSthresh=S*MSS
× ×ª×•×Ÿ ×›×™ ×œ××•×¨×š ×›×œ ×”×§×©×¨ rwnd < MSS*S.
××”×™ ×”×ª×¤×•×§×” ×©×œ ×”×§×©×¨ ×-A ×œ-B( ×‘ -sec / Bytes )×‘×–××Ÿ ×”× "×œ? × ××§×™.
]S*MSS / [lg (S) * RTT*2 ×‘×¢×¨×š .1
]S*MSS / [S^0.5 * RTT*2 ×‘×¢×¨×š .2
S*MSS / RTT ×‘×¢×¨×š .3
S^2)*MSS / RTT( ×‘×¢×¨×š .4
â— ×©×ª×™ ×ª×—× ×•×ª ××ª×§×©×¨×•×ª ×‘××•×¤×Ÿ ××œ×—×•×˜×™ ×‘×©×™×˜×ª N Back Go.
× ×¡××Ÿ ×‘-X ××ª ×¡×¤×¨×ª ×”×‘×™×§×•×¨×ª ×©×œ ×”×ª.×–. ×©×œ×š. ×× ×©× ×™ ×©×•×ª×¤×™× ××’×™×©×™× ××ª ×”×ª×¨×’×™×œ ×™×—×“, X ×”×•× ×¡×¤×¨×ª
×”×‘×™×§×•×¨×ª ×‘×¢×œ×ª ×”×¢×¨×š ×”× ××•×š ×™×•×ª×¨ ××‘×™×Ÿ ×”×©×ª×™×™×.
×§×¦×‘ ×”×ª×§×©×•×¨×ª ×”×•× 8Gbps, ×•×’×•×“×œ ×›×œ ×—×‘×™×œ×” ×”×•× KByte*X. ×’×“×œ×™ ×”-headers ×•×” -Acks ×–× ×™×—×™×.
ï¿½ğ‘’ğ‘ ï¿½/ï¿½ï¿½ 8 , ×•×”××¨×—×§ ×‘×™×Ÿ ×”×ª×—× ×•×ª ×”×•× 1Km. ×§×¦×‘ ×”×”×ª×¤×©×˜×•×ª ×”×•× 10 â‹… 2
×–××Ÿ ×¢×™×‘×•×“ ×”× ×ª×•× ×™× ×‘×ª×—× ×•×ª ×–× ×™×—.
××£ ×—×‘×™×œ×” ×•××£ Ack ×œ× ×”×•×œ×›×™× ×œ××™×‘×•×“.
â— ××”×• X ×©×œ×š?
â— ××” ×¦×¨×™×š ×œ×”×™×•×ª ×’×•×“×œ ×—×œ×•×Ÿ ×”××©×œ×•×— ×›×“×™ ×œ×”×‘×˜×™×— ×ª×¤×•×§×” ××§×¡×™××œ×™×ª?
 Communication Networks Course
Page | 9
Bonus â€“ Improving the Reliable UDP â€“ 15 points
Note: This part isnâ€™t mandatory and is a bonus only!
In this part, youâ€™ll improve your RUDP implementation by adding the concepts of flow
control and congestion control from TCP. Youâ€™re free to choose which algorithms to
implement, as long as you explain in your PDF which algorithms youâ€™ve used. Youâ€™ll probably
need to make changes in the original design of the RUDP. Changes only need to be to the API
itself, ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„.
Points distribution:
â€¢ Flow control improvement â€“ 7 Points
â€¢ Congestion control improvement â€“ 8 points.
Guidance:
â€¢ For flow control, you must use one of the Sliding window techniques: stop-and-wait
ARQ, Go-Back-N or Selective repeat.
â€¢ List of known TCP congestion control algorithms, which you can use any one of them
for this bonus task, or makeup your own:
Figure 2 â€“ List of known TCP congestion control algorithms, Wikipedia
 Communication Networks Course
Page | 10
Appendix A â€“ Linux local packet loss tool
To simulate a packet loss in a local network, we'll use a Linux tool that's called Linux Traffic
Control (ğ‘¡ğ‘). This requires a full Linux installation, so working with WSL won't work.
If the tool isn't installed in your machine, you can install it by using the following commands:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’
If the installation didn't work, you can use the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’2
To create a packet loss scenario, type the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘ğ‘‘ğ‘‘ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
After creating a packet loss scenario, you can change the percentage by typing the following
command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘â„ğ‘ğ‘›ğ‘”ğ‘’ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
To remove the packet loss scenario, write the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘‘ğ‘’ğ‘™ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š
 Communication Networks Course
Page | 11
Appendix B â€“ ğ’ğ’‚ğ’(ğŸ) system calls
This appendixâ€™s purpose is to give you a better understanding of socket handling in C.
A recommended reference is Beejâ€™s Guide to Network Programming, by Brian â€œBeej
Jorgensenâ€ Hall, which gives a lot of information about sockets in C and functions.
Functions and documentation links:
â€¢ ğ’”ğ’ğ’„ğ’Œğ’†ğ’•(ğŸ) â€“ A Factory method system call that creates a socket with the given
parameters.
â€¢ ğ’ƒğ’Šğ’ğ’…(ğŸ) â€“ Whenever we create a new socket, we need to bind it to a specific port in
our machine, â€œto catch a portâ€. The port number is managed and used by the kernel
to link incoming packets to the corresponding application socket. The port numbers
are usually fixed. The ğ‘ğ‘‘ğ‘‘ğ‘Ÿ parameter must match the current socket that is used.
â€¢ ğ’ğ’Šğ’”ğ’•ğ’†ğ’(ğŸ) â€“ The ğ‘™ğ‘–ğ‘ ğ‘¡ğ‘’ğ‘›(2) system call doesn't do anything in the mean of
communication but only memory allocation (malloc) for stream sockets only. If we
won't allocate memory, any incoming connection will fail.
â€¢ ğ’„ğ’ğ’ğ’ğ’†ğ’„ğ’•(ğŸ) â€“ The ğ‘ğ‘œğ‘›ğ‘›ğ‘’ğ‘ğ‘¡(2) system call starts the link between a client and a
specific IP address and port number. The connection would complete when the
other side will call the ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call.
â€¢ ğ’‚ğ’„ğ’„ğ’†ğ’‘ğ’•(ğŸ) â€“ The ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call accepts the incoming stream connection
request from the other side, by the listening socket. This system call completes the
three-way handshake of stream socket (like TCP) and opens a new socket that has a
direct communication channel only with the other party in the handshake.
â€¢ ğ’”ğ’†ğ’ğ’…(ğŸ) and ğ’”ğ’†ğ’ğ’…ğ’•ğ’(ğŸ) â€“ The ğ‘ ğ‘’ğ‘›ğ‘‘(2) and ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system calls are an analogy
for the ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’(2) system call, specifcly for sockets, with flags set to 0. Those system
calls return the number of bytes that were sent through the socket itself, as the
number of bytes can vary. The ğ‘ ğ‘’ğ‘›ğ‘‘(2)system call designed for stream sockets (like
TCP), while the ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system call designed for datagram connection-less
sockets (like UDP). When the ğ‘ ğ‘’ğ‘›ğ‘‘(2) system call returns 0, it means that the other
party closed the connection.
â€¢ ğ’“ğ’†ğ’„ğ’—(ğŸ) and ğ’“ğ’†ğ’„ğ’—ğ’‡ğ’“ğ’ğ’(ğŸ) â€“ The ğ‘Ÿğ‘’ğ‘ğ‘£(2) and ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system calls are an
analogy for the ğ‘Ÿğ‘’ğ‘ğ‘‘(2) system call, specifically for sockets, with flags set to 0.
Those system calls return the number of bytes that were received through the socket
itself, as the number of bytes can vary. The ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call designed for stream
sockets (like TCP), while the ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system call designed for datagram
connection-less sockets (like UDP). When the ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call returns 0, it means
that the other party closed the connection.
â€¢ ğ’„ğ’ğ’ğ’”ğ’†(ğŸ) and ğ’”ğ’‰ğ’–ğ’•ğ’…ğ’ğ’˜ğ’(ğŸ) â€“ The ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) and ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2) system calls close
the socket. While ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) system call closes the whole socket, the ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2)
system call partially closes the socket for read/write.
 Communication Networks Course
Page | 12
Appendix C â€“ Random data generator
The data that you are going to send in this assignment is randomly generated. You can use
your own file with appropriate size or use the following function (or a function of your own)
to generate the data:
/*
* @brief A random data generator function based on srand() and rand().
* @param size The size of the data to generate (up to 2^32 bytes).
* @return A pointer to the buffer.
*/
char *util_generate_random_data(unsigned int size) {
 char *buffer = NULL;
 // Argument check.
 if (size == 0)
 return NULL;
 buffer = (char *)calloc(size, sizeof(char));
 // Error checking.
 if (buffer == NULL)
 return NULL;
 // Randomize the seed of the random number generator.
 srand(time(NULL));
 for (unsigned int i = 0; i < size; i++)
 *(buffer + i) = ((unsigned int)rand() % 256);
 return buffer;
}
 Communication Networks Course
Page | 13
Appendix D â€“ Checksum function
A checksum is a small-sized block of data derived from another block of digital data for the
purpose of detecting errors that may have been introduced during its transmission or
storage. By themselves, checksums are often used to verify data integrity but are not relied
upon to verify data authenticity.
Below is a simple yet efficient implementation of the checksum function, you can use it for
the assignment, but you can implement your own checksum function.
/*
* @brief A checksum function that returns 16 bit checksum for data.
* @param data The data to do the checksum for.
* @param bytes The length of the data in bytes.
* @return The checksum itself as 16 bit unsigned number.
* @note This function is taken from RFC1071, can be found here:
* @note https://tools.ietf.org/html/rfc1071
* @note It is the simplest way to calculate a checksum and is not very strong.
* However, it is good enough for this assignment.
* @note You are free to use any other checksum function as well.
* You can also use this function as such without any change.
*/
unsigned short int calculate_checksum(void *data, unsigned int bytes) {
 unsigned short int *data_pointer = (unsigned short int *)data;
 unsigned int total_sum = 0;
 // Main summing loop
 while (bytes > 1) {
 total_sum += *data_pointer++;
 bytes -= 2;
 }
 // Add left-over byte, if any
 if (bytes > 0)
 total_sum += *((unsigned char *)data_pointer);
 // Fold 32-bit sum to 16 bits
 while (total_sum >> 16)
 total_sum = (total_sum & 0xFFFF) + (total_sum >> 16);
 return (~((unsigned short int)total_sum));
} Communication Networks Course
Page | 1
Assignment 3 â€“ Transport Layer
Assignment Notes and Instructions
This assignment is to be done in pairs only. You must upload all the necessary files in a ZIP
file named after both of the studentâ€™s ID. For example: ğŸğŸğŸ‘ğŸ’ğŸ“ğŸ”ğŸ•ğŸ–ğŸ—_ğŸ—ğŸ–ğŸ•ğŸ”ğŸ“ğŸ’ğŸ‘ğŸğŸ. ğ’›ğ’Šğ’‘.
1) The assignment must be submitted by the date specified in the submission box.
2) All the assignment files (Code, Wireshark pcap files, PDF) must be submitted in a ZIP file. The
PDF must contain all the necessary screenshots with a description for each one of them.
3) The assignment must be done in pairs only. In exceptional cases, you should send an email to
the course coordinator.
4) You can use any reference material available through the course Moodle website or any
material passed during the exercises.
5) You can use any reference from the web, but copying codes from websites is forbidden; this
includes codes from other GitHub repositories. A student who gets caught in the act will
automatically fail this assignment (score 0). Any website youâ€™ve used to solve the
assignment, every website you used to solve the assignment must be noted in the PDF.
6) No delays in submission without special permission. Lateness without approval will result in
failure of the assignment (score 0).
7) All submissions will be submitted via the course's Moodle website. Email submissions will not
be accepted, resulting in a failure in the assignment.
8) The order and design of the code must be carefully considered. Make sure that the program
output is as clear as possible, comments in the code, and meaningful variable names. You
must also submit a makefile that compiles all the programs.
9) The assignment code must be written in C only.
10) The assignment is personal for each pair, and you should not accept help from other people,
whether outside the university or inside it. You can contact the course staff during reception
hours for help or raise a question in the course forum. Do not transfer code sections
between students, upload solutions or parts of solutions to websites on the Internet or in
various communication groups.
11) Students who copy a solution will receive a 0 in all assignments in the course and a report will
be made to the institutional disciplinary committee.
12) All code files of the assignment are required to both compile and run properly on the Ubuntu
22.04 LTS operating system. This is the operating system where the submissions will be
tested. You mustnâ€™t code it in Windows, as it uses different API for sockets. WSL wonâ€™t work,
as the task needs a tool that works only in a fully Linux environment.
Good Luck!
 Communication Networks Course
Page | 2
Part A â€“ Transmission Control Protocol (TCP) â€“ 30 points
In this part, youâ€™ll write two program files: ğ‘»ğ‘ªğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and ğ‘»ğ‘ªğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
The Sender will send a randomly generated file and the Receiver will receive it and measure
the time it took for his program to receive the file. The file size should be at least 2MB.
When running the Sender and Receiver, they both should support two standard congestion
control algorithms: TCP Reno and TCP Cubic.
Notes:
â€¢ The main goal of this part is to get familiar with the TCP concept of sending
messages between two endpoints.
â€¢ For approaching this part of the assignment, please be sure that you are familiar
with the congestion control algorithms and how to change them using the correct
method in C (see Appendix B for more information).
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). You've
learned that TCP is reliable by design, so you can assume that all the data have been
passed correctly, and thus, no need to recheck.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
Usage:
â€¢ Receiver:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
â€¢ Sender:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port of the Receiver.
â€¢ ğ‘¨ğ‘³ğ‘®ğ‘¶ â€“ The TCP congestion control algorithm that will be used by the party
member (either ğ’“ğ’†ğ’ğ’ for TCP Reno or ğ’„ğ’–ğ’ƒğ’Šğ’„ for TCP Cubic).
 Communication Networks Course
Page | 3
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a TCP socket between the Sender and the
Receiver.
3) Send the file.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a TCP connection between the Receiver and
the Sender.
2) Get a connection from the sender.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./TCP_Receiver -p 1234 -algo reno
Starting Receiver...
Waiting for TCP connection...
Sender connected, beginning to receive file...
File transfer completed.
Waiting for Sender response...
Sender sent exit message.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 4
Part B â€“ Reliable User Datagram Protocol (Reliable UDP or RUDP) â€“ 40 points
Youâ€™ve learned that while TCP is reliable, it lacks speed and has an overhead data of 20 bytes,
compering to UDP that needs only 8 bytes of overhead data.
Reliable UDP or RUDP, is a protocol that uses the UDP protocol for a faster transmission of
data, while adding a reliability layer to it, but without adding too much overhead data like
TCP.
A simple sketch for a RUDP connection would look something like this:
Your task in this part is to implement a Reliable protocol using UDP only. For simplicity, your
implementation should only support a handshake, closing scheme, error checking,
acknowledgment of received packets, and retransmission of lost packets.
Guidance:
â€¢ You can use ğ‘ ğ‘’ğ‘¡ğ‘ ğ‘œğ‘ğ‘˜ğ‘œğ‘ğ‘¡(2) for detecting a timeout.
â€¢ You need to build your own protocol, as Reliable UDP isnâ€™t a standard protocol (see a
draft of RUDP in this link), and no official header is provided. You can use this sketch
for a header, but you can come up with your own protocol, as long as it works.
Where:
o ğ‘³ğ’†ğ’ğ’ˆğ’•ğ’‰ is the length of the data itself, without the RUDP header.
o ğ‘ªğ’‰ğ’†ğ’„ğ’Œğ’”ğ’–ğ’ is a 16bit number that validates the correctness of the data.
o ğ‘­ğ’ğ’‚ğ’ˆğ’” is a special byte where we classify the packet itself (SYN, ACK, etc.).
â€¢ In your PDF, you must explain how your implementation of RUDP works â€“ How does
it detect a timeout to do retransmissions, how does the handshake work, what is the
header overhead, etc.
â€¢ For this part, youâ€™ll write three files: ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¨ğ‘·ğ‘°. ğ’„, ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and
ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
Reliable UDP Header proposed sketch
Byte 0 Byte 1 Byte 2 Byte 3
Length (2 Bytes) Checksum (2 Bytes)
Flags (1 Byte)
Figure 1 - RUDP Protocol Architecture, Geeksforgeeks
 Communication Networks Course
Page | 5
Notes:
â€¢ The Sender will send a random generated file and the Receiver will receive it and
measure the time it took for his program to receive the file. The file size should be at
least 2MB.
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). But, as the
RUDP is based on UDP, itâ€™s not reliable. You must use some form of error checking
(like checksum) to ensure that the packet wasnâ€™t alerted during the transfer.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
â€¢ The RUDP needs support only 1 sender and 1 receiver, for simplicity purposes.
Usage:
â€¢ Receiver:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
â€¢ Sender:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port that both the Sender and the Receiver will use.
The ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„ file will contain all the implementations of the RUDP API functions (That is, to
prevent reusing the same chuck of code both in the Sender and the Receiver.).
The API should support at the bare minimum the following functions (you decide what
parameters to implement, and what are the names of the functions, as long as the API is
explained in the PDF):
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘œğ‘ğ‘˜ğ‘’ğ‘¡() â€“ Creating a RUDP socket and creating a handshake between two
peers.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘’ğ‘›ğ‘‘() â€“ Sending data to the peer. The function should wait for an
acknowledgment packet, and if it didnâ€™t receive any, retransmits the data.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘Ÿğ‘’ğ‘ğ‘£() â€“ Receive data from a peer.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ğ‘™ğ‘œğ‘ ğ‘’() â€“ Closes a connection between peers.
 Communication Networks Course
Page | 6
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a UDP socket between the Sender and the
Receiver.
3) Send the file via the RUDP protocol.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a UDP connection between the Receiver and
the Sender.
2) Get a connection from the sender, by the custom
RUDP protocol youâ€™ve built.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./RUDP_Receiver -p 1234
Starting Receiver...
Waiting for RUDP connection...
Connection request received, sending ACK.
Sender connected, beginning to receive file...
File transfer completed.
ACK sent.
Waiting for Sender response...
Sender sent exit message.
ACK sent.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 7
Part C â€“ Research â€“ 30 points
In this part, youâ€™ll conduct research about your implementations of part A and part B.
In the research itself, each one of the versions (TCP version and UDP version) will be run at
least 5 times (meaning that the file transfer will occur at least 5 times) by the following
conditions:
â€¢ For TCP, youâ€™ll run it in TCP Reno and TCP Cubic, alternating each time, for each
scenario, meaning that you run 5 times with TCP Reno in both Sender and Receiver,
and 5 times with TCP Cubic in both Sender and Receiver.
Bonus (5 points): Create a very large data set â€“ 5 times with TCP Reno in both Sender
and Receiver, 5 times with TCP Reno in Sender and TCP Cubic in Receiver, 5 times
with TCP Cubic in Sender and TCP Reno in Receiver, and 5 times with TCP Cubic in
both Sender and Receiver. This will give you a data set large enough, which allows
you to work with, compare with and to reach a definite conclusion.
â€¢ For RUDP, you will run it 5 times for each scenario.
â€¢ For both TCP and RUDP, you will run them on those scenarios of packet loss:
o 0% packet loss â€“ Control group, simulating perfect connection.
o 2% packet loss â€“ Simulating unstable connection that commonly occur.
o 5% packet loss â€“ Simulating bad connection.
o 10% packet loss â€“ Simulating extremely poor connection.
For each scenario, you must provide a filtered PCAP file and relevant screenshots that
explain each one of the steps in the process. (10 points)
After youâ€™ve gathered the data set for both TCP and Reliable UDP, answer the following
questions:
1) In TCP, which congestion control algorithm gave better results overall? TCP Reno or
TCP Cubic? Which one gave better results on high packet loss? Explain how you came
to this conclusion based on the data set youâ€™ve gathered. (5 points)
2) How did your implementation of Reliable UDP perform overall compared to regular
TCP? Which one is better for high packet loss? (5 points)
3) According to the data youâ€™ve gathered, in which scenarios and applications would we
prefer to use TCP and in which situations would we prefer to use reliable UDP?
Explain your answer. (5 points)
 Communication Networks Course
Page | 8
×¢× ×• ×¢×œ ×”×©××œ×•×ª ×”×‘××•×ª )5 × ×§×•×“×•×ª(:
â— ×‘"×¨×©×ª ×××™× ×”" ×”×›×•×•× ×” ×”×™× ×œ×¨×©×ª ×©×‘×” ××¢×˜ ×××•×“ ×—×‘×™×œ×•×ª ×”×•×œ×›×•×ª ×œ××™×‘×•×“. ×‘"×§×©×¨ ××¨×•×š" ×”×›×•×•× ×” ×”×™×
×œ×§×©×¨ TCP ×©×™×© ×‘×• ×”×¨×‘×” ×××•×“ ××™×“×¢ ×œ×©×œ×•×—. ××•×¦×¢ ×œ×”×’×“×™×œ ×‘ -TCP ××ª SSThreshold ×‘×ª×—×™×œ×ª ×”×§×©×¨.
×‘××™×–×” ××”××§×¨×™× ×”×‘××™× ×”×©×™× ×•×™ ×”×–×” ×¢×©×•×™ ×œ×”×•×¢×™×œ ×‘××™×“×” ×”××™×¨×‘×™×ª? × ××§.
.1 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
.2 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.3 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.4 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.5 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.6 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.7 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.8 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
â— A ×©×•×œ×— ×œ -B ×—×‘×™×œ×•×ª ××™×“×¢ ×‘×××¦×¢×•×ª ×§×©×¨ TCP. × ×ª×•×Ÿ ×›×™ ×”×§×©×¨ ××ª×—×™×œ ×¢× ×—×œ×•×Ÿ ×‘×’×•×“×œ 1MSS. ×”×§×©×¨
××¡×ª×™×™× ×‘×¤×¢× ×”×¨××©×•× ×” ×©×”×•× ××’×™×¢ ×œ -SSthresh. ×‘××”×œ×š ×”×§×©×¨ ×œ× ××•×‘×“×•×ª ×—×‘×™×œ×•×ª. × ×¡××Ÿ ×‘×§×™×¦×•×¨:
.SSthresh=S*MSS
× ×ª×•×Ÿ ×›×™ ×œ××•×¨×š ×›×œ ×”×§×©×¨ rwnd < MSS*S.
××”×™ ×”×ª×¤×•×§×” ×©×œ ×”×§×©×¨ ×-A ×œ-B( ×‘ -sec / Bytes )×‘×–××Ÿ ×”× "×œ? × ××§×™.
]S*MSS / [lg (S) * RTT*2 ×‘×¢×¨×š .1
]S*MSS / [S^0.5 * RTT*2 ×‘×¢×¨×š .2
S*MSS / RTT ×‘×¢×¨×š .3
S^2)*MSS / RTT( ×‘×¢×¨×š .4
â— ×©×ª×™ ×ª×—× ×•×ª ××ª×§×©×¨×•×ª ×‘××•×¤×Ÿ ××œ×—×•×˜×™ ×‘×©×™×˜×ª N Back Go.
× ×¡××Ÿ ×‘-X ××ª ×¡×¤×¨×ª ×”×‘×™×§×•×¨×ª ×©×œ ×”×ª.×–. ×©×œ×š. ×× ×©× ×™ ×©×•×ª×¤×™× ××’×™×©×™× ××ª ×”×ª×¨×’×™×œ ×™×—×“, X ×”×•× ×¡×¤×¨×ª
×”×‘×™×§×•×¨×ª ×‘×¢×œ×ª ×”×¢×¨×š ×”× ××•×š ×™×•×ª×¨ ××‘×™×Ÿ ×”×©×ª×™×™×.
×§×¦×‘ ×”×ª×§×©×•×¨×ª ×”×•× 8Gbps, ×•×’×•×“×œ ×›×œ ×—×‘×™×œ×” ×”×•× KByte*X. ×’×“×œ×™ ×”-headers ×•×” -Acks ×–× ×™×—×™×.
ï¿½ğ‘’ğ‘ ï¿½/ï¿½ï¿½ 8 , ×•×”××¨×—×§ ×‘×™×Ÿ ×”×ª×—× ×•×ª ×”×•× 1Km. ×§×¦×‘ ×”×”×ª×¤×©×˜×•×ª ×”×•× 10 â‹… 2
×–××Ÿ ×¢×™×‘×•×“ ×”× ×ª×•× ×™× ×‘×ª×—× ×•×ª ×–× ×™×—.
××£ ×—×‘×™×œ×” ×•××£ Ack ×œ× ×”×•×œ×›×™× ×œ××™×‘×•×“.
â— ××”×• X ×©×œ×š?
â— ××” ×¦×¨×™×š ×œ×”×™×•×ª ×’×•×“×œ ×—×œ×•×Ÿ ×”××©×œ×•×— ×›×“×™ ×œ×”×‘×˜×™×— ×ª×¤×•×§×” ××§×¡×™××œ×™×ª?
 Communication Networks Course
Page | 9
Bonus â€“ Improving the Reliable UDP â€“ 15 points
Note: This part isnâ€™t mandatory and is a bonus only!
In this part, youâ€™ll improve your RUDP implementation by adding the concepts of flow
control and congestion control from TCP. Youâ€™re free to choose which algorithms to
implement, as long as you explain in your PDF which algorithms youâ€™ve used. Youâ€™ll probably
need to make changes in the original design of the RUDP. Changes only need to be to the API
itself, ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„.
Points distribution:
â€¢ Flow control improvement â€“ 7 Points
â€¢ Congestion control improvement â€“ 8 points.
Guidance:
â€¢ For flow control, you must use one of the Sliding window techniques: stop-and-wait
ARQ, Go-Back-N or Selective repeat.
â€¢ List of known TCP congestion control algorithms, which you can use any one of them
for this bonus task, or makeup your own:
Figure 2 â€“ List of known TCP congestion control algorithms, Wikipedia
 Communication Networks Course
Page | 10
Appendix A â€“ Linux local packet loss tool
To simulate a packet loss in a local network, we'll use a Linux tool that's called Linux Traffic
Control (ğ‘¡ğ‘). This requires a full Linux installation, so working with WSL won't work.
If the tool isn't installed in your machine, you can install it by using the following commands:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’
If the installation didn't work, you can use the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’2
To create a packet loss scenario, type the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘ğ‘‘ğ‘‘ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
After creating a packet loss scenario, you can change the percentage by typing the following
command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘â„ğ‘ğ‘›ğ‘”ğ‘’ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
To remove the packet loss scenario, write the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘‘ğ‘’ğ‘™ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š
 Communication Networks Course
Page | 11
Appendix B â€“ ğ’ğ’‚ğ’(ğŸ) system calls
This appendixâ€™s purpose is to give you a better understanding of socket handling in C.
A recommended reference is Beejâ€™s Guide to Network Programming, by Brian â€œBeej
Jorgensenâ€ Hall, which gives a lot of information about sockets in C and functions.
Functions and documentation links:
â€¢ ğ’”ğ’ğ’„ğ’Œğ’†ğ’•(ğŸ) â€“ A Factory method system call that creates a socket with the given
parameters.
â€¢ ğ’ƒğ’Šğ’ğ’…(ğŸ) â€“ Whenever we create a new socket, we need to bind it to a specific port in
our machine, â€œto catch a portâ€. The port number is managed and used by the kernel
to link incoming packets to the corresponding application socket. The port numbers
are usually fixed. The ğ‘ğ‘‘ğ‘‘ğ‘Ÿ parameter must match the current socket that is used.
â€¢ ğ’ğ’Šğ’”ğ’•ğ’†ğ’(ğŸ) â€“ The ğ‘™ğ‘–ğ‘ ğ‘¡ğ‘’ğ‘›(2) system call doesn't do anything in the mean of
communication but only memory allocation (malloc) for stream sockets only. If we
won't allocate memory, any incoming connection will fail.
â€¢ ğ’„ğ’ğ’ğ’ğ’†ğ’„ğ’•(ğŸ) â€“ The ğ‘ğ‘œğ‘›ğ‘›ğ‘’ğ‘ğ‘¡(2) system call starts the link between a client and a
specific IP address and port number. The connection would complete when the
other side will call the ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call.
â€¢ ğ’‚ğ’„ğ’„ğ’†ğ’‘ğ’•(ğŸ) â€“ The ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call accepts the incoming stream connection
request from the other side, by the listening socket. This system call completes the
three-way handshake of stream socket (like TCP) and opens a new socket that has a
direct communication channel only with the other party in the handshake.
â€¢ ğ’”ğ’†ğ’ğ’…(ğŸ) and ğ’”ğ’†ğ’ğ’…ğ’•ğ’(ğŸ) â€“ The ğ‘ ğ‘’ğ‘›ğ‘‘(2) and ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system calls are an analogy
for the ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’(2) system call, specifcly for sockets, with flags set to 0. Those system
calls return the number of bytes that were sent through the socket itself, as the
number of bytes can vary. The ğ‘ ğ‘’ğ‘›ğ‘‘(2)system call designed for stream sockets (like
TCP), while the ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system call designed for datagram connection-less
sockets (like UDP). When the ğ‘ ğ‘’ğ‘›ğ‘‘(2) system call returns 0, it means that the other
party closed the connection.
â€¢ ğ’“ğ’†ğ’„ğ’—(ğŸ) and ğ’“ğ’†ğ’„ğ’—ğ’‡ğ’“ğ’ğ’(ğŸ) â€“ The ğ‘Ÿğ‘’ğ‘ğ‘£(2) and ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system calls are an
analogy for the ğ‘Ÿğ‘’ğ‘ğ‘‘(2) system call, specifically for sockets, with flags set to 0.
Those system calls return the number of bytes that were received through the socket
itself, as the number of bytes can vary. The ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call designed for stream
sockets (like TCP), while the ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system call designed for datagram
connection-less sockets (like UDP). When the ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call returns 0, it means
that the other party closed the connection.
â€¢ ğ’„ğ’ğ’ğ’”ğ’†(ğŸ) and ğ’”ğ’‰ğ’–ğ’•ğ’…ğ’ğ’˜ğ’(ğŸ) â€“ The ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) and ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2) system calls close
the socket. While ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) system call closes the whole socket, the ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2)
system call partially closes the socket for read/write.
 Communication Networks Course
Page | 12
Appendix C â€“ Random data generator
The data that you are going to send in this assignment is randomly generated. You can use
your own file with appropriate size or use the following function (or a function of your own)
to generate the data:
/*
* @brief A random data generator function based on srand() and rand().
* @param size The size of the data to generate (up to 2^32 bytes).
* @return A pointer to the buffer.
*/
char *util_generate_random_data(unsigned int size) {
 char *buffer = NULL;
 // Argument check.
 if (size == 0)
 return NULL;
 buffer = (char *)calloc(size, sizeof(char));
 // Error checking.
 if (buffer == NULL)
 return NULL;
 // Randomize the seed of the random number generator.
 srand(time(NULL));
 for (unsigned int i = 0; i < size; i++)
 *(buffer + i) = ((unsigned int)rand() % 256);
 return buffer;
}
 Communication Networks Course
Page | 13
Appendix D â€“ Checksum function
A checksum is a small-sized block of data derived from another block of digital data for the
purpose of detecting errors that may have been introduced during its transmission or
storage. By themselves, checksums are often used to verify data integrity but are not relied
upon to verify data authenticity.
Below is a simple yet efficient implementation of the checksum function, you can use it for
the assignment, but you can implement your own checksum function.
/*
* @brief A checksum function that returns 16 bit checksum for data.
* @param data The data to do the checksum for.
* @param bytes The length of the data in bytes.
* @return The checksum itself as 16 bit unsigned number.
* @note This function is taken from RFC1071, can be found here:
* @note https://tools.ietf.org/html/rfc1071
* @note It is the simplest way to calculate a checksum and is not very strong.
* However, it is good enough for this assignment.
* @note You are free to use any other checksum function as well.
* You can also use this function as such without any change.
*/
unsigned short int calculate_checksum(void *data, unsigned int bytes) {
 unsigned short int *data_pointer = (unsigned short int *)data;
 unsigned int total_sum = 0;
 // Main summing loop
 while (bytes > 1) {
 total_sum += *data_pointer++;
 bytes -= 2;
 }
 // Add left-over byte, if any
 if (bytes > 0)
 total_sum += *((unsigned char *)data_pointer);
 // Fold 32-bit sum to 16 bits
 while (total_sum >> 16)
 total_sum = (total_sum & 0xFFFF) + (total_sum >> 16);
 return (~((unsigned short int)total_sum));
} Communication Networks Course
Page | 1
Assignment 3 â€“ Transport Layer
Assignment Notes and Instructions
This assignment is to be done in pairs only. You must upload all the necessary files in a ZIP
file named after both of the studentâ€™s ID. For example: ğŸğŸğŸ‘ğŸ’ğŸ“ğŸ”ğŸ•ğŸ–ğŸ—_ğŸ—ğŸ–ğŸ•ğŸ”ğŸ“ğŸ’ğŸ‘ğŸğŸ. ğ’›ğ’Šğ’‘.
1) The assignment must be submitted by the date specified in the submission box.
2) All the assignment files (Code, Wireshark pcap files, PDF) must be submitted in a ZIP file. The
PDF must contain all the necessary screenshots with a description for each one of them.
3) The assignment must be done in pairs only. In exceptional cases, you should send an email to
the course coordinator.
4) You can use any reference material available through the course Moodle website or any
material passed during the exercises.
5) You can use any reference from the web, but copying codes from websites is forbidden; this
includes codes from other GitHub repositories. A student who gets caught in the act will
automatically fail this assignment (score 0). Any website youâ€™ve used to solve the
assignment, every website you used to solve the assignment must be noted in the PDF.
6) No delays in submission without special permission. Lateness without approval will result in
failure of the assignment (score 0).
7) All submissions will be submitted via the course's Moodle website. Email submissions will not
be accepted, resulting in a failure in the assignment.
8) The order and design of the code must be carefully considered. Make sure that the program
output is as clear as possible, comments in the code, and meaningful variable names. You
must also submit a makefile that compiles all the programs.
9) The assignment code must be written in C only.
10) The assignment is personal for each pair, and you should not accept help from other people,
whether outside the university or inside it. You can contact the course staff during reception
hours for help or raise a question in the course forum. Do not transfer code sections
between students, upload solutions or parts of solutions to websites on the Internet or in
various communication groups.
11) Students who copy a solution will receive a 0 in all assignments in the course and a report will
be made to the institutional disciplinary committee.
12) All code files of the assignment are required to both compile and run properly on the Ubuntu
22.04 LTS operating system. This is the operating system where the submissions will be
tested. You mustnâ€™t code it in Windows, as it uses different API for sockets. WSL wonâ€™t work,
as the task needs a tool that works only in a fully Linux environment.
Good Luck!
 Communication Networks Course
Page | 2
Part A â€“ Transmission Control Protocol (TCP) â€“ 30 points
In this part, youâ€™ll write two program files: ğ‘»ğ‘ªğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and ğ‘»ğ‘ªğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
The Sender will send a randomly generated file and the Receiver will receive it and measure
the time it took for his program to receive the file. The file size should be at least 2MB.
When running the Sender and Receiver, they both should support two standard congestion
control algorithms: TCP Reno and TCP Cubic.
Notes:
â€¢ The main goal of this part is to get familiar with the TCP concept of sending
messages between two endpoints.
â€¢ For approaching this part of the assignment, please be sure that you are familiar
with the congestion control algorithms and how to change them using the correct
method in C (see Appendix B for more information).
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). You've
learned that TCP is reliable by design, so you can assume that all the data have been
passed correctly, and thus, no need to recheck.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
Usage:
â€¢ Receiver:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
â€¢ Sender:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port of the Receiver.
â€¢ ğ‘¨ğ‘³ğ‘®ğ‘¶ â€“ The TCP congestion control algorithm that will be used by the party
member (either ğ’“ğ’†ğ’ğ’ for TCP Reno or ğ’„ğ’–ğ’ƒğ’Šğ’„ for TCP Cubic).
 Communication Networks Course
Page | 3
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a TCP socket between the Sender and the
Receiver.
3) Send the file.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a TCP connection between the Receiver and
the Sender.
2) Get a connection from the sender.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./TCP_Receiver -p 1234 -algo reno
Starting Receiver...
Waiting for TCP connection...
Sender connected, beginning to receive file...
File transfer completed.
Waiting for Sender response...
Sender sent exit message.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 4
Part B â€“ Reliable User Datagram Protocol (Reliable UDP or RUDP) â€“ 40 points
Youâ€™ve learned that while TCP is reliable, it lacks speed and has an overhead data of 20 bytes,
compering to UDP that needs only 8 bytes of overhead data.
Reliable UDP or RUDP, is a protocol that uses the UDP protocol for a faster transmission of
data, while adding a reliability layer to it, but without adding too much overhead data like
TCP.
A simple sketch for a RUDP connection would look something like this:
Your task in this part is to implement a Reliable protocol using UDP only. For simplicity, your
implementation should only support a handshake, closing scheme, error checking,
acknowledgment of received packets, and retransmission of lost packets.
Guidance:
â€¢ You can use ğ‘ ğ‘’ğ‘¡ğ‘ ğ‘œğ‘ğ‘˜ğ‘œğ‘ğ‘¡(2) for detecting a timeout.
â€¢ You need to build your own protocol, as Reliable UDP isnâ€™t a standard protocol (see a
draft of RUDP in this link), and no official header is provided. You can use this sketch
for a header, but you can come up with your own protocol, as long as it works.
Where:
o ğ‘³ğ’†ğ’ğ’ˆğ’•ğ’‰ is the length of the data itself, without the RUDP header.
o ğ‘ªğ’‰ğ’†ğ’„ğ’Œğ’”ğ’–ğ’ is a 16bit number that validates the correctness of the data.
o ğ‘­ğ’ğ’‚ğ’ˆğ’” is a special byte where we classify the packet itself (SYN, ACK, etc.).
â€¢ In your PDF, you must explain how your implementation of RUDP works â€“ How does
it detect a timeout to do retransmissions, how does the handshake work, what is the
header overhead, etc.
â€¢ For this part, youâ€™ll write three files: ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¨ğ‘·ğ‘°. ğ’„, ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and
ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
Reliable UDP Header proposed sketch
Byte 0 Byte 1 Byte 2 Byte 3
Length (2 Bytes) Checksum (2 Bytes)
Flags (1 Byte)
Figure 1 - RUDP Protocol Architecture, Geeksforgeeks
 Communication Networks Course
Page | 5
Notes:
â€¢ The Sender will send a random generated file and the Receiver will receive it and
measure the time it took for his program to receive the file. The file size should be at
least 2MB.
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). But, as the
RUDP is based on UDP, itâ€™s not reliable. You must use some form of error checking
(like checksum) to ensure that the packet wasnâ€™t alerted during the transfer.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
â€¢ The RUDP needs support only 1 sender and 1 receiver, for simplicity purposes.
Usage:
â€¢ Receiver:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
â€¢ Sender:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port that both the Sender and the Receiver will use.
The ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„ file will contain all the implementations of the RUDP API functions (That is, to
prevent reusing the same chuck of code both in the Sender and the Receiver.).
The API should support at the bare minimum the following functions (you decide what
parameters to implement, and what are the names of the functions, as long as the API is
explained in the PDF):
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘œğ‘ğ‘˜ğ‘’ğ‘¡() â€“ Creating a RUDP socket and creating a handshake between two
peers.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘’ğ‘›ğ‘‘() â€“ Sending data to the peer. The function should wait for an
acknowledgment packet, and if it didnâ€™t receive any, retransmits the data.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘Ÿğ‘’ğ‘ğ‘£() â€“ Receive data from a peer.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ğ‘™ğ‘œğ‘ ğ‘’() â€“ Closes a connection between peers.
 Communication Networks Course
Page | 6
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a UDP socket between the Sender and the
Receiver.
3) Send the file via the RUDP protocol.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a UDP connection between the Receiver and
the Sender.
2) Get a connection from the sender, by the custom
RUDP protocol youâ€™ve built.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./RUDP_Receiver -p 1234
Starting Receiver...
Waiting for RUDP connection...
Connection request received, sending ACK.
Sender connected, beginning to receive file...
File transfer completed.
ACK sent.
Waiting for Sender response...
Sender sent exit message.
ACK sent.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 7
Part C â€“ Research â€“ 30 points
In this part, youâ€™ll conduct research about your implementations of part A and part B.
In the research itself, each one of the versions (TCP version and UDP version) will be run at
least 5 times (meaning that the file transfer will occur at least 5 times) by the following
conditions:
â€¢ For TCP, youâ€™ll run it in TCP Reno and TCP Cubic, alternating each time, for each
scenario, meaning that you run 5 times with TCP Reno in both Sender and Receiver,
and 5 times with TCP Cubic in both Sender and Receiver.
Bonus (5 points): Create a very large data set â€“ 5 times with TCP Reno in both Sender
and Receiver, 5 times with TCP Reno in Sender and TCP Cubic in Receiver, 5 times
with TCP Cubic in Sender and TCP Reno in Receiver, and 5 times with TCP Cubic in
both Sender and Receiver. This will give you a data set large enough, which allows
you to work with, compare with and to reach a definite conclusion.
â€¢ For RUDP, you will run it 5 times for each scenario.
â€¢ For both TCP and RUDP, you will run them on those scenarios of packet loss:
o 0% packet loss â€“ Control group, simulating perfect connection.
o 2% packet loss â€“ Simulating unstable connection that commonly occur.
o 5% packet loss â€“ Simulating bad connection.
o 10% packet loss â€“ Simulating extremely poor connection.
For each scenario, you must provide a filtered PCAP file and relevant screenshots that
explain each one of the steps in the process. (10 points)
After youâ€™ve gathered the data set for both TCP and Reliable UDP, answer the following
questions:
1) In TCP, which congestion control algorithm gave better results overall? TCP Reno or
TCP Cubic? Which one gave better results on high packet loss? Explain how you came
to this conclusion based on the data set youâ€™ve gathered. (5 points)
2) How did your implementation of Reliable UDP perform overall compared to regular
TCP? Which one is better for high packet loss? (5 points)
3) According to the data youâ€™ve gathered, in which scenarios and applications would we
prefer to use TCP and in which situations would we prefer to use reliable UDP?
Explain your answer. (5 points)
 Communication Networks Course
Page | 8
×¢× ×• ×¢×œ ×”×©××œ×•×ª ×”×‘××•×ª )5 × ×§×•×“×•×ª(:
â— ×‘"×¨×©×ª ×××™× ×”" ×”×›×•×•× ×” ×”×™× ×œ×¨×©×ª ×©×‘×” ××¢×˜ ×××•×“ ×—×‘×™×œ×•×ª ×”×•×œ×›×•×ª ×œ××™×‘×•×“. ×‘"×§×©×¨ ××¨×•×š" ×”×›×•×•× ×” ×”×™×
×œ×§×©×¨ TCP ×©×™×© ×‘×• ×”×¨×‘×” ×××•×“ ××™×“×¢ ×œ×©×œ×•×—. ××•×¦×¢ ×œ×”×’×“×™×œ ×‘ -TCP ××ª SSThreshold ×‘×ª×—×™×œ×ª ×”×§×©×¨.
×‘××™×–×” ××”××§×¨×™× ×”×‘××™× ×”×©×™× ×•×™ ×”×–×” ×¢×©×•×™ ×œ×”×•×¢×™×œ ×‘××™×“×” ×”××™×¨×‘×™×ª? × ××§.
.1 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
.2 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.3 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.4 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.5 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.6 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.7 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.8 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
â— A ×©×•×œ×— ×œ -B ×—×‘×™×œ×•×ª ××™×“×¢ ×‘×××¦×¢×•×ª ×§×©×¨ TCP. × ×ª×•×Ÿ ×›×™ ×”×§×©×¨ ××ª×—×™×œ ×¢× ×—×œ×•×Ÿ ×‘×’×•×“×œ 1MSS. ×”×§×©×¨
××¡×ª×™×™× ×‘×¤×¢× ×”×¨××©×•× ×” ×©×”×•× ××’×™×¢ ×œ -SSthresh. ×‘××”×œ×š ×”×§×©×¨ ×œ× ××•×‘×“×•×ª ×—×‘×™×œ×•×ª. × ×¡××Ÿ ×‘×§×™×¦×•×¨:
.SSthresh=S*MSS
× ×ª×•×Ÿ ×›×™ ×œ××•×¨×š ×›×œ ×”×§×©×¨ rwnd < MSS*S.
××”×™ ×”×ª×¤×•×§×” ×©×œ ×”×§×©×¨ ×-A ×œ-B( ×‘ -sec / Bytes )×‘×–××Ÿ ×”× "×œ? × ××§×™.
]S*MSS / [lg (S) * RTT*2 ×‘×¢×¨×š .1
]S*MSS / [S^0.5 * RTT*2 ×‘×¢×¨×š .2
S*MSS / RTT ×‘×¢×¨×š .3
S^2)*MSS / RTT( ×‘×¢×¨×š .4
â— ×©×ª×™ ×ª×—× ×•×ª ××ª×§×©×¨×•×ª ×‘××•×¤×Ÿ ××œ×—×•×˜×™ ×‘×©×™×˜×ª N Back Go.
× ×¡××Ÿ ×‘-X ××ª ×¡×¤×¨×ª ×”×‘×™×§×•×¨×ª ×©×œ ×”×ª.×–. ×©×œ×š. ×× ×©× ×™ ×©×•×ª×¤×™× ××’×™×©×™× ××ª ×”×ª×¨×’×™×œ ×™×—×“, X ×”×•× ×¡×¤×¨×ª
×”×‘×™×§×•×¨×ª ×‘×¢×œ×ª ×”×¢×¨×š ×”× ××•×š ×™×•×ª×¨ ××‘×™×Ÿ ×”×©×ª×™×™×.
×§×¦×‘ ×”×ª×§×©×•×¨×ª ×”×•× 8Gbps, ×•×’×•×“×œ ×›×œ ×—×‘×™×œ×” ×”×•× KByte*X. ×’×“×œ×™ ×”-headers ×•×” -Acks ×–× ×™×—×™×.
ï¿½ğ‘’ğ‘ ï¿½/ï¿½ï¿½ 8 , ×•×”××¨×—×§ ×‘×™×Ÿ ×”×ª×—× ×•×ª ×”×•× 1Km. ×§×¦×‘ ×”×”×ª×¤×©×˜×•×ª ×”×•× 10 â‹… 2
×–××Ÿ ×¢×™×‘×•×“ ×”× ×ª×•× ×™× ×‘×ª×—× ×•×ª ×–× ×™×—.
××£ ×—×‘×™×œ×” ×•××£ Ack ×œ× ×”×•×œ×›×™× ×œ××™×‘×•×“.
â— ××”×• X ×©×œ×š?
â— ××” ×¦×¨×™×š ×œ×”×™×•×ª ×’×•×“×œ ×—×œ×•×Ÿ ×”××©×œ×•×— ×›×“×™ ×œ×”×‘×˜×™×— ×ª×¤×•×§×” ××§×¡×™××œ×™×ª?
 Communication Networks Course
Page | 9
Bonus â€“ Improving the Reliable UDP â€“ 15 points
Note: This part isnâ€™t mandatory and is a bonus only!
In this part, youâ€™ll improve your RUDP implementation by adding the concepts of flow
control and congestion control from TCP. Youâ€™re free to choose which algorithms to
implement, as long as you explain in your PDF which algorithms youâ€™ve used. Youâ€™ll probably
need to make changes in the original design of the RUDP. Changes only need to be to the API
itself, ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„.
Points distribution:
â€¢ Flow control improvement â€“ 7 Points
â€¢ Congestion control improvement â€“ 8 points.
Guidance:
â€¢ For flow control, you must use one of the Sliding window techniques: stop-and-wait
ARQ, Go-Back-N or Selective repeat.
â€¢ List of known TCP congestion control algorithms, which you can use any one of them
for this bonus task, or makeup your own:
Figure 2 â€“ List of known TCP congestion control algorithms, Wikipedia
 Communication Networks Course
Page | 10
Appendix A â€“ Linux local packet loss tool
To simulate a packet loss in a local network, we'll use a Linux tool that's called Linux Traffic
Control (ğ‘¡ğ‘). This requires a full Linux installation, so working with WSL won't work.
If the tool isn't installed in your machine, you can install it by using the following commands:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’
If the installation didn't work, you can use the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’2
To create a packet loss scenario, type the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘ğ‘‘ğ‘‘ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
After creating a packet loss scenario, you can change the percentage by typing the following
command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘â„ğ‘ğ‘›ğ‘”ğ‘’ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
To remove the packet loss scenario, write the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘‘ğ‘’ğ‘™ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š
 Communication Networks Course
Page | 11
Appendix B â€“ ğ’ğ’‚ğ’(ğŸ) system calls
This appendixâ€™s purpose is to give you a better understanding of socket handling in C.
A recommended reference is Beejâ€™s Guide to Network Programming, by Brian â€œBeej
Jorgensenâ€ Hall, which gives a lot of information about sockets in C and functions.
Functions and documentation links:
â€¢ ğ’”ğ’ğ’„ğ’Œğ’†ğ’•(ğŸ) â€“ A Factory method system call that creates a socket with the given
parameters.
â€¢ ğ’ƒğ’Šğ’ğ’…(ğŸ) â€“ Whenever we create a new socket, we need to bind it to a specific port in
our machine, â€œto catch a portâ€. The port number is managed and used by the kernel
to link incoming packets to the corresponding application socket. The port numbers
are usually fixed. The ğ‘ğ‘‘ğ‘‘ğ‘Ÿ parameter must match the current socket that is used.
â€¢ ğ’ğ’Šğ’”ğ’•ğ’†ğ’(ğŸ) â€“ The ğ‘™ğ‘–ğ‘ ğ‘¡ğ‘’ğ‘›(2) system call doesn't do anything in the mean of
communication but only memory allocation (malloc) for stream sockets only. If we
won't allocate memory, any incoming connection will fail.
â€¢ ğ’„ğ’ğ’ğ’ğ’†ğ’„ğ’•(ğŸ) â€“ The ğ‘ğ‘œğ‘›ğ‘›ğ‘’ğ‘ğ‘¡(2) system call starts the link between a client and a
specific IP address and port number. The connection would complete when the
other side will call the ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call.
â€¢ ğ’‚ğ’„ğ’„ğ’†ğ’‘ğ’•(ğŸ) â€“ The ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call accepts the incoming stream connection
request from the other side, by the listening socket. This system call completes the
three-way handshake of stream socket (like TCP) and opens a new socket that has a
direct communication channel only with the other party in the handshake.
â€¢ ğ’”ğ’†ğ’ğ’…(ğŸ) and ğ’”ğ’†ğ’ğ’…ğ’•ğ’(ğŸ) â€“ The ğ‘ ğ‘’ğ‘›ğ‘‘(2) and ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system calls are an analogy
for the ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’(2) system call, specifcly for sockets, with flags set to 0. Those system
calls return the number of bytes that were sent through the socket itself, as the
number of bytes can vary. The ğ‘ ğ‘’ğ‘›ğ‘‘(2)system call designed for stream sockets (like
TCP), while the ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system call designed for datagram connection-less
sockets (like UDP). When the ğ‘ ğ‘’ğ‘›ğ‘‘(2) system call returns 0, it means that the other
party closed the connection.
â€¢ ğ’“ğ’†ğ’„ğ’—(ğŸ) and ğ’“ğ’†ğ’„ğ’—ğ’‡ğ’“ğ’ğ’(ğŸ) â€“ The ğ‘Ÿğ‘’ğ‘ğ‘£(2) and ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system calls are an
analogy for the ğ‘Ÿğ‘’ğ‘ğ‘‘(2) system call, specifically for sockets, with flags set to 0.
Those system calls return the number of bytes that were received through the socket
itself, as the number of bytes can vary. The ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call designed for stream
sockets (like TCP), while the ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system call designed for datagram
connection-less sockets (like UDP). When the ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call returns 0, it means
that the other party closed the connection.
â€¢ ğ’„ğ’ğ’ğ’”ğ’†(ğŸ) and ğ’”ğ’‰ğ’–ğ’•ğ’…ğ’ğ’˜ğ’(ğŸ) â€“ The ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) and ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2) system calls close
the socket. While ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) system call closes the whole socket, the ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2)
system call partially closes the socket for read/write.
 Communication Networks Course
Page | 12
Appendix C â€“ Random data generator
The data that you are going to send in this assignment is randomly generated. You can use
your own file with appropriate size or use the following function (or a function of your own)
to generate the data:
/*
* @brief A random data generator function based on srand() and rand().
* @param size The size of the data to generate (up to 2^32 bytes).
* @return A pointer to the buffer.
*/
char *util_generate_random_data(unsigned int size) {
 char *buffer = NULL;
 // Argument check.
 if (size == 0)
 return NULL;
 buffer = (char *)calloc(size, sizeof(char));
 // Error checking.
 if (buffer == NULL)
 return NULL;
 // Randomize the seed of the random number generator.
 srand(time(NULL));
 for (unsigned int i = 0; i < size; i++)
 *(buffer + i) = ((unsigned int)rand() % 256);
 return buffer;
}
 Communication Networks Course
Page | 13
Appendix D â€“ Checksum function
A checksum is a small-sized block of data derived from another block of digital data for the
purpose of detecting errors that may have been introduced during its transmission or
storage. By themselves, checksums are often used to verify data integrity but are not relied
upon to verify data authenticity.
Below is a simple yet efficient implementation of the checksum function, you can use it for
the assignment, but you can implement your own checksum function.
/*
* @brief A checksum function that returns 16 bit checksum for data.
* @param data The data to do the checksum for.
* @param bytes The length of the data in bytes.
* @return The checksum itself as 16 bit unsigned number.
* @note This function is taken from RFC1071, can be found here:
* @note https://tools.ietf.org/html/rfc1071
* @note It is the simplest way to calculate a checksum and is not very strong.
* However, it is good enough for this assignment.
* @note You are free to use any other checksum function as well.
* You can also use this function as such without any change.
*/
unsigned short int calculate_checksum(void *data, unsigned int bytes) {
 unsigned short int *data_pointer = (unsigned short int *)data;
 unsigned int total_sum = 0;
 // Main summing loop
 while (bytes > 1) {
 total_sum += *data_pointer++;
 bytes -= 2;
 }
 // Add left-over byte, if any
 if (bytes > 0)
 total_sum += *((unsigned char *)data_pointer);
 // Fold 32-bit sum to 16 bits
 while (total_sum >> 16)
 total_sum = (total_sum & 0xFFFF) + (total_sum >> 16);
 return (~((unsigned short int)total_sum));
} Communication Networks Course
Page | 1
Assignment 3 â€“ Transport Layer
Assignment Notes and Instructions
This assignment is to be done in pairs only. You must upload all the necessary files in a ZIP
file named after both of the studentâ€™s ID. For example: ğŸğŸğŸ‘ğŸ’ğŸ“ğŸ”ğŸ•ğŸ–ğŸ—_ğŸ—ğŸ–ğŸ•ğŸ”ğŸ“ğŸ’ğŸ‘ğŸğŸ. ğ’›ğ’Šğ’‘.
1) The assignment must be submitted by the date specified in the submission box.
2) All the assignment files (Code, Wireshark pcap files, PDF) must be submitted in a ZIP file. The
PDF must contain all the necessary screenshots with a description for each one of them.
3) The assignment must be done in pairs only. In exceptional cases, you should send an email to
the course coordinator.
4) You can use any reference material available through the course Moodle website or any
material passed during the exercises.
5) You can use any reference from the web, but copying codes from websites is forbidden; this
includes codes from other GitHub repositories. A student who gets caught in the act will
automatically fail this assignment (score 0). Any website youâ€™ve used to solve the
assignment, every website you used to solve the assignment must be noted in the PDF.
6) No delays in submission without special permission. Lateness without approval will result in
failure of the assignment (score 0).
7) All submissions will be submitted via the course's Moodle website. Email submissions will not
be accepted, resulting in a failure in the assignment.
8) The order and design of the code must be carefully considered. Make sure that the program
output is as clear as possible, comments in the code, and meaningful variable names. You
must also submit a makefile that compiles all the programs.
9) The assignment code must be written in C only.
10) The assignment is personal for each pair, and you should not accept help from other people,
whether outside the university or inside it. You can contact the course staff during reception
hours for help or raise a question in the course forum. Do not transfer code sections
between students, upload solutions or parts of solutions to websites on the Internet or in
various communication groups.
11) Students who copy a solution will receive a 0 in all assignments in the course and a report will
be made to the institutional disciplinary committee.
12) All code files of the assignment are required to both compile and run properly on the Ubuntu
22.04 LTS operating system. This is the operating system where the submissions will be
tested. You mustnâ€™t code it in Windows, as it uses different API for sockets. WSL wonâ€™t work,
as the task needs a tool that works only in a fully Linux environment.
Good Luck!
 Communication Networks Course
Page | 2
Part A â€“ Transmission Control Protocol (TCP) â€“ 30 points
In this part, youâ€™ll write two program files: ğ‘»ğ‘ªğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and ğ‘»ğ‘ªğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
The Sender will send a randomly generated file and the Receiver will receive it and measure
the time it took for his program to receive the file. The file size should be at least 2MB.
When running the Sender and Receiver, they both should support two standard congestion
control algorithms: TCP Reno and TCP Cubic.
Notes:
â€¢ The main goal of this part is to get familiar with the TCP concept of sending
messages between two endpoints.
â€¢ For approaching this part of the assignment, please be sure that you are familiar
with the congestion control algorithms and how to change them using the correct
method in C (see Appendix B for more information).
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). You've
learned that TCP is reliable by design, so you can assume that all the data have been
passed correctly, and thus, no need to recheck.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
Usage:
â€¢ Receiver:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
â€¢ Sender:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port of the Receiver.
â€¢ ğ‘¨ğ‘³ğ‘®ğ‘¶ â€“ The TCP congestion control algorithm that will be used by the party
member (either ğ’“ğ’†ğ’ğ’ for TCP Reno or ğ’„ğ’–ğ’ƒğ’Šğ’„ for TCP Cubic).
 Communication Networks Course
Page | 3
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a TCP socket between the Sender and the
Receiver.
3) Send the file.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a TCP connection between the Receiver and
the Sender.
2) Get a connection from the sender.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./TCP_Receiver -p 1234 -algo reno
Starting Receiver...
Waiting for TCP connection...
Sender connected, beginning to receive file...
File transfer completed.
Waiting for Sender response...
Sender sent exit message.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 4
Part B â€“ Reliable User Datagram Protocol (Reliable UDP or RUDP) â€“ 40 points
Youâ€™ve learned that while TCP is reliable, it lacks speed and has an overhead data of 20 bytes,
compering to UDP that needs only 8 bytes of overhead data.
Reliable UDP or RUDP, is a protocol that uses the UDP protocol for a faster transmission of
data, while adding a reliability layer to it, but without adding too much overhead data like
TCP.
A simple sketch for a RUDP connection would look something like this:
Your task in this part is to implement a Reliable protocol using UDP only. For simplicity, your
implementation should only support a handshake, closing scheme, error checking,
acknowledgment of received packets, and retransmission of lost packets.
Guidance:
â€¢ You can use ğ‘ ğ‘’ğ‘¡ğ‘ ğ‘œğ‘ğ‘˜ğ‘œğ‘ğ‘¡(2) for detecting a timeout.
â€¢ You need to build your own protocol, as Reliable UDP isnâ€™t a standard protocol (see a
draft of RUDP in this link), and no official header is provided. You can use this sketch
for a header, but you can come up with your own protocol, as long as it works.
Where:
o ğ‘³ğ’†ğ’ğ’ˆğ’•ğ’‰ is the length of the data itself, without the RUDP header.
o ğ‘ªğ’‰ğ’†ğ’„ğ’Œğ’”ğ’–ğ’ is a 16bit number that validates the correctness of the data.
o ğ‘­ğ’ğ’‚ğ’ˆğ’” is a special byte where we classify the packet itself (SYN, ACK, etc.).
â€¢ In your PDF, you must explain how your implementation of RUDP works â€“ How does
it detect a timeout to do retransmissions, how does the handshake work, what is the
header overhead, etc.
â€¢ For this part, youâ€™ll write three files: ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¨ğ‘·ğ‘°. ğ’„, ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and
ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
Reliable UDP Header proposed sketch
Byte 0 Byte 1 Byte 2 Byte 3
Length (2 Bytes) Checksum (2 Bytes)
Flags (1 Byte)
Figure 1 - RUDP Protocol Architecture, Geeksforgeeks
 Communication Networks Course
Page | 5
Notes:
â€¢ The Sender will send a random generated file and the Receiver will receive it and
measure the time it took for his program to receive the file. The file size should be at
least 2MB.
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). But, as the
RUDP is based on UDP, itâ€™s not reliable. You must use some form of error checking
(like checksum) to ensure that the packet wasnâ€™t alerted during the transfer.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
â€¢ The RUDP needs support only 1 sender and 1 receiver, for simplicity purposes.
Usage:
â€¢ Receiver:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
â€¢ Sender:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port that both the Sender and the Receiver will use.
The ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„ file will contain all the implementations of the RUDP API functions (That is, to
prevent reusing the same chuck of code both in the Sender and the Receiver.).
The API should support at the bare minimum the following functions (you decide what
parameters to implement, and what are the names of the functions, as long as the API is
explained in the PDF):
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘œğ‘ğ‘˜ğ‘’ğ‘¡() â€“ Creating a RUDP socket and creating a handshake between two
peers.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘’ğ‘›ğ‘‘() â€“ Sending data to the peer. The function should wait for an
acknowledgment packet, and if it didnâ€™t receive any, retransmits the data.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘Ÿğ‘’ğ‘ğ‘£() â€“ Receive data from a peer.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ğ‘™ğ‘œğ‘ ğ‘’() â€“ Closes a connection between peers.
 Communication Networks Course
Page | 6
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a UDP socket between the Sender and the
Receiver.
3) Send the file via the RUDP protocol.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a UDP connection between the Receiver and
the Sender.
2) Get a connection from the sender, by the custom
RUDP protocol youâ€™ve built.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./RUDP_Receiver -p 1234
Starting Receiver...
Waiting for RUDP connection...
Connection request received, sending ACK.
Sender connected, beginning to receive file...
File transfer completed.
ACK sent.
Waiting for Sender response...
Sender sent exit message.
ACK sent.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 7
Part C â€“ Research â€“ 30 points
In this part, youâ€™ll conduct research about your implementations of part A and part B.
In the research itself, each one of the versions (TCP version and UDP version) will be run at
least 5 times (meaning that the file transfer will occur at least 5 times) by the following
conditions:
â€¢ For TCP, youâ€™ll run it in TCP Reno and TCP Cubic, alternating each time, for each
scenario, meaning that you run 5 times with TCP Reno in both Sender and Receiver,
and 5 times with TCP Cubic in both Sender and Receiver.
Bonus (5 points): Create a very large data set â€“ 5 times with TCP Reno in both Sender
and Receiver, 5 times with TCP Reno in Sender and TCP Cubic in Receiver, 5 times
with TCP Cubic in Sender and TCP Reno in Receiver, and 5 times with TCP Cubic in
both Sender and Receiver. This will give you a data set large enough, which allows
you to work with, compare with and to reach a definite conclusion.
â€¢ For RUDP, you will run it 5 times for each scenario.
â€¢ For both TCP and RUDP, you will run them on those scenarios of packet loss:
o 0% packet loss â€“ Control group, simulating perfect connection.
o 2% packet loss â€“ Simulating unstable connection that commonly occur.
o 5% packet loss â€“ Simulating bad connection.
o 10% packet loss â€“ Simulating extremely poor connection.
For each scenario, you must provide a filtered PCAP file and relevant screenshots that
explain each one of the steps in the process. (10 points)
After youâ€™ve gathered the data set for both TCP and Reliable UDP, answer the following
questions:
1) In TCP, which congestion control algorithm gave better results overall? TCP Reno or
TCP Cubic? Which one gave better results on high packet loss? Explain how you came
to this conclusion based on the data set youâ€™ve gathered. (5 points)
2) How did your implementation of Reliable UDP perform overall compared to regular
TCP? Which one is better for high packet loss? (5 points)
3) According to the data youâ€™ve gathered, in which scenarios and applications would we
prefer to use TCP and in which situations would we prefer to use reliable UDP?
Explain your answer. (5 points)
 Communication Networks Course
Page | 8
×¢× ×• ×¢×œ ×”×©××œ×•×ª ×”×‘××•×ª )5 × ×§×•×“×•×ª(:
â— ×‘"×¨×©×ª ×××™× ×”" ×”×›×•×•× ×” ×”×™× ×œ×¨×©×ª ×©×‘×” ××¢×˜ ×××•×“ ×—×‘×™×œ×•×ª ×”×•×œ×›×•×ª ×œ××™×‘×•×“. ×‘"×§×©×¨ ××¨×•×š" ×”×›×•×•× ×” ×”×™×
×œ×§×©×¨ TCP ×©×™×© ×‘×• ×”×¨×‘×” ×××•×“ ××™×“×¢ ×œ×©×œ×•×—. ××•×¦×¢ ×œ×”×’×“×™×œ ×‘ -TCP ××ª SSThreshold ×‘×ª×—×™×œ×ª ×”×§×©×¨.
×‘××™×–×” ××”××§×¨×™× ×”×‘××™× ×”×©×™× ×•×™ ×”×–×” ×¢×©×•×™ ×œ×”×•×¢×™×œ ×‘××™×“×” ×”××™×¨×‘×™×ª? × ××§.
.1 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
.2 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.3 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.4 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.5 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.6 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.7 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.8 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
â— A ×©×•×œ×— ×œ -B ×—×‘×™×œ×•×ª ××™×“×¢ ×‘×××¦×¢×•×ª ×§×©×¨ TCP. × ×ª×•×Ÿ ×›×™ ×”×§×©×¨ ××ª×—×™×œ ×¢× ×—×œ×•×Ÿ ×‘×’×•×“×œ 1MSS. ×”×§×©×¨
××¡×ª×™×™× ×‘×¤×¢× ×”×¨××©×•× ×” ×©×”×•× ××’×™×¢ ×œ -SSthresh. ×‘××”×œ×š ×”×§×©×¨ ×œ× ××•×‘×“×•×ª ×—×‘×™×œ×•×ª. × ×¡××Ÿ ×‘×§×™×¦×•×¨:
.SSthresh=S*MSS
× ×ª×•×Ÿ ×›×™ ×œ××•×¨×š ×›×œ ×”×§×©×¨ rwnd < MSS*S.
××”×™ ×”×ª×¤×•×§×” ×©×œ ×”×§×©×¨ ×-A ×œ-B( ×‘ -sec / Bytes )×‘×–××Ÿ ×”× "×œ? × ××§×™.
]S*MSS / [lg (S) * RTT*2 ×‘×¢×¨×š .1
]S*MSS / [S^0.5 * RTT*2 ×‘×¢×¨×š .2
S*MSS / RTT ×‘×¢×¨×š .3
S^2)*MSS / RTT( ×‘×¢×¨×š .4
â— ×©×ª×™ ×ª×—× ×•×ª ××ª×§×©×¨×•×ª ×‘××•×¤×Ÿ ××œ×—×•×˜×™ ×‘×©×™×˜×ª N Back Go.
× ×¡××Ÿ ×‘-X ××ª ×¡×¤×¨×ª ×”×‘×™×§×•×¨×ª ×©×œ ×”×ª.×–. ×©×œ×š. ×× ×©× ×™ ×©×•×ª×¤×™× ××’×™×©×™× ××ª ×”×ª×¨×’×™×œ ×™×—×“, X ×”×•× ×¡×¤×¨×ª
×”×‘×™×§×•×¨×ª ×‘×¢×œ×ª ×”×¢×¨×š ×”× ××•×š ×™×•×ª×¨ ××‘×™×Ÿ ×”×©×ª×™×™×.
×§×¦×‘ ×”×ª×§×©×•×¨×ª ×”×•× 8Gbps, ×•×’×•×“×œ ×›×œ ×—×‘×™×œ×” ×”×•× KByte*X. ×’×“×œ×™ ×”-headers ×•×” -Acks ×–× ×™×—×™×.
ï¿½ğ‘’ğ‘ ï¿½/ï¿½ï¿½ 8 , ×•×”××¨×—×§ ×‘×™×Ÿ ×”×ª×—× ×•×ª ×”×•× 1Km. ×§×¦×‘ ×”×”×ª×¤×©×˜×•×ª ×”×•× 10 â‹… 2
×–××Ÿ ×¢×™×‘×•×“ ×”× ×ª×•× ×™× ×‘×ª×—× ×•×ª ×–× ×™×—.
××£ ×—×‘×™×œ×” ×•××£ Ack ×œ× ×”×•×œ×›×™× ×œ××™×‘×•×“.
â— ××”×• X ×©×œ×š?
â— ××” ×¦×¨×™×š ×œ×”×™×•×ª ×’×•×“×œ ×—×œ×•×Ÿ ×”××©×œ×•×— ×›×“×™ ×œ×”×‘×˜×™×— ×ª×¤×•×§×” ××§×¡×™××œ×™×ª?
 Communication Networks Course
Page | 9
Bonus â€“ Improving the Reliable UDP â€“ 15 points
Note: This part isnâ€™t mandatory and is a bonus only!
In this part, youâ€™ll improve your RUDP implementation by adding the concepts of flow
control and congestion control from TCP. Youâ€™re free to choose which algorithms to
implement, as long as you explain in your PDF which algorithms youâ€™ve used. Youâ€™ll probably
need to make changes in the original design of the RUDP. Changes only need to be to the API
itself, ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„.
Points distribution:
â€¢ Flow control improvement â€“ 7 Points
â€¢ Congestion control improvement â€“ 8 points.
Guidance:
â€¢ For flow control, you must use one of the Sliding window techniques: stop-and-wait
ARQ, Go-Back-N or Selective repeat.
â€¢ List of known TCP congestion control algorithms, which you can use any one of them
for this bonus task, or makeup your own:
Figure 2 â€“ List of known TCP congestion control algorithms, Wikipedia
 Communication Networks Course
Page | 10
Appendix A â€“ Linux local packet loss tool
To simulate a packet loss in a local network, we'll use a Linux tool that's called Linux Traffic
Control (ğ‘¡ğ‘). This requires a full Linux installation, so working with WSL won't work.
If the tool isn't installed in your machine, you can install it by using the following commands:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’
If the installation didn't work, you can use the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’2
To create a packet loss scenario, type the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘ğ‘‘ğ‘‘ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
After creating a packet loss scenario, you can change the percentage by typing the following
command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘â„ğ‘ğ‘›ğ‘”ğ‘’ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
To remove the packet loss scenario, write the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘‘ğ‘’ğ‘™ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š
 Communication Networks Course
Page | 11
Appendix B â€“ ğ’ğ’‚ğ’(ğŸ) system calls
This appendixâ€™s purpose is to give you a better understanding of socket handling in C.
A recommended reference is Beejâ€™s Guide to Network Programming, by Brian â€œBeej
Jorgensenâ€ Hall, which gives a lot of information about sockets in C and functions.
Functions and documentation links:
â€¢ ğ’”ğ’ğ’„ğ’Œğ’†ğ’•(ğŸ) â€“ A Factory method system call that creates a socket with the given
parameters.
â€¢ ğ’ƒğ’Šğ’ğ’…(ğŸ) â€“ Whenever we create a new socket, we need to bind it to a specific port in
our machine, â€œto catch a portâ€. The port number is managed and used by the kernel
to link incoming packets to the corresponding application socket. The port numbers
are usually fixed. The ğ‘ğ‘‘ğ‘‘ğ‘Ÿ parameter must match the current socket that is used.
â€¢ ğ’ğ’Šğ’”ğ’•ğ’†ğ’(ğŸ) â€“ The ğ‘™ğ‘–ğ‘ ğ‘¡ğ‘’ğ‘›(2) system call doesn't do anything in the mean of
communication but only memory allocation (malloc) for stream sockets only. If we
won't allocate memory, any incoming connection will fail.
â€¢ ğ’„ğ’ğ’ğ’ğ’†ğ’„ğ’•(ğŸ) â€“ The ğ‘ğ‘œğ‘›ğ‘›ğ‘’ğ‘ğ‘¡(2) system call starts the link between a client and a
specific IP address and port number. The connection would complete when the
other side will call the ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call.
â€¢ ğ’‚ğ’„ğ’„ğ’†ğ’‘ğ’•(ğŸ) â€“ The ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call accepts the incoming stream connection
request from the other side, by the listening socket. This system call completes the
three-way handshake of stream socket (like TCP) and opens a new socket that has a
direct communication channel only with the other party in the handshake.
â€¢ ğ’”ğ’†ğ’ğ’…(ğŸ) and ğ’”ğ’†ğ’ğ’…ğ’•ğ’(ğŸ) â€“ The ğ‘ ğ‘’ğ‘›ğ‘‘(2) and ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system calls are an analogy
for the ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’(2) system call, specifcly for sockets, with flags set to 0. Those system
calls return the number of bytes that were sent through the socket itself, as the
number of bytes can vary. The ğ‘ ğ‘’ğ‘›ğ‘‘(2)system call designed for stream sockets (like
TCP), while the ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system call designed for datagram connection-less
sockets (like UDP). When the ğ‘ ğ‘’ğ‘›ğ‘‘(2) system call returns 0, it means that the other
party closed the connection.
â€¢ ğ’“ğ’†ğ’„ğ’—(ğŸ) and ğ’“ğ’†ğ’„ğ’—ğ’‡ğ’“ğ’ğ’(ğŸ) â€“ The ğ‘Ÿğ‘’ğ‘ğ‘£(2) and ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system calls are an
analogy for the ğ‘Ÿğ‘’ğ‘ğ‘‘(2) system call, specifically for sockets, with flags set to 0.
Those system calls return the number of bytes that were received through the socket
itself, as the number of bytes can vary. The ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call designed for stream
sockets (like TCP), while the ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system call designed for datagram
connection-less sockets (like UDP). When the ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call returns 0, it means
that the other party closed the connection.
â€¢ ğ’„ğ’ğ’ğ’”ğ’†(ğŸ) and ğ’”ğ’‰ğ’–ğ’•ğ’…ğ’ğ’˜ğ’(ğŸ) â€“ The ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) and ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2) system calls close
the socket. While ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) system call closes the whole socket, the ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2)
system call partially closes the socket for read/write.
 Communication Networks Course
Page | 12
Appendix C â€“ Random data generator
The data that you are going to send in this assignment is randomly generated. You can use
your own file with appropriate size or use the following function (or a function of your own)
to generate the data:
/*
* @brief A random data generator function based on srand() and rand().
* @param size The size of the data to generate (up to 2^32 bytes).
* @return A pointer to the buffer.
*/
char *util_generate_random_data(unsigned int size) {
 char *buffer = NULL;
 // Argument check.
 if (size == 0)
 return NULL;
 buffer = (char *)calloc(size, sizeof(char));
 // Error checking.
 if (buffer == NULL)
 return NULL;
 // Randomize the seed of the random number generator.
 srand(time(NULL));
 for (unsigned int i = 0; i < size; i++)
 *(buffer + i) = ((unsigned int)rand() % 256);
 return buffer;
}
 Communication Networks Course
Page | 13
Appendix D â€“ Checksum function
A checksum is a small-sized block of data derived from another block of digital data for the
purpose of detecting errors that may have been introduced during its transmission or
storage. By themselves, checksums are often used to verify data integrity but are not relied
upon to verify data authenticity.
Below is a simple yet efficient implementation of the checksum function, you can use it for
the assignment, but you can implement your own checksum function.
/*
* @brief A checksum function that returns 16 bit checksum for data.
* @param data The data to do the checksum for.
* @param bytes The length of the data in bytes.
* @return The checksum itself as 16 bit unsigned number.
* @note This function is taken from RFC1071, can be found here:
* @note https://tools.ietf.org/html/rfc1071
* @note It is the simplest way to calculate a checksum and is not very strong.
* However, it is good enough for this assignment.
* @note You are free to use any other checksum function as well.
* You can also use this function as such without any change.
*/
unsigned short int calculate_checksum(void *data, unsigned int bytes) {
 unsigned short int *data_pointer = (unsigned short int *)data;
 unsigned int total_sum = 0;
 // Main summing loop
 while (bytes > 1) {
 total_sum += *data_pointer++;
 bytes -= 2;
 }
 // Add left-over byte, if any
 if (bytes > 0)
 total_sum += *((unsigned char *)data_pointer);
 // Fold 32-bit sum to 16 bits
 while (total_sum >> 16)
 total_sum = (total_sum & 0xFFFF) + (total_sum >> 16);
 return (~((unsigned short int)total_sum));
} Communication Networks Course
Page | 1
Assignment 3 â€“ Transport Layer
Assignment Notes and Instructions
This assignment is to be done in pairs only. You must upload all the necessary files in a ZIP
file named after both of the studentâ€™s ID. For example: ğŸğŸğŸ‘ğŸ’ğŸ“ğŸ”ğŸ•ğŸ–ğŸ—_ğŸ—ğŸ–ğŸ•ğŸ”ğŸ“ğŸ’ğŸ‘ğŸğŸ. ğ’›ğ’Šğ’‘.
1) The assignment must be submitted by the date specified in the submission box.
2) All the assignment files (Code, Wireshark pcap files, PDF) must be submitted in a ZIP file. The
PDF must contain all the necessary screenshots with a description for each one of them.
3) The assignment must be done in pairs only. In exceptional cases, you should send an email to
the course coordinator.
4) You can use any reference material available through the course Moodle website or any
material passed during the exercises.
5) You can use any reference from the web, but copying codes from websites is forbidden; this
includes codes from other GitHub repositories. A student who gets caught in the act will
automatically fail this assignment (score 0). Any website youâ€™ve used to solve the
assignment, every website you used to solve the assignment must be noted in the PDF.
6) No delays in submission without special permission. Lateness without approval will result in
failure of the assignment (score 0).
7) All submissions will be submitted via the course's Moodle website. Email submissions will not
be accepted, resulting in a failure in the assignment.
8) The order and design of the code must be carefully considered. Make sure that the program
output is as clear as possible, comments in the code, and meaningful variable names. You
must also submit a makefile that compiles all the programs.
9) The assignment code must be written in C only.
10) The assignment is personal for each pair, and you should not accept help from other people,
whether outside the university or inside it. You can contact the course staff during reception
hours for help or raise a question in the course forum. Do not transfer code sections
between students, upload solutions or parts of solutions to websites on the Internet or in
various communication groups.
11) Students who copy a solution will receive a 0 in all assignments in the course and a report will
be made to the institutional disciplinary committee.
12) All code files of the assignment are required to both compile and run properly on the Ubuntu
22.04 LTS operating system. This is the operating system where the submissions will be
tested. You mustnâ€™t code it in Windows, as it uses different API for sockets. WSL wonâ€™t work,
as the task needs a tool that works only in a fully Linux environment.
Good Luck!
 Communication Networks Course
Page | 2
Part A â€“ Transmission Control Protocol (TCP) â€“ 30 points
In this part, youâ€™ll write two program files: ğ‘»ğ‘ªğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and ğ‘»ğ‘ªğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
The Sender will send a randomly generated file and the Receiver will receive it and measure
the time it took for his program to receive the file. The file size should be at least 2MB.
When running the Sender and Receiver, they both should support two standard congestion
control algorithms: TCP Reno and TCP Cubic.
Notes:
â€¢ The main goal of this part is to get familiar with the TCP concept of sending
messages between two endpoints.
â€¢ For approaching this part of the assignment, please be sure that you are familiar
with the congestion control algorithms and how to change them using the correct
method in C (see Appendix B for more information).
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). You've
learned that TCP is reliable by design, so you can assume that all the data have been
passed correctly, and thus, no need to recheck.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
Usage:
â€¢ Receiver:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
â€¢ Sender:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port of the Receiver.
â€¢ ğ‘¨ğ‘³ğ‘®ğ‘¶ â€“ The TCP congestion control algorithm that will be used by the party
member (either ğ’“ğ’†ğ’ğ’ for TCP Reno or ğ’„ğ’–ğ’ƒğ’Šğ’„ for TCP Cubic).
 Communication Networks Course
Page | 3
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a TCP socket between the Sender and the
Receiver.
3) Send the file.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a TCP connection between the Receiver and
the Sender.
2) Get a connection from the sender.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./TCP_Receiver -p 1234 -algo reno
Starting Receiver...
Waiting for TCP connection...
Sender connected, beginning to receive file...
File transfer completed.
Waiting for Sender response...
Sender sent exit message.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 4
Part B â€“ Reliable User Datagram Protocol (Reliable UDP or RUDP) â€“ 40 points
Youâ€™ve learned that while TCP is reliable, it lacks speed and has an overhead data of 20 bytes,
compering to UDP that needs only 8 bytes of overhead data.
Reliable UDP or RUDP, is a protocol that uses the UDP protocol for a faster transmission of
data, while adding a reliability layer to it, but without adding too much overhead data like
TCP.
A simple sketch for a RUDP connection would look something like this:
Your task in this part is to implement a Reliable protocol using UDP only. For simplicity, your
implementation should only support a handshake, closing scheme, error checking,
acknowledgment of received packets, and retransmission of lost packets.
Guidance:
â€¢ You can use ğ‘ ğ‘’ğ‘¡ğ‘ ğ‘œğ‘ğ‘˜ğ‘œğ‘ğ‘¡(2) for detecting a timeout.
â€¢ You need to build your own protocol, as Reliable UDP isnâ€™t a standard protocol (see a
draft of RUDP in this link), and no official header is provided. You can use this sketch
for a header, but you can come up with your own protocol, as long as it works.
Where:
o ğ‘³ğ’†ğ’ğ’ˆğ’•ğ’‰ is the length of the data itself, without the RUDP header.
o ğ‘ªğ’‰ğ’†ğ’„ğ’Œğ’”ğ’–ğ’ is a 16bit number that validates the correctness of the data.
o ğ‘­ğ’ğ’‚ğ’ˆğ’” is a special byte where we classify the packet itself (SYN, ACK, etc.).
â€¢ In your PDF, you must explain how your implementation of RUDP works â€“ How does
it detect a timeout to do retransmissions, how does the handshake work, what is the
header overhead, etc.
â€¢ For this part, youâ€™ll write three files: ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¨ğ‘·ğ‘°. ğ’„, ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and
ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
Reliable UDP Header proposed sketch
Byte 0 Byte 1 Byte 2 Byte 3
Length (2 Bytes) Checksum (2 Bytes)
Flags (1 Byte)
Figure 1 - RUDP Protocol Architecture, Geeksforgeeks
 Communication Networks Course
Page | 5
Notes:
â€¢ The Sender will send a random generated file and the Receiver will receive it and
measure the time it took for his program to receive the file. The file size should be at
least 2MB.
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). But, as the
RUDP is based on UDP, itâ€™s not reliable. You must use some form of error checking
(like checksum) to ensure that the packet wasnâ€™t alerted during the transfer.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
â€¢ The RUDP needs support only 1 sender and 1 receiver, for simplicity purposes.
Usage:
â€¢ Receiver:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
â€¢ Sender:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port that both the Sender and the Receiver will use.
The ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„ file will contain all the implementations of the RUDP API functions (That is, to
prevent reusing the same chuck of code both in the Sender and the Receiver.).
The API should support at the bare minimum the following functions (you decide what
parameters to implement, and what are the names of the functions, as long as the API is
explained in the PDF):
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘œğ‘ğ‘˜ğ‘’ğ‘¡() â€“ Creating a RUDP socket and creating a handshake between two
peers.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘’ğ‘›ğ‘‘() â€“ Sending data to the peer. The function should wait for an
acknowledgment packet, and if it didnâ€™t receive any, retransmits the data.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘Ÿğ‘’ğ‘ğ‘£() â€“ Receive data from a peer.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ğ‘™ğ‘œğ‘ ğ‘’() â€“ Closes a connection between peers.
 Communication Networks Course
Page | 6
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a UDP socket between the Sender and the
Receiver.
3) Send the file via the RUDP protocol.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a UDP connection between the Receiver and
the Sender.
2) Get a connection from the sender, by the custom
RUDP protocol youâ€™ve built.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./RUDP_Receiver -p 1234
Starting Receiver...
Waiting for RUDP connection...
Connection request received, sending ACK.
Sender connected, beginning to receive file...
File transfer completed.
ACK sent.
Waiting for Sender response...
Sender sent exit message.
ACK sent.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 7
Part C â€“ Research â€“ 30 points
In this part, youâ€™ll conduct research about your implementations of part A and part B.
In the research itself, each one of the versions (TCP version and UDP version) will be run at
least 5 times (meaning that the file transfer will occur at least 5 times) by the following
conditions:
â€¢ For TCP, youâ€™ll run it in TCP Reno and TCP Cubic, alternating each time, for each
scenario, meaning that you run 5 times with TCP Reno in both Sender and Receiver,
and 5 times with TCP Cubic in both Sender and Receiver.
Bonus (5 points): Create a very large data set â€“ 5 times with TCP Reno in both Sender
and Receiver, 5 times with TCP Reno in Sender and TCP Cubic in Receiver, 5 times
with TCP Cubic in Sender and TCP Reno in Receiver, and 5 times with TCP Cubic in
both Sender and Receiver. This will give you a data set large enough, which allows
you to work with, compare with and to reach a definite conclusion.
â€¢ For RUDP, you will run it 5 times for each scenario.
â€¢ For both TCP and RUDP, you will run them on those scenarios of packet loss:
o 0% packet loss â€“ Control group, simulating perfect connection.
o 2% packet loss â€“ Simulating unstable connection that commonly occur.
o 5% packet loss â€“ Simulating bad connection.
o 10% packet loss â€“ Simulating extremely poor connection.
For each scenario, you must provide a filtered PCAP file and relevant screenshots that
explain each one of the steps in the process. (10 points)
After youâ€™ve gathered the data set for both TCP and Reliable UDP, answer the following
questions:
1) In TCP, which congestion control algorithm gave better results overall? TCP Reno or
TCP Cubic? Which one gave better results on high packet loss? Explain how you came
to this conclusion based on the data set youâ€™ve gathered. (5 points)
2) How did your implementation of Reliable UDP perform overall compared to regular
TCP? Which one is better for high packet loss? (5 points)
3) According to the data youâ€™ve gathered, in which scenarios and applications would we
prefer to use TCP and in which situations would we prefer to use reliable UDP?
Explain your answer. (5 points)
 Communication Networks Course
Page | 8
×¢× ×• ×¢×œ ×”×©××œ×•×ª ×”×‘××•×ª )5 × ×§×•×“×•×ª(:
â— ×‘"×¨×©×ª ×××™× ×”" ×”×›×•×•× ×” ×”×™× ×œ×¨×©×ª ×©×‘×” ××¢×˜ ×××•×“ ×—×‘×™×œ×•×ª ×”×•×œ×›×•×ª ×œ××™×‘×•×“. ×‘"×§×©×¨ ××¨×•×š" ×”×›×•×•× ×” ×”×™×
×œ×§×©×¨ TCP ×©×™×© ×‘×• ×”×¨×‘×” ×××•×“ ××™×“×¢ ×œ×©×œ×•×—. ××•×¦×¢ ×œ×”×’×“×™×œ ×‘ -TCP ××ª SSThreshold ×‘×ª×—×™×œ×ª ×”×§×©×¨.
×‘××™×–×” ××”××§×¨×™× ×”×‘××™× ×”×©×™× ×•×™ ×”×–×” ×¢×©×•×™ ×œ×”×•×¢×™×œ ×‘××™×“×” ×”××™×¨×‘×™×ª? × ××§.
.1 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
.2 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.3 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.4 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.5 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.6 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.7 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.8 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
â— A ×©×•×œ×— ×œ -B ×—×‘×™×œ×•×ª ××™×“×¢ ×‘×××¦×¢×•×ª ×§×©×¨ TCP. × ×ª×•×Ÿ ×›×™ ×”×§×©×¨ ××ª×—×™×œ ×¢× ×—×œ×•×Ÿ ×‘×’×•×“×œ 1MSS. ×”×§×©×¨
××¡×ª×™×™× ×‘×¤×¢× ×”×¨××©×•× ×” ×©×”×•× ××’×™×¢ ×œ -SSthresh. ×‘××”×œ×š ×”×§×©×¨ ×œ× ××•×‘×“×•×ª ×—×‘×™×œ×•×ª. × ×¡××Ÿ ×‘×§×™×¦×•×¨:
.SSthresh=S*MSS
× ×ª×•×Ÿ ×›×™ ×œ××•×¨×š ×›×œ ×”×§×©×¨ rwnd < MSS*S.
××”×™ ×”×ª×¤×•×§×” ×©×œ ×”×§×©×¨ ×-A ×œ-B( ×‘ -sec / Bytes )×‘×–××Ÿ ×”× "×œ? × ××§×™.
]S*MSS / [lg (S) * RTT*2 ×‘×¢×¨×š .1
]S*MSS / [S^0.5 * RTT*2 ×‘×¢×¨×š .2
S*MSS / RTT ×‘×¢×¨×š .3
S^2)*MSS / RTT( ×‘×¢×¨×š .4
â— ×©×ª×™ ×ª×—× ×•×ª ××ª×§×©×¨×•×ª ×‘××•×¤×Ÿ ××œ×—×•×˜×™ ×‘×©×™×˜×ª N Back Go.
× ×¡××Ÿ ×‘-X ××ª ×¡×¤×¨×ª ×”×‘×™×§×•×¨×ª ×©×œ ×”×ª.×–. ×©×œ×š. ×× ×©× ×™ ×©×•×ª×¤×™× ××’×™×©×™× ××ª ×”×ª×¨×’×™×œ ×™×—×“, X ×”×•× ×¡×¤×¨×ª
×”×‘×™×§×•×¨×ª ×‘×¢×œ×ª ×”×¢×¨×š ×”× ××•×š ×™×•×ª×¨ ××‘×™×Ÿ ×”×©×ª×™×™×.
×§×¦×‘ ×”×ª×§×©×•×¨×ª ×”×•× 8Gbps, ×•×’×•×“×œ ×›×œ ×—×‘×™×œ×” ×”×•× KByte*X. ×’×“×œ×™ ×”-headers ×•×” -Acks ×–× ×™×—×™×.
ï¿½ğ‘’ğ‘ ï¿½/ï¿½ï¿½ 8 , ×•×”××¨×—×§ ×‘×™×Ÿ ×”×ª×—× ×•×ª ×”×•× 1Km. ×§×¦×‘ ×”×”×ª×¤×©×˜×•×ª ×”×•× 10 â‹… 2
×–××Ÿ ×¢×™×‘×•×“ ×”× ×ª×•× ×™× ×‘×ª×—× ×•×ª ×–× ×™×—.
××£ ×—×‘×™×œ×” ×•××£ Ack ×œ× ×”×•×œ×›×™× ×œ××™×‘×•×“.
â— ××”×• X ×©×œ×š?
â— ××” ×¦×¨×™×š ×œ×”×™×•×ª ×’×•×“×œ ×—×œ×•×Ÿ ×”××©×œ×•×— ×›×“×™ ×œ×”×‘×˜×™×— ×ª×¤×•×§×” ××§×¡×™××œ×™×ª?
 Communication Networks Course
Page | 9
Bonus â€“ Improving the Reliable UDP â€“ 15 points
Note: This part isnâ€™t mandatory and is a bonus only!
In this part, youâ€™ll improve your RUDP implementation by adding the concepts of flow
control and congestion control from TCP. Youâ€™re free to choose which algorithms to
implement, as long as you explain in your PDF which algorithms youâ€™ve used. Youâ€™ll probably
need to make changes in the original design of the RUDP. Changes only need to be to the API
itself, ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„.
Points distribution:
â€¢ Flow control improvement â€“ 7 Points
â€¢ Congestion control improvement â€“ 8 points.
Guidance:
â€¢ For flow control, you must use one of the Sliding window techniques: stop-and-wait
ARQ, Go-Back-N or Selective repeat.
â€¢ List of known TCP congestion control algorithms, which you can use any one of them
for this bonus task, or makeup your own:
Figure 2 â€“ List of known TCP congestion control algorithms, Wikipedia
 Communication Networks Course
Page | 10
Appendix A â€“ Linux local packet loss tool
To simulate a packet loss in a local network, we'll use a Linux tool that's called Linux Traffic
Control (ğ‘¡ğ‘). This requires a full Linux installation, so working with WSL won't work.
If the tool isn't installed in your machine, you can install it by using the following commands:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’
If the installation didn't work, you can use the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’2
To create a packet loss scenario, type the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘ğ‘‘ğ‘‘ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
After creating a packet loss scenario, you can change the percentage by typing the following
command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘â„ğ‘ğ‘›ğ‘”ğ‘’ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
To remove the packet loss scenario, write the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘‘ğ‘’ğ‘™ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š
 Communication Networks Course
Page | 11
Appendix B â€“ ğ’ğ’‚ğ’(ğŸ) system calls
This appendixâ€™s purpose is to give you a better understanding of socket handling in C.
A recommended reference is Beejâ€™s Guide to Network Programming, by Brian â€œBeej
Jorgensenâ€ Hall, which gives a lot of information about sockets in C and functions.
Functions and documentation links:
â€¢ ğ’”ğ’ğ’„ğ’Œğ’†ğ’•(ğŸ) â€“ A Factory method system call that creates a socket with the given
parameters.
â€¢ ğ’ƒğ’Šğ’ğ’…(ğŸ) â€“ Whenever we create a new socket, we need to bind it to a specific port in
our machine, â€œto catch a portâ€. The port number is managed and used by the kernel
to link incoming packets to the corresponding application socket. The port numbers
are usually fixed. The ğ‘ğ‘‘ğ‘‘ğ‘Ÿ parameter must match the current socket that is used.
â€¢ ğ’ğ’Šğ’”ğ’•ğ’†ğ’(ğŸ) â€“ The ğ‘™ğ‘–ğ‘ ğ‘¡ğ‘’ğ‘›(2) system call doesn't do anything in the mean of
communication but only memory allocation (malloc) for stream sockets only. If we
won't allocate memory, any incoming connection will fail.
â€¢ ğ’„ğ’ğ’ğ’ğ’†ğ’„ğ’•(ğŸ) â€“ The ğ‘ğ‘œğ‘›ğ‘›ğ‘’ğ‘ğ‘¡(2) system call starts the link between a client and a
specific IP address and port number. The connection would complete when the
other side will call the ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call.
â€¢ ğ’‚ğ’„ğ’„ğ’†ğ’‘ğ’•(ğŸ) â€“ The ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call accepts the incoming stream connection
request from the other side, by the listening socket. This system call completes the
three-way handshake of stream socket (like TCP) and opens a new socket that has a
direct communication channel only with the other party in the handshake.
â€¢ ğ’”ğ’†ğ’ğ’…(ğŸ) and ğ’”ğ’†ğ’ğ’…ğ’•ğ’(ğŸ) â€“ The ğ‘ ğ‘’ğ‘›ğ‘‘(2) and ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system calls are an analogy
for the ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’(2) system call, specifcly for sockets, with flags set to 0. Those system
calls return the number of bytes that were sent through the socket itself, as the
number of bytes can vary. The ğ‘ ğ‘’ğ‘›ğ‘‘(2)system call designed for stream sockets (like
TCP), while the ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system call designed for datagram connection-less
sockets (like UDP). When the ğ‘ ğ‘’ğ‘›ğ‘‘(2) system call returns 0, it means that the other
party closed the connection.
â€¢ ğ’“ğ’†ğ’„ğ’—(ğŸ) and ğ’“ğ’†ğ’„ğ’—ğ’‡ğ’“ğ’ğ’(ğŸ) â€“ The ğ‘Ÿğ‘’ğ‘ğ‘£(2) and ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system calls are an
analogy for the ğ‘Ÿğ‘’ğ‘ğ‘‘(2) system call, specifically for sockets, with flags set to 0.
Those system calls return the number of bytes that were received through the socket
itself, as the number of bytes can vary. The ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call designed for stream
sockets (like TCP), while the ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system call designed for datagram
connection-less sockets (like UDP). When the ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call returns 0, it means
that the other party closed the connection.
â€¢ ğ’„ğ’ğ’ğ’”ğ’†(ğŸ) and ğ’”ğ’‰ğ’–ğ’•ğ’…ğ’ğ’˜ğ’(ğŸ) â€“ The ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) and ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2) system calls close
the socket. While ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) system call closes the whole socket, the ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2)
system call partially closes the socket for read/write.
 Communication Networks Course
Page | 12
Appendix C â€“ Random data generator
The data that you are going to send in this assignment is randomly generated. You can use
your own file with appropriate size or use the following function (or a function of your own)
to generate the data:
/*
* @brief A random data generator function based on srand() and rand().
* @param size The size of the data to generate (up to 2^32 bytes).
* @return A pointer to the buffer.
*/
char *util_generate_random_data(unsigned int size) {
 char *buffer = NULL;
 // Argument check.
 if (size == 0)
 return NULL;
 buffer = (char *)calloc(size, sizeof(char));
 // Error checking.
 if (buffer == NULL)
 return NULL;
 // Randomize the seed of the random number generator.
 srand(time(NULL));
 for (unsigned int i = 0; i < size; i++)
 *(buffer + i) = ((unsigned int)rand() % 256);
 return buffer;
}
 Communication Networks Course
Page | 13
Appendix D â€“ Checksum function
A checksum is a small-sized block of data derived from another block of digital data for the
purpose of detecting errors that may have been introduced during its transmission or
storage. By themselves, checksums are often used to verify data integrity but are not relied
upon to verify data authenticity.
Below is a simple yet efficient implementation of the checksum function, you can use it for
the assignment, but you can implement your own checksum function.
/*
* @brief A checksum function that returns 16 bit checksum for data.
* @param data The data to do the checksum for.
* @param bytes The length of the data in bytes.
* @return The checksum itself as 16 bit unsigned number.
* @note This function is taken from RFC1071, can be found here:
* @note https://tools.ietf.org/html/rfc1071
* @note It is the simplest way to calculate a checksum and is not very strong.
* However, it is good enough for this assignment.
* @note You are free to use any other checksum function as well.
* You can also use this function as such without any change.
*/
unsigned short int calculate_checksum(void *data, unsigned int bytes) {
 unsigned short int *data_pointer = (unsigned short int *)data;
 unsigned int total_sum = 0;
 // Main summing loop
 while (bytes > 1) {
 total_sum += *data_pointer++;
 bytes -= 2;
 }
 // Add left-over byte, if any
 if (bytes > 0)
 total_sum += *((unsigned char *)data_pointer);
 // Fold 32-bit sum to 16 bits
 while (total_sum >> 16)
 total_sum = (total_sum & 0xFFFF) + (total_sum >> 16);
 return (~((unsigned short int)total_sum));
} Communication Networks Course
Page | 1
Assignment 3 â€“ Transport Layer
Assignment Notes and Instructions
This assignment is to be done in pairs only. You must upload all the necessary files in a ZIP
file named after both of the studentâ€™s ID. For example: ğŸğŸğŸ‘ğŸ’ğŸ“ğŸ”ğŸ•ğŸ–ğŸ—_ğŸ—ğŸ–ğŸ•ğŸ”ğŸ“ğŸ’ğŸ‘ğŸğŸ. ğ’›ğ’Šğ’‘.
1) The assignment must be submitted by the date specified in the submission box.
2) All the assignment files (Code, Wireshark pcap files, PDF) must be submitted in a ZIP file. The
PDF must contain all the necessary screenshots with a description for each one of them.
3) The assignment must be done in pairs only. In exceptional cases, you should send an email to
the course coordinator.
4) You can use any reference material available through the course Moodle website or any
material passed during the exercises.
5) You can use any reference from the web, but copying codes from websites is forbidden; this
includes codes from other GitHub repositories. A student who gets caught in the act will
automatically fail this assignment (score 0). Any website youâ€™ve used to solve the
assignment, every website you used to solve the assignment must be noted in the PDF.
6) No delays in submission without special permission. Lateness without approval will result in
failure of the assignment (score 0).
7) All submissions will be submitted via the course's Moodle website. Email submissions will not
be accepted, resulting in a failure in the assignment.
8) The order and design of the code must be carefully considered. Make sure that the program
output is as clear as possible, comments in the code, and meaningful variable names. You
must also submit a makefile that compiles all the programs.
9) The assignment code must be written in C only.
10) The assignment is personal for each pair, and you should not accept help from other people,
whether outside the university or inside it. You can contact the course staff during reception
hours for help or raise a question in the course forum. Do not transfer code sections
between students, upload solutions or parts of solutions to websites on the Internet or in
various communication groups.
11) Students who copy a solution will receive a 0 in all assignments in the course and a report will
be made to the institutional disciplinary committee.
12) All code files of the assignment are required to both compile and run properly on the Ubuntu
22.04 LTS operating system. This is the operating system where the submissions will be
tested. You mustnâ€™t code it in Windows, as it uses different API for sockets. WSL wonâ€™t work,
as the task needs a tool that works only in a fully Linux environment.
Good Luck!
 Communication Networks Course
Page | 2
Part A â€“ Transmission Control Protocol (TCP) â€“ 30 points
In this part, youâ€™ll write two program files: ğ‘»ğ‘ªğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and ğ‘»ğ‘ªğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
The Sender will send a randomly generated file and the Receiver will receive it and measure
the time it took for his program to receive the file. The file size should be at least 2MB.
When running the Sender and Receiver, they both should support two standard congestion
control algorithms: TCP Reno and TCP Cubic.
Notes:
â€¢ The main goal of this part is to get familiar with the TCP concept of sending
messages between two endpoints.
â€¢ For approaching this part of the assignment, please be sure that you are familiar
with the congestion control algorithms and how to change them using the correct
method in C (see Appendix B for more information).
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). You've
learned that TCP is reliable by design, so you can assume that all the data have been
passed correctly, and thus, no need to recheck.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
Usage:
â€¢ Receiver:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
â€¢ Sender:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port of the Receiver.
â€¢ ğ‘¨ğ‘³ğ‘®ğ‘¶ â€“ The TCP congestion control algorithm that will be used by the party
member (either ğ’“ğ’†ğ’ğ’ for TCP Reno or ğ’„ğ’–ğ’ƒğ’Šğ’„ for TCP Cubic).
 Communication Networks Course
Page | 3
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a TCP socket between the Sender and the
Receiver.
3) Send the file.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a TCP connection between the Receiver and
the Sender.
2) Get a connection from the sender.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./TCP_Receiver -p 1234 -algo reno
Starting Receiver...
Waiting for TCP connection...
Sender connected, beginning to receive file...
File transfer completed.
Waiting for Sender response...
Sender sent exit message.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 4
Part B â€“ Reliable User Datagram Protocol (Reliable UDP or RUDP) â€“ 40 points
Youâ€™ve learned that while TCP is reliable, it lacks speed and has an overhead data of 20 bytes,
compering to UDP that needs only 8 bytes of overhead data.
Reliable UDP or RUDP, is a protocol that uses the UDP protocol for a faster transmission of
data, while adding a reliability layer to it, but without adding too much overhead data like
TCP.
A simple sketch for a RUDP connection would look something like this:
Your task in this part is to implement a Reliable protocol using UDP only. For simplicity, your
implementation should only support a handshake, closing scheme, error checking,
acknowledgment of received packets, and retransmission of lost packets.
Guidance:
â€¢ You can use ğ‘ ğ‘’ğ‘¡ğ‘ ğ‘œğ‘ğ‘˜ğ‘œğ‘ğ‘¡(2) for detecting a timeout.
â€¢ You need to build your own protocol, as Reliable UDP isnâ€™t a standard protocol (see a
draft of RUDP in this link), and no official header is provided. You can use this sketch
for a header, but you can come up with your own protocol, as long as it works.
Where:
o ğ‘³ğ’†ğ’ğ’ˆğ’•ğ’‰ is the length of the data itself, without the RUDP header.
o ğ‘ªğ’‰ğ’†ğ’„ğ’Œğ’”ğ’–ğ’ is a 16bit number that validates the correctness of the data.
o ğ‘­ğ’ğ’‚ğ’ˆğ’” is a special byte where we classify the packet itself (SYN, ACK, etc.).
â€¢ In your PDF, you must explain how your implementation of RUDP works â€“ How does
it detect a timeout to do retransmissions, how does the handshake work, what is the
header overhead, etc.
â€¢ For this part, youâ€™ll write three files: ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¨ğ‘·ğ‘°. ğ’„, ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and
ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
Reliable UDP Header proposed sketch
Byte 0 Byte 1 Byte 2 Byte 3
Length (2 Bytes) Checksum (2 Bytes)
Flags (1 Byte)
Figure 1 - RUDP Protocol Architecture, Geeksforgeeks
 Communication Networks Course
Page | 5
Notes:
â€¢ The Sender will send a random generated file and the Receiver will receive it and
measure the time it took for his program to receive the file. The file size should be at
least 2MB.
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). But, as the
RUDP is based on UDP, itâ€™s not reliable. You must use some form of error checking
(like checksum) to ensure that the packet wasnâ€™t alerted during the transfer.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
â€¢ The RUDP needs support only 1 sender and 1 receiver, for simplicity purposes.
Usage:
â€¢ Receiver:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
â€¢ Sender:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port that both the Sender and the Receiver will use.
The ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„ file will contain all the implementations of the RUDP API functions (That is, to
prevent reusing the same chuck of code both in the Sender and the Receiver.).
The API should support at the bare minimum the following functions (you decide what
parameters to implement, and what are the names of the functions, as long as the API is
explained in the PDF):
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘œğ‘ğ‘˜ğ‘’ğ‘¡() â€“ Creating a RUDP socket and creating a handshake between two
peers.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘’ğ‘›ğ‘‘() â€“ Sending data to the peer. The function should wait for an
acknowledgment packet, and if it didnâ€™t receive any, retransmits the data.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘Ÿğ‘’ğ‘ğ‘£() â€“ Receive data from a peer.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ğ‘™ğ‘œğ‘ ğ‘’() â€“ Closes a connection between peers.
 Communication Networks Course
Page | 6
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a UDP socket between the Sender and the
Receiver.
3) Send the file via the RUDP protocol.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a UDP connection between the Receiver and
the Sender.
2) Get a connection from the sender, by the custom
RUDP protocol youâ€™ve built.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./RUDP_Receiver -p 1234
Starting Receiver...
Waiting for RUDP connection...
Connection request received, sending ACK.
Sender connected, beginning to receive file...
File transfer completed.
ACK sent.
Waiting for Sender response...
Sender sent exit message.
ACK sent.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 7
Part C â€“ Research â€“ 30 points
In this part, youâ€™ll conduct research about your implementations of part A and part B.
In the research itself, each one of the versions (TCP version and UDP version) will be run at
least 5 times (meaning that the file transfer will occur at least 5 times) by the following
conditions:
â€¢ For TCP, youâ€™ll run it in TCP Reno and TCP Cubic, alternating each time, for each
scenario, meaning that you run 5 times with TCP Reno in both Sender and Receiver,
and 5 times with TCP Cubic in both Sender and Receiver.
Bonus (5 points): Create a very large data set â€“ 5 times with TCP Reno in both Sender
and Receiver, 5 times with TCP Reno in Sender and TCP Cubic in Receiver, 5 times
with TCP Cubic in Sender and TCP Reno in Receiver, and 5 times with TCP Cubic in
both Sender and Receiver. This will give you a data set large enough, which allows
you to work with, compare with and to reach a definite conclusion.
â€¢ For RUDP, you will run it 5 times for each scenario.
â€¢ For both TCP and RUDP, you will run them on those scenarios of packet loss:
o 0% packet loss â€“ Control group, simulating perfect connection.
o 2% packet loss â€“ Simulating unstable connection that commonly occur.
o 5% packet loss â€“ Simulating bad connection.
o 10% packet loss â€“ Simulating extremely poor connection.
For each scenario, you must provide a filtered PCAP file and relevant screenshots that
explain each one of the steps in the process. (10 points)
After youâ€™ve gathered the data set for both TCP and Reliable UDP, answer the following
questions:
1) In TCP, which congestion control algorithm gave better results overall? TCP Reno or
TCP Cubic? Which one gave better results on high packet loss? Explain how you came
to this conclusion based on the data set youâ€™ve gathered. (5 points)
2) How did your implementation of Reliable UDP perform overall compared to regular
TCP? Which one is better for high packet loss? (5 points)
3) According to the data youâ€™ve gathered, in which scenarios and applications would we
prefer to use TCP and in which situations would we prefer to use reliable UDP?
Explain your answer. (5 points)
 Communication Networks Course
Page | 8
×¢× ×• ×¢×œ ×”×©××œ×•×ª ×”×‘××•×ª )5 × ×§×•×“×•×ª(:
â— ×‘"×¨×©×ª ×××™× ×”" ×”×›×•×•× ×” ×”×™× ×œ×¨×©×ª ×©×‘×” ××¢×˜ ×××•×“ ×—×‘×™×œ×•×ª ×”×•×œ×›×•×ª ×œ××™×‘×•×“. ×‘"×§×©×¨ ××¨×•×š" ×”×›×•×•× ×” ×”×™×
×œ×§×©×¨ TCP ×©×™×© ×‘×• ×”×¨×‘×” ×××•×“ ××™×“×¢ ×œ×©×œ×•×—. ××•×¦×¢ ×œ×”×’×“×™×œ ×‘ -TCP ××ª SSThreshold ×‘×ª×—×™×œ×ª ×”×§×©×¨.
×‘××™×–×” ××”××§×¨×™× ×”×‘××™× ×”×©×™× ×•×™ ×”×–×” ×¢×©×•×™ ×œ×”×•×¢×™×œ ×‘××™×“×” ×”××™×¨×‘×™×ª? × ××§.
.1 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
.2 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.3 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.4 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.5 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.6 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.7 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.8 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
â— A ×©×•×œ×— ×œ -B ×—×‘×™×œ×•×ª ××™×“×¢ ×‘×××¦×¢×•×ª ×§×©×¨ TCP. × ×ª×•×Ÿ ×›×™ ×”×§×©×¨ ××ª×—×™×œ ×¢× ×—×œ×•×Ÿ ×‘×’×•×“×œ 1MSS. ×”×§×©×¨
××¡×ª×™×™× ×‘×¤×¢× ×”×¨××©×•× ×” ×©×”×•× ××’×™×¢ ×œ -SSthresh. ×‘××”×œ×š ×”×§×©×¨ ×œ× ××•×‘×“×•×ª ×—×‘×™×œ×•×ª. × ×¡××Ÿ ×‘×§×™×¦×•×¨:
.SSthresh=S*MSS
× ×ª×•×Ÿ ×›×™ ×œ××•×¨×š ×›×œ ×”×§×©×¨ rwnd < MSS*S.
××”×™ ×”×ª×¤×•×§×” ×©×œ ×”×§×©×¨ ×-A ×œ-B( ×‘ -sec / Bytes )×‘×–××Ÿ ×”× "×œ? × ××§×™.
]S*MSS / [lg (S) * RTT*2 ×‘×¢×¨×š .1
]S*MSS / [S^0.5 * RTT*2 ×‘×¢×¨×š .2
S*MSS / RTT ×‘×¢×¨×š .3
S^2)*MSS / RTT( ×‘×¢×¨×š .4
â— ×©×ª×™ ×ª×—× ×•×ª ××ª×§×©×¨×•×ª ×‘××•×¤×Ÿ ××œ×—×•×˜×™ ×‘×©×™×˜×ª N Back Go.
× ×¡××Ÿ ×‘-X ××ª ×¡×¤×¨×ª ×”×‘×™×§×•×¨×ª ×©×œ ×”×ª.×–. ×©×œ×š. ×× ×©× ×™ ×©×•×ª×¤×™× ××’×™×©×™× ××ª ×”×ª×¨×’×™×œ ×™×—×“, X ×”×•× ×¡×¤×¨×ª
×”×‘×™×§×•×¨×ª ×‘×¢×œ×ª ×”×¢×¨×š ×”× ××•×š ×™×•×ª×¨ ××‘×™×Ÿ ×”×©×ª×™×™×.
×§×¦×‘ ×”×ª×§×©×•×¨×ª ×”×•× 8Gbps, ×•×’×•×“×œ ×›×œ ×—×‘×™×œ×” ×”×•× KByte*X. ×’×“×œ×™ ×”-headers ×•×” -Acks ×–× ×™×—×™×.
ï¿½ğ‘’ğ‘ ï¿½/ï¿½ï¿½ 8 , ×•×”××¨×—×§ ×‘×™×Ÿ ×”×ª×—× ×•×ª ×”×•× 1Km. ×§×¦×‘ ×”×”×ª×¤×©×˜×•×ª ×”×•× 10 â‹… 2
×–××Ÿ ×¢×™×‘×•×“ ×”× ×ª×•× ×™× ×‘×ª×—× ×•×ª ×–× ×™×—.
××£ ×—×‘×™×œ×” ×•××£ Ack ×œ× ×”×•×œ×›×™× ×œ××™×‘×•×“.
â— ××”×• X ×©×œ×š?
â— ××” ×¦×¨×™×š ×œ×”×™×•×ª ×’×•×“×œ ×—×œ×•×Ÿ ×”××©×œ×•×— ×›×“×™ ×œ×”×‘×˜×™×— ×ª×¤×•×§×” ××§×¡×™××œ×™×ª?
 Communication Networks Course
Page | 9
Bonus â€“ Improving the Reliable UDP â€“ 15 points
Note: This part isnâ€™t mandatory and is a bonus only!
In this part, youâ€™ll improve your RUDP implementation by adding the concepts of flow
control and congestion control from TCP. Youâ€™re free to choose which algorithms to
implement, as long as you explain in your PDF which algorithms youâ€™ve used. Youâ€™ll probably
need to make changes in the original design of the RUDP. Changes only need to be to the API
itself, ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„.
Points distribution:
â€¢ Flow control improvement â€“ 7 Points
â€¢ Congestion control improvement â€“ 8 points.
Guidance:
â€¢ For flow control, you must use one of the Sliding window techniques: stop-and-wait
ARQ, Go-Back-N or Selective repeat.
â€¢ List of known TCP congestion control algorithms, which you can use any one of them
for this bonus task, or makeup your own:
Figure 2 â€“ List of known TCP congestion control algorithms, Wikipedia
 Communication Networks Course
Page | 10
Appendix A â€“ Linux local packet loss tool
To simulate a packet loss in a local network, we'll use a Linux tool that's called Linux Traffic
Control (ğ‘¡ğ‘). This requires a full Linux installation, so working with WSL won't work.
If the tool isn't installed in your machine, you can install it by using the following commands:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’
If the installation didn't work, you can use the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’2
To create a packet loss scenario, type the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘ğ‘‘ğ‘‘ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
After creating a packet loss scenario, you can change the percentage by typing the following
command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘â„ğ‘ğ‘›ğ‘”ğ‘’ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
To remove the packet loss scenario, write the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘‘ğ‘’ğ‘™ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š
 Communication Networks Course
Page | 11
Appendix B â€“ ğ’ğ’‚ğ’(ğŸ) system calls
This appendixâ€™s purpose is to give you a better understanding of socket handling in C.
A recommended reference is Beejâ€™s Guide to Network Programming, by Brian â€œBeej
Jorgensenâ€ Hall, which gives a lot of information about sockets in C and functions.
Functions and documentation links:
â€¢ ğ’”ğ’ğ’„ğ’Œğ’†ğ’•(ğŸ) â€“ A Factory method system call that creates a socket with the given
parameters.
â€¢ ğ’ƒğ’Šğ’ğ’…(ğŸ) â€“ Whenever we create a new socket, we need to bind it to a specific port in
our machine, â€œto catch a portâ€. The port number is managed and used by the kernel
to link incoming packets to the corresponding application socket. The port numbers
are usually fixed. The ğ‘ğ‘‘ğ‘‘ğ‘Ÿ parameter must match the current socket that is used.
â€¢ ğ’ğ’Šğ’”ğ’•ğ’†ğ’(ğŸ) â€“ The ğ‘™ğ‘–ğ‘ ğ‘¡ğ‘’ğ‘›(2) system call doesn't do anything in the mean of
communication but only memory allocation (malloc) for stream sockets only. If we
won't allocate memory, any incoming connection will fail.
â€¢ ğ’„ğ’ğ’ğ’ğ’†ğ’„ğ’•(ğŸ) â€“ The ğ‘ğ‘œğ‘›ğ‘›ğ‘’ğ‘ğ‘¡(2) system call starts the link between a client and a
specific IP address and port number. The connection would complete when the
other side will call the ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call.
â€¢ ğ’‚ğ’„ğ’„ğ’†ğ’‘ğ’•(ğŸ) â€“ The ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call accepts the incoming stream connection
request from the other side, by the listening socket. This system call completes the
three-way handshake of stream socket (like TCP) and opens a new socket that has a
direct communication channel only with the other party in the handshake.
â€¢ ğ’”ğ’†ğ’ğ’…(ğŸ) and ğ’”ğ’†ğ’ğ’…ğ’•ğ’(ğŸ) â€“ The ğ‘ ğ‘’ğ‘›ğ‘‘(2) and ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system calls are an analogy
for the ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’(2) system call, specifcly for sockets, with flags set to 0. Those system
calls return the number of bytes that were sent through the socket itself, as the
number of bytes can vary. The ğ‘ ğ‘’ğ‘›ğ‘‘(2)system call designed for stream sockets (like
TCP), while the ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system call designed for datagram connection-less
sockets (like UDP). When the ğ‘ ğ‘’ğ‘›ğ‘‘(2) system call returns 0, it means that the other
party closed the connection.
â€¢ ğ’“ğ’†ğ’„ğ’—(ğŸ) and ğ’“ğ’†ğ’„ğ’—ğ’‡ğ’“ğ’ğ’(ğŸ) â€“ The ğ‘Ÿğ‘’ğ‘ğ‘£(2) and ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system calls are an
analogy for the ğ‘Ÿğ‘’ğ‘ğ‘‘(2) system call, specifically for sockets, with flags set to 0.
Those system calls return the number of bytes that were received through the socket
itself, as the number of bytes can vary. The ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call designed for stream
sockets (like TCP), while the ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system call designed for datagram
connection-less sockets (like UDP). When the ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call returns 0, it means
that the other party closed the connection.
â€¢ ğ’„ğ’ğ’ğ’”ğ’†(ğŸ) and ğ’”ğ’‰ğ’–ğ’•ğ’…ğ’ğ’˜ğ’(ğŸ) â€“ The ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) and ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2) system calls close
the socket. While ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) system call closes the whole socket, the ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2)
system call partially closes the socket for read/write.
 Communication Networks Course
Page | 12
Appendix C â€“ Random data generator
The data that you are going to send in this assignment is randomly generated. You can use
your own file with appropriate size or use the following function (or a function of your own)
to generate the data:
/*
* @brief A random data generator function based on srand() and rand().
* @param size The size of the data to generate (up to 2^32 bytes).
* @return A pointer to the buffer.
*/
char *util_generate_random_data(unsigned int size) {
 char *buffer = NULL;
 // Argument check.
 if (size == 0)
 return NULL;
 buffer = (char *)calloc(size, sizeof(char));
 // Error checking.
 if (buffer == NULL)
 return NULL;
 // Randomize the seed of the random number generator.
 srand(time(NULL));
 for (unsigned int i = 0; i < size; i++)
 *(buffer + i) = ((unsigned int)rand() % 256);
 return buffer;
}
 Communication Networks Course
Page | 13
Appendix D â€“ Checksum function
A checksum is a small-sized block of data derived from another block of digital data for the
purpose of detecting errors that may have been introduced during its transmission or
storage. By themselves, checksums are often used to verify data integrity but are not relied
upon to verify data authenticity.
Below is a simple yet efficient implementation of the checksum function, you can use it for
the assignment, but you can implement your own checksum function.
/*
* @brief A checksum function that returns 16 bit checksum for data.
* @param data The data to do the checksum for.
* @param bytes The length of the data in bytes.
* @return The checksum itself as 16 bit unsigned number.
* @note This function is taken from RFC1071, can be found here:
* @note https://tools.ietf.org/html/rfc1071
* @note It is the simplest way to calculate a checksum and is not very strong.
* However, it is good enough for this assignment.
* @note You are free to use any other checksum function as well.
* You can also use this function as such without any change.
*/
unsigned short int calculate_checksum(void *data, unsigned int bytes) {
 unsigned short int *data_pointer = (unsigned short int *)data;
 unsigned int total_sum = 0;
 // Main summing loop
 while (bytes > 1) {
 total_sum += *data_pointer++;
 bytes -= 2;
 }
 // Add left-over byte, if any
 if (bytes > 0)
 total_sum += *((unsigned char *)data_pointer);
 // Fold 32-bit sum to 16 bits
 while (total_sum >> 16)
 total_sum = (total_sum & 0xFFFF) + (total_sum >> 16);
 return (~((unsigned short int)total_sum));
} Communication Networks Course
Page | 1
Assignment 3 â€“ Transport Layer
Assignment Notes and Instructions
This assignment is to be done in pairs only. You must upload all the necessary files in a ZIP
file named after both of the studentâ€™s ID. For example: ğŸğŸğŸ‘ğŸ’ğŸ“ğŸ”ğŸ•ğŸ–ğŸ—_ğŸ—ğŸ–ğŸ•ğŸ”ğŸ“ğŸ’ğŸ‘ğŸğŸ. ğ’›ğ’Šğ’‘.
1) The assignment must be submitted by the date specified in the submission box.
2) All the assignment files (Code, Wireshark pcap files, PDF) must be submitted in a ZIP file. The
PDF must contain all the necessary screenshots with a description for each one of them.
3) The assignment must be done in pairs only. In exceptional cases, you should send an email to
the course coordinator.
4) You can use any reference material available through the course Moodle website or any
material passed during the exercises.
5) You can use any reference from the web, but copying codes from websites is forbidden; this
includes codes from other GitHub repositories. A student who gets caught in the act will
automatically fail this assignment (score 0). Any website youâ€™ve used to solve the
assignment, every website you used to solve the assignment must be noted in the PDF.
6) No delays in submission without special permission. Lateness without approval will result in
failure of the assignment (score 0).
7) All submissions will be submitted via the course's Moodle website. Email submissions will not
be accepted, resulting in a failure in the assignment.
8) The order and design of the code must be carefully considered. Make sure that the program
output is as clear as possible, comments in the code, and meaningful variable names. You
must also submit a makefile that compiles all the programs.
9) The assignment code must be written in C only.
10) The assignment is personal for each pair, and you should not accept help from other people,
whether outside the university or inside it. You can contact the course staff during reception
hours for help or raise a question in the course forum. Do not transfer code sections
between students, upload solutions or parts of solutions to websites on the Internet or in
various communication groups.
11) Students who copy a solution will receive a 0 in all assignments in the course and a report will
be made to the institutional disciplinary committee.
12) All code files of the assignment are required to both compile and run properly on the Ubuntu
22.04 LTS operating system. This is the operating system where the submissions will be
tested. You mustnâ€™t code it in Windows, as it uses different API for sockets. WSL wonâ€™t work,
as the task needs a tool that works only in a fully Linux environment.
Good Luck!
 Communication Networks Course
Page | 2
Part A â€“ Transmission Control Protocol (TCP) â€“ 30 points
In this part, youâ€™ll write two program files: ğ‘»ğ‘ªğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and ğ‘»ğ‘ªğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
The Sender will send a randomly generated file and the Receiver will receive it and measure
the time it took for his program to receive the file. The file size should be at least 2MB.
When running the Sender and Receiver, they both should support two standard congestion
control algorithms: TCP Reno and TCP Cubic.
Notes:
â€¢ The main goal of this part is to get familiar with the TCP concept of sending
messages between two endpoints.
â€¢ For approaching this part of the assignment, please be sure that you are familiar
with the congestion control algorithms and how to change them using the correct
method in C (see Appendix B for more information).
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). You've
learned that TCP is reliable by design, so you can assume that all the data have been
passed correctly, and thus, no need to recheck.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
Usage:
â€¢ Receiver:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
â€¢ Sender:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port of the Receiver.
â€¢ ğ‘¨ğ‘³ğ‘®ğ‘¶ â€“ The TCP congestion control algorithm that will be used by the party
member (either ğ’“ğ’†ğ’ğ’ for TCP Reno or ğ’„ğ’–ğ’ƒğ’Šğ’„ for TCP Cubic).
 Communication Networks Course
Page | 3
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a TCP socket between the Sender and the
Receiver.
3) Send the file.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a TCP connection between the Receiver and
the Sender.
2) Get a connection from the sender.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./TCP_Receiver -p 1234 -algo reno
Starting Receiver...
Waiting for TCP connection...
Sender connected, beginning to receive file...
File transfer completed.
Waiting for Sender response...
Sender sent exit message.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 4
Part B â€“ Reliable User Datagram Protocol (Reliable UDP or RUDP) â€“ 40 points
Youâ€™ve learned that while TCP is reliable, it lacks speed and has an overhead data of 20 bytes,
compering to UDP that needs only 8 bytes of overhead data.
Reliable UDP or RUDP, is a protocol that uses the UDP protocol for a faster transmission of
data, while adding a reliability layer to it, but without adding too much overhead data like
TCP.
A simple sketch for a RUDP connection would look something like this:
Your task in this part is to implement a Reliable protocol using UDP only. For simplicity, your
implementation should only support a handshake, closing scheme, error checking,
acknowledgment of received packets, and retransmission of lost packets.
Guidance:
â€¢ You can use ğ‘ ğ‘’ğ‘¡ğ‘ ğ‘œğ‘ğ‘˜ğ‘œğ‘ğ‘¡(2) for detecting a timeout.
â€¢ You need to build your own protocol, as Reliable UDP isnâ€™t a standard protocol (see a
draft of RUDP in this link), and no official header is provided. You can use this sketch
for a header, but you can come up with your own protocol, as long as it works.
Where:
o ğ‘³ğ’†ğ’ğ’ˆğ’•ğ’‰ is the length of the data itself, without the RUDP header.
o ğ‘ªğ’‰ğ’†ğ’„ğ’Œğ’”ğ’–ğ’ is a 16bit number that validates the correctness of the data.
o ğ‘­ğ’ğ’‚ğ’ˆğ’” is a special byte where we classify the packet itself (SYN, ACK, etc.).
â€¢ In your PDF, you must explain how your implementation of RUDP works â€“ How does
it detect a timeout to do retransmissions, how does the handshake work, what is the
header overhead, etc.
â€¢ For this part, youâ€™ll write three files: ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¨ğ‘·ğ‘°. ğ’„, ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and
ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
Reliable UDP Header proposed sketch
Byte 0 Byte 1 Byte 2 Byte 3
Length (2 Bytes) Checksum (2 Bytes)
Flags (1 Byte)
Figure 1 - RUDP Protocol Architecture, Geeksforgeeks
 Communication Networks Course
Page | 5
Notes:
â€¢ The Sender will send a random generated file and the Receiver will receive it and
measure the time it took for his program to receive the file. The file size should be at
least 2MB.
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). But, as the
RUDP is based on UDP, itâ€™s not reliable. You must use some form of error checking
(like checksum) to ensure that the packet wasnâ€™t alerted during the transfer.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
â€¢ The RUDP needs support only 1 sender and 1 receiver, for simplicity purposes.
Usage:
â€¢ Receiver:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
â€¢ Sender:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port that both the Sender and the Receiver will use.
The ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„ file will contain all the implementations of the RUDP API functions (That is, to
prevent reusing the same chuck of code both in the Sender and the Receiver.).
The API should support at the bare minimum the following functions (you decide what
parameters to implement, and what are the names of the functions, as long as the API is
explained in the PDF):
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘œğ‘ğ‘˜ğ‘’ğ‘¡() â€“ Creating a RUDP socket and creating a handshake between two
peers.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘’ğ‘›ğ‘‘() â€“ Sending data to the peer. The function should wait for an
acknowledgment packet, and if it didnâ€™t receive any, retransmits the data.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘Ÿğ‘’ğ‘ğ‘£() â€“ Receive data from a peer.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ğ‘™ğ‘œğ‘ ğ‘’() â€“ Closes a connection between peers.
 Communication Networks Course
Page | 6
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a UDP socket between the Sender and the
Receiver.
3) Send the file via the RUDP protocol.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a UDP connection between the Receiver and
the Sender.
2) Get a connection from the sender, by the custom
RUDP protocol youâ€™ve built.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./RUDP_Receiver -p 1234
Starting Receiver...
Waiting for RUDP connection...
Connection request received, sending ACK.
Sender connected, beginning to receive file...
File transfer completed.
ACK sent.
Waiting for Sender response...
Sender sent exit message.
ACK sent.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 7
Part C â€“ Research â€“ 30 points
In this part, youâ€™ll conduct research about your implementations of part A and part B.
In the research itself, each one of the versions (TCP version and UDP version) will be run at
least 5 times (meaning that the file transfer will occur at least 5 times) by the following
conditions:
â€¢ For TCP, youâ€™ll run it in TCP Reno and TCP Cubic, alternating each time, for each
scenario, meaning that you run 5 times with TCP Reno in both Sender and Receiver,
and 5 times with TCP Cubic in both Sender and Receiver.
Bonus (5 points): Create a very large data set â€“ 5 times with TCP Reno in both Sender
and Receiver, 5 times with TCP Reno in Sender and TCP Cubic in Receiver, 5 times
with TCP Cubic in Sender and TCP Reno in Receiver, and 5 times with TCP Cubic in
both Sender and Receiver. This will give you a data set large enough, which allows
you to work with, compare with and to reach a definite conclusion.
â€¢ For RUDP, you will run it 5 times for each scenario.
â€¢ For both TCP and RUDP, you will run them on those scenarios of packet loss:
o 0% packet loss â€“ Control group, simulating perfect connection.
o 2% packet loss â€“ Simulating unstable connection that commonly occur.
o 5% packet loss â€“ Simulating bad connection.
o 10% packet loss â€“ Simulating extremely poor connection.
For each scenario, you must provide a filtered PCAP file and relevant screenshots that
explain each one of the steps in the process. (10 points)
After youâ€™ve gathered the data set for both TCP and Reliable UDP, answer the following
questions:
1) In TCP, which congestion control algorithm gave better results overall? TCP Reno or
TCP Cubic? Which one gave better results on high packet loss? Explain how you came
to this conclusion based on the data set youâ€™ve gathered. (5 points)
2) How did your implementation of Reliable UDP perform overall compared to regular
TCP? Which one is better for high packet loss? (5 points)
3) According to the data youâ€™ve gathered, in which scenarios and applications would we
prefer to use TCP and in which situations would we prefer to use reliable UDP?
Explain your answer. (5 points)
 Communication Networks Course
Page | 8
×¢× ×• ×¢×œ ×”×©××œ×•×ª ×”×‘××•×ª )5 × ×§×•×“×•×ª(:
â— ×‘"×¨×©×ª ×××™× ×”" ×”×›×•×•× ×” ×”×™× ×œ×¨×©×ª ×©×‘×” ××¢×˜ ×××•×“ ×—×‘×™×œ×•×ª ×”×•×œ×›×•×ª ×œ××™×‘×•×“. ×‘"×§×©×¨ ××¨×•×š" ×”×›×•×•× ×” ×”×™×
×œ×§×©×¨ TCP ×©×™×© ×‘×• ×”×¨×‘×” ×××•×“ ××™×“×¢ ×œ×©×œ×•×—. ××•×¦×¢ ×œ×”×’×“×™×œ ×‘ -TCP ××ª SSThreshold ×‘×ª×—×™×œ×ª ×”×§×©×¨.
×‘××™×–×” ××”××§×¨×™× ×”×‘××™× ×”×©×™× ×•×™ ×”×–×” ×¢×©×•×™ ×œ×”×•×¢×™×œ ×‘××™×“×” ×”××™×¨×‘×™×ª? × ××§.
.1 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
.2 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.3 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.4 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.5 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.6 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.7 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.8 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
â— A ×©×•×œ×— ×œ -B ×—×‘×™×œ×•×ª ××™×“×¢ ×‘×××¦×¢×•×ª ×§×©×¨ TCP. × ×ª×•×Ÿ ×›×™ ×”×§×©×¨ ××ª×—×™×œ ×¢× ×—×œ×•×Ÿ ×‘×’×•×“×œ 1MSS. ×”×§×©×¨
××¡×ª×™×™× ×‘×¤×¢× ×”×¨××©×•× ×” ×©×”×•× ××’×™×¢ ×œ -SSthresh. ×‘××”×œ×š ×”×§×©×¨ ×œ× ××•×‘×“×•×ª ×—×‘×™×œ×•×ª. × ×¡××Ÿ ×‘×§×™×¦×•×¨:
.SSthresh=S*MSS
× ×ª×•×Ÿ ×›×™ ×œ××•×¨×š ×›×œ ×”×§×©×¨ rwnd < MSS*S.
××”×™ ×”×ª×¤×•×§×” ×©×œ ×”×§×©×¨ ×-A ×œ-B( ×‘ -sec / Bytes )×‘×–××Ÿ ×”× "×œ? × ××§×™.
]S*MSS / [lg (S) * RTT*2 ×‘×¢×¨×š .1
]S*MSS / [S^0.5 * RTT*2 ×‘×¢×¨×š .2
S*MSS / RTT ×‘×¢×¨×š .3
S^2)*MSS / RTT( ×‘×¢×¨×š .4
â— ×©×ª×™ ×ª×—× ×•×ª ××ª×§×©×¨×•×ª ×‘××•×¤×Ÿ ××œ×—×•×˜×™ ×‘×©×™×˜×ª N Back Go.
× ×¡××Ÿ ×‘-X ××ª ×¡×¤×¨×ª ×”×‘×™×§×•×¨×ª ×©×œ ×”×ª.×–. ×©×œ×š. ×× ×©× ×™ ×©×•×ª×¤×™× ××’×™×©×™× ××ª ×”×ª×¨×’×™×œ ×™×—×“, X ×”×•× ×¡×¤×¨×ª
×”×‘×™×§×•×¨×ª ×‘×¢×œ×ª ×”×¢×¨×š ×”× ××•×š ×™×•×ª×¨ ××‘×™×Ÿ ×”×©×ª×™×™×.
×§×¦×‘ ×”×ª×§×©×•×¨×ª ×”×•× 8Gbps, ×•×’×•×“×œ ×›×œ ×—×‘×™×œ×” ×”×•× KByte*X. ×’×“×œ×™ ×”-headers ×•×” -Acks ×–× ×™×—×™×.
ï¿½ğ‘’ğ‘ ï¿½/ï¿½ï¿½ 8 , ×•×”××¨×—×§ ×‘×™×Ÿ ×”×ª×—× ×•×ª ×”×•× 1Km. ×§×¦×‘ ×”×”×ª×¤×©×˜×•×ª ×”×•× 10 â‹… 2
×–××Ÿ ×¢×™×‘×•×“ ×”× ×ª×•× ×™× ×‘×ª×—× ×•×ª ×–× ×™×—.
××£ ×—×‘×™×œ×” ×•××£ Ack ×œ× ×”×•×œ×›×™× ×œ××™×‘×•×“.
â— ××”×• X ×©×œ×š?
â— ××” ×¦×¨×™×š ×œ×”×™×•×ª ×’×•×“×œ ×—×œ×•×Ÿ ×”××©×œ×•×— ×›×“×™ ×œ×”×‘×˜×™×— ×ª×¤×•×§×” ××§×¡×™××œ×™×ª?
 Communication Networks Course
Page | 9
Bonus â€“ Improving the Reliable UDP â€“ 15 points
Note: This part isnâ€™t mandatory and is a bonus only!
In this part, youâ€™ll improve your RUDP implementation by adding the concepts of flow
control and congestion control from TCP. Youâ€™re free to choose which algorithms to
implement, as long as you explain in your PDF which algorithms youâ€™ve used. Youâ€™ll probably
need to make changes in the original design of the RUDP. Changes only need to be to the API
itself, ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„.
Points distribution:
â€¢ Flow control improvement â€“ 7 Points
â€¢ Congestion control improvement â€“ 8 points.
Guidance:
â€¢ For flow control, you must use one of the Sliding window techniques: stop-and-wait
ARQ, Go-Back-N or Selective repeat.
â€¢ List of known TCP congestion control algorithms, which you can use any one of them
for this bonus task, or makeup your own:
Figure 2 â€“ List of known TCP congestion control algorithms, Wikipedia
 Communication Networks Course
Page | 10
Appendix A â€“ Linux local packet loss tool
To simulate a packet loss in a local network, we'll use a Linux tool that's called Linux Traffic
Control (ğ‘¡ğ‘). This requires a full Linux installation, so working with WSL won't work.
If the tool isn't installed in your machine, you can install it by using the following commands:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’
If the installation didn't work, you can use the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’2
To create a packet loss scenario, type the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘ğ‘‘ğ‘‘ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
After creating a packet loss scenario, you can change the percentage by typing the following
command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘â„ğ‘ğ‘›ğ‘”ğ‘’ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
To remove the packet loss scenario, write the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘‘ğ‘’ğ‘™ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š
 Communication Networks Course
Page | 11
Appendix B â€“ ğ’ğ’‚ğ’(ğŸ) system calls
This appendixâ€™s purpose is to give you a better understanding of socket handling in C.
A recommended reference is Beejâ€™s Guide to Network Programming, by Brian â€œBeej
Jorgensenâ€ Hall, which gives a lot of information about sockets in C and functions.
Functions and documentation links:
â€¢ ğ’”ğ’ğ’„ğ’Œğ’†ğ’•(ğŸ) â€“ A Factory method system call that creates a socket with the given
parameters.
â€¢ ğ’ƒğ’Šğ’ğ’…(ğŸ) â€“ Whenever we create a new socket, we need to bind it to a specific port in
our machine, â€œto catch a portâ€. The port number is managed and used by the kernel
to link incoming packets to the corresponding application socket. The port numbers
are usually fixed. The ğ‘ğ‘‘ğ‘‘ğ‘Ÿ parameter must match the current socket that is used.
â€¢ ğ’ğ’Šğ’”ğ’•ğ’†ğ’(ğŸ) â€“ The ğ‘™ğ‘–ğ‘ ğ‘¡ğ‘’ğ‘›(2) system call doesn't do anything in the mean of
communication but only memory allocation (malloc) for stream sockets only. If we
won't allocate memory, any incoming connection will fail.
â€¢ ğ’„ğ’ğ’ğ’ğ’†ğ’„ğ’•(ğŸ) â€“ The ğ‘ğ‘œğ‘›ğ‘›ğ‘’ğ‘ğ‘¡(2) system call starts the link between a client and a
specific IP address and port number. The connection would complete when the
other side will call the ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call.
â€¢ ğ’‚ğ’„ğ’„ğ’†ğ’‘ğ’•(ğŸ) â€“ The ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call accepts the incoming stream connection
request from the other side, by the listening socket. This system call completes the
three-way handshake of stream socket (like TCP) and opens a new socket that has a
direct communication channel only with the other party in the handshake.
â€¢ ğ’”ğ’†ğ’ğ’…(ğŸ) and ğ’”ğ’†ğ’ğ’…ğ’•ğ’(ğŸ) â€“ The ğ‘ ğ‘’ğ‘›ğ‘‘(2) and ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system calls are an analogy
for the ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’(2) system call, specifcly for sockets, with flags set to 0. Those system
calls return the number of bytes that were sent through the socket itself, as the
number of bytes can vary. The ğ‘ ğ‘’ğ‘›ğ‘‘(2)system call designed for stream sockets (like
TCP), while the ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system call designed for datagram connection-less
sockets (like UDP). When the ğ‘ ğ‘’ğ‘›ğ‘‘(2) system call returns 0, it means that the other
party closed the connection.
â€¢ ğ’“ğ’†ğ’„ğ’—(ğŸ) and ğ’“ğ’†ğ’„ğ’—ğ’‡ğ’“ğ’ğ’(ğŸ) â€“ The ğ‘Ÿğ‘’ğ‘ğ‘£(2) and ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system calls are an
analogy for the ğ‘Ÿğ‘’ğ‘ğ‘‘(2) system call, specifically for sockets, with flags set to 0.
Those system calls return the number of bytes that were received through the socket
itself, as the number of bytes can vary. The ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call designed for stream
sockets (like TCP), while the ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system call designed for datagram
connection-less sockets (like UDP). When the ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call returns 0, it means
that the other party closed the connection.
â€¢ ğ’„ğ’ğ’ğ’”ğ’†(ğŸ) and ğ’”ğ’‰ğ’–ğ’•ğ’…ğ’ğ’˜ğ’(ğŸ) â€“ The ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) and ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2) system calls close
the socket. While ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) system call closes the whole socket, the ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2)
system call partially closes the socket for read/write.
 Communication Networks Course
Page | 12
Appendix C â€“ Random data generator
The data that you are going to send in this assignment is randomly generated. You can use
your own file with appropriate size or use the following function (or a function of your own)
to generate the data:
/*
* @brief A random data generator function based on srand() and rand().
* @param size The size of the data to generate (up to 2^32 bytes).
* @return A pointer to the buffer.
*/
char *util_generate_random_data(unsigned int size) {
 char *buffer = NULL;
 // Argument check.
 if (size == 0)
 return NULL;
 buffer = (char *)calloc(size, sizeof(char));
 // Error checking.
 if (buffer == NULL)
 return NULL;
 // Randomize the seed of the random number generator.
 srand(time(NULL));
 for (unsigned int i = 0; i < size; i++)
 *(buffer + i) = ((unsigned int)rand() % 256);
 return buffer;
}
 Communication Networks Course
Page | 13
Appendix D â€“ Checksum function
A checksum is a small-sized block of data derived from another block of digital data for the
purpose of detecting errors that may have been introduced during its transmission or
storage. By themselves, checksums are often used to verify data integrity but are not relied
upon to verify data authenticity.
Below is a simple yet efficient implementation of the checksum function, you can use it for
the assignment, but you can implement your own checksum function.
/*
* @brief A checksum function that returns 16 bit checksum for data.
* @param data The data to do the checksum for.
* @param bytes The length of the data in bytes.
* @return The checksum itself as 16 bit unsigned number.
* @note This function is taken from RFC1071, can be found here:
* @note https://tools.ietf.org/html/rfc1071
* @note It is the simplest way to calculate a checksum and is not very strong.
* However, it is good enough for this assignment.
* @note You are free to use any other checksum function as well.
* You can also use this function as such without any change.
*/
unsigned short int calculate_checksum(void *data, unsigned int bytes) {
 unsigned short int *data_pointer = (unsigned short int *)data;
 unsigned int total_sum = 0;
 // Main summing loop
 while (bytes > 1) {
 total_sum += *data_pointer++;
 bytes -= 2;
 }
 // Add left-over byte, if any
 if (bytes > 0)
 total_sum += *((unsigned char *)data_pointer);
 // Fold 32-bit sum to 16 bits
 while (total_sum >> 16)
 total_sum = (total_sum & 0xFFFF) + (total_sum >> 16);
 return (~((unsigned short int)total_sum));
} Communication Networks Course
Page | 1
Assignment 3 â€“ Transport Layer
Assignment Notes and Instructions
This assignment is to be done in pairs only. You must upload all the necessary files in a ZIP
file named after both of the studentâ€™s ID. For example: ğŸğŸğŸ‘ğŸ’ğŸ“ğŸ”ğŸ•ğŸ–ğŸ—_ğŸ—ğŸ–ğŸ•ğŸ”ğŸ“ğŸ’ğŸ‘ğŸğŸ. ğ’›ğ’Šğ’‘.
1) The assignment must be submitted by the date specified in the submission box.
2) All the assignment files (Code, Wireshark pcap files, PDF) must be submitted in a ZIP file. The
PDF must contain all the necessary screenshots with a description for each one of them.
3) The assignment must be done in pairs only. In exceptional cases, you should send an email to
the course coordinator.
4) You can use any reference material available through the course Moodle website or any
material passed during the exercises.
5) You can use any reference from the web, but copying codes from websites is forbidden; this
includes codes from other GitHub repositories. A student who gets caught in the act will
automatically fail this assignment (score 0). Any website youâ€™ve used to solve the
assignment, every website you used to solve the assignment must be noted in the PDF.
6) No delays in submission without special permission. Lateness without approval will result in
failure of the assignment (score 0).
7) All submissions will be submitted via the course's Moodle website. Email submissions will not
be accepted, resulting in a failure in the assignment.
8) The order and design of the code must be carefully considered. Make sure that the program
output is as clear as possible, comments in the code, and meaningful variable names. You
must also submit a makefile that compiles all the programs.
9) The assignment code must be written in C only.
10) The assignment is personal for each pair, and you should not accept help from other people,
whether outside the university or inside it. You can contact the course staff during reception
hours for help or raise a question in the course forum. Do not transfer code sections
between students, upload solutions or parts of solutions to websites on the Internet or in
various communication groups.
11) Students who copy a solution will receive a 0 in all assignments in the course and a report will
be made to the institutional disciplinary committee.
12) All code files of the assignment are required to both compile and run properly on the Ubuntu
22.04 LTS operating system. This is the operating system where the submissions will be
tested. You mustnâ€™t code it in Windows, as it uses different API for sockets. WSL wonâ€™t work,
as the task needs a tool that works only in a fully Linux environment.
Good Luck!
 Communication Networks Course
Page | 2
Part A â€“ Transmission Control Protocol (TCP) â€“ 30 points
In this part, youâ€™ll write two program files: ğ‘»ğ‘ªğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and ğ‘»ğ‘ªğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
The Sender will send a randomly generated file and the Receiver will receive it and measure
the time it took for his program to receive the file. The file size should be at least 2MB.
When running the Sender and Receiver, they both should support two standard congestion
control algorithms: TCP Reno and TCP Cubic.
Notes:
â€¢ The main goal of this part is to get familiar with the TCP concept of sending
messages between two endpoints.
â€¢ For approaching this part of the assignment, please be sure that you are familiar
with the congestion control algorithms and how to change them using the correct
method in C (see Appendix B for more information).
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). You've
learned that TCP is reliable by design, so you can assume that all the data have been
passed correctly, and thus, no need to recheck.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
Usage:
â€¢ Receiver:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
â€¢ Sender:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port of the Receiver.
â€¢ ğ‘¨ğ‘³ğ‘®ğ‘¶ â€“ The TCP congestion control algorithm that will be used by the party
member (either ğ’“ğ’†ğ’ğ’ for TCP Reno or ğ’„ğ’–ğ’ƒğ’Šğ’„ for TCP Cubic).
 Communication Networks Course
Page | 3
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a TCP socket between the Sender and the
Receiver.
3) Send the file.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a TCP connection between the Receiver and
the Sender.
2) Get a connection from the sender.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./TCP_Receiver -p 1234 -algo reno
Starting Receiver...
Waiting for TCP connection...
Sender connected, beginning to receive file...
File transfer completed.
Waiting for Sender response...
Sender sent exit message.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 4
Part B â€“ Reliable User Datagram Protocol (Reliable UDP or RUDP) â€“ 40 points
Youâ€™ve learned that while TCP is reliable, it lacks speed and has an overhead data of 20 bytes,
compering to UDP that needs only 8 bytes of overhead data.
Reliable UDP or RUDP, is a protocol that uses the UDP protocol for a faster transmission of
data, while adding a reliability layer to it, but without adding too much overhead data like
TCP.
A simple sketch for a RUDP connection would look something like this:
Your task in this part is to implement a Reliable protocol using UDP only. For simplicity, your
implementation should only support a handshake, closing scheme, error checking,
acknowledgment of received packets, and retransmission of lost packets.
Guidance:
â€¢ You can use ğ‘ ğ‘’ğ‘¡ğ‘ ğ‘œğ‘ğ‘˜ğ‘œğ‘ğ‘¡(2) for detecting a timeout.
â€¢ You need to build your own protocol, as Reliable UDP isnâ€™t a standard protocol (see a
draft of RUDP in this link), and no official header is provided. You can use this sketch
for a header, but you can come up with your own protocol, as long as it works.
Where:
o ğ‘³ğ’†ğ’ğ’ˆğ’•ğ’‰ is the length of the data itself, without the RUDP header.
o ğ‘ªğ’‰ğ’†ğ’„ğ’Œğ’”ğ’–ğ’ is a 16bit number that validates the correctness of the data.
o ğ‘­ğ’ğ’‚ğ’ˆğ’” is a special byte where we classify the packet itself (SYN, ACK, etc.).
â€¢ In your PDF, you must explain how your implementation of RUDP works â€“ How does
it detect a timeout to do retransmissions, how does the handshake work, what is the
header overhead, etc.
â€¢ For this part, youâ€™ll write three files: ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¨ğ‘·ğ‘°. ğ’„, ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and
ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
Reliable UDP Header proposed sketch
Byte 0 Byte 1 Byte 2 Byte 3
Length (2 Bytes) Checksum (2 Bytes)
Flags (1 Byte)
Figure 1 - RUDP Protocol Architecture, Geeksforgeeks
 Communication Networks Course
Page | 5
Notes:
â€¢ The Sender will send a random generated file and the Receiver will receive it and
measure the time it took for his program to receive the file. The file size should be at
least 2MB.
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). But, as the
RUDP is based on UDP, itâ€™s not reliable. You must use some form of error checking
(like checksum) to ensure that the packet wasnâ€™t alerted during the transfer.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
â€¢ The RUDP needs support only 1 sender and 1 receiver, for simplicity purposes.
Usage:
â€¢ Receiver:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
â€¢ Sender:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port that both the Sender and the Receiver will use.
The ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„ file will contain all the implementations of the RUDP API functions (That is, to
prevent reusing the same chuck of code both in the Sender and the Receiver.).
The API should support at the bare minimum the following functions (you decide what
parameters to implement, and what are the names of the functions, as long as the API is
explained in the PDF):
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘œğ‘ğ‘˜ğ‘’ğ‘¡() â€“ Creating a RUDP socket and creating a handshake between two
peers.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘’ğ‘›ğ‘‘() â€“ Sending data to the peer. The function should wait for an
acknowledgment packet, and if it didnâ€™t receive any, retransmits the data.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘Ÿğ‘’ğ‘ğ‘£() â€“ Receive data from a peer.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ğ‘™ğ‘œğ‘ ğ‘’() â€“ Closes a connection between peers.
 Communication Networks Course
Page | 6
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a UDP socket between the Sender and the
Receiver.
3) Send the file via the RUDP protocol.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a UDP connection between the Receiver and
the Sender.
2) Get a connection from the sender, by the custom
RUDP protocol youâ€™ve built.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./RUDP_Receiver -p 1234
Starting Receiver...
Waiting for RUDP connection...
Connection request received, sending ACK.
Sender connected, beginning to receive file...
File transfer completed.
ACK sent.
Waiting for Sender response...
Sender sent exit message.
ACK sent.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 7
Part C â€“ Research â€“ 30 points
In this part, youâ€™ll conduct research about your implementations of part A and part B.
In the research itself, each one of the versions (TCP version and UDP version) will be run at
least 5 times (meaning that the file transfer will occur at least 5 times) by the following
conditions:
â€¢ For TCP, youâ€™ll run it in TCP Reno and TCP Cubic, alternating each time, for each
scenario, meaning that you run 5 times with TCP Reno in both Sender and Receiver,
and 5 times with TCP Cubic in both Sender and Receiver.
Bonus (5 points): Create a very large data set â€“ 5 times with TCP Reno in both Sender
and Receiver, 5 times with TCP Reno in Sender and TCP Cubic in Receiver, 5 times
with TCP Cubic in Sender and TCP Reno in Receiver, and 5 times with TCP Cubic in
both Sender and Receiver. This will give you a data set large enough, which allows
you to work with, compare with and to reach a definite conclusion.
â€¢ For RUDP, you will run it 5 times for each scenario.
â€¢ For both TCP and RUDP, you will run them on those scenarios of packet loss:
o 0% packet loss â€“ Control group, simulating perfect connection.
o 2% packet loss â€“ Simulating unstable connection that commonly occur.
o 5% packet loss â€“ Simulating bad connection.
o 10% packet loss â€“ Simulating extremely poor connection.
For each scenario, you must provide a filtered PCAP file and relevant screenshots that
explain each one of the steps in the process. (10 points)
After youâ€™ve gathered the data set for both TCP and Reliable UDP, answer the following
questions:
1) In TCP, which congestion control algorithm gave better results overall? TCP Reno or
TCP Cubic? Which one gave better results on high packet loss? Explain how you came
to this conclusion based on the data set youâ€™ve gathered. (5 points)
2) How did your implementation of Reliable UDP perform overall compared to regular
TCP? Which one is better for high packet loss? (5 points)
3) According to the data youâ€™ve gathered, in which scenarios and applications would we
prefer to use TCP and in which situations would we prefer to use reliable UDP?
Explain your answer. (5 points)
 Communication Networks Course
Page | 8
×¢× ×• ×¢×œ ×”×©××œ×•×ª ×”×‘××•×ª )5 × ×§×•×“×•×ª(:
â— ×‘"×¨×©×ª ×××™× ×”" ×”×›×•×•× ×” ×”×™× ×œ×¨×©×ª ×©×‘×” ××¢×˜ ×××•×“ ×—×‘×™×œ×•×ª ×”×•×œ×›×•×ª ×œ××™×‘×•×“. ×‘"×§×©×¨ ××¨×•×š" ×”×›×•×•× ×” ×”×™×
×œ×§×©×¨ TCP ×©×™×© ×‘×• ×”×¨×‘×” ×××•×“ ××™×“×¢ ×œ×©×œ×•×—. ××•×¦×¢ ×œ×”×’×“×™×œ ×‘ -TCP ××ª SSThreshold ×‘×ª×—×™×œ×ª ×”×§×©×¨.
×‘××™×–×” ××”××§×¨×™× ×”×‘××™× ×”×©×™× ×•×™ ×”×–×” ×¢×©×•×™ ×œ×”×•×¢×™×œ ×‘××™×“×” ×”××™×¨×‘×™×ª? × ××§.
.1 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
.2 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.3 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.4 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.5 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.6 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.7 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.8 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
â— A ×©×•×œ×— ×œ -B ×—×‘×™×œ×•×ª ××™×“×¢ ×‘×××¦×¢×•×ª ×§×©×¨ TCP. × ×ª×•×Ÿ ×›×™ ×”×§×©×¨ ××ª×—×™×œ ×¢× ×—×œ×•×Ÿ ×‘×’×•×“×œ 1MSS. ×”×§×©×¨
××¡×ª×™×™× ×‘×¤×¢× ×”×¨××©×•× ×” ×©×”×•× ××’×™×¢ ×œ -SSthresh. ×‘××”×œ×š ×”×§×©×¨ ×œ× ××•×‘×“×•×ª ×—×‘×™×œ×•×ª. × ×¡××Ÿ ×‘×§×™×¦×•×¨:
.SSthresh=S*MSS
× ×ª×•×Ÿ ×›×™ ×œ××•×¨×š ×›×œ ×”×§×©×¨ rwnd < MSS*S.
××”×™ ×”×ª×¤×•×§×” ×©×œ ×”×§×©×¨ ×-A ×œ-B( ×‘ -sec / Bytes )×‘×–××Ÿ ×”× "×œ? × ××§×™.
]S*MSS / [lg (S) * RTT*2 ×‘×¢×¨×š .1
]S*MSS / [S^0.5 * RTT*2 ×‘×¢×¨×š .2
S*MSS / RTT ×‘×¢×¨×š .3
S^2)*MSS / RTT( ×‘×¢×¨×š .4
â— ×©×ª×™ ×ª×—× ×•×ª ××ª×§×©×¨×•×ª ×‘××•×¤×Ÿ ××œ×—×•×˜×™ ×‘×©×™×˜×ª N Back Go.
× ×¡××Ÿ ×‘-X ××ª ×¡×¤×¨×ª ×”×‘×™×§×•×¨×ª ×©×œ ×”×ª.×–. ×©×œ×š. ×× ×©× ×™ ×©×•×ª×¤×™× ××’×™×©×™× ××ª ×”×ª×¨×’×™×œ ×™×—×“, X ×”×•× ×¡×¤×¨×ª
×”×‘×™×§×•×¨×ª ×‘×¢×œ×ª ×”×¢×¨×š ×”× ××•×š ×™×•×ª×¨ ××‘×™×Ÿ ×”×©×ª×™×™×.
×§×¦×‘ ×”×ª×§×©×•×¨×ª ×”×•× 8Gbps, ×•×’×•×“×œ ×›×œ ×—×‘×™×œ×” ×”×•× KByte*X. ×’×“×œ×™ ×”-headers ×•×” -Acks ×–× ×™×—×™×.
ï¿½ğ‘’ğ‘ ï¿½/ï¿½ï¿½ 8 , ×•×”××¨×—×§ ×‘×™×Ÿ ×”×ª×—× ×•×ª ×”×•× 1Km. ×§×¦×‘ ×”×”×ª×¤×©×˜×•×ª ×”×•× 10 â‹… 2
×–××Ÿ ×¢×™×‘×•×“ ×”× ×ª×•× ×™× ×‘×ª×—× ×•×ª ×–× ×™×—.
××£ ×—×‘×™×œ×” ×•××£ Ack ×œ× ×”×•×œ×›×™× ×œ××™×‘×•×“.
â— ××”×• X ×©×œ×š?
â— ××” ×¦×¨×™×š ×œ×”×™×•×ª ×’×•×“×œ ×—×œ×•×Ÿ ×”××©×œ×•×— ×›×“×™ ×œ×”×‘×˜×™×— ×ª×¤×•×§×” ××§×¡×™××œ×™×ª?
 Communication Networks Course
Page | 9
Bonus â€“ Improving the Reliable UDP â€“ 15 points
Note: This part isnâ€™t mandatory and is a bonus only!
In this part, youâ€™ll improve your RUDP implementation by adding the concepts of flow
control and congestion control from TCP. Youâ€™re free to choose which algorithms to
implement, as long as you explain in your PDF which algorithms youâ€™ve used. Youâ€™ll probably
need to make changes in the original design of the RUDP. Changes only need to be to the API
itself, ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„.
Points distribution:
â€¢ Flow control improvement â€“ 7 Points
â€¢ Congestion control improvement â€“ 8 points.
Guidance:
â€¢ For flow control, you must use one of the Sliding window techniques: stop-and-wait
ARQ, Go-Back-N or Selective repeat.
â€¢ List of known TCP congestion control algorithms, which you can use any one of them
for this bonus task, or makeup your own:
Figure 2 â€“ List of known TCP congestion control algorithms, Wikipedia
 Communication Networks Course
Page | 10
Appendix A â€“ Linux local packet loss tool
To simulate a packet loss in a local network, we'll use a Linux tool that's called Linux Traffic
Control (ğ‘¡ğ‘). This requires a full Linux installation, so working with WSL won't work.
If the tool isn't installed in your machine, you can install it by using the following commands:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’
If the installation didn't work, you can use the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’2
To create a packet loss scenario, type the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘ğ‘‘ğ‘‘ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
After creating a packet loss scenario, you can change the percentage by typing the following
command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘â„ğ‘ğ‘›ğ‘”ğ‘’ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
To remove the packet loss scenario, write the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘‘ğ‘’ğ‘™ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š
 Communication Networks Course
Page | 11
Appendix B â€“ ğ’ğ’‚ğ’(ğŸ) system calls
This appendixâ€™s purpose is to give you a better understanding of socket handling in C.
A recommended reference is Beejâ€™s Guide to Network Programming, by Brian â€œBeej
Jorgensenâ€ Hall, which gives a lot of information about sockets in C and functions.
Functions and documentation links:
â€¢ ğ’”ğ’ğ’„ğ’Œğ’†ğ’•(ğŸ) â€“ A Factory method system call that creates a socket with the given
parameters.
â€¢ ğ’ƒğ’Šğ’ğ’…(ğŸ) â€“ Whenever we create a new socket, we need to bind it to a specific port in
our machine, â€œto catch a portâ€. The port number is managed and used by the kernel
to link incoming packets to the corresponding application socket. The port numbers
are usually fixed. The ğ‘ğ‘‘ğ‘‘ğ‘Ÿ parameter must match the current socket that is used.
â€¢ ğ’ğ’Šğ’”ğ’•ğ’†ğ’(ğŸ) â€“ The ğ‘™ğ‘–ğ‘ ğ‘¡ğ‘’ğ‘›(2) system call doesn't do anything in the mean of
communication but only memory allocation (malloc) for stream sockets only. If we
won't allocate memory, any incoming connection will fail.
â€¢ ğ’„ğ’ğ’ğ’ğ’†ğ’„ğ’•(ğŸ) â€“ The ğ‘ğ‘œğ‘›ğ‘›ğ‘’ğ‘ğ‘¡(2) system call starts the link between a client and a
specific IP address and port number. The connection would complete when the
other side will call the ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call.
â€¢ ğ’‚ğ’„ğ’„ğ’†ğ’‘ğ’•(ğŸ) â€“ The ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call accepts the incoming stream connection
request from the other side, by the listening socket. This system call completes the
three-way handshake of stream socket (like TCP) and opens a new socket that has a
direct communication channel only with the other party in the handshake.
â€¢ ğ’”ğ’†ğ’ğ’…(ğŸ) and ğ’”ğ’†ğ’ğ’…ğ’•ğ’(ğŸ) â€“ The ğ‘ ğ‘’ğ‘›ğ‘‘(2) and ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system calls are an analogy
for the ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’(2) system call, specifcly for sockets, with flags set to 0. Those system
calls return the number of bytes that were sent through the socket itself, as the
number of bytes can vary. The ğ‘ ğ‘’ğ‘›ğ‘‘(2)system call designed for stream sockets (like
TCP), while the ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system call designed for datagram connection-less
sockets (like UDP). When the ğ‘ ğ‘’ğ‘›ğ‘‘(2) system call returns 0, it means that the other
party closed the connection.
â€¢ ğ’“ğ’†ğ’„ğ’—(ğŸ) and ğ’“ğ’†ğ’„ğ’—ğ’‡ğ’“ğ’ğ’(ğŸ) â€“ The ğ‘Ÿğ‘’ğ‘ğ‘£(2) and ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system calls are an
analogy for the ğ‘Ÿğ‘’ğ‘ğ‘‘(2) system call, specifically for sockets, with flags set to 0.
Those system calls return the number of bytes that were received through the socket
itself, as the number of bytes can vary. The ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call designed for stream
sockets (like TCP), while the ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system call designed for datagram
connection-less sockets (like UDP). When the ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call returns 0, it means
that the other party closed the connection.
â€¢ ğ’„ğ’ğ’ğ’”ğ’†(ğŸ) and ğ’”ğ’‰ğ’–ğ’•ğ’…ğ’ğ’˜ğ’(ğŸ) â€“ The ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) and ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2) system calls close
the socket. While ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) system call closes the whole socket, the ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2)
system call partially closes the socket for read/write.
 Communication Networks Course
Page | 12
Appendix C â€“ Random data generator
The data that you are going to send in this assignment is randomly generated. You can use
your own file with appropriate size or use the following function (or a function of your own)
to generate the data:
/*
* @brief A random data generator function based on srand() and rand().
* @param size The size of the data to generate (up to 2^32 bytes).
* @return A pointer to the buffer.
*/
char *util_generate_random_data(unsigned int size) {
 char *buffer = NULL;
 // Argument check.
 if (size == 0)
 return NULL;
 buffer = (char *)calloc(size, sizeof(char));
 // Error checking.
 if (buffer == NULL)
 return NULL;
 // Randomize the seed of the random number generator.
 srand(time(NULL));
 for (unsigned int i = 0; i < size; i++)
 *(buffer + i) = ((unsigned int)rand() % 256);
 return buffer;
}
 Communication Networks Course
Page | 13
Appendix D â€“ Checksum function
A checksum is a small-sized block of data derived from another block of digital data for the
purpose of detecting errors that may have been introduced during its transmission or
storage. By themselves, checksums are often used to verify data integrity but are not relied
upon to verify data authenticity.
Below is a simple yet efficient implementation of the checksum function, you can use it for
the assignment, but you can implement your own checksum function.
/*
* @brief A checksum function that returns 16 bit checksum for data.
* @param data The data to do the checksum for.
* @param bytes The length of the data in bytes.
* @return The checksum itself as 16 bit unsigned number.
* @note This function is taken from RFC1071, can be found here:
* @note https://tools.ietf.org/html/rfc1071
* @note It is the simplest way to calculate a checksum and is not very strong.
* However, it is good enough for this assignment.
* @note You are free to use any other checksum function as well.
* You can also use this function as such without any change.
*/
unsigned short int calculate_checksum(void *data, unsigned int bytes) {
 unsigned short int *data_pointer = (unsigned short int *)data;
 unsigned int total_sum = 0;
 // Main summing loop
 while (bytes > 1) {
 total_sum += *data_pointer++;
 bytes -= 2;
 }
 // Add left-over byte, if any
 if (bytes > 0)
 total_sum += *((unsigned char *)data_pointer);
 // Fold 32-bit sum to 16 bits
 while (total_sum >> 16)
 total_sum = (total_sum & 0xFFFF) + (total_sum >> 16);
 return (~((unsigned short int)total_sum));
} Communication Networks Course
Page | 1
Assignment 3 â€“ Transport Layer
Assignment Notes and Instructions
This assignment is to be done in pairs only. You must upload all the necessary files in a ZIP
file named after both of the studentâ€™s ID. For example: ğŸğŸğŸ‘ğŸ’ğŸ“ğŸ”ğŸ•ğŸ–ğŸ—_ğŸ—ğŸ–ğŸ•ğŸ”ğŸ“ğŸ’ğŸ‘ğŸğŸ. ğ’›ğ’Šğ’‘.
1) The assignment must be submitted by the date specified in the submission box.
2) All the assignment files (Code, Wireshark pcap files, PDF) must be submitted in a ZIP file. The
PDF must contain all the necessary screenshots with a description for each one of them.
3) The assignment must be done in pairs only. In exceptional cases, you should send an email to
the course coordinator.
4) You can use any reference material available through the course Moodle website or any
material passed during the exercises.
5) You can use any reference from the web, but copying codes from websites is forbidden; this
includes codes from other GitHub repositories. A student who gets caught in the act will
automatically fail this assignment (score 0). Any website youâ€™ve used to solve the
assignment, every website you used to solve the assignment must be noted in the PDF.
6) No delays in submission without special permission. Lateness without approval will result in
failure of the assignment (score 0).
7) All submissions will be submitted via the course's Moodle website. Email submissions will not
be accepted, resulting in a failure in the assignment.
8) The order and design of the code must be carefully considered. Make sure that the program
output is as clear as possible, comments in the code, and meaningful variable names. You
must also submit a makefile that compiles all the programs.
9) The assignment code must be written in C only.
10) The assignment is personal for each pair, and you should not accept help from other people,
whether outside the university or inside it. You can contact the course staff during reception
hours for help or raise a question in the course forum. Do not transfer code sections
between students, upload solutions or parts of solutions to websites on the Internet or in
various communication groups.
11) Students who copy a solution will receive a 0 in all assignments in the course and a report will
be made to the institutional disciplinary committee.
12) All code files of the assignment are required to both compile and run properly on the Ubuntu
22.04 LTS operating system. This is the operating system where the submissions will be
tested. You mustnâ€™t code it in Windows, as it uses different API for sockets. WSL wonâ€™t work,
as the task needs a tool that works only in a fully Linux environment.
Good Luck!
 Communication Networks Course
Page | 2
Part A â€“ Transmission Control Protocol (TCP) â€“ 30 points
In this part, youâ€™ll write two program files: ğ‘»ğ‘ªğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and ğ‘»ğ‘ªğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
The Sender will send a randomly generated file and the Receiver will receive it and measure
the time it took for his program to receive the file. The file size should be at least 2MB.
When running the Sender and Receiver, they both should support two standard congestion
control algorithms: TCP Reno and TCP Cubic.
Notes:
â€¢ The main goal of this part is to get familiar with the TCP concept of sending
messages between two endpoints.
â€¢ For approaching this part of the assignment, please be sure that you are familiar
with the congestion control algorithms and how to change them using the correct
method in C (see Appendix B for more information).
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). You've
learned that TCP is reliable by design, so you can assume that all the data have been
passed correctly, and thus, no need to recheck.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
Usage:
â€¢ Receiver:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
â€¢ Sender:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port of the Receiver.
â€¢ ğ‘¨ğ‘³ğ‘®ğ‘¶ â€“ The TCP congestion control algorithm that will be used by the party
member (either ğ’“ğ’†ğ’ğ’ for TCP Reno or ğ’„ğ’–ğ’ƒğ’Šğ’„ for TCP Cubic).
 Communication Networks Course
Page | 3
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a TCP socket between the Sender and the
Receiver.
3) Send the file.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a TCP connection between the Receiver and
the Sender.
2) Get a connection from the sender.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./TCP_Receiver -p 1234 -algo reno
Starting Receiver...
Waiting for TCP connection...
Sender connected, beginning to receive file...
File transfer completed.
Waiting for Sender response...
Sender sent exit message.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 4
Part B â€“ Reliable User Datagram Protocol (Reliable UDP or RUDP) â€“ 40 points
Youâ€™ve learned that while TCP is reliable, it lacks speed and has an overhead data of 20 bytes,
compering to UDP that needs only 8 bytes of overhead data.
Reliable UDP or RUDP, is a protocol that uses the UDP protocol for a faster transmission of
data, while adding a reliability layer to it, but without adding too much overhead data like
TCP.
A simple sketch for a RUDP connection would look something like this:
Your task in this part is to implement a Reliable protocol using UDP only. For simplicity, your
implementation should only support a handshake, closing scheme, error checking,
acknowledgment of received packets, and retransmission of lost packets.
Guidance:
â€¢ You can use ğ‘ ğ‘’ğ‘¡ğ‘ ğ‘œğ‘ğ‘˜ğ‘œğ‘ğ‘¡(2) for detecting a timeout.
â€¢ You need to build your own protocol, as Reliable UDP isnâ€™t a standard protocol (see a
draft of RUDP in this link), and no official header is provided. You can use this sketch
for a header, but you can come up with your own protocol, as long as it works.
Where:
o ğ‘³ğ’†ğ’ğ’ˆğ’•ğ’‰ is the length of the data itself, without the RUDP header.
o ğ‘ªğ’‰ğ’†ğ’„ğ’Œğ’”ğ’–ğ’ is a 16bit number that validates the correctness of the data.
o ğ‘­ğ’ğ’‚ğ’ˆğ’” is a special byte where we classify the packet itself (SYN, ACK, etc.).
â€¢ In your PDF, you must explain how your implementation of RUDP works â€“ How does
it detect a timeout to do retransmissions, how does the handshake work, what is the
header overhead, etc.
â€¢ For this part, youâ€™ll write three files: ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¨ğ‘·ğ‘°. ğ’„, ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and
ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
Reliable UDP Header proposed sketch
Byte 0 Byte 1 Byte 2 Byte 3
Length (2 Bytes) Checksum (2 Bytes)
Flags (1 Byte)
Figure 1 - RUDP Protocol Architecture, Geeksforgeeks
 Communication Networks Course
Page | 5
Notes:
â€¢ The Sender will send a random generated file and the Receiver will receive it and
measure the time it took for his program to receive the file. The file size should be at
least 2MB.
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). But, as the
RUDP is based on UDP, itâ€™s not reliable. You must use some form of error checking
(like checksum) to ensure that the packet wasnâ€™t alerted during the transfer.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
â€¢ The RUDP needs support only 1 sender and 1 receiver, for simplicity purposes.
Usage:
â€¢ Receiver:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
â€¢ Sender:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port that both the Sender and the Receiver will use.
The ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„ file will contain all the implementations of the RUDP API functions (That is, to
prevent reusing the same chuck of code both in the Sender and the Receiver.).
The API should support at the bare minimum the following functions (you decide what
parameters to implement, and what are the names of the functions, as long as the API is
explained in the PDF):
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘œğ‘ğ‘˜ğ‘’ğ‘¡() â€“ Creating a RUDP socket and creating a handshake between two
peers.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘’ğ‘›ğ‘‘() â€“ Sending data to the peer. The function should wait for an
acknowledgment packet, and if it didnâ€™t receive any, retransmits the data.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘Ÿğ‘’ğ‘ğ‘£() â€“ Receive data from a peer.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ğ‘™ğ‘œğ‘ ğ‘’() â€“ Closes a connection between peers.
 Communication Networks Course
Page | 6
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a UDP socket between the Sender and the
Receiver.
3) Send the file via the RUDP protocol.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a UDP connection between the Receiver and
the Sender.
2) Get a connection from the sender, by the custom
RUDP protocol youâ€™ve built.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./RUDP_Receiver -p 1234
Starting Receiver...
Waiting for RUDP connection...
Connection request received, sending ACK.
Sender connected, beginning to receive file...
File transfer completed.
ACK sent.
Waiting for Sender response...
Sender sent exit message.
ACK sent.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 7
Part C â€“ Research â€“ 30 points
In this part, youâ€™ll conduct research about your implementations of part A and part B.
In the research itself, each one of the versions (TCP version and UDP version) will be run at
least 5 times (meaning that the file transfer will occur at least 5 times) by the following
conditions:
â€¢ For TCP, youâ€™ll run it in TCP Reno and TCP Cubic, alternating each time, for each
scenario, meaning that you run 5 times with TCP Reno in both Sender and Receiver,
and 5 times with TCP Cubic in both Sender and Receiver.
Bonus (5 points): Create a very large data set â€“ 5 times with TCP Reno in both Sender
and Receiver, 5 times with TCP Reno in Sender and TCP Cubic in Receiver, 5 times
with TCP Cubic in Sender and TCP Reno in Receiver, and 5 times with TCP Cubic in
both Sender and Receiver. This will give you a data set large enough, which allows
you to work with, compare with and to reach a definite conclusion.
â€¢ For RUDP, you will run it 5 times for each scenario.
â€¢ For both TCP and RUDP, you will run them on those scenarios of packet loss:
o 0% packet loss â€“ Control group, simulating perfect connection.
o 2% packet loss â€“ Simulating unstable connection that commonly occur.
o 5% packet loss â€“ Simulating bad connection.
o 10% packet loss â€“ Simulating extremely poor connection.
For each scenario, you must provide a filtered PCAP file and relevant screenshots that
explain each one of the steps in the process. (10 points)
After youâ€™ve gathered the data set for both TCP and Reliable UDP, answer the following
questions:
1) In TCP, which congestion control algorithm gave better results overall? TCP Reno or
TCP Cubic? Which one gave better results on high packet loss? Explain how you came
to this conclusion based on the data set youâ€™ve gathered. (5 points)
2) How did your implementation of Reliable UDP perform overall compared to regular
TCP? Which one is better for high packet loss? (5 points)
3) According to the data youâ€™ve gathered, in which scenarios and applications would we
prefer to use TCP and in which situations would we prefer to use reliable UDP?
Explain your answer. (5 points)
 Communication Networks Course
Page | 8
×¢× ×• ×¢×œ ×”×©××œ×•×ª ×”×‘××•×ª )5 × ×§×•×“×•×ª(:
â— ×‘"×¨×©×ª ×××™× ×”" ×”×›×•×•× ×” ×”×™× ×œ×¨×©×ª ×©×‘×” ××¢×˜ ×××•×“ ×—×‘×™×œ×•×ª ×”×•×œ×›×•×ª ×œ××™×‘×•×“. ×‘"×§×©×¨ ××¨×•×š" ×”×›×•×•× ×” ×”×™×
×œ×§×©×¨ TCP ×©×™×© ×‘×• ×”×¨×‘×” ×××•×“ ××™×“×¢ ×œ×©×œ×•×—. ××•×¦×¢ ×œ×”×’×“×™×œ ×‘ -TCP ××ª SSThreshold ×‘×ª×—×™×œ×ª ×”×§×©×¨.
×‘××™×–×” ××”××§×¨×™× ×”×‘××™× ×”×©×™× ×•×™ ×”×–×” ×¢×©×•×™ ×œ×”×•×¢×™×œ ×‘××™×“×” ×”××™×¨×‘×™×ª? × ××§.
.1 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
.2 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.3 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.4 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.5 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.6 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.7 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.8 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
â— A ×©×•×œ×— ×œ -B ×—×‘×™×œ×•×ª ××™×“×¢ ×‘×××¦×¢×•×ª ×§×©×¨ TCP. × ×ª×•×Ÿ ×›×™ ×”×§×©×¨ ××ª×—×™×œ ×¢× ×—×œ×•×Ÿ ×‘×’×•×“×œ 1MSS. ×”×§×©×¨
××¡×ª×™×™× ×‘×¤×¢× ×”×¨××©×•× ×” ×©×”×•× ××’×™×¢ ×œ -SSthresh. ×‘××”×œ×š ×”×§×©×¨ ×œ× ××•×‘×“×•×ª ×—×‘×™×œ×•×ª. × ×¡××Ÿ ×‘×§×™×¦×•×¨:
.SSthresh=S*MSS
× ×ª×•×Ÿ ×›×™ ×œ××•×¨×š ×›×œ ×”×§×©×¨ rwnd < MSS*S.
××”×™ ×”×ª×¤×•×§×” ×©×œ ×”×§×©×¨ ×-A ×œ-B( ×‘ -sec / Bytes )×‘×–××Ÿ ×”× "×œ? × ××§×™.
]S*MSS / [lg (S) * RTT*2 ×‘×¢×¨×š .1
]S*MSS / [S^0.5 * RTT*2 ×‘×¢×¨×š .2
S*MSS / RTT ×‘×¢×¨×š .3
S^2)*MSS / RTT( ×‘×¢×¨×š .4
â— ×©×ª×™ ×ª×—× ×•×ª ××ª×§×©×¨×•×ª ×‘××•×¤×Ÿ ××œ×—×•×˜×™ ×‘×©×™×˜×ª N Back Go.
× ×¡××Ÿ ×‘-X ××ª ×¡×¤×¨×ª ×”×‘×™×§×•×¨×ª ×©×œ ×”×ª.×–. ×©×œ×š. ×× ×©× ×™ ×©×•×ª×¤×™× ××’×™×©×™× ××ª ×”×ª×¨×’×™×œ ×™×—×“, X ×”×•× ×¡×¤×¨×ª
×”×‘×™×§×•×¨×ª ×‘×¢×œ×ª ×”×¢×¨×š ×”× ××•×š ×™×•×ª×¨ ××‘×™×Ÿ ×”×©×ª×™×™×.
×§×¦×‘ ×”×ª×§×©×•×¨×ª ×”×•× 8Gbps, ×•×’×•×“×œ ×›×œ ×—×‘×™×œ×” ×”×•× KByte*X. ×’×“×œ×™ ×”-headers ×•×” -Acks ×–× ×™×—×™×.
ï¿½ğ‘’ğ‘ ï¿½/ï¿½ï¿½ 8 , ×•×”××¨×—×§ ×‘×™×Ÿ ×”×ª×—× ×•×ª ×”×•× 1Km. ×§×¦×‘ ×”×”×ª×¤×©×˜×•×ª ×”×•× 10 â‹… 2
×–××Ÿ ×¢×™×‘×•×“ ×”× ×ª×•× ×™× ×‘×ª×—× ×•×ª ×–× ×™×—.
××£ ×—×‘×™×œ×” ×•××£ Ack ×œ× ×”×•×œ×›×™× ×œ××™×‘×•×“.
â— ××”×• X ×©×œ×š?
â— ××” ×¦×¨×™×š ×œ×”×™×•×ª ×’×•×“×œ ×—×œ×•×Ÿ ×”××©×œ×•×— ×›×“×™ ×œ×”×‘×˜×™×— ×ª×¤×•×§×” ××§×¡×™××œ×™×ª?
 Communication Networks Course
Page | 9
Bonus â€“ Improving the Reliable UDP â€“ 15 points
Note: This part isnâ€™t mandatory and is a bonus only!
In this part, youâ€™ll improve your RUDP implementation by adding the concepts of flow
control and congestion control from TCP. Youâ€™re free to choose which algorithms to
implement, as long as you explain in your PDF which algorithms youâ€™ve used. Youâ€™ll probably
need to make changes in the original design of the RUDP. Changes only need to be to the API
itself, ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„.
Points distribution:
â€¢ Flow control improvement â€“ 7 Points
â€¢ Congestion control improvement â€“ 8 points.
Guidance:
â€¢ For flow control, you must use one of the Sliding window techniques: stop-and-wait
ARQ, Go-Back-N or Selective repeat.
â€¢ List of known TCP congestion control algorithms, which you can use any one of them
for this bonus task, or makeup your own:
Figure 2 â€“ List of known TCP congestion control algorithms, Wikipedia
 Communication Networks Course
Page | 10
Appendix A â€“ Linux local packet loss tool
To simulate a packet loss in a local network, we'll use a Linux tool that's called Linux Traffic
Control (ğ‘¡ğ‘). This requires a full Linux installation, so working with WSL won't work.
If the tool isn't installed in your machine, you can install it by using the following commands:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’
If the installation didn't work, you can use the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’2
To create a packet loss scenario, type the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘ğ‘‘ğ‘‘ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
After creating a packet loss scenario, you can change the percentage by typing the following
command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘â„ğ‘ğ‘›ğ‘”ğ‘’ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
To remove the packet loss scenario, write the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘‘ğ‘’ğ‘™ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š
 Communication Networks Course
Page | 11
Appendix B â€“ ğ’ğ’‚ğ’(ğŸ) system calls
This appendixâ€™s purpose is to give you a better understanding of socket handling in C.
A recommended reference is Beejâ€™s Guide to Network Programming, by Brian â€œBeej
Jorgensenâ€ Hall, which gives a lot of information about sockets in C and functions.
Functions and documentation links:
â€¢ ğ’”ğ’ğ’„ğ’Œğ’†ğ’•(ğŸ) â€“ A Factory method system call that creates a socket with the given
parameters.
â€¢ ğ’ƒğ’Šğ’ğ’…(ğŸ) â€“ Whenever we create a new socket, we need to bind it to a specific port in
our machine, â€œto catch a portâ€. The port number is managed and used by the kernel
to link incoming packets to the corresponding application socket. The port numbers
are usually fixed. The ğ‘ğ‘‘ğ‘‘ğ‘Ÿ parameter must match the current socket that is used.
â€¢ ğ’ğ’Šğ’”ğ’•ğ’†ğ’(ğŸ) â€“ The ğ‘™ğ‘–ğ‘ ğ‘¡ğ‘’ğ‘›(2) system call doesn't do anything in the mean of
communication but only memory allocation (malloc) for stream sockets only. If we
won't allocate memory, any incoming connection will fail.
â€¢ ğ’„ğ’ğ’ğ’ğ’†ğ’„ğ’•(ğŸ) â€“ The ğ‘ğ‘œğ‘›ğ‘›ğ‘’ğ‘ğ‘¡(2) system call starts the link between a client and a
specific IP address and port number. The connection would complete when the
other side will call the ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call.
â€¢ ğ’‚ğ’„ğ’„ğ’†ğ’‘ğ’•(ğŸ) â€“ The ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call accepts the incoming stream connection
request from the other side, by the listening socket. This system call completes the
three-way handshake of stream socket (like TCP) and opens a new socket that has a
direct communication channel only with the other party in the handshake.
â€¢ ğ’”ğ’†ğ’ğ’…(ğŸ) and ğ’”ğ’†ğ’ğ’…ğ’•ğ’(ğŸ) â€“ The ğ‘ ğ‘’ğ‘›ğ‘‘(2) and ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system calls are an analogy
for the ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’(2) system call, specifcly for sockets, with flags set to 0. Those system
calls return the number of bytes that were sent through the socket itself, as the
number of bytes can vary. The ğ‘ ğ‘’ğ‘›ğ‘‘(2)system call designed for stream sockets (like
TCP), while the ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system call designed for datagram connection-less
sockets (like UDP). When the ğ‘ ğ‘’ğ‘›ğ‘‘(2) system call returns 0, it means that the other
party closed the connection.
â€¢ ğ’“ğ’†ğ’„ğ’—(ğŸ) and ğ’“ğ’†ğ’„ğ’—ğ’‡ğ’“ğ’ğ’(ğŸ) â€“ The ğ‘Ÿğ‘’ğ‘ğ‘£(2) and ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system calls are an
analogy for the ğ‘Ÿğ‘’ğ‘ğ‘‘(2) system call, specifically for sockets, with flags set to 0.
Those system calls return the number of bytes that were received through the socket
itself, as the number of bytes can vary. The ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call designed for stream
sockets (like TCP), while the ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system call designed for datagram
connection-less sockets (like UDP). When the ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call returns 0, it means
that the other party closed the connection.
â€¢ ğ’„ğ’ğ’ğ’”ğ’†(ğŸ) and ğ’”ğ’‰ğ’–ğ’•ğ’…ğ’ğ’˜ğ’(ğŸ) â€“ The ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) and ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2) system calls close
the socket. While ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) system call closes the whole socket, the ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2)
system call partially closes the socket for read/write.
 Communication Networks Course
Page | 12
Appendix C â€“ Random data generator
The data that you are going to send in this assignment is randomly generated. You can use
your own file with appropriate size or use the following function (or a function of your own)
to generate the data:
/*
* @brief A random data generator function based on srand() and rand().
* @param size The size of the data to generate (up to 2^32 bytes).
* @return A pointer to the buffer.
*/
char *util_generate_random_data(unsigned int size) {
 char *buffer = NULL;
 // Argument check.
 if (size == 0)
 return NULL;
 buffer = (char *)calloc(size, sizeof(char));
 // Error checking.
 if (buffer == NULL)
 return NULL;
 // Randomize the seed of the random number generator.
 srand(time(NULL));
 for (unsigned int i = 0; i < size; i++)
 *(buffer + i) = ((unsigned int)rand() % 256);
 return buffer;
}
 Communication Networks Course
Page | 13
Appendix D â€“ Checksum function
A checksum is a small-sized block of data derived from another block of digital data for the
purpose of detecting errors that may have been introduced during its transmission or
storage. By themselves, checksums are often used to verify data integrity but are not relied
upon to verify data authenticity.
Below is a simple yet efficient implementation of the checksum function, you can use it for
the assignment, but you can implement your own checksum function.
/*
* @brief A checksum function that returns 16 bit checksum for data.
* @param data The data to do the checksum for.
* @param bytes The length of the data in bytes.
* @return The checksum itself as 16 bit unsigned number.
* @note This function is taken from RFC1071, can be found here:
* @note https://tools.ietf.org/html/rfc1071
* @note It is the simplest way to calculate a checksum and is not very strong.
* However, it is good enough for this assignment.
* @note You are free to use any other checksum function as well.
* You can also use this function as such without any change.
*/
unsigned short int calculate_checksum(void *data, unsigned int bytes) {
 unsigned short int *data_pointer = (unsigned short int *)data;
 unsigned int total_sum = 0;
 // Main summing loop
 while (bytes > 1) {
 total_sum += *data_pointer++;
 bytes -= 2;
 }
 // Add left-over byte, if any
 if (bytes > 0)
 total_sum += *((unsigned char *)data_pointer);
 // Fold 32-bit sum to 16 bits
 while (total_sum >> 16)
 total_sum = (total_sum & 0xFFFF) + (total_sum >> 16);
 return (~((unsigned short int)total_sum));
} Communication Networks Course
Page | 1
Assignment 3 â€“ Transport Layer
Assignment Notes and Instructions
This assignment is to be done in pairs only. You must upload all the necessary files in a ZIP
file named after both of the studentâ€™s ID. For example: ğŸğŸğŸ‘ğŸ’ğŸ“ğŸ”ğŸ•ğŸ–ğŸ—_ğŸ—ğŸ–ğŸ•ğŸ”ğŸ“ğŸ’ğŸ‘ğŸğŸ. ğ’›ğ’Šğ’‘.
1) The assignment must be submitted by the date specified in the submission box.
2) All the assignment files (Code, Wireshark pcap files, PDF) must be submitted in a ZIP file. The
PDF must contain all the necessary screenshots with a description for each one of them.
3) The assignment must be done in pairs only. In exceptional cases, you should send an email to
the course coordinator.
4) You can use any reference material available through the course Moodle website or any
material passed during the exercises.
5) You can use any reference from the web, but copying codes from websites is forbidden; this
includes codes from other GitHub repositories. A student who gets caught in the act will
automatically fail this assignment (score 0). Any website youâ€™ve used to solve the
assignment, every website you used to solve the assignment must be noted in the PDF.
6) No delays in submission without special permission. Lateness without approval will result in
failure of the assignment (score 0).
7) All submissions will be submitted via the course's Moodle website. Email submissions will not
be accepted, resulting in a failure in the assignment.
8) The order and design of the code must be carefully considered. Make sure that the program
output is as clear as possible, comments in the code, and meaningful variable names. You
must also submit a makefile that compiles all the programs.
9) The assignment code must be written in C only.
10) The assignment is personal for each pair, and you should not accept help from other people,
whether outside the university or inside it. You can contact the course staff during reception
hours for help or raise a question in the course forum. Do not transfer code sections
between students, upload solutions or parts of solutions to websites on the Internet or in
various communication groups.
11) Students who copy a solution will receive a 0 in all assignments in the course and a report will
be made to the institutional disciplinary committee.
12) All code files of the assignment are required to both compile and run properly on the Ubuntu
22.04 LTS operating system. This is the operating system where the submissions will be
tested. You mustnâ€™t code it in Windows, as it uses different API for sockets. WSL wonâ€™t work,
as the task needs a tool that works only in a fully Linux environment.
Good Luck!
 Communication Networks Course
Page | 2
Part A â€“ Transmission Control Protocol (TCP) â€“ 30 points
In this part, youâ€™ll write two program files: ğ‘»ğ‘ªğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and ğ‘»ğ‘ªğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
The Sender will send a randomly generated file and the Receiver will receive it and measure
the time it took for his program to receive the file. The file size should be at least 2MB.
When running the Sender and Receiver, they both should support two standard congestion
control algorithms: TCP Reno and TCP Cubic.
Notes:
â€¢ The main goal of this part is to get familiar with the TCP concept of sending
messages between two endpoints.
â€¢ For approaching this part of the assignment, please be sure that you are familiar
with the congestion control algorithms and how to change them using the correct
method in C (see Appendix B for more information).
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). You've
learned that TCP is reliable by design, so you can assume that all the data have been
passed correctly, and thus, no need to recheck.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
Usage:
â€¢ Receiver:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
â€¢ Sender:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port of the Receiver.
â€¢ ğ‘¨ğ‘³ğ‘®ğ‘¶ â€“ The TCP congestion control algorithm that will be used by the party
member (either ğ’“ğ’†ğ’ğ’ for TCP Reno or ğ’„ğ’–ğ’ƒğ’Šğ’„ for TCP Cubic).
 Communication Networks Course
Page | 3
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a TCP socket between the Sender and the
Receiver.
3) Send the file.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a TCP connection between the Receiver and
the Sender.
2) Get a connection from the sender.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./TCP_Receiver -p 1234 -algo reno
Starting Receiver...
Waiting for TCP connection...
Sender connected, beginning to receive file...
File transfer completed.
Waiting for Sender response...
Sender sent exit message.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 4
Part B â€“ Reliable User Datagram Protocol (Reliable UDP or RUDP) â€“ 40 points
Youâ€™ve learned that while TCP is reliable, it lacks speed and has an overhead data of 20 bytes,
compering to UDP that needs only 8 bytes of overhead data.
Reliable UDP or RUDP, is a protocol that uses the UDP protocol for a faster transmission of
data, while adding a reliability layer to it, but without adding too much overhead data like
TCP.
A simple sketch for a RUDP connection would look something like this:
Your task in this part is to implement a Reliable protocol using UDP only. For simplicity, your
implementation should only support a handshake, closing scheme, error checking,
acknowledgment of received packets, and retransmission of lost packets.
Guidance:
â€¢ You can use ğ‘ ğ‘’ğ‘¡ğ‘ ğ‘œğ‘ğ‘˜ğ‘œğ‘ğ‘¡(2) for detecting a timeout.
â€¢ You need to build your own protocol, as Reliable UDP isnâ€™t a standard protocol (see a
draft of RUDP in this link), and no official header is provided. You can use this sketch
for a header, but you can come up with your own protocol, as long as it works.
Where:
o ğ‘³ğ’†ğ’ğ’ˆğ’•ğ’‰ is the length of the data itself, without the RUDP header.
o ğ‘ªğ’‰ğ’†ğ’„ğ’Œğ’”ğ’–ğ’ is a 16bit number that validates the correctness of the data.
o ğ‘­ğ’ğ’‚ğ’ˆğ’” is a special byte where we classify the packet itself (SYN, ACK, etc.).
â€¢ In your PDF, you must explain how your implementation of RUDP works â€“ How does
it detect a timeout to do retransmissions, how does the handshake work, what is the
header overhead, etc.
â€¢ For this part, youâ€™ll write three files: ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¨ğ‘·ğ‘°. ğ’„, ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and
ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
Reliable UDP Header proposed sketch
Byte 0 Byte 1 Byte 2 Byte 3
Length (2 Bytes) Checksum (2 Bytes)
Flags (1 Byte)
Figure 1 - RUDP Protocol Architecture, Geeksforgeeks
 Communication Networks Course
Page | 5
Notes:
â€¢ The Sender will send a random generated file and the Receiver will receive it and
measure the time it took for his program to receive the file. The file size should be at
least 2MB.
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). But, as the
RUDP is based on UDP, itâ€™s not reliable. You must use some form of error checking
(like checksum) to ensure that the packet wasnâ€™t alerted during the transfer.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
â€¢ The RUDP needs support only 1 sender and 1 receiver, for simplicity purposes.
Usage:
â€¢ Receiver:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
â€¢ Sender:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port that both the Sender and the Receiver will use.
The ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„ file will contain all the implementations of the RUDP API functions (That is, to
prevent reusing the same chuck of code both in the Sender and the Receiver.).
The API should support at the bare minimum the following functions (you decide what
parameters to implement, and what are the names of the functions, as long as the API is
explained in the PDF):
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘œğ‘ğ‘˜ğ‘’ğ‘¡() â€“ Creating a RUDP socket and creating a handshake between two
peers.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘’ğ‘›ğ‘‘() â€“ Sending data to the peer. The function should wait for an
acknowledgment packet, and if it didnâ€™t receive any, retransmits the data.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘Ÿğ‘’ğ‘ğ‘£() â€“ Receive data from a peer.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ğ‘™ğ‘œğ‘ ğ‘’() â€“ Closes a connection between peers.
 Communication Networks Course
Page | 6
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a UDP socket between the Sender and the
Receiver.
3) Send the file via the RUDP protocol.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a UDP connection between the Receiver and
the Sender.
2) Get a connection from the sender, by the custom
RUDP protocol youâ€™ve built.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./RUDP_Receiver -p 1234
Starting Receiver...
Waiting for RUDP connection...
Connection request received, sending ACK.
Sender connected, beginning to receive file...
File transfer completed.
ACK sent.
Waiting for Sender response...
Sender sent exit message.
ACK sent.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 7
Part C â€“ Research â€“ 30 points
In this part, youâ€™ll conduct research about your implementations of part A and part B.
In the research itself, each one of the versions (TCP version and UDP version) will be run at
least 5 times (meaning that the file transfer will occur at least 5 times) by the following
conditions:
â€¢ For TCP, youâ€™ll run it in TCP Reno and TCP Cubic, alternating each time, for each
scenario, meaning that you run 5 times with TCP Reno in both Sender and Receiver,
and 5 times with TCP Cubic in both Sender and Receiver.
Bonus (5 points): Create a very large data set â€“ 5 times with TCP Reno in both Sender
and Receiver, 5 times with TCP Reno in Sender and TCP Cubic in Receiver, 5 times
with TCP Cubic in Sender and TCP Reno in Receiver, and 5 times with TCP Cubic in
both Sender and Receiver. This will give you a data set large enough, which allows
you to work with, compare with and to reach a definite conclusion.
â€¢ For RUDP, you will run it 5 times for each scenario.
â€¢ For both TCP and RUDP, you will run them on those scenarios of packet loss:
o 0% packet loss â€“ Control group, simulating perfect connection.
o 2% packet loss â€“ Simulating unstable connection that commonly occur.
o 5% packet loss â€“ Simulating bad connection.
o 10% packet loss â€“ Simulating extremely poor connection.
For each scenario, you must provide a filtered PCAP file and relevant screenshots that
explain each one of the steps in the process. (10 points)
After youâ€™ve gathered the data set for both TCP and Reliable UDP, answer the following
questions:
1) In TCP, which congestion control algorithm gave better results overall? TCP Reno or
TCP Cubic? Which one gave better results on high packet loss? Explain how you came
to this conclusion based on the data set youâ€™ve gathered. (5 points)
2) How did your implementation of Reliable UDP perform overall compared to regular
TCP? Which one is better for high packet loss? (5 points)
3) According to the data youâ€™ve gathered, in which scenarios and applications would we
prefer to use TCP and in which situations would we prefer to use reliable UDP?
Explain your answer. (5 points)
 Communication Networks Course
Page | 8
×¢× ×• ×¢×œ ×”×©××œ×•×ª ×”×‘××•×ª )5 × ×§×•×“×•×ª(:
â— ×‘"×¨×©×ª ×××™× ×”" ×”×›×•×•× ×” ×”×™× ×œ×¨×©×ª ×©×‘×” ××¢×˜ ×××•×“ ×—×‘×™×œ×•×ª ×”×•×œ×›×•×ª ×œ××™×‘×•×“. ×‘"×§×©×¨ ××¨×•×š" ×”×›×•×•× ×” ×”×™×
×œ×§×©×¨ TCP ×©×™×© ×‘×• ×”×¨×‘×” ×××•×“ ××™×“×¢ ×œ×©×œ×•×—. ××•×¦×¢ ×œ×”×’×“×™×œ ×‘ -TCP ××ª SSThreshold ×‘×ª×—×™×œ×ª ×”×§×©×¨.
×‘××™×–×” ××”××§×¨×™× ×”×‘××™× ×”×©×™× ×•×™ ×”×–×” ×¢×©×•×™ ×œ×”×•×¢×™×œ ×‘××™×“×” ×”××™×¨×‘×™×ª? × ××§.
.1 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
.2 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.3 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.4 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.5 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.6 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.7 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.8 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
â— A ×©×•×œ×— ×œ -B ×—×‘×™×œ×•×ª ××™×“×¢ ×‘×××¦×¢×•×ª ×§×©×¨ TCP. × ×ª×•×Ÿ ×›×™ ×”×§×©×¨ ××ª×—×™×œ ×¢× ×—×œ×•×Ÿ ×‘×’×•×“×œ 1MSS. ×”×§×©×¨
××¡×ª×™×™× ×‘×¤×¢× ×”×¨××©×•× ×” ×©×”×•× ××’×™×¢ ×œ -SSthresh. ×‘××”×œ×š ×”×§×©×¨ ×œ× ××•×‘×“×•×ª ×—×‘×™×œ×•×ª. × ×¡××Ÿ ×‘×§×™×¦×•×¨:
.SSthresh=S*MSS
× ×ª×•×Ÿ ×›×™ ×œ××•×¨×š ×›×œ ×”×§×©×¨ rwnd < MSS*S.
××”×™ ×”×ª×¤×•×§×” ×©×œ ×”×§×©×¨ ×-A ×œ-B( ×‘ -sec / Bytes )×‘×–××Ÿ ×”× "×œ? × ××§×™.
]S*MSS / [lg (S) * RTT*2 ×‘×¢×¨×š .1
]S*MSS / [S^0.5 * RTT*2 ×‘×¢×¨×š .2
S*MSS / RTT ×‘×¢×¨×š .3
S^2)*MSS / RTT( ×‘×¢×¨×š .4
â— ×©×ª×™ ×ª×—× ×•×ª ××ª×§×©×¨×•×ª ×‘××•×¤×Ÿ ××œ×—×•×˜×™ ×‘×©×™×˜×ª N Back Go.
× ×¡××Ÿ ×‘-X ××ª ×¡×¤×¨×ª ×”×‘×™×§×•×¨×ª ×©×œ ×”×ª.×–. ×©×œ×š. ×× ×©× ×™ ×©×•×ª×¤×™× ××’×™×©×™× ××ª ×”×ª×¨×’×™×œ ×™×—×“, X ×”×•× ×¡×¤×¨×ª
×”×‘×™×§×•×¨×ª ×‘×¢×œ×ª ×”×¢×¨×š ×”× ××•×š ×™×•×ª×¨ ××‘×™×Ÿ ×”×©×ª×™×™×.
×§×¦×‘ ×”×ª×§×©×•×¨×ª ×”×•× 8Gbps, ×•×’×•×“×œ ×›×œ ×—×‘×™×œ×” ×”×•× KByte*X. ×’×“×œ×™ ×”-headers ×•×” -Acks ×–× ×™×—×™×.
ï¿½ğ‘’ğ‘ ï¿½/ï¿½ï¿½ 8 , ×•×”××¨×—×§ ×‘×™×Ÿ ×”×ª×—× ×•×ª ×”×•× 1Km. ×§×¦×‘ ×”×”×ª×¤×©×˜×•×ª ×”×•× 10 â‹… 2
×–××Ÿ ×¢×™×‘×•×“ ×”× ×ª×•× ×™× ×‘×ª×—× ×•×ª ×–× ×™×—.
××£ ×—×‘×™×œ×” ×•××£ Ack ×œ× ×”×•×œ×›×™× ×œ××™×‘×•×“.
â— ××”×• X ×©×œ×š?
â— ××” ×¦×¨×™×š ×œ×”×™×•×ª ×’×•×“×œ ×—×œ×•×Ÿ ×”××©×œ×•×— ×›×“×™ ×œ×”×‘×˜×™×— ×ª×¤×•×§×” ××§×¡×™××œ×™×ª?
 Communication Networks Course
Page | 9
Bonus â€“ Improving the Reliable UDP â€“ 15 points
Note: This part isnâ€™t mandatory and is a bonus only!
In this part, youâ€™ll improve your RUDP implementation by adding the concepts of flow
control and congestion control from TCP. Youâ€™re free to choose which algorithms to
implement, as long as you explain in your PDF which algorithms youâ€™ve used. Youâ€™ll probably
need to make changes in the original design of the RUDP. Changes only need to be to the API
itself, ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„.
Points distribution:
â€¢ Flow control improvement â€“ 7 Points
â€¢ Congestion control improvement â€“ 8 points.
Guidance:
â€¢ For flow control, you must use one of the Sliding window techniques: stop-and-wait
ARQ, Go-Back-N or Selective repeat.
â€¢ List of known TCP congestion control algorithms, which you can use any one of them
for this bonus task, or makeup your own:
Figure 2 â€“ List of known TCP congestion control algorithms, Wikipedia
 Communication Networks Course
Page | 10
Appendix A â€“ Linux local packet loss tool
To simulate a packet loss in a local network, we'll use a Linux tool that's called Linux Traffic
Control (ğ‘¡ğ‘). This requires a full Linux installation, so working with WSL won't work.
If the tool isn't installed in your machine, you can install it by using the following commands:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’
If the installation didn't work, you can use the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’2
To create a packet loss scenario, type the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘ğ‘‘ğ‘‘ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
After creating a packet loss scenario, you can change the percentage by typing the following
command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘â„ğ‘ğ‘›ğ‘”ğ‘’ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
To remove the packet loss scenario, write the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘‘ğ‘’ğ‘™ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š
 Communication Networks Course
Page | 11
Appendix B â€“ ğ’ğ’‚ğ’(ğŸ) system calls
This appendixâ€™s purpose is to give you a better understanding of socket handling in C.
A recommended reference is Beejâ€™s Guide to Network Programming, by Brian â€œBeej
Jorgensenâ€ Hall, which gives a lot of information about sockets in C and functions.
Functions and documentation links:
â€¢ ğ’”ğ’ğ’„ğ’Œğ’†ğ’•(ğŸ) â€“ A Factory method system call that creates a socket with the given
parameters.
â€¢ ğ’ƒğ’Šğ’ğ’…(ğŸ) â€“ Whenever we create a new socket, we need to bind it to a specific port in
our machine, â€œto catch a portâ€. The port number is managed and used by the kernel
to link incoming packets to the corresponding application socket. The port numbers
are usually fixed. The ğ‘ğ‘‘ğ‘‘ğ‘Ÿ parameter must match the current socket that is used.
â€¢ ğ’ğ’Šğ’”ğ’•ğ’†ğ’(ğŸ) â€“ The ğ‘™ğ‘–ğ‘ ğ‘¡ğ‘’ğ‘›(2) system call doesn't do anything in the mean of
communication but only memory allocation (malloc) for stream sockets only. If we
won't allocate memory, any incoming connection will fail.
â€¢ ğ’„ğ’ğ’ğ’ğ’†ğ’„ğ’•(ğŸ) â€“ The ğ‘ğ‘œğ‘›ğ‘›ğ‘’ğ‘ğ‘¡(2) system call starts the link between a client and a
specific IP address and port number. The connection would complete when the
other side will call the ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call.
â€¢ ğ’‚ğ’„ğ’„ğ’†ğ’‘ğ’•(ğŸ) â€“ The ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call accepts the incoming stream connection
request from the other side, by the listening socket. This system call completes the
three-way handshake of stream socket (like TCP) and opens a new socket that has a
direct communication channel only with the other party in the handshake.
â€¢ ğ’”ğ’†ğ’ğ’…(ğŸ) and ğ’”ğ’†ğ’ğ’…ğ’•ğ’(ğŸ) â€“ The ğ‘ ğ‘’ğ‘›ğ‘‘(2) and ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system calls are an analogy
for the ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’(2) system call, specifcly for sockets, with flags set to 0. Those system
calls return the number of bytes that were sent through the socket itself, as the
number of bytes can vary. The ğ‘ ğ‘’ğ‘›ğ‘‘(2)system call designed for stream sockets (like
TCP), while the ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system call designed for datagram connection-less
sockets (like UDP). When the ğ‘ ğ‘’ğ‘›ğ‘‘(2) system call returns 0, it means that the other
party closed the connection.
â€¢ ğ’“ğ’†ğ’„ğ’—(ğŸ) and ğ’“ğ’†ğ’„ğ’—ğ’‡ğ’“ğ’ğ’(ğŸ) â€“ The ğ‘Ÿğ‘’ğ‘ğ‘£(2) and ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system calls are an
analogy for the ğ‘Ÿğ‘’ğ‘ğ‘‘(2) system call, specifically for sockets, with flags set to 0.
Those system calls return the number of bytes that were received through the socket
itself, as the number of bytes can vary. The ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call designed for stream
sockets (like TCP), while the ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system call designed for datagram
connection-less sockets (like UDP). When the ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call returns 0, it means
that the other party closed the connection.
â€¢ ğ’„ğ’ğ’ğ’”ğ’†(ğŸ) and ğ’”ğ’‰ğ’–ğ’•ğ’…ğ’ğ’˜ğ’(ğŸ) â€“ The ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) and ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2) system calls close
the socket. While ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) system call closes the whole socket, the ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2)
system call partially closes the socket for read/write.
 Communication Networks Course
Page | 12
Appendix C â€“ Random data generator
The data that you are going to send in this assignment is randomly generated. You can use
your own file with appropriate size or use the following function (or a function of your own)
to generate the data:
/*
* @brief A random data generator function based on srand() and rand().
* @param size The size of the data to generate (up to 2^32 bytes).
* @return A pointer to the buffer.
*/
char *util_generate_random_data(unsigned int size) {
 char *buffer = NULL;
 // Argument check.
 if (size == 0)
 return NULL;
 buffer = (char *)calloc(size, sizeof(char));
 // Error checking.
 if (buffer == NULL)
 return NULL;
 // Randomize the seed of the random number generator.
 srand(time(NULL));
 for (unsigned int i = 0; i < size; i++)
 *(buffer + i) = ((unsigned int)rand() % 256);
 return buffer;
}
 Communication Networks Course
Page | 13
Appendix D â€“ Checksum function
A checksum is a small-sized block of data derived from another block of digital data for the
purpose of detecting errors that may have been introduced during its transmission or
storage. By themselves, checksums are often used to verify data integrity but are not relied
upon to verify data authenticity.
Below is a simple yet efficient implementation of the checksum function, you can use it for
the assignment, but you can implement your own checksum function.
/*
* @brief A checksum function that returns 16 bit checksum for data.
* @param data The data to do the checksum for.
* @param bytes The length of the data in bytes.
* @return The checksum itself as 16 bit unsigned number.
* @note This function is taken from RFC1071, can be found here:
* @note https://tools.ietf.org/html/rfc1071
* @note It is the simplest way to calculate a checksum and is not very strong.
* However, it is good enough for this assignment.
* @note You are free to use any other checksum function as well.
* You can also use this function as such without any change.
*/
unsigned short int calculate_checksum(void *data, unsigned int bytes) {
 unsigned short int *data_pointer = (unsigned short int *)data;
 unsigned int total_sum = 0;
 // Main summing loop
 while (bytes > 1) {
 total_sum += *data_pointer++;
 bytes -= 2;
 }
 // Add left-over byte, if any
 if (bytes > 0)
 total_sum += *((unsigned char *)data_pointer);
 // Fold 32-bit sum to 16 bits
 while (total_sum >> 16)
 total_sum = (total_sum & 0xFFFF) + (total_sum >> 16);
 return (~((unsigned short int)total_sum));
} Communication Networks Course
Page | 1
Assignment 3 â€“ Transport Layer
Assignment Notes and Instructions
This assignment is to be done in pairs only. You must upload all the necessary files in a ZIP
file named after both of the studentâ€™s ID. For example: ğŸğŸğŸ‘ğŸ’ğŸ“ğŸ”ğŸ•ğŸ–ğŸ—_ğŸ—ğŸ–ğŸ•ğŸ”ğŸ“ğŸ’ğŸ‘ğŸğŸ. ğ’›ğ’Šğ’‘.
1) The assignment must be submitted by the date specified in the submission box.
2) All the assignment files (Code, Wireshark pcap files, PDF) must be submitted in a ZIP file. The
PDF must contain all the necessary screenshots with a description for each one of them.
3) The assignment must be done in pairs only. In exceptional cases, you should send an email to
the course coordinator.
4) You can use any reference material available through the course Moodle website or any
material passed during the exercises.
5) You can use any reference from the web, but copying codes from websites is forbidden; this
includes codes from other GitHub repositories. A student who gets caught in the act will
automatically fail this assignment (score 0). Any website youâ€™ve used to solve the
assignment, every website you used to solve the assignment must be noted in the PDF.
6) No delays in submission without special permission. Lateness without approval will result in
failure of the assignment (score 0).
7) All submissions will be submitted via the course's Moodle website. Email submissions will not
be accepted, resulting in a failure in the assignment.
8) The order and design of the code must be carefully considered. Make sure that the program
output is as clear as possible, comments in the code, and meaningful variable names. You
must also submit a makefile that compiles all the programs.
9) The assignment code must be written in C only.
10) The assignment is personal for each pair, and you should not accept help from other people,
whether outside the university or inside it. You can contact the course staff during reception
hours for help or raise a question in the course forum. Do not transfer code sections
between students, upload solutions or parts of solutions to websites on the Internet or in
various communication groups.
11) Students who copy a solution will receive a 0 in all assignments in the course and a report will
be made to the institutional disciplinary committee.
12) All code files of the assignment are required to both compile and run properly on the Ubuntu
22.04 LTS operating system. This is the operating system where the submissions will be
tested. You mustnâ€™t code it in Windows, as it uses different API for sockets. WSL wonâ€™t work,
as the task needs a tool that works only in a fully Linux environment.
Good Luck!
 Communication Networks Course
Page | 2
Part A â€“ Transmission Control Protocol (TCP) â€“ 30 points
In this part, youâ€™ll write two program files: ğ‘»ğ‘ªğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and ğ‘»ğ‘ªğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
The Sender will send a randomly generated file and the Receiver will receive it and measure
the time it took for his program to receive the file. The file size should be at least 2MB.
When running the Sender and Receiver, they both should support two standard congestion
control algorithms: TCP Reno and TCP Cubic.
Notes:
â€¢ The main goal of this part is to get familiar with the TCP concept of sending
messages between two endpoints.
â€¢ For approaching this part of the assignment, please be sure that you are familiar
with the congestion control algorithms and how to change them using the correct
method in C (see Appendix B for more information).
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). You've
learned that TCP is reliable by design, so you can assume that all the data have been
passed correctly, and thus, no need to recheck.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
Usage:
â€¢ Receiver:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
â€¢ Sender:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port of the Receiver.
â€¢ ğ‘¨ğ‘³ğ‘®ğ‘¶ â€“ The TCP congestion control algorithm that will be used by the party
member (either ğ’“ğ’†ğ’ğ’ for TCP Reno or ğ’„ğ’–ğ’ƒğ’Šğ’„ for TCP Cubic).
 Communication Networks Course
Page | 3
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a TCP socket between the Sender and the
Receiver.
3) Send the file.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a TCP connection between the Receiver and
the Sender.
2) Get a connection from the sender.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./TCP_Receiver -p 1234 -algo reno
Starting Receiver...
Waiting for TCP connection...
Sender connected, beginning to receive file...
File transfer completed.
Waiting for Sender response...
Sender sent exit message.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 4
Part B â€“ Reliable User Datagram Protocol (Reliable UDP or RUDP) â€“ 40 points
Youâ€™ve learned that while TCP is reliable, it lacks speed and has an overhead data of 20 bytes,
compering to UDP that needs only 8 bytes of overhead data.
Reliable UDP or RUDP, is a protocol that uses the UDP protocol for a faster transmission of
data, while adding a reliability layer to it, but without adding too much overhead data like
TCP.
A simple sketch for a RUDP connection would look something like this:
Your task in this part is to implement a Reliable protocol using UDP only. For simplicity, your
implementation should only support a handshake, closing scheme, error checking,
acknowledgment of received packets, and retransmission of lost packets.
Guidance:
â€¢ You can use ğ‘ ğ‘’ğ‘¡ğ‘ ğ‘œğ‘ğ‘˜ğ‘œğ‘ğ‘¡(2) for detecting a timeout.
â€¢ You need to build your own protocol, as Reliable UDP isnâ€™t a standard protocol (see a
draft of RUDP in this link), and no official header is provided. You can use this sketch
for a header, but you can come up with your own protocol, as long as it works.
Where:
o ğ‘³ğ’†ğ’ğ’ˆğ’•ğ’‰ is the length of the data itself, without the RUDP header.
o ğ‘ªğ’‰ğ’†ğ’„ğ’Œğ’”ğ’–ğ’ is a 16bit number that validates the correctness of the data.
o ğ‘­ğ’ğ’‚ğ’ˆğ’” is a special byte where we classify the packet itself (SYN, ACK, etc.).
â€¢ In your PDF, you must explain how your implementation of RUDP works â€“ How does
it detect a timeout to do retransmissions, how does the handshake work, what is the
header overhead, etc.
â€¢ For this part, youâ€™ll write three files: ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¨ğ‘·ğ‘°. ğ’„, ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and
ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
Reliable UDP Header proposed sketch
Byte 0 Byte 1 Byte 2 Byte 3
Length (2 Bytes) Checksum (2 Bytes)
Flags (1 Byte)
Figure 1 - RUDP Protocol Architecture, Geeksforgeeks
 Communication Networks Course
Page | 5
Notes:
â€¢ The Sender will send a random generated file and the Receiver will receive it and
measure the time it took for his program to receive the file. The file size should be at
least 2MB.
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). But, as the
RUDP is based on UDP, itâ€™s not reliable. You must use some form of error checking
(like checksum) to ensure that the packet wasnâ€™t alerted during the transfer.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
â€¢ The RUDP needs support only 1 sender and 1 receiver, for simplicity purposes.
Usage:
â€¢ Receiver:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
â€¢ Sender:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port that both the Sender and the Receiver will use.
The ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„ file will contain all the implementations of the RUDP API functions (That is, to
prevent reusing the same chuck of code both in the Sender and the Receiver.).
The API should support at the bare minimum the following functions (you decide what
parameters to implement, and what are the names of the functions, as long as the API is
explained in the PDF):
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘œğ‘ğ‘˜ğ‘’ğ‘¡() â€“ Creating a RUDP socket and creating a handshake between two
peers.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘’ğ‘›ğ‘‘() â€“ Sending data to the peer. The function should wait for an
acknowledgment packet, and if it didnâ€™t receive any, retransmits the data.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘Ÿğ‘’ğ‘ğ‘£() â€“ Receive data from a peer.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ğ‘™ğ‘œğ‘ ğ‘’() â€“ Closes a connection between peers.
 Communication Networks Course
Page | 6
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a UDP socket between the Sender and the
Receiver.
3) Send the file via the RUDP protocol.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a UDP connection between the Receiver and
the Sender.
2) Get a connection from the sender, by the custom
RUDP protocol youâ€™ve built.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./RUDP_Receiver -p 1234
Starting Receiver...
Waiting for RUDP connection...
Connection request received, sending ACK.
Sender connected, beginning to receive file...
File transfer completed.
ACK sent.
Waiting for Sender response...
Sender sent exit message.
ACK sent.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 7
Part C â€“ Research â€“ 30 points
In this part, youâ€™ll conduct research about your implementations of part A and part B.
In the research itself, each one of the versions (TCP version and UDP version) will be run at
least 5 times (meaning that the file transfer will occur at least 5 times) by the following
conditions:
â€¢ For TCP, youâ€™ll run it in TCP Reno and TCP Cubic, alternating each time, for each
scenario, meaning that you run 5 times with TCP Reno in both Sender and Receiver,
and 5 times with TCP Cubic in both Sender and Receiver.
Bonus (5 points): Create a very large data set â€“ 5 times with TCP Reno in both Sender
and Receiver, 5 times with TCP Reno in Sender and TCP Cubic in Receiver, 5 times
with TCP Cubic in Sender and TCP Reno in Receiver, and 5 times with TCP Cubic in
both Sender and Receiver. This will give you a data set large enough, which allows
you to work with, compare with and to reach a definite conclusion.
â€¢ For RUDP, you will run it 5 times for each scenario.
â€¢ For both TCP and RUDP, you will run them on those scenarios of packet loss:
o 0% packet loss â€“ Control group, simulating perfect connection.
o 2% packet loss â€“ Simulating unstable connection that commonly occur.
o 5% packet loss â€“ Simulating bad connection.
o 10% packet loss â€“ Simulating extremely poor connection.
For each scenario, you must provide a filtered PCAP file and relevant screenshots that
explain each one of the steps in the process. (10 points)
After youâ€™ve gathered the data set for both TCP and Reliable UDP, answer the following
questions:
1) In TCP, which congestion control algorithm gave better results overall? TCP Reno or
TCP Cubic? Which one gave better results on high packet loss? Explain how you came
to this conclusion based on the data set youâ€™ve gathered. (5 points)
2) How did your implementation of Reliable UDP perform overall compared to regular
TCP? Which one is better for high packet loss? (5 points)
3) According to the data youâ€™ve gathered, in which scenarios and applications would we
prefer to use TCP and in which situations would we prefer to use reliable UDP?
Explain your answer. (5 points)
 Communication Networks Course
Page | 8
×¢× ×• ×¢×œ ×”×©××œ×•×ª ×”×‘××•×ª )5 × ×§×•×“×•×ª(:
â— ×‘"×¨×©×ª ×××™× ×”" ×”×›×•×•× ×” ×”×™× ×œ×¨×©×ª ×©×‘×” ××¢×˜ ×××•×“ ×—×‘×™×œ×•×ª ×”×•×œ×›×•×ª ×œ××™×‘×•×“. ×‘"×§×©×¨ ××¨×•×š" ×”×›×•×•× ×” ×”×™×
×œ×§×©×¨ TCP ×©×™×© ×‘×• ×”×¨×‘×” ×××•×“ ××™×“×¢ ×œ×©×œ×•×—. ××•×¦×¢ ×œ×”×’×“×™×œ ×‘ -TCP ××ª SSThreshold ×‘×ª×—×™×œ×ª ×”×§×©×¨.
×‘××™×–×” ××”××§×¨×™× ×”×‘××™× ×”×©×™× ×•×™ ×”×–×” ×¢×©×•×™ ×œ×”×•×¢×™×œ ×‘××™×“×” ×”××™×¨×‘×™×ª? × ××§.
.1 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
.2 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.3 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.4 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.5 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.6 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.7 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.8 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
â— A ×©×•×œ×— ×œ -B ×—×‘×™×œ×•×ª ××™×“×¢ ×‘×××¦×¢×•×ª ×§×©×¨ TCP. × ×ª×•×Ÿ ×›×™ ×”×§×©×¨ ××ª×—×™×œ ×¢× ×—×œ×•×Ÿ ×‘×’×•×“×œ 1MSS. ×”×§×©×¨
××¡×ª×™×™× ×‘×¤×¢× ×”×¨××©×•× ×” ×©×”×•× ××’×™×¢ ×œ -SSthresh. ×‘××”×œ×š ×”×§×©×¨ ×œ× ××•×‘×“×•×ª ×—×‘×™×œ×•×ª. × ×¡××Ÿ ×‘×§×™×¦×•×¨:
.SSthresh=S*MSS
× ×ª×•×Ÿ ×›×™ ×œ××•×¨×š ×›×œ ×”×§×©×¨ rwnd < MSS*S.
××”×™ ×”×ª×¤×•×§×” ×©×œ ×”×§×©×¨ ×-A ×œ-B( ×‘ -sec / Bytes )×‘×–××Ÿ ×”× "×œ? × ××§×™.
]S*MSS / [lg (S) * RTT*2 ×‘×¢×¨×š .1
]S*MSS / [S^0.5 * RTT*2 ×‘×¢×¨×š .2
S*MSS / RTT ×‘×¢×¨×š .3
S^2)*MSS / RTT( ×‘×¢×¨×š .4
â— ×©×ª×™ ×ª×—× ×•×ª ××ª×§×©×¨×•×ª ×‘××•×¤×Ÿ ××œ×—×•×˜×™ ×‘×©×™×˜×ª N Back Go.
× ×¡××Ÿ ×‘-X ××ª ×¡×¤×¨×ª ×”×‘×™×§×•×¨×ª ×©×œ ×”×ª.×–. ×©×œ×š. ×× ×©× ×™ ×©×•×ª×¤×™× ××’×™×©×™× ××ª ×”×ª×¨×’×™×œ ×™×—×“, X ×”×•× ×¡×¤×¨×ª
×”×‘×™×§×•×¨×ª ×‘×¢×œ×ª ×”×¢×¨×š ×”× ××•×š ×™×•×ª×¨ ××‘×™×Ÿ ×”×©×ª×™×™×.
×§×¦×‘ ×”×ª×§×©×•×¨×ª ×”×•× 8Gbps, ×•×’×•×“×œ ×›×œ ×—×‘×™×œ×” ×”×•× KByte*X. ×’×“×œ×™ ×”-headers ×•×” -Acks ×–× ×™×—×™×.
ï¿½ğ‘’ğ‘ ï¿½/ï¿½ï¿½ 8 , ×•×”××¨×—×§ ×‘×™×Ÿ ×”×ª×—× ×•×ª ×”×•× 1Km. ×§×¦×‘ ×”×”×ª×¤×©×˜×•×ª ×”×•× 10 â‹… 2
×–××Ÿ ×¢×™×‘×•×“ ×”× ×ª×•× ×™× ×‘×ª×—× ×•×ª ×–× ×™×—.
××£ ×—×‘×™×œ×” ×•××£ Ack ×œ× ×”×•×œ×›×™× ×œ××™×‘×•×“.
â— ××”×• X ×©×œ×š?
â— ××” ×¦×¨×™×š ×œ×”×™×•×ª ×’×•×“×œ ×—×œ×•×Ÿ ×”××©×œ×•×— ×›×“×™ ×œ×”×‘×˜×™×— ×ª×¤×•×§×” ××§×¡×™××œ×™×ª?
 Communication Networks Course
Page | 9
Bonus â€“ Improving the Reliable UDP â€“ 15 points
Note: This part isnâ€™t mandatory and is a bonus only!
In this part, youâ€™ll improve your RUDP implementation by adding the concepts of flow
control and congestion control from TCP. Youâ€™re free to choose which algorithms to
implement, as long as you explain in your PDF which algorithms youâ€™ve used. Youâ€™ll probably
need to make changes in the original design of the RUDP. Changes only need to be to the API
itself, ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„.
Points distribution:
â€¢ Flow control improvement â€“ 7 Points
â€¢ Congestion control improvement â€“ 8 points.
Guidance:
â€¢ For flow control, you must use one of the Sliding window techniques: stop-and-wait
ARQ, Go-Back-N or Selective repeat.
â€¢ List of known TCP congestion control algorithms, which you can use any one of them
for this bonus task, or makeup your own:
Figure 2 â€“ List of known TCP congestion control algorithms, Wikipedia
 Communication Networks Course
Page | 10
Appendix A â€“ Linux local packet loss tool
To simulate a packet loss in a local network, we'll use a Linux tool that's called Linux Traffic
Control (ğ‘¡ğ‘). This requires a full Linux installation, so working with WSL won't work.
If the tool isn't installed in your machine, you can install it by using the following commands:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’
If the installation didn't work, you can use the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’2
To create a packet loss scenario, type the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘ğ‘‘ğ‘‘ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
After creating a packet loss scenario, you can change the percentage by typing the following
command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘â„ğ‘ğ‘›ğ‘”ğ‘’ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
To remove the packet loss scenario, write the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘‘ğ‘’ğ‘™ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š
 Communication Networks Course
Page | 11
Appendix B â€“ ğ’ğ’‚ğ’(ğŸ) system calls
This appendixâ€™s purpose is to give you a better understanding of socket handling in C.
A recommended reference is Beejâ€™s Guide to Network Programming, by Brian â€œBeej
Jorgensenâ€ Hall, which gives a lot of information about sockets in C and functions.
Functions and documentation links:
â€¢ ğ’”ğ’ğ’„ğ’Œğ’†ğ’•(ğŸ) â€“ A Factory method system call that creates a socket with the given
parameters.
â€¢ ğ’ƒğ’Šğ’ğ’…(ğŸ) â€“ Whenever we create a new socket, we need to bind it to a specific port in
our machine, â€œto catch a portâ€. The port number is managed and used by the kernel
to link incoming packets to the corresponding application socket. The port numbers
are usually fixed. The ğ‘ğ‘‘ğ‘‘ğ‘Ÿ parameter must match the current socket that is used.
â€¢ ğ’ğ’Šğ’”ğ’•ğ’†ğ’(ğŸ) â€“ The ğ‘™ğ‘–ğ‘ ğ‘¡ğ‘’ğ‘›(2) system call doesn't do anything in the mean of
communication but only memory allocation (malloc) for stream sockets only. If we
won't allocate memory, any incoming connection will fail.
â€¢ ğ’„ğ’ğ’ğ’ğ’†ğ’„ğ’•(ğŸ) â€“ The ğ‘ğ‘œğ‘›ğ‘›ğ‘’ğ‘ğ‘¡(2) system call starts the link between a client and a
specific IP address and port number. The connection would complete when the
other side will call the ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call.
â€¢ ğ’‚ğ’„ğ’„ğ’†ğ’‘ğ’•(ğŸ) â€“ The ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call accepts the incoming stream connection
request from the other side, by the listening socket. This system call completes the
three-way handshake of stream socket (like TCP) and opens a new socket that has a
direct communication channel only with the other party in the handshake.
â€¢ ğ’”ğ’†ğ’ğ’…(ğŸ) and ğ’”ğ’†ğ’ğ’…ğ’•ğ’(ğŸ) â€“ The ğ‘ ğ‘’ğ‘›ğ‘‘(2) and ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system calls are an analogy
for the ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’(2) system call, specifcly for sockets, with flags set to 0. Those system
calls return the number of bytes that were sent through the socket itself, as the
number of bytes can vary. The ğ‘ ğ‘’ğ‘›ğ‘‘(2)system call designed for stream sockets (like
TCP), while the ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system call designed for datagram connection-less
sockets (like UDP). When the ğ‘ ğ‘’ğ‘›ğ‘‘(2) system call returns 0, it means that the other
party closed the connection.
â€¢ ğ’“ğ’†ğ’„ğ’—(ğŸ) and ğ’“ğ’†ğ’„ğ’—ğ’‡ğ’“ğ’ğ’(ğŸ) â€“ The ğ‘Ÿğ‘’ğ‘ğ‘£(2) and ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system calls are an
analogy for the ğ‘Ÿğ‘’ğ‘ğ‘‘(2) system call, specifically for sockets, with flags set to 0.
Those system calls return the number of bytes that were received through the socket
itself, as the number of bytes can vary. The ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call designed for stream
sockets (like TCP), while the ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system call designed for datagram
connection-less sockets (like UDP). When the ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call returns 0, it means
that the other party closed the connection.
â€¢ ğ’„ğ’ğ’ğ’”ğ’†(ğŸ) and ğ’”ğ’‰ğ’–ğ’•ğ’…ğ’ğ’˜ğ’(ğŸ) â€“ The ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) and ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2) system calls close
the socket. While ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) system call closes the whole socket, the ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2)
system call partially closes the socket for read/write.
 Communication Networks Course
Page | 12
Appendix C â€“ Random data generator
The data that you are going to send in this assignment is randomly generated. You can use
your own file with appropriate size or use the following function (or a function of your own)
to generate the data:
/*
* @brief A random data generator function based on srand() and rand().
* @param size The size of the data to generate (up to 2^32 bytes).
* @return A pointer to the buffer.
*/
char *util_generate_random_data(unsigned int size) {
 char *buffer = NULL;
 // Argument check.
 if (size == 0)
 return NULL;
 buffer = (char *)calloc(size, sizeof(char));
 // Error checking.
 if (buffer == NULL)
 return NULL;
 // Randomize the seed of the random number generator.
 srand(time(NULL));
 for (unsigned int i = 0; i < size; i++)
 *(buffer + i) = ((unsigned int)rand() % 256);
 return buffer;
}
 Communication Networks Course
Page | 13
Appendix D â€“ Checksum function
A checksum is a small-sized block of data derived from another block of digital data for the
purpose of detecting errors that may have been introduced during its transmission or
storage. By themselves, checksums are often used to verify data integrity but are not relied
upon to verify data authenticity.
Below is a simple yet efficient implementation of the checksum function, you can use it for
the assignment, but you can implement your own checksum function.
/*
* @brief A checksum function that returns 16 bit checksum for data.
* @param data The data to do the checksum for.
* @param bytes The length of the data in bytes.
* @return The checksum itself as 16 bit unsigned number.
* @note This function is taken from RFC1071, can be found here:
* @note https://tools.ietf.org/html/rfc1071
* @note It is the simplest way to calculate a checksum and is not very strong.
* However, it is good enough for this assignment.
* @note You are free to use any other checksum function as well.
* You can also use this function as such without any change.
*/
unsigned short int calculate_checksum(void *data, unsigned int bytes) {
 unsigned short int *data_pointer = (unsigned short int *)data;
 unsigned int total_sum = 0;
 // Main summing loop
 while (bytes > 1) {
 total_sum += *data_pointer++;
 bytes -= 2;
 }
 // Add left-over byte, if any
 if (bytes > 0)
 total_sum += *((unsigned char *)data_pointer);
 // Fold 32-bit sum to 16 bits
 while (total_sum >> 16)
 total_sum = (total_sum & 0xFFFF) + (total_sum >> 16);
 return (~((unsigned short int)total_sum));
} Communication Networks Course
Page | 1
Assignment 3 â€“ Transport Layer
Assignment Notes and Instructions
This assignment is to be done in pairs only. You must upload all the necessary files in a ZIP
file named after both of the studentâ€™s ID. For example: ğŸğŸğŸ‘ğŸ’ğŸ“ğŸ”ğŸ•ğŸ–ğŸ—_ğŸ—ğŸ–ğŸ•ğŸ”ğŸ“ğŸ’ğŸ‘ğŸğŸ. ğ’›ğ’Šğ’‘.
1) The assignment must be submitted by the date specified in the submission box.
2) All the assignment files (Code, Wireshark pcap files, PDF) must be submitted in a ZIP file. The
PDF must contain all the necessary screenshots with a description for each one of them.
3) The assignment must be done in pairs only. In exceptional cases, you should send an email to
the course coordinator.
4) You can use any reference material available through the course Moodle website or any
material passed during the exercises.
5) You can use any reference from the web, but copying codes from websites is forbidden; this
includes codes from other GitHub repositories. A student who gets caught in the act will
automatically fail this assignment (score 0). Any website youâ€™ve used to solve the
assignment, every website you used to solve the assignment must be noted in the PDF.
6) No delays in submission without special permission. Lateness without approval will result in
failure of the assignment (score 0).
7) All submissions will be submitted via the course's Moodle website. Email submissions will not
be accepted, resulting in a failure in the assignment.
8) The order and design of the code must be carefully considered. Make sure that the program
output is as clear as possible, comments in the code, and meaningful variable names. You
must also submit a makefile that compiles all the programs.
9) The assignment code must be written in C only.
10) The assignment is personal for each pair, and you should not accept help from other people,
whether outside the university or inside it. You can contact the course staff during reception
hours for help or raise a question in the course forum. Do not transfer code sections
between students, upload solutions or parts of solutions to websites on the Internet or in
various communication groups.
11) Students who copy a solution will receive a 0 in all assignments in the course and a report will
be made to the institutional disciplinary committee.
12) All code files of the assignment are required to both compile and run properly on the Ubuntu
22.04 LTS operating system. This is the operating system where the submissions will be
tested. You mustnâ€™t code it in Windows, as it uses different API for sockets. WSL wonâ€™t work,
as the task needs a tool that works only in a fully Linux environment.
Good Luck!
 Communication Networks Course
Page | 2
Part A â€“ Transmission Control Protocol (TCP) â€“ 30 points
In this part, youâ€™ll write two program files: ğ‘»ğ‘ªğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and ğ‘»ğ‘ªğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
The Sender will send a randomly generated file and the Receiver will receive it and measure
the time it took for his program to receive the file. The file size should be at least 2MB.
When running the Sender and Receiver, they both should support two standard congestion
control algorithms: TCP Reno and TCP Cubic.
Notes:
â€¢ The main goal of this part is to get familiar with the TCP concept of sending
messages between two endpoints.
â€¢ For approaching this part of the assignment, please be sure that you are familiar
with the congestion control algorithms and how to change them using the correct
method in C (see Appendix B for more information).
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). You've
learned that TCP is reliable by design, so you can assume that all the data have been
passed correctly, and thus, no need to recheck.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
Usage:
â€¢ Receiver:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
â€¢ Sender:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port of the Receiver.
â€¢ ğ‘¨ğ‘³ğ‘®ğ‘¶ â€“ The TCP congestion control algorithm that will be used by the party
member (either ğ’“ğ’†ğ’ğ’ for TCP Reno or ğ’„ğ’–ğ’ƒğ’Šğ’„ for TCP Cubic).
 Communication Networks Course
Page | 3
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a TCP socket between the Sender and the
Receiver.
3) Send the file.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a TCP connection between the Receiver and
the Sender.
2) Get a connection from the sender.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./TCP_Receiver -p 1234 -algo reno
Starting Receiver...
Waiting for TCP connection...
Sender connected, beginning to receive file...
File transfer completed.
Waiting for Sender response...
Sender sent exit message.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 4
Part B â€“ Reliable User Datagram Protocol (Reliable UDP or RUDP) â€“ 40 points
Youâ€™ve learned that while TCP is reliable, it lacks speed and has an overhead data of 20 bytes,
compering to UDP that needs only 8 bytes of overhead data.
Reliable UDP or RUDP, is a protocol that uses the UDP protocol for a faster transmission of
data, while adding a reliability layer to it, but without adding too much overhead data like
TCP.
A simple sketch for a RUDP connection would look something like this:
Your task in this part is to implement a Reliable protocol using UDP only. For simplicity, your
implementation should only support a handshake, closing scheme, error checking,
acknowledgment of received packets, and retransmission of lost packets.
Guidance:
â€¢ You can use ğ‘ ğ‘’ğ‘¡ğ‘ ğ‘œğ‘ğ‘˜ğ‘œğ‘ğ‘¡(2) for detecting a timeout.
â€¢ You need to build your own protocol, as Reliable UDP isnâ€™t a standard protocol (see a
draft of RUDP in this link), and no official header is provided. You can use this sketch
for a header, but you can come up with your own protocol, as long as it works.
Where:
o ğ‘³ğ’†ğ’ğ’ˆğ’•ğ’‰ is the length of the data itself, without the RUDP header.
o ğ‘ªğ’‰ğ’†ğ’„ğ’Œğ’”ğ’–ğ’ is a 16bit number that validates the correctness of the data.
o ğ‘­ğ’ğ’‚ğ’ˆğ’” is a special byte where we classify the packet itself (SYN, ACK, etc.).
â€¢ In your PDF, you must explain how your implementation of RUDP works â€“ How does
it detect a timeout to do retransmissions, how does the handshake work, what is the
header overhead, etc.
â€¢ For this part, youâ€™ll write three files: ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¨ğ‘·ğ‘°. ğ’„, ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and
ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
Reliable UDP Header proposed sketch
Byte 0 Byte 1 Byte 2 Byte 3
Length (2 Bytes) Checksum (2 Bytes)
Flags (1 Byte)
Figure 1 - RUDP Protocol Architecture, Geeksforgeeks
 Communication Networks Course
Page | 5
Notes:
â€¢ The Sender will send a random generated file and the Receiver will receive it and
measure the time it took for his program to receive the file. The file size should be at
least 2MB.
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). But, as the
RUDP is based on UDP, itâ€™s not reliable. You must use some form of error checking
(like checksum) to ensure that the packet wasnâ€™t alerted during the transfer.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
â€¢ The RUDP needs support only 1 sender and 1 receiver, for simplicity purposes.
Usage:
â€¢ Receiver:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
â€¢ Sender:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port that both the Sender and the Receiver will use.
The ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„ file will contain all the implementations of the RUDP API functions (That is, to
prevent reusing the same chuck of code both in the Sender and the Receiver.).
The API should support at the bare minimum the following functions (you decide what
parameters to implement, and what are the names of the functions, as long as the API is
explained in the PDF):
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘œğ‘ğ‘˜ğ‘’ğ‘¡() â€“ Creating a RUDP socket and creating a handshake between two
peers.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘’ğ‘›ğ‘‘() â€“ Sending data to the peer. The function should wait for an
acknowledgment packet, and if it didnâ€™t receive any, retransmits the data.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘Ÿğ‘’ğ‘ğ‘£() â€“ Receive data from a peer.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ğ‘™ğ‘œğ‘ ğ‘’() â€“ Closes a connection between peers.
 Communication Networks Course
Page | 6
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a UDP socket between the Sender and the
Receiver.
3) Send the file via the RUDP protocol.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a UDP connection between the Receiver and
the Sender.
2) Get a connection from the sender, by the custom
RUDP protocol youâ€™ve built.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./RUDP_Receiver -p 1234
Starting Receiver...
Waiting for RUDP connection...
Connection request received, sending ACK.
Sender connected, beginning to receive file...
File transfer completed.
ACK sent.
Waiting for Sender response...
Sender sent exit message.
ACK sent.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 7
Part C â€“ Research â€“ 30 points
In this part, youâ€™ll conduct research about your implementations of part A and part B.
In the research itself, each one of the versions (TCP version and UDP version) will be run at
least 5 times (meaning that the file transfer will occur at least 5 times) by the following
conditions:
â€¢ For TCP, youâ€™ll run it in TCP Reno and TCP Cubic, alternating each time, for each
scenario, meaning that you run 5 times with TCP Reno in both Sender and Receiver,
and 5 times with TCP Cubic in both Sender and Receiver.
Bonus (5 points): Create a very large data set â€“ 5 times with TCP Reno in both Sender
and Receiver, 5 times with TCP Reno in Sender and TCP Cubic in Receiver, 5 times
with TCP Cubic in Sender and TCP Reno in Receiver, and 5 times with TCP Cubic in
both Sender and Receiver. This will give you a data set large enough, which allows
you to work with, compare with and to reach a definite conclusion.
â€¢ For RUDP, you will run it 5 times for each scenario.
â€¢ For both TCP and RUDP, you will run them on those scenarios of packet loss:
o 0% packet loss â€“ Control group, simulating perfect connection.
o 2% packet loss â€“ Simulating unstable connection that commonly occur.
o 5% packet loss â€“ Simulating bad connection.
o 10% packet loss â€“ Simulating extremely poor connection.
For each scenario, you must provide a filtered PCAP file and relevant screenshots that
explain each one of the steps in the process. (10 points)
After youâ€™ve gathered the data set for both TCP and Reliable UDP, answer the following
questions:
1) In TCP, which congestion control algorithm gave better results overall? TCP Reno or
TCP Cubic? Which one gave better results on high packet loss? Explain how you came
to this conclusion based on the data set youâ€™ve gathered. (5 points)
2) How did your implementation of Reliable UDP perform overall compared to regular
TCP? Which one is better for high packet loss? (5 points)
3) According to the data youâ€™ve gathered, in which scenarios and applications would we
prefer to use TCP and in which situations would we prefer to use reliable UDP?
Explain your answer. (5 points)
 Communication Networks Course
Page | 8
×¢× ×• ×¢×œ ×”×©××œ×•×ª ×”×‘××•×ª )5 × ×§×•×“×•×ª(:
â— ×‘"×¨×©×ª ×××™× ×”" ×”×›×•×•× ×” ×”×™× ×œ×¨×©×ª ×©×‘×” ××¢×˜ ×××•×“ ×—×‘×™×œ×•×ª ×”×•×œ×›×•×ª ×œ××™×‘×•×“. ×‘"×§×©×¨ ××¨×•×š" ×”×›×•×•× ×” ×”×™×
×œ×§×©×¨ TCP ×©×™×© ×‘×• ×”×¨×‘×” ×××•×“ ××™×“×¢ ×œ×©×œ×•×—. ××•×¦×¢ ×œ×”×’×“×™×œ ×‘ -TCP ××ª SSThreshold ×‘×ª×—×™×œ×ª ×”×§×©×¨.
×‘××™×–×” ××”××§×¨×™× ×”×‘××™× ×”×©×™× ×•×™ ×”×–×” ×¢×©×•×™ ×œ×”×•×¢×™×œ ×‘××™×“×” ×”××™×¨×‘×™×ª? × ××§.
.1 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
.2 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.3 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.4 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.5 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.6 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.7 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.8 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
â— A ×©×•×œ×— ×œ -B ×—×‘×™×œ×•×ª ××™×“×¢ ×‘×××¦×¢×•×ª ×§×©×¨ TCP. × ×ª×•×Ÿ ×›×™ ×”×§×©×¨ ××ª×—×™×œ ×¢× ×—×œ×•×Ÿ ×‘×’×•×“×œ 1MSS. ×”×§×©×¨
××¡×ª×™×™× ×‘×¤×¢× ×”×¨××©×•× ×” ×©×”×•× ××’×™×¢ ×œ -SSthresh. ×‘××”×œ×š ×”×§×©×¨ ×œ× ××•×‘×“×•×ª ×—×‘×™×œ×•×ª. × ×¡××Ÿ ×‘×§×™×¦×•×¨:
.SSthresh=S*MSS
× ×ª×•×Ÿ ×›×™ ×œ××•×¨×š ×›×œ ×”×§×©×¨ rwnd < MSS*S.
××”×™ ×”×ª×¤×•×§×” ×©×œ ×”×§×©×¨ ×-A ×œ-B( ×‘ -sec / Bytes )×‘×–××Ÿ ×”× "×œ? × ××§×™.
]S*MSS / [lg (S) * RTT*2 ×‘×¢×¨×š .1
]S*MSS / [S^0.5 * RTT*2 ×‘×¢×¨×š .2
S*MSS / RTT ×‘×¢×¨×š .3
S^2)*MSS / RTT( ×‘×¢×¨×š .4
â— ×©×ª×™ ×ª×—× ×•×ª ××ª×§×©×¨×•×ª ×‘××•×¤×Ÿ ××œ×—×•×˜×™ ×‘×©×™×˜×ª N Back Go.
× ×¡××Ÿ ×‘-X ××ª ×¡×¤×¨×ª ×”×‘×™×§×•×¨×ª ×©×œ ×”×ª.×–. ×©×œ×š. ×× ×©× ×™ ×©×•×ª×¤×™× ××’×™×©×™× ××ª ×”×ª×¨×’×™×œ ×™×—×“, X ×”×•× ×¡×¤×¨×ª
×”×‘×™×§×•×¨×ª ×‘×¢×œ×ª ×”×¢×¨×š ×”× ××•×š ×™×•×ª×¨ ××‘×™×Ÿ ×”×©×ª×™×™×.
×§×¦×‘ ×”×ª×§×©×•×¨×ª ×”×•× 8Gbps, ×•×’×•×“×œ ×›×œ ×—×‘×™×œ×” ×”×•× KByte*X. ×’×“×œ×™ ×”-headers ×•×” -Acks ×–× ×™×—×™×.
ï¿½ğ‘’ğ‘ ï¿½/ï¿½ï¿½ 8 , ×•×”××¨×—×§ ×‘×™×Ÿ ×”×ª×—× ×•×ª ×”×•× 1Km. ×§×¦×‘ ×”×”×ª×¤×©×˜×•×ª ×”×•× 10 â‹… 2
×–××Ÿ ×¢×™×‘×•×“ ×”× ×ª×•× ×™× ×‘×ª×—× ×•×ª ×–× ×™×—.
××£ ×—×‘×™×œ×” ×•××£ Ack ×œ× ×”×•×œ×›×™× ×œ××™×‘×•×“.
â— ××”×• X ×©×œ×š?
â— ××” ×¦×¨×™×š ×œ×”×™×•×ª ×’×•×“×œ ×—×œ×•×Ÿ ×”××©×œ×•×— ×›×“×™ ×œ×”×‘×˜×™×— ×ª×¤×•×§×” ××§×¡×™××œ×™×ª?
 Communication Networks Course
Page | 9
Bonus â€“ Improving the Reliable UDP â€“ 15 points
Note: This part isnâ€™t mandatory and is a bonus only!
In this part, youâ€™ll improve your RUDP implementation by adding the concepts of flow
control and congestion control from TCP. Youâ€™re free to choose which algorithms to
implement, as long as you explain in your PDF which algorithms youâ€™ve used. Youâ€™ll probably
need to make changes in the original design of the RUDP. Changes only need to be to the API
itself, ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„.
Points distribution:
â€¢ Flow control improvement â€“ 7 Points
â€¢ Congestion control improvement â€“ 8 points.
Guidance:
â€¢ For flow control, you must use one of the Sliding window techniques: stop-and-wait
ARQ, Go-Back-N or Selective repeat.
â€¢ List of known TCP congestion control algorithms, which you can use any one of them
for this bonus task, or makeup your own:
Figure 2 â€“ List of known TCP congestion control algorithms, Wikipedia
 Communication Networks Course
Page | 10
Appendix A â€“ Linux local packet loss tool
To simulate a packet loss in a local network, we'll use a Linux tool that's called Linux Traffic
Control (ğ‘¡ğ‘). This requires a full Linux installation, so working with WSL won't work.
If the tool isn't installed in your machine, you can install it by using the following commands:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’
If the installation didn't work, you can use the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’2
To create a packet loss scenario, type the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘ğ‘‘ğ‘‘ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
After creating a packet loss scenario, you can change the percentage by typing the following
command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘â„ğ‘ğ‘›ğ‘”ğ‘’ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
To remove the packet loss scenario, write the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘‘ğ‘’ğ‘™ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š
 Communication Networks Course
Page | 11
Appendix B â€“ ğ’ğ’‚ğ’(ğŸ) system calls
This appendixâ€™s purpose is to give you a better understanding of socket handling in C.
A recommended reference is Beejâ€™s Guide to Network Programming, by Brian â€œBeej
Jorgensenâ€ Hall, which gives a lot of information about sockets in C and functions.
Functions and documentation links:
â€¢ ğ’”ğ’ğ’„ğ’Œğ’†ğ’•(ğŸ) â€“ A Factory method system call that creates a socket with the given
parameters.
â€¢ ğ’ƒğ’Šğ’ğ’…(ğŸ) â€“ Whenever we create a new socket, we need to bind it to a specific port in
our machine, â€œto catch a portâ€. The port number is managed and used by the kernel
to link incoming packets to the corresponding application socket. The port numbers
are usually fixed. The ğ‘ğ‘‘ğ‘‘ğ‘Ÿ parameter must match the current socket that is used.
â€¢ ğ’ğ’Šğ’”ğ’•ğ’†ğ’(ğŸ) â€“ The ğ‘™ğ‘–ğ‘ ğ‘¡ğ‘’ğ‘›(2) system call doesn't do anything in the mean of
communication but only memory allocation (malloc) for stream sockets only. If we
won't allocate memory, any incoming connection will fail.
â€¢ ğ’„ğ’ğ’ğ’ğ’†ğ’„ğ’•(ğŸ) â€“ The ğ‘ğ‘œğ‘›ğ‘›ğ‘’ğ‘ğ‘¡(2) system call starts the link between a client and a
specific IP address and port number. The connection would complete when the
other side will call the ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call.
â€¢ ğ’‚ğ’„ğ’„ğ’†ğ’‘ğ’•(ğŸ) â€“ The ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call accepts the incoming stream connection
request from the other side, by the listening socket. This system call completes the
three-way handshake of stream socket (like TCP) and opens a new socket that has a
direct communication channel only with the other party in the handshake.
â€¢ ğ’”ğ’†ğ’ğ’…(ğŸ) and ğ’”ğ’†ğ’ğ’…ğ’•ğ’(ğŸ) â€“ The ğ‘ ğ‘’ğ‘›ğ‘‘(2) and ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system calls are an analogy
for the ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’(2) system call, specifcly for sockets, with flags set to 0. Those system
calls return the number of bytes that were sent through the socket itself, as the
number of bytes can vary. The ğ‘ ğ‘’ğ‘›ğ‘‘(2)system call designed for stream sockets (like
TCP), while the ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system call designed for datagram connection-less
sockets (like UDP). When the ğ‘ ğ‘’ğ‘›ğ‘‘(2) system call returns 0, it means that the other
party closed the connection.
â€¢ ğ’“ğ’†ğ’„ğ’—(ğŸ) and ğ’“ğ’†ğ’„ğ’—ğ’‡ğ’“ğ’ğ’(ğŸ) â€“ The ğ‘Ÿğ‘’ğ‘ğ‘£(2) and ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system calls are an
analogy for the ğ‘Ÿğ‘’ğ‘ğ‘‘(2) system call, specifically for sockets, with flags set to 0.
Those system calls return the number of bytes that were received through the socket
itself, as the number of bytes can vary. The ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call designed for stream
sockets (like TCP), while the ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system call designed for datagram
connection-less sockets (like UDP). When the ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call returns 0, it means
that the other party closed the connection.
â€¢ ğ’„ğ’ğ’ğ’”ğ’†(ğŸ) and ğ’”ğ’‰ğ’–ğ’•ğ’…ğ’ğ’˜ğ’(ğŸ) â€“ The ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) and ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2) system calls close
the socket. While ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) system call closes the whole socket, the ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2)
system call partially closes the socket for read/write.
 Communication Networks Course
Page | 12
Appendix C â€“ Random data generator
The data that you are going to send in this assignment is randomly generated. You can use
your own file with appropriate size or use the following function (or a function of your own)
to generate the data:
/*
* @brief A random data generator function based on srand() and rand().
* @param size The size of the data to generate (up to 2^32 bytes).
* @return A pointer to the buffer.
*/
char *util_generate_random_data(unsigned int size) {
 char *buffer = NULL;
 // Argument check.
 if (size == 0)
 return NULL;
 buffer = (char *)calloc(size, sizeof(char));
 // Error checking.
 if (buffer == NULL)
 return NULL;
 // Randomize the seed of the random number generator.
 srand(time(NULL));
 for (unsigned int i = 0; i < size; i++)
 *(buffer + i) = ((unsigned int)rand() % 256);
 return buffer;
}
 Communication Networks Course
Page | 13
Appendix D â€“ Checksum function
A checksum is a small-sized block of data derived from another block of digital data for the
purpose of detecting errors that may have been introduced during its transmission or
storage. By themselves, checksums are often used to verify data integrity but are not relied
upon to verify data authenticity.
Below is a simple yet efficient implementation of the checksum function, you can use it for
the assignment, but you can implement your own checksum function.
/*
* @brief A checksum function that returns 16 bit checksum for data.
* @param data The data to do the checksum for.
* @param bytes The length of the data in bytes.
* @return The checksum itself as 16 bit unsigned number.
* @note This function is taken from RFC1071, can be found here:
* @note https://tools.ietf.org/html/rfc1071
* @note It is the simplest way to calculate a checksum and is not very strong.
* However, it is good enough for this assignment.
* @note You are free to use any other checksum function as well.
* You can also use this function as such without any change.
*/
unsigned short int calculate_checksum(void *data, unsigned int bytes) {
 unsigned short int *data_pointer = (unsigned short int *)data;
 unsigned int total_sum = 0;
 // Main summing loop
 while (bytes > 1) {
 total_sum += *data_pointer++;
 bytes -= 2;
 }
 // Add left-over byte, if any
 if (bytes > 0)
 total_sum += *((unsigned char *)data_pointer);
 // Fold 32-bit sum to 16 bits
 while (total_sum >> 16)
 total_sum = (total_sum & 0xFFFF) + (total_sum >> 16);
 return (~((unsigned short int)total_sum));
} Communication Networks Course
Page | 1
Assignment 3 â€“ Transport Layer
Assignment Notes and Instructions
This assignment is to be done in pairs only. You must upload all the necessary files in a ZIP
file named after both of the studentâ€™s ID. For example: ğŸğŸğŸ‘ğŸ’ğŸ“ğŸ”ğŸ•ğŸ–ğŸ—_ğŸ—ğŸ–ğŸ•ğŸ”ğŸ“ğŸ’ğŸ‘ğŸğŸ. ğ’›ğ’Šğ’‘.
1) The assignment must be submitted by the date specified in the submission box.
2) All the assignment files (Code, Wireshark pcap files, PDF) must be submitted in a ZIP file. The
PDF must contain all the necessary screenshots with a description for each one of them.
3) The assignment must be done in pairs only. In exceptional cases, you should send an email to
the course coordinator.
4) You can use any reference material available through the course Moodle website or any
material passed during the exercises.
5) You can use any reference from the web, but copying codes from websites is forbidden; this
includes codes from other GitHub repositories. A student who gets caught in the act will
automatically fail this assignment (score 0). Any website youâ€™ve used to solve the
assignment, every website you used to solve the assignment must be noted in the PDF.
6) No delays in submission without special permission. Lateness without approval will result in
failure of the assignment (score 0).
7) All submissions will be submitted via the course's Moodle website. Email submissions will not
be accepted, resulting in a failure in the assignment.
8) The order and design of the code must be carefully considered. Make sure that the program
output is as clear as possible, comments in the code, and meaningful variable names. You
must also submit a makefile that compiles all the programs.
9) The assignment code must be written in C only.
10) The assignment is personal for each pair, and you should not accept help from other people,
whether outside the university or inside it. You can contact the course staff during reception
hours for help or raise a question in the course forum. Do not transfer code sections
between students, upload solutions or parts of solutions to websites on the Internet or in
various communication groups.
11) Students who copy a solution will receive a 0 in all assignments in the course and a report will
be made to the institutional disciplinary committee.
12) All code files of the assignment are required to both compile and run properly on the Ubuntu
22.04 LTS operating system. This is the operating system where the submissions will be
tested. You mustnâ€™t code it in Windows, as it uses different API for sockets. WSL wonâ€™t work,
as the task needs a tool that works only in a fully Linux environment.
Good Luck!
 Communication Networks Course
Page | 2
Part A â€“ Transmission Control Protocol (TCP) â€“ 30 points
In this part, youâ€™ll write two program files: ğ‘»ğ‘ªğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and ğ‘»ğ‘ªğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
The Sender will send a randomly generated file and the Receiver will receive it and measure
the time it took for his program to receive the file. The file size should be at least 2MB.
When running the Sender and Receiver, they both should support two standard congestion
control algorithms: TCP Reno and TCP Cubic.
Notes:
â€¢ The main goal of this part is to get familiar with the TCP concept of sending
messages between two endpoints.
â€¢ For approaching this part of the assignment, please be sure that you are familiar
with the congestion control algorithms and how to change them using the correct
method in C (see Appendix B for more information).
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). You've
learned that TCP is reliable by design, so you can assume that all the data have been
passed correctly, and thus, no need to recheck.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
Usage:
â€¢ Receiver:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
â€¢ Sender:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port of the Receiver.
â€¢ ğ‘¨ğ‘³ğ‘®ğ‘¶ â€“ The TCP congestion control algorithm that will be used by the party
member (either ğ’“ğ’†ğ’ğ’ for TCP Reno or ğ’„ğ’–ğ’ƒğ’Šğ’„ for TCP Cubic).
 Communication Networks Course
Page | 3
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a TCP socket between the Sender and the
Receiver.
3) Send the file.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a TCP connection between the Receiver and
the Sender.
2) Get a connection from the sender.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./TCP_Receiver -p 1234 -algo reno
Starting Receiver...
Waiting for TCP connection...
Sender connected, beginning to receive file...
File transfer completed.
Waiting for Sender response...
Sender sent exit message.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 4
Part B â€“ Reliable User Datagram Protocol (Reliable UDP or RUDP) â€“ 40 points
Youâ€™ve learned that while TCP is reliable, it lacks speed and has an overhead data of 20 bytes,
compering to UDP that needs only 8 bytes of overhead data.
Reliable UDP or RUDP, is a protocol that uses the UDP protocol for a faster transmission of
data, while adding a reliability layer to it, but without adding too much overhead data like
TCP.
A simple sketch for a RUDP connection would look something like this:
Your task in this part is to implement a Reliable protocol using UDP only. For simplicity, your
implementation should only support a handshake, closing scheme, error checking,
acknowledgment of received packets, and retransmission of lost packets.
Guidance:
â€¢ You can use ğ‘ ğ‘’ğ‘¡ğ‘ ğ‘œğ‘ğ‘˜ğ‘œğ‘ğ‘¡(2) for detecting a timeout.
â€¢ You need to build your own protocol, as Reliable UDP isnâ€™t a standard protocol (see a
draft of RUDP in this link), and no official header is provided. You can use this sketch
for a header, but you can come up with your own protocol, as long as it works.
Where:
o ğ‘³ğ’†ğ’ğ’ˆğ’•ğ’‰ is the length of the data itself, without the RUDP header.
o ğ‘ªğ’‰ğ’†ğ’„ğ’Œğ’”ğ’–ğ’ is a 16bit number that validates the correctness of the data.
o ğ‘­ğ’ğ’‚ğ’ˆğ’” is a special byte where we classify the packet itself (SYN, ACK, etc.).
â€¢ In your PDF, you must explain how your implementation of RUDP works â€“ How does
it detect a timeout to do retransmissions, how does the handshake work, what is the
header overhead, etc.
â€¢ For this part, youâ€™ll write three files: ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¨ğ‘·ğ‘°. ğ’„, ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and
ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
Reliable UDP Header proposed sketch
Byte 0 Byte 1 Byte 2 Byte 3
Length (2 Bytes) Checksum (2 Bytes)
Flags (1 Byte)
Figure 1 - RUDP Protocol Architecture, Geeksforgeeks
 Communication Networks Course
Page | 5
Notes:
â€¢ The Sender will send a random generated file and the Receiver will receive it and
measure the time it took for his program to receive the file. The file size should be at
least 2MB.
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). But, as the
RUDP is based on UDP, itâ€™s not reliable. You must use some form of error checking
(like checksum) to ensure that the packet wasnâ€™t alerted during the transfer.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
â€¢ The RUDP needs support only 1 sender and 1 receiver, for simplicity purposes.
Usage:
â€¢ Receiver:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
â€¢ Sender:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port that both the Sender and the Receiver will use.
The ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„ file will contain all the implementations of the RUDP API functions (That is, to
prevent reusing the same chuck of code both in the Sender and the Receiver.).
The API should support at the bare minimum the following functions (you decide what
parameters to implement, and what are the names of the functions, as long as the API is
explained in the PDF):
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘œğ‘ğ‘˜ğ‘’ğ‘¡() â€“ Creating a RUDP socket and creating a handshake between two
peers.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘’ğ‘›ğ‘‘() â€“ Sending data to the peer. The function should wait for an
acknowledgment packet, and if it didnâ€™t receive any, retransmits the data.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘Ÿğ‘’ğ‘ğ‘£() â€“ Receive data from a peer.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ğ‘™ğ‘œğ‘ ğ‘’() â€“ Closes a connection between peers.
 Communication Networks Course
Page | 6
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a UDP socket between the Sender and the
Receiver.
3) Send the file via the RUDP protocol.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a UDP connection between the Receiver and
the Sender.
2) Get a connection from the sender, by the custom
RUDP protocol youâ€™ve built.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./RUDP_Receiver -p 1234
Starting Receiver...
Waiting for RUDP connection...
Connection request received, sending ACK.
Sender connected, beginning to receive file...
File transfer completed.
ACK sent.
Waiting for Sender response...
Sender sent exit message.
ACK sent.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 7
Part C â€“ Research â€“ 30 points
In this part, youâ€™ll conduct research about your implementations of part A and part B.
In the research itself, each one of the versions (TCP version and UDP version) will be run at
least 5 times (meaning that the file transfer will occur at least 5 times) by the following
conditions:
â€¢ For TCP, youâ€™ll run it in TCP Reno and TCP Cubic, alternating each time, for each
scenario, meaning that you run 5 times with TCP Reno in both Sender and Receiver,
and 5 times with TCP Cubic in both Sender and Receiver.
Bonus (5 points): Create a very large data set â€“ 5 times with TCP Reno in both Sender
and Receiver, 5 times with TCP Reno in Sender and TCP Cubic in Receiver, 5 times
with TCP Cubic in Sender and TCP Reno in Receiver, and 5 times with TCP Cubic in
both Sender and Receiver. This will give you a data set large enough, which allows
you to work with, compare with and to reach a definite conclusion.
â€¢ For RUDP, you will run it 5 times for each scenario.
â€¢ For both TCP and RUDP, you will run them on those scenarios of packet loss:
o 0% packet loss â€“ Control group, simulating perfect connection.
o 2% packet loss â€“ Simulating unstable connection that commonly occur.
o 5% packet loss â€“ Simulating bad connection.
o 10% packet loss â€“ Simulating extremely poor connection.
For each scenario, you must provide a filtered PCAP file and relevant screenshots that
explain each one of the steps in the process. (10 points)
After youâ€™ve gathered the data set for both TCP and Reliable UDP, answer the following
questions:
1) In TCP, which congestion control algorithm gave better results overall? TCP Reno or
TCP Cubic? Which one gave better results on high packet loss? Explain how you came
to this conclusion based on the data set youâ€™ve gathered. (5 points)
2) How did your implementation of Reliable UDP perform overall compared to regular
TCP? Which one is better for high packet loss? (5 points)
3) According to the data youâ€™ve gathered, in which scenarios and applications would we
prefer to use TCP and in which situations would we prefer to use reliable UDP?
Explain your answer. (5 points)
 Communication Networks Course
Page | 8
×¢× ×• ×¢×œ ×”×©××œ×•×ª ×”×‘××•×ª )5 × ×§×•×“×•×ª(:
â— ×‘"×¨×©×ª ×××™× ×”" ×”×›×•×•× ×” ×”×™× ×œ×¨×©×ª ×©×‘×” ××¢×˜ ×××•×“ ×—×‘×™×œ×•×ª ×”×•×œ×›×•×ª ×œ××™×‘×•×“. ×‘"×§×©×¨ ××¨×•×š" ×”×›×•×•× ×” ×”×™×
×œ×§×©×¨ TCP ×©×™×© ×‘×• ×”×¨×‘×” ×××•×“ ××™×“×¢ ×œ×©×œ×•×—. ××•×¦×¢ ×œ×”×’×“×™×œ ×‘ -TCP ××ª SSThreshold ×‘×ª×—×™×œ×ª ×”×§×©×¨.
×‘××™×–×” ××”××§×¨×™× ×”×‘××™× ×”×©×™× ×•×™ ×”×–×” ×¢×©×•×™ ×œ×”×•×¢×™×œ ×‘××™×“×” ×”××™×¨×‘×™×ª? × ××§.
.1 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
.2 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.3 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.4 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.5 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.6 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.7 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.8 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
â— A ×©×•×œ×— ×œ -B ×—×‘×™×œ×•×ª ××™×“×¢ ×‘×××¦×¢×•×ª ×§×©×¨ TCP. × ×ª×•×Ÿ ×›×™ ×”×§×©×¨ ××ª×—×™×œ ×¢× ×—×œ×•×Ÿ ×‘×’×•×“×œ 1MSS. ×”×§×©×¨
××¡×ª×™×™× ×‘×¤×¢× ×”×¨××©×•× ×” ×©×”×•× ××’×™×¢ ×œ -SSthresh. ×‘××”×œ×š ×”×§×©×¨ ×œ× ××•×‘×“×•×ª ×—×‘×™×œ×•×ª. × ×¡××Ÿ ×‘×§×™×¦×•×¨:
.SSthresh=S*MSS
× ×ª×•×Ÿ ×›×™ ×œ××•×¨×š ×›×œ ×”×§×©×¨ rwnd < MSS*S.
××”×™ ×”×ª×¤×•×§×” ×©×œ ×”×§×©×¨ ×-A ×œ-B( ×‘ -sec / Bytes )×‘×–××Ÿ ×”× "×œ? × ××§×™.
]S*MSS / [lg (S) * RTT*2 ×‘×¢×¨×š .1
]S*MSS / [S^0.5 * RTT*2 ×‘×¢×¨×š .2
S*MSS / RTT ×‘×¢×¨×š .3
S^2)*MSS / RTT( ×‘×¢×¨×š .4
â— ×©×ª×™ ×ª×—× ×•×ª ××ª×§×©×¨×•×ª ×‘××•×¤×Ÿ ××œ×—×•×˜×™ ×‘×©×™×˜×ª N Back Go.
× ×¡××Ÿ ×‘-X ××ª ×¡×¤×¨×ª ×”×‘×™×§×•×¨×ª ×©×œ ×”×ª.×–. ×©×œ×š. ×× ×©× ×™ ×©×•×ª×¤×™× ××’×™×©×™× ××ª ×”×ª×¨×’×™×œ ×™×—×“, X ×”×•× ×¡×¤×¨×ª
×”×‘×™×§×•×¨×ª ×‘×¢×œ×ª ×”×¢×¨×š ×”× ××•×š ×™×•×ª×¨ ××‘×™×Ÿ ×”×©×ª×™×™×.
×§×¦×‘ ×”×ª×§×©×•×¨×ª ×”×•× 8Gbps, ×•×’×•×“×œ ×›×œ ×—×‘×™×œ×” ×”×•× KByte*X. ×’×“×œ×™ ×”-headers ×•×” -Acks ×–× ×™×—×™×.
ï¿½ğ‘’ğ‘ ï¿½/ï¿½ï¿½ 8 , ×•×”××¨×—×§ ×‘×™×Ÿ ×”×ª×—× ×•×ª ×”×•× 1Km. ×§×¦×‘ ×”×”×ª×¤×©×˜×•×ª ×”×•× 10 â‹… 2
×–××Ÿ ×¢×™×‘×•×“ ×”× ×ª×•× ×™× ×‘×ª×—× ×•×ª ×–× ×™×—.
××£ ×—×‘×™×œ×” ×•××£ Ack ×œ× ×”×•×œ×›×™× ×œ××™×‘×•×“.
â— ××”×• X ×©×œ×š?
â— ××” ×¦×¨×™×š ×œ×”×™×•×ª ×’×•×“×œ ×—×œ×•×Ÿ ×”××©×œ×•×— ×›×“×™ ×œ×”×‘×˜×™×— ×ª×¤×•×§×” ××§×¡×™××œ×™×ª?
 Communication Networks Course
Page | 9
Bonus â€“ Improving the Reliable UDP â€“ 15 points
Note: This part isnâ€™t mandatory and is a bonus only!
In this part, youâ€™ll improve your RUDP implementation by adding the concepts of flow
control and congestion control from TCP. Youâ€™re free to choose which algorithms to
implement, as long as you explain in your PDF which algorithms youâ€™ve used. Youâ€™ll probably
need to make changes in the original design of the RUDP. Changes only need to be to the API
itself, ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„.
Points distribution:
â€¢ Flow control improvement â€“ 7 Points
â€¢ Congestion control improvement â€“ 8 points.
Guidance:
â€¢ For flow control, you must use one of the Sliding window techniques: stop-and-wait
ARQ, Go-Back-N or Selective repeat.
â€¢ List of known TCP congestion control algorithms, which you can use any one of them
for this bonus task, or makeup your own:
Figure 2 â€“ List of known TCP congestion control algorithms, Wikipedia
 Communication Networks Course
Page | 10
Appendix A â€“ Linux local packet loss tool
To simulate a packet loss in a local network, we'll use a Linux tool that's called Linux Traffic
Control (ğ‘¡ğ‘). This requires a full Linux installation, so working with WSL won't work.
If the tool isn't installed in your machine, you can install it by using the following commands:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’
If the installation didn't work, you can use the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’2
To create a packet loss scenario, type the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘ğ‘‘ğ‘‘ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
After creating a packet loss scenario, you can change the percentage by typing the following
command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘â„ğ‘ğ‘›ğ‘”ğ‘’ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
To remove the packet loss scenario, write the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘‘ğ‘’ğ‘™ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š
 Communication Networks Course
Page | 11
Appendix B â€“ ğ’ğ’‚ğ’(ğŸ) system calls
This appendixâ€™s purpose is to give you a better understanding of socket handling in C.
A recommended reference is Beejâ€™s Guide to Network Programming, by Brian â€œBeej
Jorgensenâ€ Hall, which gives a lot of information about sockets in C and functions.
Functions and documentation links:
â€¢ ğ’”ğ’ğ’„ğ’Œğ’†ğ’•(ğŸ) â€“ A Factory method system call that creates a socket with the given
parameters.
â€¢ ğ’ƒğ’Šğ’ğ’…(ğŸ) â€“ Whenever we create a new socket, we need to bind it to a specific port in
our machine, â€œto catch a portâ€. The port number is managed and used by the kernel
to link incoming packets to the corresponding application socket. The port numbers
are usually fixed. The ğ‘ğ‘‘ğ‘‘ğ‘Ÿ parameter must match the current socket that is used.
â€¢ ğ’ğ’Šğ’”ğ’•ğ’†ğ’(ğŸ) â€“ The ğ‘™ğ‘–ğ‘ ğ‘¡ğ‘’ğ‘›(2) system call doesn't do anything in the mean of
communication but only memory allocation (malloc) for stream sockets only. If we
won't allocate memory, any incoming connection will fail.
â€¢ ğ’„ğ’ğ’ğ’ğ’†ğ’„ğ’•(ğŸ) â€“ The ğ‘ğ‘œğ‘›ğ‘›ğ‘’ğ‘ğ‘¡(2) system call starts the link between a client and a
specific IP address and port number. The connection would complete when the
other side will call the ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call.
â€¢ ğ’‚ğ’„ğ’„ğ’†ğ’‘ğ’•(ğŸ) â€“ The ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call accepts the incoming stream connection
request from the other side, by the listening socket. This system call completes the
three-way handshake of stream socket (like TCP) and opens a new socket that has a
direct communication channel only with the other party in the handshake.
â€¢ ğ’”ğ’†ğ’ğ’…(ğŸ) and ğ’”ğ’†ğ’ğ’…ğ’•ğ’(ğŸ) â€“ The ğ‘ ğ‘’ğ‘›ğ‘‘(2) and ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system calls are an analogy
for the ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’(2) system call, specifcly for sockets, with flags set to 0. Those system
calls return the number of bytes that were sent through the socket itself, as the
number of bytes can vary. The ğ‘ ğ‘’ğ‘›ğ‘‘(2)system call designed for stream sockets (like
TCP), while the ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system call designed for datagram connection-less
sockets (like UDP). When the ğ‘ ğ‘’ğ‘›ğ‘‘(2) system call returns 0, it means that the other
party closed the connection.
â€¢ ğ’“ğ’†ğ’„ğ’—(ğŸ) and ğ’“ğ’†ğ’„ğ’—ğ’‡ğ’“ğ’ğ’(ğŸ) â€“ The ğ‘Ÿğ‘’ğ‘ğ‘£(2) and ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system calls are an
analogy for the ğ‘Ÿğ‘’ğ‘ğ‘‘(2) system call, specifically for sockets, with flags set to 0.
Those system calls return the number of bytes that were received through the socket
itself, as the number of bytes can vary. The ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call designed for stream
sockets (like TCP), while the ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system call designed for datagram
connection-less sockets (like UDP). When the ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call returns 0, it means
that the other party closed the connection.
â€¢ ğ’„ğ’ğ’ğ’”ğ’†(ğŸ) and ğ’”ğ’‰ğ’–ğ’•ğ’…ğ’ğ’˜ğ’(ğŸ) â€“ The ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) and ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2) system calls close
the socket. While ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) system call closes the whole socket, the ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2)
system call partially closes the socket for read/write.
 Communication Networks Course
Page | 12
Appendix C â€“ Random data generator
The data that you are going to send in this assignment is randomly generated. You can use
your own file with appropriate size or use the following function (or a function of your own)
to generate the data:
/*
* @brief A random data generator function based on srand() and rand().
* @param size The size of the data to generate (up to 2^32 bytes).
* @return A pointer to the buffer.
*/
char *util_generate_random_data(unsigned int size) {
 char *buffer = NULL;
 // Argument check.
 if (size == 0)
 return NULL;
 buffer = (char *)calloc(size, sizeof(char));
 // Error checking.
 if (buffer == NULL)
 return NULL;
 // Randomize the seed of the random number generator.
 srand(time(NULL));
 for (unsigned int i = 0; i < size; i++)
 *(buffer + i) = ((unsigned int)rand() % 256);
 return buffer;
}
 Communication Networks Course
Page | 13
Appendix D â€“ Checksum function
A checksum is a small-sized block of data derived from another block of digital data for the
purpose of detecting errors that may have been introduced during its transmission or
storage. By themselves, checksums are often used to verify data integrity but are not relied
upon to verify data authenticity.
Below is a simple yet efficient implementation of the checksum function, you can use it for
the assignment, but you can implement your own checksum function.
/*
* @brief A checksum function that returns 16 bit checksum for data.
* @param data The data to do the checksum for.
* @param bytes The length of the data in bytes.
* @return The checksum itself as 16 bit unsigned number.
* @note This function is taken from RFC1071, can be found here:
* @note https://tools.ietf.org/html/rfc1071
* @note It is the simplest way to calculate a checksum and is not very strong.
* However, it is good enough for this assignment.
* @note You are free to use any other checksum function as well.
* You can also use this function as such without any change.
*/
unsigned short int calculate_checksum(void *data, unsigned int bytes) {
 unsigned short int *data_pointer = (unsigned short int *)data;
 unsigned int total_sum = 0;
 // Main summing loop
 while (bytes > 1) {
 total_sum += *data_pointer++;
 bytes -= 2;
 }
 // Add left-over byte, if any
 if (bytes > 0)
 total_sum += *((unsigned char *)data_pointer);
 // Fold 32-bit sum to 16 bits
 while (total_sum >> 16)
 total_sum = (total_sum & 0xFFFF) + (total_sum >> 16);
 return (~((unsigned short int)total_sum));
} Communication Networks Course
Page | 1
Assignment 3 â€“ Transport Layer
Assignment Notes and Instructions
This assignment is to be done in pairs only. You must upload all the necessary files in a ZIP
file named after both of the studentâ€™s ID. For example: ğŸğŸğŸ‘ğŸ’ğŸ“ğŸ”ğŸ•ğŸ–ğŸ—_ğŸ—ğŸ–ğŸ•ğŸ”ğŸ“ğŸ’ğŸ‘ğŸğŸ. ğ’›ğ’Šğ’‘.
1) The assignment must be submitted by the date specified in the submission box.
2) All the assignment files (Code, Wireshark pcap files, PDF) must be submitted in a ZIP file. The
PDF must contain all the necessary screenshots with a description for each one of them.
3) The assignment must be done in pairs only. In exceptional cases, you should send an email to
the course coordinator.
4) You can use any reference material available through the course Moodle website or any
material passed during the exercises.
5) You can use any reference from the web, but copying codes from websites is forbidden; this
includes codes from other GitHub repositories. A student who gets caught in the act will
automatically fail this assignment (score 0). Any website youâ€™ve used to solve the
assignment, every website you used to solve the assignment must be noted in the PDF.
6) No delays in submission without special permission. Lateness without approval will result in
failure of the assignment (score 0).
7) All submissions will be submitted via the course's Moodle website. Email submissions will not
be accepted, resulting in a failure in the assignment.
8) The order and design of the code must be carefully considered. Make sure that the program
output is as clear as possible, comments in the code, and meaningful variable names. You
must also submit a makefile that compiles all the programs.
9) The assignment code must be written in C only.
10) The assignment is personal for each pair, and you should not accept help from other people,
whether outside the university or inside it. You can contact the course staff during reception
hours for help or raise a question in the course forum. Do not transfer code sections
between students, upload solutions or parts of solutions to websites on the Internet or in
various communication groups.
11) Students who copy a solution will receive a 0 in all assignments in the course and a report will
be made to the institutional disciplinary committee.
12) All code files of the assignment are required to both compile and run properly on the Ubuntu
22.04 LTS operating system. This is the operating system where the submissions will be
tested. You mustnâ€™t code it in Windows, as it uses different API for sockets. WSL wonâ€™t work,
as the task needs a tool that works only in a fully Linux environment.
Good Luck!
 Communication Networks Course
Page | 2
Part A â€“ Transmission Control Protocol (TCP) â€“ 30 points
In this part, youâ€™ll write two program files: ğ‘»ğ‘ªğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and ğ‘»ğ‘ªğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
The Sender will send a randomly generated file and the Receiver will receive it and measure
the time it took for his program to receive the file. The file size should be at least 2MB.
When running the Sender and Receiver, they both should support two standard congestion
control algorithms: TCP Reno and TCP Cubic.
Notes:
â€¢ The main goal of this part is to get familiar with the TCP concept of sending
messages between two endpoints.
â€¢ For approaching this part of the assignment, please be sure that you are familiar
with the congestion control algorithms and how to change them using the correct
method in C (see Appendix B for more information).
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). You've
learned that TCP is reliable by design, so you can assume that all the data have been
passed correctly, and thus, no need to recheck.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
Usage:
â€¢ Receiver:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
â€¢ Sender:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port of the Receiver.
â€¢ ğ‘¨ğ‘³ğ‘®ğ‘¶ â€“ The TCP congestion control algorithm that will be used by the party
member (either ğ’“ğ’†ğ’ğ’ for TCP Reno or ğ’„ğ’–ğ’ƒğ’Šğ’„ for TCP Cubic).
 Communication Networks Course
Page | 3
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a TCP socket between the Sender and the
Receiver.
3) Send the file.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a TCP connection between the Receiver and
the Sender.
2) Get a connection from the sender.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./TCP_Receiver -p 1234 -algo reno
Starting Receiver...
Waiting for TCP connection...
Sender connected, beginning to receive file...
File transfer completed.
Waiting for Sender response...
Sender sent exit message.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 4
Part B â€“ Reliable User Datagram Protocol (Reliable UDP or RUDP) â€“ 40 points
Youâ€™ve learned that while TCP is reliable, it lacks speed and has an overhead data of 20 bytes,
compering to UDP that needs only 8 bytes of overhead data.
Reliable UDP or RUDP, is a protocol that uses the UDP protocol for a faster transmission of
data, while adding a reliability layer to it, but without adding too much overhead data like
TCP.
A simple sketch for a RUDP connection would look something like this:
Your task in this part is to implement a Reliable protocol using UDP only. For simplicity, your
implementation should only support a handshake, closing scheme, error checking,
acknowledgment of received packets, and retransmission of lost packets.
Guidance:
â€¢ You can use ğ‘ ğ‘’ğ‘¡ğ‘ ğ‘œğ‘ğ‘˜ğ‘œğ‘ğ‘¡(2) for detecting a timeout.
â€¢ You need to build your own protocol, as Reliable UDP isnâ€™t a standard protocol (see a
draft of RUDP in this link), and no official header is provided. You can use this sketch
for a header, but you can come up with your own protocol, as long as it works.
Where:
o ğ‘³ğ’†ğ’ğ’ˆğ’•ğ’‰ is the length of the data itself, without the RUDP header.
o ğ‘ªğ’‰ğ’†ğ’„ğ’Œğ’”ğ’–ğ’ is a 16bit number that validates the correctness of the data.
o ğ‘­ğ’ğ’‚ğ’ˆğ’” is a special byte where we classify the packet itself (SYN, ACK, etc.).
â€¢ In your PDF, you must explain how your implementation of RUDP works â€“ How does
it detect a timeout to do retransmissions, how does the handshake work, what is the
header overhead, etc.
â€¢ For this part, youâ€™ll write three files: ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¨ğ‘·ğ‘°. ğ’„, ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and
ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
Reliable UDP Header proposed sketch
Byte 0 Byte 1 Byte 2 Byte 3
Length (2 Bytes) Checksum (2 Bytes)
Flags (1 Byte)
Figure 1 - RUDP Protocol Architecture, Geeksforgeeks
 Communication Networks Course
Page | 5
Notes:
â€¢ The Sender will send a random generated file and the Receiver will receive it and
measure the time it took for his program to receive the file. The file size should be at
least 2MB.
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). But, as the
RUDP is based on UDP, itâ€™s not reliable. You must use some form of error checking
(like checksum) to ensure that the packet wasnâ€™t alerted during the transfer.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
â€¢ The RUDP needs support only 1 sender and 1 receiver, for simplicity purposes.
Usage:
â€¢ Receiver:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
â€¢ Sender:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port that both the Sender and the Receiver will use.
The ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„ file will contain all the implementations of the RUDP API functions (That is, to
prevent reusing the same chuck of code both in the Sender and the Receiver.).
The API should support at the bare minimum the following functions (you decide what
parameters to implement, and what are the names of the functions, as long as the API is
explained in the PDF):
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘œğ‘ğ‘˜ğ‘’ğ‘¡() â€“ Creating a RUDP socket and creating a handshake between two
peers.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘’ğ‘›ğ‘‘() â€“ Sending data to the peer. The function should wait for an
acknowledgment packet, and if it didnâ€™t receive any, retransmits the data.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘Ÿğ‘’ğ‘ğ‘£() â€“ Receive data from a peer.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ğ‘™ğ‘œğ‘ ğ‘’() â€“ Closes a connection between peers.
 Communication Networks Course
Page | 6
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a UDP socket between the Sender and the
Receiver.
3) Send the file via the RUDP protocol.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a UDP connection between the Receiver and
the Sender.
2) Get a connection from the sender, by the custom
RUDP protocol youâ€™ve built.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./RUDP_Receiver -p 1234
Starting Receiver...
Waiting for RUDP connection...
Connection request received, sending ACK.
Sender connected, beginning to receive file...
File transfer completed.
ACK sent.
Waiting for Sender response...
Sender sent exit message.
ACK sent.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 7
Part C â€“ Research â€“ 30 points
In this part, youâ€™ll conduct research about your implementations of part A and part B.
In the research itself, each one of the versions (TCP version and UDP version) will be run at
least 5 times (meaning that the file transfer will occur at least 5 times) by the following
conditions:
â€¢ For TCP, youâ€™ll run it in TCP Reno and TCP Cubic, alternating each time, for each
scenario, meaning that you run 5 times with TCP Reno in both Sender and Receiver,
and 5 times with TCP Cubic in both Sender and Receiver.
Bonus (5 points): Create a very large data set â€“ 5 times with TCP Reno in both Sender
and Receiver, 5 times with TCP Reno in Sender and TCP Cubic in Receiver, 5 times
with TCP Cubic in Sender and TCP Reno in Receiver, and 5 times with TCP Cubic in
both Sender and Receiver. This will give you a data set large enough, which allows
you to work with, compare with and to reach a definite conclusion.
â€¢ For RUDP, you will run it 5 times for each scenario.
â€¢ For both TCP and RUDP, you will run them on those scenarios of packet loss:
o 0% packet loss â€“ Control group, simulating perfect connection.
o 2% packet loss â€“ Simulating unstable connection that commonly occur.
o 5% packet loss â€“ Simulating bad connection.
o 10% packet loss â€“ Simulating extremely poor connection.
For each scenario, you must provide a filtered PCAP file and relevant screenshots that
explain each one of the steps in the process. (10 points)
After youâ€™ve gathered the data set for both TCP and Reliable UDP, answer the following
questions:
1) In TCP, which congestion control algorithm gave better results overall? TCP Reno or
TCP Cubic? Which one gave better results on high packet loss? Explain how you came
to this conclusion based on the data set youâ€™ve gathered. (5 points)
2) How did your implementation of Reliable UDP perform overall compared to regular
TCP? Which one is better for high packet loss? (5 points)
3) According to the data youâ€™ve gathered, in which scenarios and applications would we
prefer to use TCP and in which situations would we prefer to use reliable UDP?
Explain your answer. (5 points)
 Communication Networks Course
Page | 8
×¢× ×• ×¢×œ ×”×©××œ×•×ª ×”×‘××•×ª )5 × ×§×•×“×•×ª(:
â— ×‘"×¨×©×ª ×××™× ×”" ×”×›×•×•× ×” ×”×™× ×œ×¨×©×ª ×©×‘×” ××¢×˜ ×××•×“ ×—×‘×™×œ×•×ª ×”×•×œ×›×•×ª ×œ××™×‘×•×“. ×‘"×§×©×¨ ××¨×•×š" ×”×›×•×•× ×” ×”×™×
×œ×§×©×¨ TCP ×©×™×© ×‘×• ×”×¨×‘×” ×××•×“ ××™×“×¢ ×œ×©×œ×•×—. ××•×¦×¢ ×œ×”×’×“×™×œ ×‘ -TCP ××ª SSThreshold ×‘×ª×—×™×œ×ª ×”×§×©×¨.
×‘××™×–×” ××”××§×¨×™× ×”×‘××™× ×”×©×™× ×•×™ ×”×–×” ×¢×©×•×™ ×œ×”×•×¢×™×œ ×‘××™×“×” ×”××™×¨×‘×™×ª? × ××§.
.1 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
.2 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.3 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.4 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.5 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.6 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.7 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.8 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
â— A ×©×•×œ×— ×œ -B ×—×‘×™×œ×•×ª ××™×“×¢ ×‘×××¦×¢×•×ª ×§×©×¨ TCP. × ×ª×•×Ÿ ×›×™ ×”×§×©×¨ ××ª×—×™×œ ×¢× ×—×œ×•×Ÿ ×‘×’×•×“×œ 1MSS. ×”×§×©×¨
××¡×ª×™×™× ×‘×¤×¢× ×”×¨××©×•× ×” ×©×”×•× ××’×™×¢ ×œ -SSthresh. ×‘××”×œ×š ×”×§×©×¨ ×œ× ××•×‘×“×•×ª ×—×‘×™×œ×•×ª. × ×¡××Ÿ ×‘×§×™×¦×•×¨:
.SSthresh=S*MSS
× ×ª×•×Ÿ ×›×™ ×œ××•×¨×š ×›×œ ×”×§×©×¨ rwnd < MSS*S.
××”×™ ×”×ª×¤×•×§×” ×©×œ ×”×§×©×¨ ×-A ×œ-B( ×‘ -sec / Bytes )×‘×–××Ÿ ×”× "×œ? × ××§×™.
]S*MSS / [lg (S) * RTT*2 ×‘×¢×¨×š .1
]S*MSS / [S^0.5 * RTT*2 ×‘×¢×¨×š .2
S*MSS / RTT ×‘×¢×¨×š .3
S^2)*MSS / RTT( ×‘×¢×¨×š .4
â— ×©×ª×™ ×ª×—× ×•×ª ××ª×§×©×¨×•×ª ×‘××•×¤×Ÿ ××œ×—×•×˜×™ ×‘×©×™×˜×ª N Back Go.
× ×¡××Ÿ ×‘-X ××ª ×¡×¤×¨×ª ×”×‘×™×§×•×¨×ª ×©×œ ×”×ª.×–. ×©×œ×š. ×× ×©× ×™ ×©×•×ª×¤×™× ××’×™×©×™× ××ª ×”×ª×¨×’×™×œ ×™×—×“, X ×”×•× ×¡×¤×¨×ª
×”×‘×™×§×•×¨×ª ×‘×¢×œ×ª ×”×¢×¨×š ×”× ××•×š ×™×•×ª×¨ ××‘×™×Ÿ ×”×©×ª×™×™×.
×§×¦×‘ ×”×ª×§×©×•×¨×ª ×”×•× 8Gbps, ×•×’×•×“×œ ×›×œ ×—×‘×™×œ×” ×”×•× KByte*X. ×’×“×œ×™ ×”-headers ×•×” -Acks ×–× ×™×—×™×.
ï¿½ğ‘’ğ‘ ï¿½/ï¿½ï¿½ 8 , ×•×”××¨×—×§ ×‘×™×Ÿ ×”×ª×—× ×•×ª ×”×•× 1Km. ×§×¦×‘ ×”×”×ª×¤×©×˜×•×ª ×”×•× 10 â‹… 2
×–××Ÿ ×¢×™×‘×•×“ ×”× ×ª×•× ×™× ×‘×ª×—× ×•×ª ×–× ×™×—.
××£ ×—×‘×™×œ×” ×•××£ Ack ×œ× ×”×•×œ×›×™× ×œ××™×‘×•×“.
â— ××”×• X ×©×œ×š?
â— ××” ×¦×¨×™×š ×œ×”×™×•×ª ×’×•×“×œ ×—×œ×•×Ÿ ×”××©×œ×•×— ×›×“×™ ×œ×”×‘×˜×™×— ×ª×¤×•×§×” ××§×¡×™××œ×™×ª?
 Communication Networks Course
Page | 9
Bonus â€“ Improving the Reliable UDP â€“ 15 points
Note: This part isnâ€™t mandatory and is a bonus only!
In this part, youâ€™ll improve your RUDP implementation by adding the concepts of flow
control and congestion control from TCP. Youâ€™re free to choose which algorithms to
implement, as long as you explain in your PDF which algorithms youâ€™ve used. Youâ€™ll probably
need to make changes in the original design of the RUDP. Changes only need to be to the API
itself, ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„.
Points distribution:
â€¢ Flow control improvement â€“ 7 Points
â€¢ Congestion control improvement â€“ 8 points.
Guidance:
â€¢ For flow control, you must use one of the Sliding window techniques: stop-and-wait
ARQ, Go-Back-N or Selective repeat.
â€¢ List of known TCP congestion control algorithms, which you can use any one of them
for this bonus task, or makeup your own:
Figure 2 â€“ List of known TCP congestion control algorithms, Wikipedia
 Communication Networks Course
Page | 10
Appendix A â€“ Linux local packet loss tool
To simulate a packet loss in a local network, we'll use a Linux tool that's called Linux Traffic
Control (ğ‘¡ğ‘). This requires a full Linux installation, so working with WSL won't work.
If the tool isn't installed in your machine, you can install it by using the following commands:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’
If the installation didn't work, you can use the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’2
To create a packet loss scenario, type the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘ğ‘‘ğ‘‘ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
After creating a packet loss scenario, you can change the percentage by typing the following
command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘â„ğ‘ğ‘›ğ‘”ğ‘’ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
To remove the packet loss scenario, write the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘‘ğ‘’ğ‘™ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š
 Communication Networks Course
Page | 11
Appendix B â€“ ğ’ğ’‚ğ’(ğŸ) system calls
This appendixâ€™s purpose is to give you a better understanding of socket handling in C.
A recommended reference is Beejâ€™s Guide to Network Programming, by Brian â€œBeej
Jorgensenâ€ Hall, which gives a lot of information about sockets in C and functions.
Functions and documentation links:
â€¢ ğ’”ğ’ğ’„ğ’Œğ’†ğ’•(ğŸ) â€“ A Factory method system call that creates a socket with the given
parameters.
â€¢ ğ’ƒğ’Šğ’ğ’…(ğŸ) â€“ Whenever we create a new socket, we need to bind it to a specific port in
our machine, â€œto catch a portâ€. The port number is managed and used by the kernel
to link incoming packets to the corresponding application socket. The port numbers
are usually fixed. The ğ‘ğ‘‘ğ‘‘ğ‘Ÿ parameter must match the current socket that is used.
â€¢ ğ’ğ’Šğ’”ğ’•ğ’†ğ’(ğŸ) â€“ The ğ‘™ğ‘–ğ‘ ğ‘¡ğ‘’ğ‘›(2) system call doesn't do anything in the mean of
communication but only memory allocation (malloc) for stream sockets only. If we
won't allocate memory, any incoming connection will fail.
â€¢ ğ’„ğ’ğ’ğ’ğ’†ğ’„ğ’•(ğŸ) â€“ The ğ‘ğ‘œğ‘›ğ‘›ğ‘’ğ‘ğ‘¡(2) system call starts the link between a client and a
specific IP address and port number. The connection would complete when the
other side will call the ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call.
â€¢ ğ’‚ğ’„ğ’„ğ’†ğ’‘ğ’•(ğŸ) â€“ The ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call accepts the incoming stream connection
request from the other side, by the listening socket. This system call completes the
three-way handshake of stream socket (like TCP) and opens a new socket that has a
direct communication channel only with the other party in the handshake.
â€¢ ğ’”ğ’†ğ’ğ’…(ğŸ) and ğ’”ğ’†ğ’ğ’…ğ’•ğ’(ğŸ) â€“ The ğ‘ ğ‘’ğ‘›ğ‘‘(2) and ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system calls are an analogy
for the ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’(2) system call, specifcly for sockets, with flags set to 0. Those system
calls return the number of bytes that were sent through the socket itself, as the
number of bytes can vary. The ğ‘ ğ‘’ğ‘›ğ‘‘(2)system call designed for stream sockets (like
TCP), while the ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system call designed for datagram connection-less
sockets (like UDP). When the ğ‘ ğ‘’ğ‘›ğ‘‘(2) system call returns 0, it means that the other
party closed the connection.
â€¢ ğ’“ğ’†ğ’„ğ’—(ğŸ) and ğ’“ğ’†ğ’„ğ’—ğ’‡ğ’“ğ’ğ’(ğŸ) â€“ The ğ‘Ÿğ‘’ğ‘ğ‘£(2) and ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system calls are an
analogy for the ğ‘Ÿğ‘’ğ‘ğ‘‘(2) system call, specifically for sockets, with flags set to 0.
Those system calls return the number of bytes that were received through the socket
itself, as the number of bytes can vary. The ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call designed for stream
sockets (like TCP), while the ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system call designed for datagram
connection-less sockets (like UDP). When the ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call returns 0, it means
that the other party closed the connection.
â€¢ ğ’„ğ’ğ’ğ’”ğ’†(ğŸ) and ğ’”ğ’‰ğ’–ğ’•ğ’…ğ’ğ’˜ğ’(ğŸ) â€“ The ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) and ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2) system calls close
the socket. While ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) system call closes the whole socket, the ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2)
system call partially closes the socket for read/write.
 Communication Networks Course
Page | 12
Appendix C â€“ Random data generator
The data that you are going to send in this assignment is randomly generated. You can use
your own file with appropriate size or use the following function (or a function of your own)
to generate the data:
/*
* @brief A random data generator function based on srand() and rand().
* @param size The size of the data to generate (up to 2^32 bytes).
* @return A pointer to the buffer.
*/
char *util_generate_random_data(unsigned int size) {
 char *buffer = NULL;
 // Argument check.
 if (size == 0)
 return NULL;
 buffer = (char *)calloc(size, sizeof(char));
 // Error checking.
 if (buffer == NULL)
 return NULL;
 // Randomize the seed of the random number generator.
 srand(time(NULL));
 for (unsigned int i = 0; i < size; i++)
 *(buffer + i) = ((unsigned int)rand() % 256);
 return buffer;
}
 Communication Networks Course
Page | 13
Appendix D â€“ Checksum function
A checksum is a small-sized block of data derived from another block of digital data for the
purpose of detecting errors that may have been introduced during its transmission or
storage. By themselves, checksums are often used to verify data integrity but are not relied
upon to verify data authenticity.
Below is a simple yet efficient implementation of the checksum function, you can use it for
the assignment, but you can implement your own checksum function.
/*
* @brief A checksum function that returns 16 bit checksum for data.
* @param data The data to do the checksum for.
* @param bytes The length of the data in bytes.
* @return The checksum itself as 16 bit unsigned number.
* @note This function is taken from RFC1071, can be found here:
* @note https://tools.ietf.org/html/rfc1071
* @note It is the simplest way to calculate a checksum and is not very strong.
* However, it is good enough for this assignment.
* @note You are free to use any other checksum function as well.
* You can also use this function as such without any change.
*/
unsigned short int calculate_checksum(void *data, unsigned int bytes) {
 unsigned short int *data_pointer = (unsigned short int *)data;
 unsigned int total_sum = 0;
 // Main summing loop
 while (bytes > 1) {
 total_sum += *data_pointer++;
 bytes -= 2;
 }
 // Add left-over byte, if any
 if (bytes > 0)
 total_sum += *((unsigned char *)data_pointer);
 // Fold 32-bit sum to 16 bits
 while (total_sum >> 16)
 total_sum = (total_sum & 0xFFFF) + (total_sum >> 16);
 return (~((unsigned short int)total_sum));
} Communication Networks Course
Page | 1
Assignment 3 â€“ Transport Layer
Assignment Notes and Instructions
This assignment is to be done in pairs only. You must upload all the necessary files in a ZIP
file named after both of the studentâ€™s ID. For example: ğŸğŸğŸ‘ğŸ’ğŸ“ğŸ”ğŸ•ğŸ–ğŸ—_ğŸ—ğŸ–ğŸ•ğŸ”ğŸ“ğŸ’ğŸ‘ğŸğŸ. ğ’›ğ’Šğ’‘.
1) The assignment must be submitted by the date specified in the submission box.
2) All the assignment files (Code, Wireshark pcap files, PDF) must be submitted in a ZIP file. The
PDF must contain all the necessary screenshots with a description for each one of them.
3) The assignment must be done in pairs only. In exceptional cases, you should send an email to
the course coordinator.
4) You can use any reference material available through the course Moodle website or any
material passed during the exercises.
5) You can use any reference from the web, but copying codes from websites is forbidden; this
includes codes from other GitHub repositories. A student who gets caught in the act will
automatically fail this assignment (score 0). Any website youâ€™ve used to solve the
assignment, every website you used to solve the assignment must be noted in the PDF.
6) No delays in submission without special permission. Lateness without approval will result in
failure of the assignment (score 0).
7) All submissions will be submitted via the course's Moodle website. Email submissions will not
be accepted, resulting in a failure in the assignment.
8) The order and design of the code must be carefully considered. Make sure that the program
output is as clear as possible, comments in the code, and meaningful variable names. You
must also submit a makefile that compiles all the programs.
9) The assignment code must be written in C only.
10) The assignment is personal for each pair, and you should not accept help from other people,
whether outside the university or inside it. You can contact the course staff during reception
hours for help or raise a question in the course forum. Do not transfer code sections
between students, upload solutions or parts of solutions to websites on the Internet or in
various communication groups.
11) Students who copy a solution will receive a 0 in all assignments in the course and a report will
be made to the institutional disciplinary committee.
12) All code files of the assignment are required to both compile and run properly on the Ubuntu
22.04 LTS operating system. This is the operating system where the submissions will be
tested. You mustnâ€™t code it in Windows, as it uses different API for sockets. WSL wonâ€™t work,
as the task needs a tool that works only in a fully Linux environment.
Good Luck!
 Communication Networks Course
Page | 2
Part A â€“ Transmission Control Protocol (TCP) â€“ 30 points
In this part, youâ€™ll write two program files: ğ‘»ğ‘ªğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and ğ‘»ğ‘ªğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
The Sender will send a randomly generated file and the Receiver will receive it and measure
the time it took for his program to receive the file. The file size should be at least 2MB.
When running the Sender and Receiver, they both should support two standard congestion
control algorithms: TCP Reno and TCP Cubic.
Notes:
â€¢ The main goal of this part is to get familiar with the TCP concept of sending
messages between two endpoints.
â€¢ For approaching this part of the assignment, please be sure that you are familiar
with the congestion control algorithms and how to change them using the correct
method in C (see Appendix B for more information).
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). You've
learned that TCP is reliable by design, so you can assume that all the data have been
passed correctly, and thus, no need to recheck.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
Usage:
â€¢ Receiver:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
â€¢ Sender:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port of the Receiver.
â€¢ ğ‘¨ğ‘³ğ‘®ğ‘¶ â€“ The TCP congestion control algorithm that will be used by the party
member (either ğ’“ğ’†ğ’ğ’ for TCP Reno or ğ’„ğ’–ğ’ƒğ’Šğ’„ for TCP Cubic).
 Communication Networks Course
Page | 3
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a TCP socket between the Sender and the
Receiver.
3) Send the file.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a TCP connection between the Receiver and
the Sender.
2) Get a connection from the sender.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./TCP_Receiver -p 1234 -algo reno
Starting Receiver...
Waiting for TCP connection...
Sender connected, beginning to receive file...
File transfer completed.
Waiting for Sender response...
Sender sent exit message.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 4
Part B â€“ Reliable User Datagram Protocol (Reliable UDP or RUDP) â€“ 40 points
Youâ€™ve learned that while TCP is reliable, it lacks speed and has an overhead data of 20 bytes,
compering to UDP that needs only 8 bytes of overhead data.
Reliable UDP or RUDP, is a protocol that uses the UDP protocol for a faster transmission of
data, while adding a reliability layer to it, but without adding too much overhead data like
TCP.
A simple sketch for a RUDP connection would look something like this:
Your task in this part is to implement a Reliable protocol using UDP only. For simplicity, your
implementation should only support a handshake, closing scheme, error checking,
acknowledgment of received packets, and retransmission of lost packets.
Guidance:
â€¢ You can use ğ‘ ğ‘’ğ‘¡ğ‘ ğ‘œğ‘ğ‘˜ğ‘œğ‘ğ‘¡(2) for detecting a timeout.
â€¢ You need to build your own protocol, as Reliable UDP isnâ€™t a standard protocol (see a
draft of RUDP in this link), and no official header is provided. You can use this sketch
for a header, but you can come up with your own protocol, as long as it works.
Where:
o ğ‘³ğ’†ğ’ğ’ˆğ’•ğ’‰ is the length of the data itself, without the RUDP header.
o ğ‘ªğ’‰ğ’†ğ’„ğ’Œğ’”ğ’–ğ’ is a 16bit number that validates the correctness of the data.
o ğ‘­ğ’ğ’‚ğ’ˆğ’” is a special byte where we classify the packet itself (SYN, ACK, etc.).
â€¢ In your PDF, you must explain how your implementation of RUDP works â€“ How does
it detect a timeout to do retransmissions, how does the handshake work, what is the
header overhead, etc.
â€¢ For this part, youâ€™ll write three files: ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¨ğ‘·ğ‘°. ğ’„, ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and
ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
Reliable UDP Header proposed sketch
Byte 0 Byte 1 Byte 2 Byte 3
Length (2 Bytes) Checksum (2 Bytes)
Flags (1 Byte)
Figure 1 - RUDP Protocol Architecture, Geeksforgeeks
 Communication Networks Course
Page | 5
Notes:
â€¢ The Sender will send a random generated file and the Receiver will receive it and
measure the time it took for his program to receive the file. The file size should be at
least 2MB.
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). But, as the
RUDP is based on UDP, itâ€™s not reliable. You must use some form of error checking
(like checksum) to ensure that the packet wasnâ€™t alerted during the transfer.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
â€¢ The RUDP needs support only 1 sender and 1 receiver, for simplicity purposes.
Usage:
â€¢ Receiver:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
â€¢ Sender:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port that both the Sender and the Receiver will use.
The ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„ file will contain all the implementations of the RUDP API functions (That is, to
prevent reusing the same chuck of code both in the Sender and the Receiver.).
The API should support at the bare minimum the following functions (you decide what
parameters to implement, and what are the names of the functions, as long as the API is
explained in the PDF):
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘œğ‘ğ‘˜ğ‘’ğ‘¡() â€“ Creating a RUDP socket and creating a handshake between two
peers.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘’ğ‘›ğ‘‘() â€“ Sending data to the peer. The function should wait for an
acknowledgment packet, and if it didnâ€™t receive any, retransmits the data.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘Ÿğ‘’ğ‘ğ‘£() â€“ Receive data from a peer.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ğ‘™ğ‘œğ‘ ğ‘’() â€“ Closes a connection between peers.
 Communication Networks Course
Page | 6
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a UDP socket between the Sender and the
Receiver.
3) Send the file via the RUDP protocol.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a UDP connection between the Receiver and
the Sender.
2) Get a connection from the sender, by the custom
RUDP protocol youâ€™ve built.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./RUDP_Receiver -p 1234
Starting Receiver...
Waiting for RUDP connection...
Connection request received, sending ACK.
Sender connected, beginning to receive file...
File transfer completed.
ACK sent.
Waiting for Sender response...
Sender sent exit message.
ACK sent.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 7
Part C â€“ Research â€“ 30 points
In this part, youâ€™ll conduct research about your implementations of part A and part B.
In the research itself, each one of the versions (TCP version and UDP version) will be run at
least 5 times (meaning that the file transfer will occur at least 5 times) by the following
conditions:
â€¢ For TCP, youâ€™ll run it in TCP Reno and TCP Cubic, alternating each time, for each
scenario, meaning that you run 5 times with TCP Reno in both Sender and Receiver,
and 5 times with TCP Cubic in both Sender and Receiver.
Bonus (5 points): Create a very large data set â€“ 5 times with TCP Reno in both Sender
and Receiver, 5 times with TCP Reno in Sender and TCP Cubic in Receiver, 5 times
with TCP Cubic in Sender and TCP Reno in Receiver, and 5 times with TCP Cubic in
both Sender and Receiver. This will give you a data set large enough, which allows
you to work with, compare with and to reach a definite conclusion.
â€¢ For RUDP, you will run it 5 times for each scenario.
â€¢ For both TCP and RUDP, you will run them on those scenarios of packet loss:
o 0% packet loss â€“ Control group, simulating perfect connection.
o 2% packet loss â€“ Simulating unstable connection that commonly occur.
o 5% packet loss â€“ Simulating bad connection.
o 10% packet loss â€“ Simulating extremely poor connection.
For each scenario, you must provide a filtered PCAP file and relevant screenshots that
explain each one of the steps in the process. (10 points)
After youâ€™ve gathered the data set for both TCP and Reliable UDP, answer the following
questions:
1) In TCP, which congestion control algorithm gave better results overall? TCP Reno or
TCP Cubic? Which one gave better results on high packet loss? Explain how you came
to this conclusion based on the data set youâ€™ve gathered. (5 points)
2) How did your implementation of Reliable UDP perform overall compared to regular
TCP? Which one is better for high packet loss? (5 points)
3) According to the data youâ€™ve gathered, in which scenarios and applications would we
prefer to use TCP and in which situations would we prefer to use reliable UDP?
Explain your answer. (5 points)
 Communication Networks Course
Page | 8
×¢× ×• ×¢×œ ×”×©××œ×•×ª ×”×‘××•×ª )5 × ×§×•×“×•×ª(:
â— ×‘"×¨×©×ª ×××™× ×”" ×”×›×•×•× ×” ×”×™× ×œ×¨×©×ª ×©×‘×” ××¢×˜ ×××•×“ ×—×‘×™×œ×•×ª ×”×•×œ×›×•×ª ×œ××™×‘×•×“. ×‘"×§×©×¨ ××¨×•×š" ×”×›×•×•× ×” ×”×™×
×œ×§×©×¨ TCP ×©×™×© ×‘×• ×”×¨×‘×” ×××•×“ ××™×“×¢ ×œ×©×œ×•×—. ××•×¦×¢ ×œ×”×’×“×™×œ ×‘ -TCP ××ª SSThreshold ×‘×ª×—×™×œ×ª ×”×§×©×¨.
×‘××™×–×” ××”××§×¨×™× ×”×‘××™× ×”×©×™× ×•×™ ×”×–×” ×¢×©×•×™ ×œ×”×•×¢×™×œ ×‘××™×“×” ×”××™×¨×‘×™×ª? × ××§.
.1 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
.2 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.3 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.4 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.5 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.6 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.7 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.8 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
â— A ×©×•×œ×— ×œ -B ×—×‘×™×œ×•×ª ××™×“×¢ ×‘×××¦×¢×•×ª ×§×©×¨ TCP. × ×ª×•×Ÿ ×›×™ ×”×§×©×¨ ××ª×—×™×œ ×¢× ×—×œ×•×Ÿ ×‘×’×•×“×œ 1MSS. ×”×§×©×¨
××¡×ª×™×™× ×‘×¤×¢× ×”×¨××©×•× ×” ×©×”×•× ××’×™×¢ ×œ -SSthresh. ×‘××”×œ×š ×”×§×©×¨ ×œ× ××•×‘×“×•×ª ×—×‘×™×œ×•×ª. × ×¡××Ÿ ×‘×§×™×¦×•×¨:
.SSthresh=S*MSS
× ×ª×•×Ÿ ×›×™ ×œ××•×¨×š ×›×œ ×”×§×©×¨ rwnd < MSS*S.
××”×™ ×”×ª×¤×•×§×” ×©×œ ×”×§×©×¨ ×-A ×œ-B( ×‘ -sec / Bytes )×‘×–××Ÿ ×”× "×œ? × ××§×™.
]S*MSS / [lg (S) * RTT*2 ×‘×¢×¨×š .1
]S*MSS / [S^0.5 * RTT*2 ×‘×¢×¨×š .2
S*MSS / RTT ×‘×¢×¨×š .3
S^2)*MSS / RTT( ×‘×¢×¨×š .4
â— ×©×ª×™ ×ª×—× ×•×ª ××ª×§×©×¨×•×ª ×‘××•×¤×Ÿ ××œ×—×•×˜×™ ×‘×©×™×˜×ª N Back Go.
× ×¡××Ÿ ×‘-X ××ª ×¡×¤×¨×ª ×”×‘×™×§×•×¨×ª ×©×œ ×”×ª.×–. ×©×œ×š. ×× ×©× ×™ ×©×•×ª×¤×™× ××’×™×©×™× ××ª ×”×ª×¨×’×™×œ ×™×—×“, X ×”×•× ×¡×¤×¨×ª
×”×‘×™×§×•×¨×ª ×‘×¢×œ×ª ×”×¢×¨×š ×”× ××•×š ×™×•×ª×¨ ××‘×™×Ÿ ×”×©×ª×™×™×.
×§×¦×‘ ×”×ª×§×©×•×¨×ª ×”×•× 8Gbps, ×•×’×•×“×œ ×›×œ ×—×‘×™×œ×” ×”×•× KByte*X. ×’×“×œ×™ ×”-headers ×•×” -Acks ×–× ×™×—×™×.
ï¿½ğ‘’ğ‘ ï¿½/ï¿½ï¿½ 8 , ×•×”××¨×—×§ ×‘×™×Ÿ ×”×ª×—× ×•×ª ×”×•× 1Km. ×§×¦×‘ ×”×”×ª×¤×©×˜×•×ª ×”×•× 10 â‹… 2
×–××Ÿ ×¢×™×‘×•×“ ×”× ×ª×•× ×™× ×‘×ª×—× ×•×ª ×–× ×™×—.
××£ ×—×‘×™×œ×” ×•××£ Ack ×œ× ×”×•×œ×›×™× ×œ××™×‘×•×“.
â— ××”×• X ×©×œ×š?
â— ××” ×¦×¨×™×š ×œ×”×™×•×ª ×’×•×“×œ ×—×œ×•×Ÿ ×”××©×œ×•×— ×›×“×™ ×œ×”×‘×˜×™×— ×ª×¤×•×§×” ××§×¡×™××œ×™×ª?
 Communication Networks Course
Page | 9
Bonus â€“ Improving the Reliable UDP â€“ 15 points
Note: This part isnâ€™t mandatory and is a bonus only!
In this part, youâ€™ll improve your RUDP implementation by adding the concepts of flow
control and congestion control from TCP. Youâ€™re free to choose which algorithms to
implement, as long as you explain in your PDF which algorithms youâ€™ve used. Youâ€™ll probably
need to make changes in the original design of the RUDP. Changes only need to be to the API
itself, ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„.
Points distribution:
â€¢ Flow control improvement â€“ 7 Points
â€¢ Congestion control improvement â€“ 8 points.
Guidance:
â€¢ For flow control, you must use one of the Sliding window techniques: stop-and-wait
ARQ, Go-Back-N or Selective repeat.
â€¢ List of known TCP congestion control algorithms, which you can use any one of them
for this bonus task, or makeup your own:
Figure 2 â€“ List of known TCP congestion control algorithms, Wikipedia
 Communication Networks Course
Page | 10
Appendix A â€“ Linux local packet loss tool
To simulate a packet loss in a local network, we'll use a Linux tool that's called Linux Traffic
Control (ğ‘¡ğ‘). This requires a full Linux installation, so working with WSL won't work.
If the tool isn't installed in your machine, you can install it by using the following commands:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’
If the installation didn't work, you can use the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’2
To create a packet loss scenario, type the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘ğ‘‘ğ‘‘ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
After creating a packet loss scenario, you can change the percentage by typing the following
command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘â„ğ‘ğ‘›ğ‘”ğ‘’ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
To remove the packet loss scenario, write the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘‘ğ‘’ğ‘™ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š
 Communication Networks Course
Page | 11
Appendix B â€“ ğ’ğ’‚ğ’(ğŸ) system calls
This appendixâ€™s purpose is to give you a better understanding of socket handling in C.
A recommended reference is Beejâ€™s Guide to Network Programming, by Brian â€œBeej
Jorgensenâ€ Hall, which gives a lot of information about sockets in C and functions.
Functions and documentation links:
â€¢ ğ’”ğ’ğ’„ğ’Œğ’†ğ’•(ğŸ) â€“ A Factory method system call that creates a socket with the given
parameters.
â€¢ ğ’ƒğ’Šğ’ğ’…(ğŸ) â€“ Whenever we create a new socket, we need to bind it to a specific port in
our machine, â€œto catch a portâ€. The port number is managed and used by the kernel
to link incoming packets to the corresponding application socket. The port numbers
are usually fixed. The ğ‘ğ‘‘ğ‘‘ğ‘Ÿ parameter must match the current socket that is used.
â€¢ ğ’ğ’Šğ’”ğ’•ğ’†ğ’(ğŸ) â€“ The ğ‘™ğ‘–ğ‘ ğ‘¡ğ‘’ğ‘›(2) system call doesn't do anything in the mean of
communication but only memory allocation (malloc) for stream sockets only. If we
won't allocate memory, any incoming connection will fail.
â€¢ ğ’„ğ’ğ’ğ’ğ’†ğ’„ğ’•(ğŸ) â€“ The ğ‘ğ‘œğ‘›ğ‘›ğ‘’ğ‘ğ‘¡(2) system call starts the link between a client and a
specific IP address and port number. The connection would complete when the
other side will call the ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call.
â€¢ ğ’‚ğ’„ğ’„ğ’†ğ’‘ğ’•(ğŸ) â€“ The ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call accepts the incoming stream connection
request from the other side, by the listening socket. This system call completes the
three-way handshake of stream socket (like TCP) and opens a new socket that has a
direct communication channel only with the other party in the handshake.
â€¢ ğ’”ğ’†ğ’ğ’…(ğŸ) and ğ’”ğ’†ğ’ğ’…ğ’•ğ’(ğŸ) â€“ The ğ‘ ğ‘’ğ‘›ğ‘‘(2) and ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system calls are an analogy
for the ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’(2) system call, specifcly for sockets, with flags set to 0. Those system
calls return the number of bytes that were sent through the socket itself, as the
number of bytes can vary. The ğ‘ ğ‘’ğ‘›ğ‘‘(2)system call designed for stream sockets (like
TCP), while the ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system call designed for datagram connection-less
sockets (like UDP). When the ğ‘ ğ‘’ğ‘›ğ‘‘(2) system call returns 0, it means that the other
party closed the connection.
â€¢ ğ’“ğ’†ğ’„ğ’—(ğŸ) and ğ’“ğ’†ğ’„ğ’—ğ’‡ğ’“ğ’ğ’(ğŸ) â€“ The ğ‘Ÿğ‘’ğ‘ğ‘£(2) and ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system calls are an
analogy for the ğ‘Ÿğ‘’ğ‘ğ‘‘(2) system call, specifically for sockets, with flags set to 0.
Those system calls return the number of bytes that were received through the socket
itself, as the number of bytes can vary. The ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call designed for stream
sockets (like TCP), while the ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system call designed for datagram
connection-less sockets (like UDP). When the ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call returns 0, it means
that the other party closed the connection.
â€¢ ğ’„ğ’ğ’ğ’”ğ’†(ğŸ) and ğ’”ğ’‰ğ’–ğ’•ğ’…ğ’ğ’˜ğ’(ğŸ) â€“ The ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) and ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2) system calls close
the socket. While ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) system call closes the whole socket, the ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2)
system call partially closes the socket for read/write.
 Communication Networks Course
Page | 12
Appendix C â€“ Random data generator
The data that you are going to send in this assignment is randomly generated. You can use
your own file with appropriate size or use the following function (or a function of your own)
to generate the data:
/*
* @brief A random data generator function based on srand() and rand().
* @param size The size of the data to generate (up to 2^32 bytes).
* @return A pointer to the buffer.
*/
char *util_generate_random_data(unsigned int size) {
 char *buffer = NULL;
 // Argument check.
 if (size == 0)
 return NULL;
 buffer = (char *)calloc(size, sizeof(char));
 // Error checking.
 if (buffer == NULL)
 return NULL;
 // Randomize the seed of the random number generator.
 srand(time(NULL));
 for (unsigned int i = 0; i < size; i++)
 *(buffer + i) = ((unsigned int)rand() % 256);
 return buffer;
}
 Communication Networks Course
Page | 13
Appendix D â€“ Checksum function
A checksum is a small-sized block of data derived from another block of digital data for the
purpose of detecting errors that may have been introduced during its transmission or
storage. By themselves, checksums are often used to verify data integrity but are not relied
upon to verify data authenticity.
Below is a simple yet efficient implementation of the checksum function, you can use it for
the assignment, but you can implement your own checksum function.
/*
* @brief A checksum function that returns 16 bit checksum for data.
* @param data The data to do the checksum for.
* @param bytes The length of the data in bytes.
* @return The checksum itself as 16 bit unsigned number.
* @note This function is taken from RFC1071, can be found here:
* @note https://tools.ietf.org/html/rfc1071
* @note It is the simplest way to calculate a checksum and is not very strong.
* However, it is good enough for this assignment.
* @note You are free to use any other checksum function as well.
* You can also use this function as such without any change.
*/
unsigned short int calculate_checksum(void *data, unsigned int bytes) {
 unsigned short int *data_pointer = (unsigned short int *)data;
 unsigned int total_sum = 0;
 // Main summing loop
 while (bytes > 1) {
 total_sum += *data_pointer++;
 bytes -= 2;
 }
 // Add left-over byte, if any
 if (bytes > 0)
 total_sum += *((unsigned char *)data_pointer);
 // Fold 32-bit sum to 16 bits
 while (total_sum >> 16)
 total_sum = (total_sum & 0xFFFF) + (total_sum >> 16);
 return (~((unsigned short int)total_sum));
} Communication Networks Course
Page | 1
Assignment 3 â€“ Transport Layer
Assignment Notes and Instructions
This assignment is to be done in pairs only. You must upload all the necessary files in a ZIP
file named after both of the studentâ€™s ID. For example: ğŸğŸğŸ‘ğŸ’ğŸ“ğŸ”ğŸ•ğŸ–ğŸ—_ğŸ—ğŸ–ğŸ•ğŸ”ğŸ“ğŸ’ğŸ‘ğŸğŸ. ğ’›ğ’Šğ’‘.
1) The assignment must be submitted by the date specified in the submission box.
2) All the assignment files (Code, Wireshark pcap files, PDF) must be submitted in a ZIP file. The
PDF must contain all the necessary screenshots with a description for each one of them.
3) The assignment must be done in pairs only. In exceptional cases, you should send an email to
the course coordinator.
4) You can use any reference material available through the course Moodle website or any
material passed during the exercises.
5) You can use any reference from the web, but copying codes from websites is forbidden; this
includes codes from other GitHub repositories. A student who gets caught in the act will
automatically fail this assignment (score 0). Any website youâ€™ve used to solve the
assignment, every website you used to solve the assignment must be noted in the PDF.
6) No delays in submission without special permission. Lateness without approval will result in
failure of the assignment (score 0).
7) All submissions will be submitted via the course's Moodle website. Email submissions will not
be accepted, resulting in a failure in the assignment.
8) The order and design of the code must be carefully considered. Make sure that the program
output is as clear as possible, comments in the code, and meaningful variable names. You
must also submit a makefile that compiles all the programs.
9) The assignment code must be written in C only.
10) The assignment is personal for each pair, and you should not accept help from other people,
whether outside the university or inside it. You can contact the course staff during reception
hours for help or raise a question in the course forum. Do not transfer code sections
between students, upload solutions or parts of solutions to websites on the Internet or in
various communication groups.
11) Students who copy a solution will receive a 0 in all assignments in the course and a report will
be made to the institutional disciplinary committee.
12) All code files of the assignment are required to both compile and run properly on the Ubuntu
22.04 LTS operating system. This is the operating system where the submissions will be
tested. You mustnâ€™t code it in Windows, as it uses different API for sockets. WSL wonâ€™t work,
as the task needs a tool that works only in a fully Linux environment.
Good Luck!
 Communication Networks Course
Page | 2
Part A â€“ Transmission Control Protocol (TCP) â€“ 30 points
In this part, youâ€™ll write two program files: ğ‘»ğ‘ªğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and ğ‘»ğ‘ªğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
The Sender will send a randomly generated file and the Receiver will receive it and measure
the time it took for his program to receive the file. The file size should be at least 2MB.
When running the Sender and Receiver, they both should support two standard congestion
control algorithms: TCP Reno and TCP Cubic.
Notes:
â€¢ The main goal of this part is to get familiar with the TCP concept of sending
messages between two endpoints.
â€¢ For approaching this part of the assignment, please be sure that you are familiar
with the congestion control algorithms and how to change them using the correct
method in C (see Appendix B for more information).
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). You've
learned that TCP is reliable by design, so you can assume that all the data have been
passed correctly, and thus, no need to recheck.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
Usage:
â€¢ Receiver:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
â€¢ Sender:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port of the Receiver.
â€¢ ğ‘¨ğ‘³ğ‘®ğ‘¶ â€“ The TCP congestion control algorithm that will be used by the party
member (either ğ’“ğ’†ğ’ğ’ for TCP Reno or ğ’„ğ’–ğ’ƒğ’Šğ’„ for TCP Cubic).
 Communication Networks Course
Page | 3
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a TCP socket between the Sender and the
Receiver.
3) Send the file.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a TCP connection between the Receiver and
the Sender.
2) Get a connection from the sender.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./TCP_Receiver -p 1234 -algo reno
Starting Receiver...
Waiting for TCP connection...
Sender connected, beginning to receive file...
File transfer completed.
Waiting for Sender response...
Sender sent exit message.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 4
Part B â€“ Reliable User Datagram Protocol (Reliable UDP or RUDP) â€“ 40 points
Youâ€™ve learned that while TCP is reliable, it lacks speed and has an overhead data of 20 bytes,
compering to UDP that needs only 8 bytes of overhead data.
Reliable UDP or RUDP, is a protocol that uses the UDP protocol for a faster transmission of
data, while adding a reliability layer to it, but without adding too much overhead data like
TCP.
A simple sketch for a RUDP connection would look something like this:
Your task in this part is to implement a Reliable protocol using UDP only. For simplicity, your
implementation should only support a handshake, closing scheme, error checking,
acknowledgment of received packets, and retransmission of lost packets.
Guidance:
â€¢ You can use ğ‘ ğ‘’ğ‘¡ğ‘ ğ‘œğ‘ğ‘˜ğ‘œğ‘ğ‘¡(2) for detecting a timeout.
â€¢ You need to build your own protocol, as Reliable UDP isnâ€™t a standard protocol (see a
draft of RUDP in this link), and no official header is provided. You can use this sketch
for a header, but you can come up with your own protocol, as long as it works.
Where:
o ğ‘³ğ’†ğ’ğ’ˆğ’•ğ’‰ is the length of the data itself, without the RUDP header.
o ğ‘ªğ’‰ğ’†ğ’„ğ’Œğ’”ğ’–ğ’ is a 16bit number that validates the correctness of the data.
o ğ‘­ğ’ğ’‚ğ’ˆğ’” is a special byte where we classify the packet itself (SYN, ACK, etc.).
â€¢ In your PDF, you must explain how your implementation of RUDP works â€“ How does
it detect a timeout to do retransmissions, how does the handshake work, what is the
header overhead, etc.
â€¢ For this part, youâ€™ll write three files: ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¨ğ‘·ğ‘°. ğ’„, ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and
ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
Reliable UDP Header proposed sketch
Byte 0 Byte 1 Byte 2 Byte 3
Length (2 Bytes) Checksum (2 Bytes)
Flags (1 Byte)
Figure 1 - RUDP Protocol Architecture, Geeksforgeeks
 Communication Networks Course
Page | 5
Notes:
â€¢ The Sender will send a random generated file and the Receiver will receive it and
measure the time it took for his program to receive the file. The file size should be at
least 2MB.
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). But, as the
RUDP is based on UDP, itâ€™s not reliable. You must use some form of error checking
(like checksum) to ensure that the packet wasnâ€™t alerted during the transfer.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
â€¢ The RUDP needs support only 1 sender and 1 receiver, for simplicity purposes.
Usage:
â€¢ Receiver:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
â€¢ Sender:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port that both the Sender and the Receiver will use.
The ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„ file will contain all the implementations of the RUDP API functions (That is, to
prevent reusing the same chuck of code both in the Sender and the Receiver.).
The API should support at the bare minimum the following functions (you decide what
parameters to implement, and what are the names of the functions, as long as the API is
explained in the PDF):
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘œğ‘ğ‘˜ğ‘’ğ‘¡() â€“ Creating a RUDP socket and creating a handshake between two
peers.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘’ğ‘›ğ‘‘() â€“ Sending data to the peer. The function should wait for an
acknowledgment packet, and if it didnâ€™t receive any, retransmits the data.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘Ÿğ‘’ğ‘ğ‘£() â€“ Receive data from a peer.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ğ‘™ğ‘œğ‘ ğ‘’() â€“ Closes a connection between peers.
 Communication Networks Course
Page | 6
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a UDP socket between the Sender and the
Receiver.
3) Send the file via the RUDP protocol.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a UDP connection between the Receiver and
the Sender.
2) Get a connection from the sender, by the custom
RUDP protocol youâ€™ve built.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./RUDP_Receiver -p 1234
Starting Receiver...
Waiting for RUDP connection...
Connection request received, sending ACK.
Sender connected, beginning to receive file...
File transfer completed.
ACK sent.
Waiting for Sender response...
Sender sent exit message.
ACK sent.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 7
Part C â€“ Research â€“ 30 points
In this part, youâ€™ll conduct research about your implementations of part A and part B.
In the research itself, each one of the versions (TCP version and UDP version) will be run at
least 5 times (meaning that the file transfer will occur at least 5 times) by the following
conditions:
â€¢ For TCP, youâ€™ll run it in TCP Reno and TCP Cubic, alternating each time, for each
scenario, meaning that you run 5 times with TCP Reno in both Sender and Receiver,
and 5 times with TCP Cubic in both Sender and Receiver.
Bonus (5 points): Create a very large data set â€“ 5 times with TCP Reno in both Sender
and Receiver, 5 times with TCP Reno in Sender and TCP Cubic in Receiver, 5 times
with TCP Cubic in Sender and TCP Reno in Receiver, and 5 times with TCP Cubic in
both Sender and Receiver. This will give you a data set large enough, which allows
you to work with, compare with and to reach a definite conclusion.
â€¢ For RUDP, you will run it 5 times for each scenario.
â€¢ For both TCP and RUDP, you will run them on those scenarios of packet loss:
o 0% packet loss â€“ Control group, simulating perfect connection.
o 2% packet loss â€“ Simulating unstable connection that commonly occur.
o 5% packet loss â€“ Simulating bad connection.
o 10% packet loss â€“ Simulating extremely poor connection.
For each scenario, you must provide a filtered PCAP file and relevant screenshots that
explain each one of the steps in the process. (10 points)
After youâ€™ve gathered the data set for both TCP and Reliable UDP, answer the following
questions:
1) In TCP, which congestion control algorithm gave better results overall? TCP Reno or
TCP Cubic? Which one gave better results on high packet loss? Explain how you came
to this conclusion based on the data set youâ€™ve gathered. (5 points)
2) How did your implementation of Reliable UDP perform overall compared to regular
TCP? Which one is better for high packet loss? (5 points)
3) According to the data youâ€™ve gathered, in which scenarios and applications would we
prefer to use TCP and in which situations would we prefer to use reliable UDP?
Explain your answer. (5 points)
 Communication Networks Course
Page | 8
×¢× ×• ×¢×œ ×”×©××œ×•×ª ×”×‘××•×ª )5 × ×§×•×“×•×ª(:
â— ×‘"×¨×©×ª ×××™× ×”" ×”×›×•×•× ×” ×”×™× ×œ×¨×©×ª ×©×‘×” ××¢×˜ ×××•×“ ×—×‘×™×œ×•×ª ×”×•×œ×›×•×ª ×œ××™×‘×•×“. ×‘"×§×©×¨ ××¨×•×š" ×”×›×•×•× ×” ×”×™×
×œ×§×©×¨ TCP ×©×™×© ×‘×• ×”×¨×‘×” ×××•×“ ××™×“×¢ ×œ×©×œ×•×—. ××•×¦×¢ ×œ×”×’×“×™×œ ×‘ -TCP ××ª SSThreshold ×‘×ª×—×™×œ×ª ×”×§×©×¨.
×‘××™×–×” ××”××§×¨×™× ×”×‘××™× ×”×©×™× ×•×™ ×”×–×” ×¢×©×•×™ ×œ×”×•×¢×™×œ ×‘××™×“×” ×”××™×¨×‘×™×ª? × ××§.
.1 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
.2 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.3 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.4 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.5 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.6 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.7 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.8 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
â— A ×©×•×œ×— ×œ -B ×—×‘×™×œ×•×ª ××™×“×¢ ×‘×××¦×¢×•×ª ×§×©×¨ TCP. × ×ª×•×Ÿ ×›×™ ×”×§×©×¨ ××ª×—×™×œ ×¢× ×—×œ×•×Ÿ ×‘×’×•×“×œ 1MSS. ×”×§×©×¨
××¡×ª×™×™× ×‘×¤×¢× ×”×¨××©×•× ×” ×©×”×•× ××’×™×¢ ×œ -SSthresh. ×‘××”×œ×š ×”×§×©×¨ ×œ× ××•×‘×“×•×ª ×—×‘×™×œ×•×ª. × ×¡××Ÿ ×‘×§×™×¦×•×¨:
.SSthresh=S*MSS
× ×ª×•×Ÿ ×›×™ ×œ××•×¨×š ×›×œ ×”×§×©×¨ rwnd < MSS*S.
××”×™ ×”×ª×¤×•×§×” ×©×œ ×”×§×©×¨ ×-A ×œ-B( ×‘ -sec / Bytes )×‘×–××Ÿ ×”× "×œ? × ××§×™.
]S*MSS / [lg (S) * RTT*2 ×‘×¢×¨×š .1
]S*MSS / [S^0.5 * RTT*2 ×‘×¢×¨×š .2
S*MSS / RTT ×‘×¢×¨×š .3
S^2)*MSS / RTT( ×‘×¢×¨×š .4
â— ×©×ª×™ ×ª×—× ×•×ª ××ª×§×©×¨×•×ª ×‘××•×¤×Ÿ ××œ×—×•×˜×™ ×‘×©×™×˜×ª N Back Go.
× ×¡××Ÿ ×‘-X ××ª ×¡×¤×¨×ª ×”×‘×™×§×•×¨×ª ×©×œ ×”×ª.×–. ×©×œ×š. ×× ×©× ×™ ×©×•×ª×¤×™× ××’×™×©×™× ××ª ×”×ª×¨×’×™×œ ×™×—×“, X ×”×•× ×¡×¤×¨×ª
×”×‘×™×§×•×¨×ª ×‘×¢×œ×ª ×”×¢×¨×š ×”× ××•×š ×™×•×ª×¨ ××‘×™×Ÿ ×”×©×ª×™×™×.
×§×¦×‘ ×”×ª×§×©×•×¨×ª ×”×•× 8Gbps, ×•×’×•×“×œ ×›×œ ×—×‘×™×œ×” ×”×•× KByte*X. ×’×“×œ×™ ×”-headers ×•×” -Acks ×–× ×™×—×™×.
ï¿½ğ‘’ğ‘ ï¿½/ï¿½ï¿½ 8 , ×•×”××¨×—×§ ×‘×™×Ÿ ×”×ª×—× ×•×ª ×”×•× 1Km. ×§×¦×‘ ×”×”×ª×¤×©×˜×•×ª ×”×•× 10 â‹… 2
×–××Ÿ ×¢×™×‘×•×“ ×”× ×ª×•× ×™× ×‘×ª×—× ×•×ª ×–× ×™×—.
××£ ×—×‘×™×œ×” ×•××£ Ack ×œ× ×”×•×œ×›×™× ×œ××™×‘×•×“.
â— ××”×• X ×©×œ×š?
â— ××” ×¦×¨×™×š ×œ×”×™×•×ª ×’×•×“×œ ×—×œ×•×Ÿ ×”××©×œ×•×— ×›×“×™ ×œ×”×‘×˜×™×— ×ª×¤×•×§×” ××§×¡×™××œ×™×ª?
 Communication Networks Course
Page | 9
Bonus â€“ Improving the Reliable UDP â€“ 15 points
Note: This part isnâ€™t mandatory and is a bonus only!
In this part, youâ€™ll improve your RUDP implementation by adding the concepts of flow
control and congestion control from TCP. Youâ€™re free to choose which algorithms to
implement, as long as you explain in your PDF which algorithms youâ€™ve used. Youâ€™ll probably
need to make changes in the original design of the RUDP. Changes only need to be to the API
itself, ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„.
Points distribution:
â€¢ Flow control improvement â€“ 7 Points
â€¢ Congestion control improvement â€“ 8 points.
Guidance:
â€¢ For flow control, you must use one of the Sliding window techniques: stop-and-wait
ARQ, Go-Back-N or Selective repeat.
â€¢ List of known TCP congestion control algorithms, which you can use any one of them
for this bonus task, or makeup your own:
Figure 2 â€“ List of known TCP congestion control algorithms, Wikipedia
 Communication Networks Course
Page | 10
Appendix A â€“ Linux local packet loss tool
To simulate a packet loss in a local network, we'll use a Linux tool that's called Linux Traffic
Control (ğ‘¡ğ‘). This requires a full Linux installation, so working with WSL won't work.
If the tool isn't installed in your machine, you can install it by using the following commands:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’
If the installation didn't work, you can use the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’2
To create a packet loss scenario, type the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘ğ‘‘ğ‘‘ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
After creating a packet loss scenario, you can change the percentage by typing the following
command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘â„ğ‘ğ‘›ğ‘”ğ‘’ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
To remove the packet loss scenario, write the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘‘ğ‘’ğ‘™ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š
 Communication Networks Course
Page | 11
Appendix B â€“ ğ’ğ’‚ğ’(ğŸ) system calls
This appendixâ€™s purpose is to give you a better understanding of socket handling in C.
A recommended reference is Beejâ€™s Guide to Network Programming, by Brian â€œBeej
Jorgensenâ€ Hall, which gives a lot of information about sockets in C and functions.
Functions and documentation links:
â€¢ ğ’”ğ’ğ’„ğ’Œğ’†ğ’•(ğŸ) â€“ A Factory method system call that creates a socket with the given
parameters.
â€¢ ğ’ƒğ’Šğ’ğ’…(ğŸ) â€“ Whenever we create a new socket, we need to bind it to a specific port in
our machine, â€œto catch a portâ€. The port number is managed and used by the kernel
to link incoming packets to the corresponding application socket. The port numbers
are usually fixed. The ğ‘ğ‘‘ğ‘‘ğ‘Ÿ parameter must match the current socket that is used.
â€¢ ğ’ğ’Šğ’”ğ’•ğ’†ğ’(ğŸ) â€“ The ğ‘™ğ‘–ğ‘ ğ‘¡ğ‘’ğ‘›(2) system call doesn't do anything in the mean of
communication but only memory allocation (malloc) for stream sockets only. If we
won't allocate memory, any incoming connection will fail.
â€¢ ğ’„ğ’ğ’ğ’ğ’†ğ’„ğ’•(ğŸ) â€“ The ğ‘ğ‘œğ‘›ğ‘›ğ‘’ğ‘ğ‘¡(2) system call starts the link between a client and a
specific IP address and port number. The connection would complete when the
other side will call the ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call.
â€¢ ğ’‚ğ’„ğ’„ğ’†ğ’‘ğ’•(ğŸ) â€“ The ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call accepts the incoming stream connection
request from the other side, by the listening socket. This system call completes the
three-way handshake of stream socket (like TCP) and opens a new socket that has a
direct communication channel only with the other party in the handshake.
â€¢ ğ’”ğ’†ğ’ğ’…(ğŸ) and ğ’”ğ’†ğ’ğ’…ğ’•ğ’(ğŸ) â€“ The ğ‘ ğ‘’ğ‘›ğ‘‘(2) and ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system calls are an analogy
for the ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’(2) system call, specifcly for sockets, with flags set to 0. Those system
calls return the number of bytes that were sent through the socket itself, as the
number of bytes can vary. The ğ‘ ğ‘’ğ‘›ğ‘‘(2)system call designed for stream sockets (like
TCP), while the ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system call designed for datagram connection-less
sockets (like UDP). When the ğ‘ ğ‘’ğ‘›ğ‘‘(2) system call returns 0, it means that the other
party closed the connection.
â€¢ ğ’“ğ’†ğ’„ğ’—(ğŸ) and ğ’“ğ’†ğ’„ğ’—ğ’‡ğ’“ğ’ğ’(ğŸ) â€“ The ğ‘Ÿğ‘’ğ‘ğ‘£(2) and ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system calls are an
analogy for the ğ‘Ÿğ‘’ğ‘ğ‘‘(2) system call, specifically for sockets, with flags set to 0.
Those system calls return the number of bytes that were received through the socket
itself, as the number of bytes can vary. The ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call designed for stream
sockets (like TCP), while the ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system call designed for datagram
connection-less sockets (like UDP). When the ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call returns 0, it means
that the other party closed the connection.
â€¢ ğ’„ğ’ğ’ğ’”ğ’†(ğŸ) and ğ’”ğ’‰ğ’–ğ’•ğ’…ğ’ğ’˜ğ’(ğŸ) â€“ The ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) and ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2) system calls close
the socket. While ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) system call closes the whole socket, the ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2)
system call partially closes the socket for read/write.
 Communication Networks Course
Page | 12
Appendix C â€“ Random data generator
The data that you are going to send in this assignment is randomly generated. You can use
your own file with appropriate size or use the following function (or a function of your own)
to generate the data:
/*
* @brief A random data generator function based on srand() and rand().
* @param size The size of the data to generate (up to 2^32 bytes).
* @return A pointer to the buffer.
*/
char *util_generate_random_data(unsigned int size) {
 char *buffer = NULL;
 // Argument check.
 if (size == 0)
 return NULL;
 buffer = (char *)calloc(size, sizeof(char));
 // Error checking.
 if (buffer == NULL)
 return NULL;
 // Randomize the seed of the random number generator.
 srand(time(NULL));
 for (unsigned int i = 0; i < size; i++)
 *(buffer + i) = ((unsigned int)rand() % 256);
 return buffer;
}
 Communication Networks Course
Page | 13
Appendix D â€“ Checksum function
A checksum is a small-sized block of data derived from another block of digital data for the
purpose of detecting errors that may have been introduced during its transmission or
storage. By themselves, checksums are often used to verify data integrity but are not relied
upon to verify data authenticity.
Below is a simple yet efficient implementation of the checksum function, you can use it for
the assignment, but you can implement your own checksum function.
/*
* @brief A checksum function that returns 16 bit checksum for data.
* @param data The data to do the checksum for.
* @param bytes The length of the data in bytes.
* @return The checksum itself as 16 bit unsigned number.
* @note This function is taken from RFC1071, can be found here:
* @note https://tools.ietf.org/html/rfc1071
* @note It is the simplest way to calculate a checksum and is not very strong.
* However, it is good enough for this assignment.
* @note You are free to use any other checksum function as well.
* You can also use this function as such without any change.
*/
unsigned short int calculate_checksum(void *data, unsigned int bytes) {
 unsigned short int *data_pointer = (unsigned short int *)data;
 unsigned int total_sum = 0;
 // Main summing loop
 while (bytes > 1) {
 total_sum += *data_pointer++;
 bytes -= 2;
 }
 // Add left-over byte, if any
 if (bytes > 0)
 total_sum += *((unsigned char *)data_pointer);
 // Fold 32-bit sum to 16 bits
 while (total_sum >> 16)
 total_sum = (total_sum & 0xFFFF) + (total_sum >> 16);
 return (~((unsigned short int)total_sum));
} Communication Networks Course
Page | 1
Assignment 3 â€“ Transport Layer
Assignment Notes and Instructions
This assignment is to be done in pairs only. You must upload all the necessary files in a ZIP
file named after both of the studentâ€™s ID. For example: ğŸğŸğŸ‘ğŸ’ğŸ“ğŸ”ğŸ•ğŸ–ğŸ—_ğŸ—ğŸ–ğŸ•ğŸ”ğŸ“ğŸ’ğŸ‘ğŸğŸ. ğ’›ğ’Šğ’‘.
1) The assignment must be submitted by the date specified in the submission box.
2) All the assignment files (Code, Wireshark pcap files, PDF) must be submitted in a ZIP file. The
PDF must contain all the necessary screenshots with a description for each one of them.
3) The assignment must be done in pairs only. In exceptional cases, you should send an email to
the course coordinator.
4) You can use any reference material available through the course Moodle website or any
material passed during the exercises.
5) You can use any reference from the web, but copying codes from websites is forbidden; this
includes codes from other GitHub repositories. A student who gets caught in the act will
automatically fail this assignment (score 0). Any website youâ€™ve used to solve the
assignment, every website you used to solve the assignment must be noted in the PDF.
6) No delays in submission without special permission. Lateness without approval will result in
failure of the assignment (score 0).
7) All submissions will be submitted via the course's Moodle website. Email submissions will not
be accepted, resulting in a failure in the assignment.
8) The order and design of the code must be carefully considered. Make sure that the program
output is as clear as possible, comments in the code, and meaningful variable names. You
must also submit a makefile that compiles all the programs.
9) The assignment code must be written in C only.
10) The assignment is personal for each pair, and you should not accept help from other people,
whether outside the university or inside it. You can contact the course staff during reception
hours for help or raise a question in the course forum. Do not transfer code sections
between students, upload solutions or parts of solutions to websites on the Internet or in
various communication groups.
11) Students who copy a solution will receive a 0 in all assignments in the course and a report will
be made to the institutional disciplinary committee.
12) All code files of the assignment are required to both compile and run properly on the Ubuntu
22.04 LTS operating system. This is the operating system where the submissions will be
tested. You mustnâ€™t code it in Windows, as it uses different API for sockets. WSL wonâ€™t work,
as the task needs a tool that works only in a fully Linux environment.
Good Luck!
 Communication Networks Course
Page | 2
Part A â€“ Transmission Control Protocol (TCP) â€“ 30 points
In this part, youâ€™ll write two program files: ğ‘»ğ‘ªğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and ğ‘»ğ‘ªğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
The Sender will send a randomly generated file and the Receiver will receive it and measure
the time it took for his program to receive the file. The file size should be at least 2MB.
When running the Sender and Receiver, they both should support two standard congestion
control algorithms: TCP Reno and TCP Cubic.
Notes:
â€¢ The main goal of this part is to get familiar with the TCP concept of sending
messages between two endpoints.
â€¢ For approaching this part of the assignment, please be sure that you are familiar
with the congestion control algorithms and how to change them using the correct
method in C (see Appendix B for more information).
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). You've
learned that TCP is reliable by design, so you can assume that all the data have been
passed correctly, and thus, no need to recheck.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
Usage:
â€¢ Receiver:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
â€¢ Sender:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port of the Receiver.
â€¢ ğ‘¨ğ‘³ğ‘®ğ‘¶ â€“ The TCP congestion control algorithm that will be used by the party
member (either ğ’“ğ’†ğ’ğ’ for TCP Reno or ğ’„ğ’–ğ’ƒğ’Šğ’„ for TCP Cubic).
 Communication Networks Course
Page | 3
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a TCP socket between the Sender and the
Receiver.
3) Send the file.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a TCP connection between the Receiver and
the Sender.
2) Get a connection from the sender.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./TCP_Receiver -p 1234 -algo reno
Starting Receiver...
Waiting for TCP connection...
Sender connected, beginning to receive file...
File transfer completed.
Waiting for Sender response...
Sender sent exit message.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 4
Part B â€“ Reliable User Datagram Protocol (Reliable UDP or RUDP) â€“ 40 points
Youâ€™ve learned that while TCP is reliable, it lacks speed and has an overhead data of 20 bytes,
compering to UDP that needs only 8 bytes of overhead data.
Reliable UDP or RUDP, is a protocol that uses the UDP protocol for a faster transmission of
data, while adding a reliability layer to it, but without adding too much overhead data like
TCP.
A simple sketch for a RUDP connection would look something like this:
Your task in this part is to implement a Reliable protocol using UDP only. For simplicity, your
implementation should only support a handshake, closing scheme, error checking,
acknowledgment of received packets, and retransmission of lost packets.
Guidance:
â€¢ You can use ğ‘ ğ‘’ğ‘¡ğ‘ ğ‘œğ‘ğ‘˜ğ‘œğ‘ğ‘¡(2) for detecting a timeout.
â€¢ You need to build your own protocol, as Reliable UDP isnâ€™t a standard protocol (see a
draft of RUDP in this link), and no official header is provided. You can use this sketch
for a header, but you can come up with your own protocol, as long as it works.
Where:
o ğ‘³ğ’†ğ’ğ’ˆğ’•ğ’‰ is the length of the data itself, without the RUDP header.
o ğ‘ªğ’‰ğ’†ğ’„ğ’Œğ’”ğ’–ğ’ is a 16bit number that validates the correctness of the data.
o ğ‘­ğ’ğ’‚ğ’ˆğ’” is a special byte where we classify the packet itself (SYN, ACK, etc.).
â€¢ In your PDF, you must explain how your implementation of RUDP works â€“ How does
it detect a timeout to do retransmissions, how does the handshake work, what is the
header overhead, etc.
â€¢ For this part, youâ€™ll write three files: ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¨ğ‘·ğ‘°. ğ’„, ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and
ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
Reliable UDP Header proposed sketch
Byte 0 Byte 1 Byte 2 Byte 3
Length (2 Bytes) Checksum (2 Bytes)
Flags (1 Byte)
Figure 1 - RUDP Protocol Architecture, Geeksforgeeks
 Communication Networks Course
Page | 5
Notes:
â€¢ The Sender will send a random generated file and the Receiver will receive it and
measure the time it took for his program to receive the file. The file size should be at
least 2MB.
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). But, as the
RUDP is based on UDP, itâ€™s not reliable. You must use some form of error checking
(like checksum) to ensure that the packet wasnâ€™t alerted during the transfer.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
â€¢ The RUDP needs support only 1 sender and 1 receiver, for simplicity purposes.
Usage:
â€¢ Receiver:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
â€¢ Sender:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port that both the Sender and the Receiver will use.
The ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„ file will contain all the implementations of the RUDP API functions (That is, to
prevent reusing the same chuck of code both in the Sender and the Receiver.).
The API should support at the bare minimum the following functions (you decide what
parameters to implement, and what are the names of the functions, as long as the API is
explained in the PDF):
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘œğ‘ğ‘˜ğ‘’ğ‘¡() â€“ Creating a RUDP socket and creating a handshake between two
peers.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘’ğ‘›ğ‘‘() â€“ Sending data to the peer. The function should wait for an
acknowledgment packet, and if it didnâ€™t receive any, retransmits the data.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘Ÿğ‘’ğ‘ğ‘£() â€“ Receive data from a peer.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ğ‘™ğ‘œğ‘ ğ‘’() â€“ Closes a connection between peers.
 Communication Networks Course
Page | 6
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a UDP socket between the Sender and the
Receiver.
3) Send the file via the RUDP protocol.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a UDP connection between the Receiver and
the Sender.
2) Get a connection from the sender, by the custom
RUDP protocol youâ€™ve built.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./RUDP_Receiver -p 1234
Starting Receiver...
Waiting for RUDP connection...
Connection request received, sending ACK.
Sender connected, beginning to receive file...
File transfer completed.
ACK sent.
Waiting for Sender response...
Sender sent exit message.
ACK sent.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 7
Part C â€“ Research â€“ 30 points
In this part, youâ€™ll conduct research about your implementations of part A and part B.
In the research itself, each one of the versions (TCP version and UDP version) will be run at
least 5 times (meaning that the file transfer will occur at least 5 times) by the following
conditions:
â€¢ For TCP, youâ€™ll run it in TCP Reno and TCP Cubic, alternating each time, for each
scenario, meaning that you run 5 times with TCP Reno in both Sender and Receiver,
and 5 times with TCP Cubic in both Sender and Receiver.
Bonus (5 points): Create a very large data set â€“ 5 times with TCP Reno in both Sender
and Receiver, 5 times with TCP Reno in Sender and TCP Cubic in Receiver, 5 times
with TCP Cubic in Sender and TCP Reno in Receiver, and 5 times with TCP Cubic in
both Sender and Receiver. This will give you a data set large enough, which allows
you to work with, compare with and to reach a definite conclusion.
â€¢ For RUDP, you will run it 5 times for each scenario.
â€¢ For both TCP and RUDP, you will run them on those scenarios of packet loss:
o 0% packet loss â€“ Control group, simulating perfect connection.
o 2% packet loss â€“ Simulating unstable connection that commonly occur.
o 5% packet loss â€“ Simulating bad connection.
o 10% packet loss â€“ Simulating extremely poor connection.
For each scenario, you must provide a filtered PCAP file and relevant screenshots that
explain each one of the steps in the process. (10 points)
After youâ€™ve gathered the data set for both TCP and Reliable UDP, answer the following
questions:
1) In TCP, which congestion control algorithm gave better results overall? TCP Reno or
TCP Cubic? Which one gave better results on high packet loss? Explain how you came
to this conclusion based on the data set youâ€™ve gathered. (5 points)
2) How did your implementation of Reliable UDP perform overall compared to regular
TCP? Which one is better for high packet loss? (5 points)
3) According to the data youâ€™ve gathered, in which scenarios and applications would we
prefer to use TCP and in which situations would we prefer to use reliable UDP?
Explain your answer. (5 points)
 Communication Networks Course
Page | 8
×¢× ×• ×¢×œ ×”×©××œ×•×ª ×”×‘××•×ª )5 × ×§×•×“×•×ª(:
â— ×‘"×¨×©×ª ×××™× ×”" ×”×›×•×•× ×” ×”×™× ×œ×¨×©×ª ×©×‘×” ××¢×˜ ×××•×“ ×—×‘×™×œ×•×ª ×”×•×œ×›×•×ª ×œ××™×‘×•×“. ×‘"×§×©×¨ ××¨×•×š" ×”×›×•×•× ×” ×”×™×
×œ×§×©×¨ TCP ×©×™×© ×‘×• ×”×¨×‘×” ×××•×“ ××™×“×¢ ×œ×©×œ×•×—. ××•×¦×¢ ×œ×”×’×“×™×œ ×‘ -TCP ××ª SSThreshold ×‘×ª×—×™×œ×ª ×”×§×©×¨.
×‘××™×–×” ××”××§×¨×™× ×”×‘××™× ×”×©×™× ×•×™ ×”×–×” ×¢×©×•×™ ×œ×”×•×¢×™×œ ×‘××™×“×” ×”××™×¨×‘×™×ª? × ××§.
.1 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
.2 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.3 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.4 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.5 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.6 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.7 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.8 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
â— A ×©×•×œ×— ×œ -B ×—×‘×™×œ×•×ª ××™×“×¢ ×‘×××¦×¢×•×ª ×§×©×¨ TCP. × ×ª×•×Ÿ ×›×™ ×”×§×©×¨ ××ª×—×™×œ ×¢× ×—×œ×•×Ÿ ×‘×’×•×“×œ 1MSS. ×”×§×©×¨
××¡×ª×™×™× ×‘×¤×¢× ×”×¨××©×•× ×” ×©×”×•× ××’×™×¢ ×œ -SSthresh. ×‘××”×œ×š ×”×§×©×¨ ×œ× ××•×‘×“×•×ª ×—×‘×™×œ×•×ª. × ×¡××Ÿ ×‘×§×™×¦×•×¨:
.SSthresh=S*MSS
× ×ª×•×Ÿ ×›×™ ×œ××•×¨×š ×›×œ ×”×§×©×¨ rwnd < MSS*S.
××”×™ ×”×ª×¤×•×§×” ×©×œ ×”×§×©×¨ ×-A ×œ-B( ×‘ -sec / Bytes )×‘×–××Ÿ ×”× "×œ? × ××§×™.
]S*MSS / [lg (S) * RTT*2 ×‘×¢×¨×š .1
]S*MSS / [S^0.5 * RTT*2 ×‘×¢×¨×š .2
S*MSS / RTT ×‘×¢×¨×š .3
S^2)*MSS / RTT( ×‘×¢×¨×š .4
â— ×©×ª×™ ×ª×—× ×•×ª ××ª×§×©×¨×•×ª ×‘××•×¤×Ÿ ××œ×—×•×˜×™ ×‘×©×™×˜×ª N Back Go.
× ×¡××Ÿ ×‘-X ××ª ×¡×¤×¨×ª ×”×‘×™×§×•×¨×ª ×©×œ ×”×ª.×–. ×©×œ×š. ×× ×©× ×™ ×©×•×ª×¤×™× ××’×™×©×™× ××ª ×”×ª×¨×’×™×œ ×™×—×“, X ×”×•× ×¡×¤×¨×ª
×”×‘×™×§×•×¨×ª ×‘×¢×œ×ª ×”×¢×¨×š ×”× ××•×š ×™×•×ª×¨ ××‘×™×Ÿ ×”×©×ª×™×™×.
×§×¦×‘ ×”×ª×§×©×•×¨×ª ×”×•× 8Gbps, ×•×’×•×“×œ ×›×œ ×—×‘×™×œ×” ×”×•× KByte*X. ×’×“×œ×™ ×”-headers ×•×” -Acks ×–× ×™×—×™×.
ï¿½ğ‘’ğ‘ ï¿½/ï¿½ï¿½ 8 , ×•×”××¨×—×§ ×‘×™×Ÿ ×”×ª×—× ×•×ª ×”×•× 1Km. ×§×¦×‘ ×”×”×ª×¤×©×˜×•×ª ×”×•× 10 â‹… 2
×–××Ÿ ×¢×™×‘×•×“ ×”× ×ª×•× ×™× ×‘×ª×—× ×•×ª ×–× ×™×—.
××£ ×—×‘×™×œ×” ×•××£ Ack ×œ× ×”×•×œ×›×™× ×œ××™×‘×•×“.
â— ××”×• X ×©×œ×š?
â— ××” ×¦×¨×™×š ×œ×”×™×•×ª ×’×•×“×œ ×—×œ×•×Ÿ ×”××©×œ×•×— ×›×“×™ ×œ×”×‘×˜×™×— ×ª×¤×•×§×” ××§×¡×™××œ×™×ª?
 Communication Networks Course
Page | 9
Bonus â€“ Improving the Reliable UDP â€“ 15 points
Note: This part isnâ€™t mandatory and is a bonus only!
In this part, youâ€™ll improve your RUDP implementation by adding the concepts of flow
control and congestion control from TCP. Youâ€™re free to choose which algorithms to
implement, as long as you explain in your PDF which algorithms youâ€™ve used. Youâ€™ll probably
need to make changes in the original design of the RUDP. Changes only need to be to the API
itself, ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„.
Points distribution:
â€¢ Flow control improvement â€“ 7 Points
â€¢ Congestion control improvement â€“ 8 points.
Guidance:
â€¢ For flow control, you must use one of the Sliding window techniques: stop-and-wait
ARQ, Go-Back-N or Selective repeat.
â€¢ List of known TCP congestion control algorithms, which you can use any one of them
for this bonus task, or makeup your own:
Figure 2 â€“ List of known TCP congestion control algorithms, Wikipedia
 Communication Networks Course
Page | 10
Appendix A â€“ Linux local packet loss tool
To simulate a packet loss in a local network, we'll use a Linux tool that's called Linux Traffic
Control (ğ‘¡ğ‘). This requires a full Linux installation, so working with WSL won't work.
If the tool isn't installed in your machine, you can install it by using the following commands:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’
If the installation didn't work, you can use the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’2
To create a packet loss scenario, type the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘ğ‘‘ğ‘‘ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
After creating a packet loss scenario, you can change the percentage by typing the following
command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘â„ğ‘ğ‘›ğ‘”ğ‘’ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
To remove the packet loss scenario, write the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘‘ğ‘’ğ‘™ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š
 Communication Networks Course
Page | 11
Appendix B â€“ ğ’ğ’‚ğ’(ğŸ) system calls
This appendixâ€™s purpose is to give you a better understanding of socket handling in C.
A recommended reference is Beejâ€™s Guide to Network Programming, by Brian â€œBeej
Jorgensenâ€ Hall, which gives a lot of information about sockets in C and functions.
Functions and documentation links:
â€¢ ğ’”ğ’ğ’„ğ’Œğ’†ğ’•(ğŸ) â€“ A Factory method system call that creates a socket with the given
parameters.
â€¢ ğ’ƒğ’Šğ’ğ’…(ğŸ) â€“ Whenever we create a new socket, we need to bind it to a specific port in
our machine, â€œto catch a portâ€. The port number is managed and used by the kernel
to link incoming packets to the corresponding application socket. The port numbers
are usually fixed. The ğ‘ğ‘‘ğ‘‘ğ‘Ÿ parameter must match the current socket that is used.
â€¢ ğ’ğ’Šğ’”ğ’•ğ’†ğ’(ğŸ) â€“ The ğ‘™ğ‘–ğ‘ ğ‘¡ğ‘’ğ‘›(2) system call doesn't do anything in the mean of
communication but only memory allocation (malloc) for stream sockets only. If we
won't allocate memory, any incoming connection will fail.
â€¢ ğ’„ğ’ğ’ğ’ğ’†ğ’„ğ’•(ğŸ) â€“ The ğ‘ğ‘œğ‘›ğ‘›ğ‘’ğ‘ğ‘¡(2) system call starts the link between a client and a
specific IP address and port number. The connection would complete when the
other side will call the ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call.
â€¢ ğ’‚ğ’„ğ’„ğ’†ğ’‘ğ’•(ğŸ) â€“ The ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call accepts the incoming stream connection
request from the other side, by the listening socket. This system call completes the
three-way handshake of stream socket (like TCP) and opens a new socket that has a
direct communication channel only with the other party in the handshake.
â€¢ ğ’”ğ’†ğ’ğ’…(ğŸ) and ğ’”ğ’†ğ’ğ’…ğ’•ğ’(ğŸ) â€“ The ğ‘ ğ‘’ğ‘›ğ‘‘(2) and ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system calls are an analogy
for the ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’(2) system call, specifcly for sockets, with flags set to 0. Those system
calls return the number of bytes that were sent through the socket itself, as the
number of bytes can vary. The ğ‘ ğ‘’ğ‘›ğ‘‘(2)system call designed for stream sockets (like
TCP), while the ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system call designed for datagram connection-less
sockets (like UDP). When the ğ‘ ğ‘’ğ‘›ğ‘‘(2) system call returns 0, it means that the other
party closed the connection.
â€¢ ğ’“ğ’†ğ’„ğ’—(ğŸ) and ğ’“ğ’†ğ’„ğ’—ğ’‡ğ’“ğ’ğ’(ğŸ) â€“ The ğ‘Ÿğ‘’ğ‘ğ‘£(2) and ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system calls are an
analogy for the ğ‘Ÿğ‘’ğ‘ğ‘‘(2) system call, specifically for sockets, with flags set to 0.
Those system calls return the number of bytes that were received through the socket
itself, as the number of bytes can vary. The ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call designed for stream
sockets (like TCP), while the ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system call designed for datagram
connection-less sockets (like UDP). When the ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call returns 0, it means
that the other party closed the connection.
â€¢ ğ’„ğ’ğ’ğ’”ğ’†(ğŸ) and ğ’”ğ’‰ğ’–ğ’•ğ’…ğ’ğ’˜ğ’(ğŸ) â€“ The ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) and ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2) system calls close
the socket. While ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) system call closes the whole socket, the ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2)
system call partially closes the socket for read/write.
 Communication Networks Course
Page | 12
Appendix C â€“ Random data generator
The data that you are going to send in this assignment is randomly generated. You can use
your own file with appropriate size or use the following function (or a function of your own)
to generate the data:
/*
* @brief A random data generator function based on srand() and rand().
* @param size The size of the data to generate (up to 2^32 bytes).
* @return A pointer to the buffer.
*/
char *util_generate_random_data(unsigned int size) {
 char *buffer = NULL;
 // Argument check.
 if (size == 0)
 return NULL;
 buffer = (char *)calloc(size, sizeof(char));
 // Error checking.
 if (buffer == NULL)
 return NULL;
 // Randomize the seed of the random number generator.
 srand(time(NULL));
 for (unsigned int i = 0; i < size; i++)
 *(buffer + i) = ((unsigned int)rand() % 256);
 return buffer;
}
 Communication Networks Course
Page | 13
Appendix D â€“ Checksum function
A checksum is a small-sized block of data derived from another block of digital data for the
purpose of detecting errors that may have been introduced during its transmission or
storage. By themselves, checksums are often used to verify data integrity but are not relied
upon to verify data authenticity.
Below is a simple yet efficient implementation of the checksum function, you can use it for
the assignment, but you can implement your own checksum function.
/*
* @brief A checksum function that returns 16 bit checksum for data.
* @param data The data to do the checksum for.
* @param bytes The length of the data in bytes.
* @return The checksum itself as 16 bit unsigned number.
* @note This function is taken from RFC1071, can be found here:
* @note https://tools.ietf.org/html/rfc1071
* @note It is the simplest way to calculate a checksum and is not very strong.
* However, it is good enough for this assignment.
* @note You are free to use any other checksum function as well.
* You can also use this function as such without any change.
*/
unsigned short int calculate_checksum(void *data, unsigned int bytes) {
 unsigned short int *data_pointer = (unsigned short int *)data;
 unsigned int total_sum = 0;
 // Main summing loop
 while (bytes > 1) {
 total_sum += *data_pointer++;
 bytes -= 2;
 }
 // Add left-over byte, if any
 if (bytes > 0)
 total_sum += *((unsigned char *)data_pointer);
 // Fold 32-bit sum to 16 bits
 while (total_sum >> 16)
 total_sum = (total_sum & 0xFFFF) + (total_sum >> 16);
 return (~((unsigned short int)total_sum));
} Communication Networks Course
Page | 1
Assignment 3 â€“ Transport Layer
Assignment Notes and Instructions
This assignment is to be done in pairs only. You must upload all the necessary files in a ZIP
file named after both of the studentâ€™s ID. For example: ğŸğŸğŸ‘ğŸ’ğŸ“ğŸ”ğŸ•ğŸ–ğŸ—_ğŸ—ğŸ–ğŸ•ğŸ”ğŸ“ğŸ’ğŸ‘ğŸğŸ. ğ’›ğ’Šğ’‘.
1) The assignment must be submitted by the date specified in the submission box.
2) All the assignment files (Code, Wireshark pcap files, PDF) must be submitted in a ZIP file. The
PDF must contain all the necessary screenshots with a description for each one of them.
3) The assignment must be done in pairs only. In exceptional cases, you should send an email to
the course coordinator.
4) You can use any reference material available through the course Moodle website or any
material passed during the exercises.
5) You can use any reference from the web, but copying codes from websites is forbidden; this
includes codes from other GitHub repositories. A student who gets caught in the act will
automatically fail this assignment (score 0). Any website youâ€™ve used to solve the
assignment, every website you used to solve the assignment must be noted in the PDF.
6) No delays in submission without special permission. Lateness without approval will result in
failure of the assignment (score 0).
7) All submissions will be submitted via the course's Moodle website. Email submissions will not
be accepted, resulting in a failure in the assignment.
8) The order and design of the code must be carefully considered. Make sure that the program
output is as clear as possible, comments in the code, and meaningful variable names. You
must also submit a makefile that compiles all the programs.
9) The assignment code must be written in C only.
10) The assignment is personal for each pair, and you should not accept help from other people,
whether outside the university or inside it. You can contact the course staff during reception
hours for help or raise a question in the course forum. Do not transfer code sections
between students, upload solutions or parts of solutions to websites on the Internet or in
various communication groups.
11) Students who copy a solution will receive a 0 in all assignments in the course and a report will
be made to the institutional disciplinary committee.
12) All code files of the assignment are required to both compile and run properly on the Ubuntu
22.04 LTS operating system. This is the operating system where the submissions will be
tested. You mustnâ€™t code it in Windows, as it uses different API for sockets. WSL wonâ€™t work,
as the task needs a tool that works only in a fully Linux environment.
Good Luck!
 Communication Networks Course
Page | 2
Part A â€“ Transmission Control Protocol (TCP) â€“ 30 points
In this part, youâ€™ll write two program files: ğ‘»ğ‘ªğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and ğ‘»ğ‘ªğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
The Sender will send a randomly generated file and the Receiver will receive it and measure
the time it took for his program to receive the file. The file size should be at least 2MB.
When running the Sender and Receiver, they both should support two standard congestion
control algorithms: TCP Reno and TCP Cubic.
Notes:
â€¢ The main goal of this part is to get familiar with the TCP concept of sending
messages between two endpoints.
â€¢ For approaching this part of the assignment, please be sure that you are familiar
with the congestion control algorithms and how to change them using the correct
method in C (see Appendix B for more information).
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). You've
learned that TCP is reliable by design, so you can assume that all the data have been
passed correctly, and thus, no need to recheck.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
Usage:
â€¢ Receiver:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
â€¢ Sender:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port of the Receiver.
â€¢ ğ‘¨ğ‘³ğ‘®ğ‘¶ â€“ The TCP congestion control algorithm that will be used by the party
member (either ğ’“ğ’†ğ’ğ’ for TCP Reno or ğ’„ğ’–ğ’ƒğ’Šğ’„ for TCP Cubic).
 Communication Networks Course
Page | 3
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a TCP socket between the Sender and the
Receiver.
3) Send the file.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a TCP connection between the Receiver and
the Sender.
2) Get a connection from the sender.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./TCP_Receiver -p 1234 -algo reno
Starting Receiver...
Waiting for TCP connection...
Sender connected, beginning to receive file...
File transfer completed.
Waiting for Sender response...
Sender sent exit message.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 4
Part B â€“ Reliable User Datagram Protocol (Reliable UDP or RUDP) â€“ 40 points
Youâ€™ve learned that while TCP is reliable, it lacks speed and has an overhead data of 20 bytes,
compering to UDP that needs only 8 bytes of overhead data.
Reliable UDP or RUDP, is a protocol that uses the UDP protocol for a faster transmission of
data, while adding a reliability layer to it, but without adding too much overhead data like
TCP.
A simple sketch for a RUDP connection would look something like this:
Your task in this part is to implement a Reliable protocol using UDP only. For simplicity, your
implementation should only support a handshake, closing scheme, error checking,
acknowledgment of received packets, and retransmission of lost packets.
Guidance:
â€¢ You can use ğ‘ ğ‘’ğ‘¡ğ‘ ğ‘œğ‘ğ‘˜ğ‘œğ‘ğ‘¡(2) for detecting a timeout.
â€¢ You need to build your own protocol, as Reliable UDP isnâ€™t a standard protocol (see a
draft of RUDP in this link), and no official header is provided. You can use this sketch
for a header, but you can come up with your own protocol, as long as it works.
Where:
o ğ‘³ğ’†ğ’ğ’ˆğ’•ğ’‰ is the length of the data itself, without the RUDP header.
o ğ‘ªğ’‰ğ’†ğ’„ğ’Œğ’”ğ’–ğ’ is a 16bit number that validates the correctness of the data.
o ğ‘­ğ’ğ’‚ğ’ˆğ’” is a special byte where we classify the packet itself (SYN, ACK, etc.).
â€¢ In your PDF, you must explain how your implementation of RUDP works â€“ How does
it detect a timeout to do retransmissions, how does the handshake work, what is the
header overhead, etc.
â€¢ For this part, youâ€™ll write three files: ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¨ğ‘·ğ‘°. ğ’„, ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and
ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
Reliable UDP Header proposed sketch
Byte 0 Byte 1 Byte 2 Byte 3
Length (2 Bytes) Checksum (2 Bytes)
Flags (1 Byte)
Figure 1 - RUDP Protocol Architecture, Geeksforgeeks
 Communication Networks Course
Page | 5
Notes:
â€¢ The Sender will send a random generated file and the Receiver will receive it and
measure the time it took for his program to receive the file. The file size should be at
least 2MB.
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). But, as the
RUDP is based on UDP, itâ€™s not reliable. You must use some form of error checking
(like checksum) to ensure that the packet wasnâ€™t alerted during the transfer.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
â€¢ The RUDP needs support only 1 sender and 1 receiver, for simplicity purposes.
Usage:
â€¢ Receiver:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
â€¢ Sender:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port that both the Sender and the Receiver will use.
The ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„ file will contain all the implementations of the RUDP API functions (That is, to
prevent reusing the same chuck of code both in the Sender and the Receiver.).
The API should support at the bare minimum the following functions (you decide what
parameters to implement, and what are the names of the functions, as long as the API is
explained in the PDF):
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘œğ‘ğ‘˜ğ‘’ğ‘¡() â€“ Creating a RUDP socket and creating a handshake between two
peers.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘’ğ‘›ğ‘‘() â€“ Sending data to the peer. The function should wait for an
acknowledgment packet, and if it didnâ€™t receive any, retransmits the data.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘Ÿğ‘’ğ‘ğ‘£() â€“ Receive data from a peer.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ğ‘™ğ‘œğ‘ ğ‘’() â€“ Closes a connection between peers.
 Communication Networks Course
Page | 6
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a UDP socket between the Sender and the
Receiver.
3) Send the file via the RUDP protocol.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a UDP connection between the Receiver and
the Sender.
2) Get a connection from the sender, by the custom
RUDP protocol youâ€™ve built.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./RUDP_Receiver -p 1234
Starting Receiver...
Waiting for RUDP connection...
Connection request received, sending ACK.
Sender connected, beginning to receive file...
File transfer completed.
ACK sent.
Waiting for Sender response...
Sender sent exit message.
ACK sent.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 7
Part C â€“ Research â€“ 30 points
In this part, youâ€™ll conduct research about your implementations of part A and part B.
In the research itself, each one of the versions (TCP version and UDP version) will be run at
least 5 times (meaning that the file transfer will occur at least 5 times) by the following
conditions:
â€¢ For TCP, youâ€™ll run it in TCP Reno and TCP Cubic, alternating each time, for each
scenario, meaning that you run 5 times with TCP Reno in both Sender and Receiver,
and 5 times with TCP Cubic in both Sender and Receiver.
Bonus (5 points): Create a very large data set â€“ 5 times with TCP Reno in both Sender
and Receiver, 5 times with TCP Reno in Sender and TCP Cubic in Receiver, 5 times
with TCP Cubic in Sender and TCP Reno in Receiver, and 5 times with TCP Cubic in
both Sender and Receiver. This will give you a data set large enough, which allows
you to work with, compare with and to reach a definite conclusion.
â€¢ For RUDP, you will run it 5 times for each scenario.
â€¢ For both TCP and RUDP, you will run them on those scenarios of packet loss:
o 0% packet loss â€“ Control group, simulating perfect connection.
o 2% packet loss â€“ Simulating unstable connection that commonly occur.
o 5% packet loss â€“ Simulating bad connection.
o 10% packet loss â€“ Simulating extremely poor connection.
For each scenario, you must provide a filtered PCAP file and relevant screenshots that
explain each one of the steps in the process. (10 points)
After youâ€™ve gathered the data set for both TCP and Reliable UDP, answer the following
questions:
1) In TCP, which congestion control algorithm gave better results overall? TCP Reno or
TCP Cubic? Which one gave better results on high packet loss? Explain how you came
to this conclusion based on the data set youâ€™ve gathered. (5 points)
2) How did your implementation of Reliable UDP perform overall compared to regular
TCP? Which one is better for high packet loss? (5 points)
3) According to the data youâ€™ve gathered, in which scenarios and applications would we
prefer to use TCP and in which situations would we prefer to use reliable UDP?
Explain your answer. (5 points)
 Communication Networks Course
Page | 8
×¢× ×• ×¢×œ ×”×©××œ×•×ª ×”×‘××•×ª )5 × ×§×•×“×•×ª(:
â— ×‘"×¨×©×ª ×××™× ×”" ×”×›×•×•× ×” ×”×™× ×œ×¨×©×ª ×©×‘×” ××¢×˜ ×××•×“ ×—×‘×™×œ×•×ª ×”×•×œ×›×•×ª ×œ××™×‘×•×“. ×‘"×§×©×¨ ××¨×•×š" ×”×›×•×•× ×” ×”×™×
×œ×§×©×¨ TCP ×©×™×© ×‘×• ×”×¨×‘×” ×××•×“ ××™×“×¢ ×œ×©×œ×•×—. ××•×¦×¢ ×œ×”×’×“×™×œ ×‘ -TCP ××ª SSThreshold ×‘×ª×—×™×œ×ª ×”×§×©×¨.
×‘××™×–×” ××”××§×¨×™× ×”×‘××™× ×”×©×™× ×•×™ ×”×–×” ×¢×©×•×™ ×œ×”×•×¢×™×œ ×‘××™×“×” ×”××™×¨×‘×™×ª? × ××§.
.1 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
.2 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.3 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.4 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.5 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.6 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.7 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.8 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
â— A ×©×•×œ×— ×œ -B ×—×‘×™×œ×•×ª ××™×“×¢ ×‘×××¦×¢×•×ª ×§×©×¨ TCP. × ×ª×•×Ÿ ×›×™ ×”×§×©×¨ ××ª×—×™×œ ×¢× ×—×œ×•×Ÿ ×‘×’×•×“×œ 1MSS. ×”×§×©×¨
××¡×ª×™×™× ×‘×¤×¢× ×”×¨××©×•× ×” ×©×”×•× ××’×™×¢ ×œ -SSthresh. ×‘××”×œ×š ×”×§×©×¨ ×œ× ××•×‘×“×•×ª ×—×‘×™×œ×•×ª. × ×¡××Ÿ ×‘×§×™×¦×•×¨:
.SSthresh=S*MSS
× ×ª×•×Ÿ ×›×™ ×œ××•×¨×š ×›×œ ×”×§×©×¨ rwnd < MSS*S.
××”×™ ×”×ª×¤×•×§×” ×©×œ ×”×§×©×¨ ×-A ×œ-B( ×‘ -sec / Bytes )×‘×–××Ÿ ×”× "×œ? × ××§×™.
]S*MSS / [lg (S) * RTT*2 ×‘×¢×¨×š .1
]S*MSS / [S^0.5 * RTT*2 ×‘×¢×¨×š .2
S*MSS / RTT ×‘×¢×¨×š .3
S^2)*MSS / RTT( ×‘×¢×¨×š .4
â— ×©×ª×™ ×ª×—× ×•×ª ××ª×§×©×¨×•×ª ×‘××•×¤×Ÿ ××œ×—×•×˜×™ ×‘×©×™×˜×ª N Back Go.
× ×¡××Ÿ ×‘-X ××ª ×¡×¤×¨×ª ×”×‘×™×§×•×¨×ª ×©×œ ×”×ª.×–. ×©×œ×š. ×× ×©× ×™ ×©×•×ª×¤×™× ××’×™×©×™× ××ª ×”×ª×¨×’×™×œ ×™×—×“, X ×”×•× ×¡×¤×¨×ª
×”×‘×™×§×•×¨×ª ×‘×¢×œ×ª ×”×¢×¨×š ×”× ××•×š ×™×•×ª×¨ ××‘×™×Ÿ ×”×©×ª×™×™×.
×§×¦×‘ ×”×ª×§×©×•×¨×ª ×”×•× 8Gbps, ×•×’×•×“×œ ×›×œ ×—×‘×™×œ×” ×”×•× KByte*X. ×’×“×œ×™ ×”-headers ×•×” -Acks ×–× ×™×—×™×.
ï¿½ğ‘’ğ‘ ï¿½/ï¿½ï¿½ 8 , ×•×”××¨×—×§ ×‘×™×Ÿ ×”×ª×—× ×•×ª ×”×•× 1Km. ×§×¦×‘ ×”×”×ª×¤×©×˜×•×ª ×”×•× 10 â‹… 2
×–××Ÿ ×¢×™×‘×•×“ ×”× ×ª×•× ×™× ×‘×ª×—× ×•×ª ×–× ×™×—.
××£ ×—×‘×™×œ×” ×•××£ Ack ×œ× ×”×•×œ×›×™× ×œ××™×‘×•×“.
â— ××”×• X ×©×œ×š?
â— ××” ×¦×¨×™×š ×œ×”×™×•×ª ×’×•×“×œ ×—×œ×•×Ÿ ×”××©×œ×•×— ×›×“×™ ×œ×”×‘×˜×™×— ×ª×¤×•×§×” ××§×¡×™××œ×™×ª?
 Communication Networks Course
Page | 9
Bonus â€“ Improving the Reliable UDP â€“ 15 points
Note: This part isnâ€™t mandatory and is a bonus only!
In this part, youâ€™ll improve your RUDP implementation by adding the concepts of flow
control and congestion control from TCP. Youâ€™re free to choose which algorithms to
implement, as long as you explain in your PDF which algorithms youâ€™ve used. Youâ€™ll probably
need to make changes in the original design of the RUDP. Changes only need to be to the API
itself, ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„.
Points distribution:
â€¢ Flow control improvement â€“ 7 Points
â€¢ Congestion control improvement â€“ 8 points.
Guidance:
â€¢ For flow control, you must use one of the Sliding window techniques: stop-and-wait
ARQ, Go-Back-N or Selective repeat.
â€¢ List of known TCP congestion control algorithms, which you can use any one of them
for this bonus task, or makeup your own:
Figure 2 â€“ List of known TCP congestion control algorithms, Wikipedia
 Communication Networks Course
Page | 10
Appendix A â€“ Linux local packet loss tool
To simulate a packet loss in a local network, we'll use a Linux tool that's called Linux Traffic
Control (ğ‘¡ğ‘). This requires a full Linux installation, so working with WSL won't work.
If the tool isn't installed in your machine, you can install it by using the following commands:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’
If the installation didn't work, you can use the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’2
To create a packet loss scenario, type the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘ğ‘‘ğ‘‘ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
After creating a packet loss scenario, you can change the percentage by typing the following
command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘â„ğ‘ğ‘›ğ‘”ğ‘’ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
To remove the packet loss scenario, write the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘‘ğ‘’ğ‘™ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š
 Communication Networks Course
Page | 11
Appendix B â€“ ğ’ğ’‚ğ’(ğŸ) system calls
This appendixâ€™s purpose is to give you a better understanding of socket handling in C.
A recommended reference is Beejâ€™s Guide to Network Programming, by Brian â€œBeej
Jorgensenâ€ Hall, which gives a lot of information about sockets in C and functions.
Functions and documentation links:
â€¢ ğ’”ğ’ğ’„ğ’Œğ’†ğ’•(ğŸ) â€“ A Factory method system call that creates a socket with the given
parameters.
â€¢ ğ’ƒğ’Šğ’ğ’…(ğŸ) â€“ Whenever we create a new socket, we need to bind it to a specific port in
our machine, â€œto catch a portâ€. The port number is managed and used by the kernel
to link incoming packets to the corresponding application socket. The port numbers
are usually fixed. The ğ‘ğ‘‘ğ‘‘ğ‘Ÿ parameter must match the current socket that is used.
â€¢ ğ’ğ’Šğ’”ğ’•ğ’†ğ’(ğŸ) â€“ The ğ‘™ğ‘–ğ‘ ğ‘¡ğ‘’ğ‘›(2) system call doesn't do anything in the mean of
communication but only memory allocation (malloc) for stream sockets only. If we
won't allocate memory, any incoming connection will fail.
â€¢ ğ’„ğ’ğ’ğ’ğ’†ğ’„ğ’•(ğŸ) â€“ The ğ‘ğ‘œğ‘›ğ‘›ğ‘’ğ‘ğ‘¡(2) system call starts the link between a client and a
specific IP address and port number. The connection would complete when the
other side will call the ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call.
â€¢ ğ’‚ğ’„ğ’„ğ’†ğ’‘ğ’•(ğŸ) â€“ The ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call accepts the incoming stream connection
request from the other side, by the listening socket. This system call completes the
three-way handshake of stream socket (like TCP) and opens a new socket that has a
direct communication channel only with the other party in the handshake.
â€¢ ğ’”ğ’†ğ’ğ’…(ğŸ) and ğ’”ğ’†ğ’ğ’…ğ’•ğ’(ğŸ) â€“ The ğ‘ ğ‘’ğ‘›ğ‘‘(2) and ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system calls are an analogy
for the ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’(2) system call, specifcly for sockets, with flags set to 0. Those system
calls return the number of bytes that were sent through the socket itself, as the
number of bytes can vary. The ğ‘ ğ‘’ğ‘›ğ‘‘(2)system call designed for stream sockets (like
TCP), while the ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system call designed for datagram connection-less
sockets (like UDP). When the ğ‘ ğ‘’ğ‘›ğ‘‘(2) system call returns 0, it means that the other
party closed the connection.
â€¢ ğ’“ğ’†ğ’„ğ’—(ğŸ) and ğ’“ğ’†ğ’„ğ’—ğ’‡ğ’“ğ’ğ’(ğŸ) â€“ The ğ‘Ÿğ‘’ğ‘ğ‘£(2) and ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system calls are an
analogy for the ğ‘Ÿğ‘’ğ‘ğ‘‘(2) system call, specifically for sockets, with flags set to 0.
Those system calls return the number of bytes that were received through the socket
itself, as the number of bytes can vary. The ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call designed for stream
sockets (like TCP), while the ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system call designed for datagram
connection-less sockets (like UDP). When the ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call returns 0, it means
that the other party closed the connection.
â€¢ ğ’„ğ’ğ’ğ’”ğ’†(ğŸ) and ğ’”ğ’‰ğ’–ğ’•ğ’…ğ’ğ’˜ğ’(ğŸ) â€“ The ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) and ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2) system calls close
the socket. While ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) system call closes the whole socket, the ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2)
system call partially closes the socket for read/write.
 Communication Networks Course
Page | 12
Appendix C â€“ Random data generator
The data that you are going to send in this assignment is randomly generated. You can use
your own file with appropriate size or use the following function (or a function of your own)
to generate the data:
/*
* @brief A random data generator function based on srand() and rand().
* @param size The size of the data to generate (up to 2^32 bytes).
* @return A pointer to the buffer.
*/
char *util_generate_random_data(unsigned int size) {
 char *buffer = NULL;
 // Argument check.
 if (size == 0)
 return NULL;
 buffer = (char *)calloc(size, sizeof(char));
 // Error checking.
 if (buffer == NULL)
 return NULL;
 // Randomize the seed of the random number generator.
 srand(time(NULL));
 for (unsigned int i = 0; i < size; i++)
 *(buffer + i) = ((unsigned int)rand() % 256);
 return buffer;
}
 Communication Networks Course
Page | 13
Appendix D â€“ Checksum function
A checksum is a small-sized block of data derived from another block of digital data for the
purpose of detecting errors that may have been introduced during its transmission or
storage. By themselves, checksums are often used to verify data integrity but are not relied
upon to verify data authenticity.
Below is a simple yet efficient implementation of the checksum function, you can use it for
the assignment, but you can implement your own checksum function.
/*
* @brief A checksum function that returns 16 bit checksum for data.
* @param data The data to do the checksum for.
* @param bytes The length of the data in bytes.
* @return The checksum itself as 16 bit unsigned number.
* @note This function is taken from RFC1071, can be found here:
* @note https://tools.ietf.org/html/rfc1071
* @note It is the simplest way to calculate a checksum and is not very strong.
* However, it is good enough for this assignment.
* @note You are free to use any other checksum function as well.
* You can also use this function as such without any change.
*/
unsigned short int calculate_checksum(void *data, unsigned int bytes) {
 unsigned short int *data_pointer = (unsigned short int *)data;
 unsigned int total_sum = 0;
 // Main summing loop
 while (bytes > 1) {
 total_sum += *data_pointer++;
 bytes -= 2;
 }
 // Add left-over byte, if any
 if (bytes > 0)
 total_sum += *((unsigned char *)data_pointer);
 // Fold 32-bit sum to 16 bits
 while (total_sum >> 16)
 total_sum = (total_sum & 0xFFFF) + (total_sum >> 16);
 return (~((unsigned short int)total_sum));
} Communication Networks Course
Page | 1
Assignment 3 â€“ Transport Layer
Assignment Notes and Instructions
This assignment is to be done in pairs only. You must upload all the necessary files in a ZIP
file named after both of the studentâ€™s ID. For example: ğŸğŸğŸ‘ğŸ’ğŸ“ğŸ”ğŸ•ğŸ–ğŸ—_ğŸ—ğŸ–ğŸ•ğŸ”ğŸ“ğŸ’ğŸ‘ğŸğŸ. ğ’›ğ’Šğ’‘.
1) The assignment must be submitted by the date specified in the submission box.
2) All the assignment files (Code, Wireshark pcap files, PDF) must be submitted in a ZIP file. The
PDF must contain all the necessary screenshots with a description for each one of them.
3) The assignment must be done in pairs only. In exceptional cases, you should send an email to
the course coordinator.
4) You can use any reference material available through the course Moodle website or any
material passed during the exercises.
5) You can use any reference from the web, but copying codes from websites is forbidden; this
includes codes from other GitHub repositories. A student who gets caught in the act will
automatically fail this assignment (score 0). Any website youâ€™ve used to solve the
assignment, every website you used to solve the assignment must be noted in the PDF.
6) No delays in submission without special permission. Lateness without approval will result in
failure of the assignment (score 0).
7) All submissions will be submitted via the course's Moodle website. Email submissions will not
be accepted, resulting in a failure in the assignment.
8) The order and design of the code must be carefully considered. Make sure that the program
output is as clear as possible, comments in the code, and meaningful variable names. You
must also submit a makefile that compiles all the programs.
9) The assignment code must be written in C only.
10) The assignment is personal for each pair, and you should not accept help from other people,
whether outside the university or inside it. You can contact the course staff during reception
hours for help or raise a question in the course forum. Do not transfer code sections
between students, upload solutions or parts of solutions to websites on the Internet or in
various communication groups.
11) Students who copy a solution will receive a 0 in all assignments in the course and a report will
be made to the institutional disciplinary committee.
12) All code files of the assignment are required to both compile and run properly on the Ubuntu
22.04 LTS operating system. This is the operating system where the submissions will be
tested. You mustnâ€™t code it in Windows, as it uses different API for sockets. WSL wonâ€™t work,
as the task needs a tool that works only in a fully Linux environment.
Good Luck!
 Communication Networks Course
Page | 2
Part A â€“ Transmission Control Protocol (TCP) â€“ 30 points
In this part, youâ€™ll write two program files: ğ‘»ğ‘ªğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and ğ‘»ğ‘ªğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
The Sender will send a randomly generated file and the Receiver will receive it and measure
the time it took for his program to receive the file. The file size should be at least 2MB.
When running the Sender and Receiver, they both should support two standard congestion
control algorithms: TCP Reno and TCP Cubic.
Notes:
â€¢ The main goal of this part is to get familiar with the TCP concept of sending
messages between two endpoints.
â€¢ For approaching this part of the assignment, please be sure that you are familiar
with the congestion control algorithms and how to change them using the correct
method in C (see Appendix B for more information).
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). You've
learned that TCP is reliable by design, so you can assume that all the data have been
passed correctly, and thus, no need to recheck.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
Usage:
â€¢ Receiver:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
â€¢ Sender:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port of the Receiver.
â€¢ ğ‘¨ğ‘³ğ‘®ğ‘¶ â€“ The TCP congestion control algorithm that will be used by the party
member (either ğ’“ğ’†ğ’ğ’ for TCP Reno or ğ’„ğ’–ğ’ƒğ’Šğ’„ for TCP Cubic).
 Communication Networks Course
Page | 3
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a TCP socket between the Sender and the
Receiver.
3) Send the file.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a TCP connection between the Receiver and
the Sender.
2) Get a connection from the sender.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./TCP_Receiver -p 1234 -algo reno
Starting Receiver...
Waiting for TCP connection...
Sender connected, beginning to receive file...
File transfer completed.
Waiting for Sender response...
Sender sent exit message.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 4
Part B â€“ Reliable User Datagram Protocol (Reliable UDP or RUDP) â€“ 40 points
Youâ€™ve learned that while TCP is reliable, it lacks speed and has an overhead data of 20 bytes,
compering to UDP that needs only 8 bytes of overhead data.
Reliable UDP or RUDP, is a protocol that uses the UDP protocol for a faster transmission of
data, while adding a reliability layer to it, but without adding too much overhead data like
TCP.
A simple sketch for a RUDP connection would look something like this:
Your task in this part is to implement a Reliable protocol using UDP only. For simplicity, your
implementation should only support a handshake, closing scheme, error checking,
acknowledgment of received packets, and retransmission of lost packets.
Guidance:
â€¢ You can use ğ‘ ğ‘’ğ‘¡ğ‘ ğ‘œğ‘ğ‘˜ğ‘œğ‘ğ‘¡(2) for detecting a timeout.
â€¢ You need to build your own protocol, as Reliable UDP isnâ€™t a standard protocol (see a
draft of RUDP in this link), and no official header is provided. You can use this sketch
for a header, but you can come up with your own protocol, as long as it works.
Where:
o ğ‘³ğ’†ğ’ğ’ˆğ’•ğ’‰ is the length of the data itself, without the RUDP header.
o ğ‘ªğ’‰ğ’†ğ’„ğ’Œğ’”ğ’–ğ’ is a 16bit number that validates the correctness of the data.
o ğ‘­ğ’ğ’‚ğ’ˆğ’” is a special byte where we classify the packet itself (SYN, ACK, etc.).
â€¢ In your PDF, you must explain how your implementation of RUDP works â€“ How does
it detect a timeout to do retransmissions, how does the handshake work, what is the
header overhead, etc.
â€¢ For this part, youâ€™ll write three files: ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¨ğ‘·ğ‘°. ğ’„, ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and
ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
Reliable UDP Header proposed sketch
Byte 0 Byte 1 Byte 2 Byte 3
Length (2 Bytes) Checksum (2 Bytes)
Flags (1 Byte)
Figure 1 - RUDP Protocol Architecture, Geeksforgeeks
 Communication Networks Course
Page | 5
Notes:
â€¢ The Sender will send a random generated file and the Receiver will receive it and
measure the time it took for his program to receive the file. The file size should be at
least 2MB.
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). But, as the
RUDP is based on UDP, itâ€™s not reliable. You must use some form of error checking
(like checksum) to ensure that the packet wasnâ€™t alerted during the transfer.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
â€¢ The RUDP needs support only 1 sender and 1 receiver, for simplicity purposes.
Usage:
â€¢ Receiver:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
â€¢ Sender:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port that both the Sender and the Receiver will use.
The ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„ file will contain all the implementations of the RUDP API functions (That is, to
prevent reusing the same chuck of code both in the Sender and the Receiver.).
The API should support at the bare minimum the following functions (you decide what
parameters to implement, and what are the names of the functions, as long as the API is
explained in the PDF):
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘œğ‘ğ‘˜ğ‘’ğ‘¡() â€“ Creating a RUDP socket and creating a handshake between two
peers.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘’ğ‘›ğ‘‘() â€“ Sending data to the peer. The function should wait for an
acknowledgment packet, and if it didnâ€™t receive any, retransmits the data.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘Ÿğ‘’ğ‘ğ‘£() â€“ Receive data from a peer.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ğ‘™ğ‘œğ‘ ğ‘’() â€“ Closes a connection between peers.
 Communication Networks Course
Page | 6
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a UDP socket between the Sender and the
Receiver.
3) Send the file via the RUDP protocol.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a UDP connection between the Receiver and
the Sender.
2) Get a connection from the sender, by the custom
RUDP protocol youâ€™ve built.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./RUDP_Receiver -p 1234
Starting Receiver...
Waiting for RUDP connection...
Connection request received, sending ACK.
Sender connected, beginning to receive file...
File transfer completed.
ACK sent.
Waiting for Sender response...
Sender sent exit message.
ACK sent.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 7
Part C â€“ Research â€“ 30 points
In this part, youâ€™ll conduct research about your implementations of part A and part B.
In the research itself, each one of the versions (TCP version and UDP version) will be run at
least 5 times (meaning that the file transfer will occur at least 5 times) by the following
conditions:
â€¢ For TCP, youâ€™ll run it in TCP Reno and TCP Cubic, alternating each time, for each
scenario, meaning that you run 5 times with TCP Reno in both Sender and Receiver,
and 5 times with TCP Cubic in both Sender and Receiver.
Bonus (5 points): Create a very large data set â€“ 5 times with TCP Reno in both Sender
and Receiver, 5 times with TCP Reno in Sender and TCP Cubic in Receiver, 5 times
with TCP Cubic in Sender and TCP Reno in Receiver, and 5 times with TCP Cubic in
both Sender and Receiver. This will give you a data set large enough, which allows
you to work with, compare with and to reach a definite conclusion.
â€¢ For RUDP, you will run it 5 times for each scenario.
â€¢ For both TCP and RUDP, you will run them on those scenarios of packet loss:
o 0% packet loss â€“ Control group, simulating perfect connection.
o 2% packet loss â€“ Simulating unstable connection that commonly occur.
o 5% packet loss â€“ Simulating bad connection.
o 10% packet loss â€“ Simulating extremely poor connection.
For each scenario, you must provide a filtered PCAP file and relevant screenshots that
explain each one of the steps in the process. (10 points)
After youâ€™ve gathered the data set for both TCP and Reliable UDP, answer the following
questions:
1) In TCP, which congestion control algorithm gave better results overall? TCP Reno or
TCP Cubic? Which one gave better results on high packet loss? Explain how you came
to this conclusion based on the data set youâ€™ve gathered. (5 points)
2) How did your implementation of Reliable UDP perform overall compared to regular
TCP? Which one is better for high packet loss? (5 points)
3) According to the data youâ€™ve gathered, in which scenarios and applications would we
prefer to use TCP and in which situations would we prefer to use reliable UDP?
Explain your answer. (5 points)
 Communication Networks Course
Page | 8
×¢× ×• ×¢×œ ×”×©××œ×•×ª ×”×‘××•×ª )5 × ×§×•×“×•×ª(:
â— ×‘"×¨×©×ª ×××™× ×”" ×”×›×•×•× ×” ×”×™× ×œ×¨×©×ª ×©×‘×” ××¢×˜ ×××•×“ ×—×‘×™×œ×•×ª ×”×•×œ×›×•×ª ×œ××™×‘×•×“. ×‘"×§×©×¨ ××¨×•×š" ×”×›×•×•× ×” ×”×™×
×œ×§×©×¨ TCP ×©×™×© ×‘×• ×”×¨×‘×” ×××•×“ ××™×“×¢ ×œ×©×œ×•×—. ××•×¦×¢ ×œ×”×’×“×™×œ ×‘ -TCP ××ª SSThreshold ×‘×ª×—×™×œ×ª ×”×§×©×¨.
×‘××™×–×” ××”××§×¨×™× ×”×‘××™× ×”×©×™× ×•×™ ×”×–×” ×¢×©×•×™ ×œ×”×•×¢×™×œ ×‘××™×“×” ×”××™×¨×‘×™×ª? × ××§.
.1 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
.2 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.3 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.4 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.5 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.6 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.7 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.8 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
â— A ×©×•×œ×— ×œ -B ×—×‘×™×œ×•×ª ××™×“×¢ ×‘×××¦×¢×•×ª ×§×©×¨ TCP. × ×ª×•×Ÿ ×›×™ ×”×§×©×¨ ××ª×—×™×œ ×¢× ×—×œ×•×Ÿ ×‘×’×•×“×œ 1MSS. ×”×§×©×¨
××¡×ª×™×™× ×‘×¤×¢× ×”×¨××©×•× ×” ×©×”×•× ××’×™×¢ ×œ -SSthresh. ×‘××”×œ×š ×”×§×©×¨ ×œ× ××•×‘×“×•×ª ×—×‘×™×œ×•×ª. × ×¡××Ÿ ×‘×§×™×¦×•×¨:
.SSthresh=S*MSS
× ×ª×•×Ÿ ×›×™ ×œ××•×¨×š ×›×œ ×”×§×©×¨ rwnd < MSS*S.
××”×™ ×”×ª×¤×•×§×” ×©×œ ×”×§×©×¨ ×-A ×œ-B( ×‘ -sec / Bytes )×‘×–××Ÿ ×”× "×œ? × ××§×™.
]S*MSS / [lg (S) * RTT*2 ×‘×¢×¨×š .1
]S*MSS / [S^0.5 * RTT*2 ×‘×¢×¨×š .2
S*MSS / RTT ×‘×¢×¨×š .3
S^2)*MSS / RTT( ×‘×¢×¨×š .4
â— ×©×ª×™ ×ª×—× ×•×ª ××ª×§×©×¨×•×ª ×‘××•×¤×Ÿ ××œ×—×•×˜×™ ×‘×©×™×˜×ª N Back Go.
× ×¡××Ÿ ×‘-X ××ª ×¡×¤×¨×ª ×”×‘×™×§×•×¨×ª ×©×œ ×”×ª.×–. ×©×œ×š. ×× ×©× ×™ ×©×•×ª×¤×™× ××’×™×©×™× ××ª ×”×ª×¨×’×™×œ ×™×—×“, X ×”×•× ×¡×¤×¨×ª
×”×‘×™×§×•×¨×ª ×‘×¢×œ×ª ×”×¢×¨×š ×”× ××•×š ×™×•×ª×¨ ××‘×™×Ÿ ×”×©×ª×™×™×.
×§×¦×‘ ×”×ª×§×©×•×¨×ª ×”×•× 8Gbps, ×•×’×•×“×œ ×›×œ ×—×‘×™×œ×” ×”×•× KByte*X. ×’×“×œ×™ ×”-headers ×•×” -Acks ×–× ×™×—×™×.
ï¿½ğ‘’ğ‘ ï¿½/ï¿½ï¿½ 8 , ×•×”××¨×—×§ ×‘×™×Ÿ ×”×ª×—× ×•×ª ×”×•× 1Km. ×§×¦×‘ ×”×”×ª×¤×©×˜×•×ª ×”×•× 10 â‹… 2
×–××Ÿ ×¢×™×‘×•×“ ×”× ×ª×•× ×™× ×‘×ª×—× ×•×ª ×–× ×™×—.
××£ ×—×‘×™×œ×” ×•××£ Ack ×œ× ×”×•×œ×›×™× ×œ××™×‘×•×“.
â— ××”×• X ×©×œ×š?
â— ××” ×¦×¨×™×š ×œ×”×™×•×ª ×’×•×“×œ ×—×œ×•×Ÿ ×”××©×œ×•×— ×›×“×™ ×œ×”×‘×˜×™×— ×ª×¤×•×§×” ××§×¡×™××œ×™×ª?
 Communication Networks Course
Page | 9
Bonus â€“ Improving the Reliable UDP â€“ 15 points
Note: This part isnâ€™t mandatory and is a bonus only!
In this part, youâ€™ll improve your RUDP implementation by adding the concepts of flow
control and congestion control from TCP. Youâ€™re free to choose which algorithms to
implement, as long as you explain in your PDF which algorithms youâ€™ve used. Youâ€™ll probably
need to make changes in the original design of the RUDP. Changes only need to be to the API
itself, ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„.
Points distribution:
â€¢ Flow control improvement â€“ 7 Points
â€¢ Congestion control improvement â€“ 8 points.
Guidance:
â€¢ For flow control, you must use one of the Sliding window techniques: stop-and-wait
ARQ, Go-Back-N or Selective repeat.
â€¢ List of known TCP congestion control algorithms, which you can use any one of them
for this bonus task, or makeup your own:
Figure 2 â€“ List of known TCP congestion control algorithms, Wikipedia
 Communication Networks Course
Page | 10
Appendix A â€“ Linux local packet loss tool
To simulate a packet loss in a local network, we'll use a Linux tool that's called Linux Traffic
Control (ğ‘¡ğ‘). This requires a full Linux installation, so working with WSL won't work.
If the tool isn't installed in your machine, you can install it by using the following commands:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’
If the installation didn't work, you can use the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’2
To create a packet loss scenario, type the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘ğ‘‘ğ‘‘ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
After creating a packet loss scenario, you can change the percentage by typing the following
command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘â„ğ‘ğ‘›ğ‘”ğ‘’ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
To remove the packet loss scenario, write the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘‘ğ‘’ğ‘™ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š
 Communication Networks Course
Page | 11
Appendix B â€“ ğ’ğ’‚ğ’(ğŸ) system calls
This appendixâ€™s purpose is to give you a better understanding of socket handling in C.
A recommended reference is Beejâ€™s Guide to Network Programming, by Brian â€œBeej
Jorgensenâ€ Hall, which gives a lot of information about sockets in C and functions.
Functions and documentation links:
â€¢ ğ’”ğ’ğ’„ğ’Œğ’†ğ’•(ğŸ) â€“ A Factory method system call that creates a socket with the given
parameters.
â€¢ ğ’ƒğ’Šğ’ğ’…(ğŸ) â€“ Whenever we create a new socket, we need to bind it to a specific port in
our machine, â€œto catch a portâ€. The port number is managed and used by the kernel
to link incoming packets to the corresponding application socket. The port numbers
are usually fixed. The ğ‘ğ‘‘ğ‘‘ğ‘Ÿ parameter must match the current socket that is used.
â€¢ ğ’ğ’Šğ’”ğ’•ğ’†ğ’(ğŸ) â€“ The ğ‘™ğ‘–ğ‘ ğ‘¡ğ‘’ğ‘›(2) system call doesn't do anything in the mean of
communication but only memory allocation (malloc) for stream sockets only. If we
won't allocate memory, any incoming connection will fail.
â€¢ ğ’„ğ’ğ’ğ’ğ’†ğ’„ğ’•(ğŸ) â€“ The ğ‘ğ‘œğ‘›ğ‘›ğ‘’ğ‘ğ‘¡(2) system call starts the link between a client and a
specific IP address and port number. The connection would complete when the
other side will call the ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call.
â€¢ ğ’‚ğ’„ğ’„ğ’†ğ’‘ğ’•(ğŸ) â€“ The ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call accepts the incoming stream connection
request from the other side, by the listening socket. This system call completes the
three-way handshake of stream socket (like TCP) and opens a new socket that has a
direct communication channel only with the other party in the handshake.
â€¢ ğ’”ğ’†ğ’ğ’…(ğŸ) and ğ’”ğ’†ğ’ğ’…ğ’•ğ’(ğŸ) â€“ The ğ‘ ğ‘’ğ‘›ğ‘‘(2) and ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system calls are an analogy
for the ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’(2) system call, specifcly for sockets, with flags set to 0. Those system
calls return the number of bytes that were sent through the socket itself, as the
number of bytes can vary. The ğ‘ ğ‘’ğ‘›ğ‘‘(2)system call designed for stream sockets (like
TCP), while the ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system call designed for datagram connection-less
sockets (like UDP). When the ğ‘ ğ‘’ğ‘›ğ‘‘(2) system call returns 0, it means that the other
party closed the connection.
â€¢ ğ’“ğ’†ğ’„ğ’—(ğŸ) and ğ’“ğ’†ğ’„ğ’—ğ’‡ğ’“ğ’ğ’(ğŸ) â€“ The ğ‘Ÿğ‘’ğ‘ğ‘£(2) and ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system calls are an
analogy for the ğ‘Ÿğ‘’ğ‘ğ‘‘(2) system call, specifically for sockets, with flags set to 0.
Those system calls return the number of bytes that were received through the socket
itself, as the number of bytes can vary. The ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call designed for stream
sockets (like TCP), while the ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system call designed for datagram
connection-less sockets (like UDP). When the ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call returns 0, it means
that the other party closed the connection.
â€¢ ğ’„ğ’ğ’ğ’”ğ’†(ğŸ) and ğ’”ğ’‰ğ’–ğ’•ğ’…ğ’ğ’˜ğ’(ğŸ) â€“ The ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) and ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2) system calls close
the socket. While ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) system call closes the whole socket, the ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2)
system call partially closes the socket for read/write.
 Communication Networks Course
Page | 12
Appendix C â€“ Random data generator
The data that you are going to send in this assignment is randomly generated. You can use
your own file with appropriate size or use the following function (or a function of your own)
to generate the data:
/*
* @brief A random data generator function based on srand() and rand().
* @param size The size of the data to generate (up to 2^32 bytes).
* @return A pointer to the buffer.
*/
char *util_generate_random_data(unsigned int size) {
 char *buffer = NULL;
 // Argument check.
 if (size == 0)
 return NULL;
 buffer = (char *)calloc(size, sizeof(char));
 // Error checking.
 if (buffer == NULL)
 return NULL;
 // Randomize the seed of the random number generator.
 srand(time(NULL));
 for (unsigned int i = 0; i < size; i++)
 *(buffer + i) = ((unsigned int)rand() % 256);
 return buffer;
}
 Communication Networks Course
Page | 13
Appendix D â€“ Checksum function
A checksum is a small-sized block of data derived from another block of digital data for the
purpose of detecting errors that may have been introduced during its transmission or
storage. By themselves, checksums are often used to verify data integrity but are not relied
upon to verify data authenticity.
Below is a simple yet efficient implementation of the checksum function, you can use it for
the assignment, but you can implement your own checksum function.
/*
* @brief A checksum function that returns 16 bit checksum for data.
* @param data The data to do the checksum for.
* @param bytes The length of the data in bytes.
* @return The checksum itself as 16 bit unsigned number.
* @note This function is taken from RFC1071, can be found here:
* @note https://tools.ietf.org/html/rfc1071
* @note It is the simplest way to calculate a checksum and is not very strong.
* However, it is good enough for this assignment.
* @note You are free to use any other checksum function as well.
* You can also use this function as such without any change.
*/
unsigned short int calculate_checksum(void *data, unsigned int bytes) {
 unsigned short int *data_pointer = (unsigned short int *)data;
 unsigned int total_sum = 0;
 // Main summing loop
 while (bytes > 1) {
 total_sum += *data_pointer++;
 bytes -= 2;
 }
 // Add left-over byte, if any
 if (bytes > 0)
 total_sum += *((unsigned char *)data_pointer);
 // Fold 32-bit sum to 16 bits
 while (total_sum >> 16)
 total_sum = (total_sum & 0xFFFF) + (total_sum >> 16);
 return (~((unsigned short int)total_sum));
} Communication Networks Course
Page | 1
Assignment 3 â€“ Transport Layer
Assignment Notes and Instructions
This assignment is to be done in pairs only. You must upload all the necessary files in a ZIP
file named after both of the studentâ€™s ID. For example: ğŸğŸğŸ‘ğŸ’ğŸ“ğŸ”ğŸ•ğŸ–ğŸ—_ğŸ—ğŸ–ğŸ•ğŸ”ğŸ“ğŸ’ğŸ‘ğŸğŸ. ğ’›ğ’Šğ’‘.
1) The assignment must be submitted by the date specified in the submission box.
2) All the assignment files (Code, Wireshark pcap files, PDF) must be submitted in a ZIP file. The
PDF must contain all the necessary screenshots with a description for each one of them.
3) The assignment must be done in pairs only. In exceptional cases, you should send an email to
the course coordinator.
4) You can use any reference material available through the course Moodle website or any
material passed during the exercises.
5) You can use any reference from the web, but copying codes from websites is forbidden; this
includes codes from other GitHub repositories. A student who gets caught in the act will
automatically fail this assignment (score 0). Any website youâ€™ve used to solve the
assignment, every website you used to solve the assignment must be noted in the PDF.
6) No delays in submission without special permission. Lateness without approval will result in
failure of the assignment (score 0).
7) All submissions will be submitted via the course's Moodle website. Email submissions will not
be accepted, resulting in a failure in the assignment.
8) The order and design of the code must be carefully considered. Make sure that the program
output is as clear as possible, comments in the code, and meaningful variable names. You
must also submit a makefile that compiles all the programs.
9) The assignment code must be written in C only.
10) The assignment is personal for each pair, and you should not accept help from other people,
whether outside the university or inside it. You can contact the course staff during reception
hours for help or raise a question in the course forum. Do not transfer code sections
between students, upload solutions or parts of solutions to websites on the Internet or in
various communication groups.
11) Students who copy a solution will receive a 0 in all assignments in the course and a report will
be made to the institutional disciplinary committee.
12) All code files of the assignment are required to both compile and run properly on the Ubuntu
22.04 LTS operating system. This is the operating system where the submissions will be
tested. You mustnâ€™t code it in Windows, as it uses different API for sockets. WSL wonâ€™t work,
as the task needs a tool that works only in a fully Linux environment.
Good Luck!
 Communication Networks Course
Page | 2
Part A â€“ Transmission Control Protocol (TCP) â€“ 30 points
In this part, youâ€™ll write two program files: ğ‘»ğ‘ªğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and ğ‘»ğ‘ªğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
The Sender will send a randomly generated file and the Receiver will receive it and measure
the time it took for his program to receive the file. The file size should be at least 2MB.
When running the Sender and Receiver, they both should support two standard congestion
control algorithms: TCP Reno and TCP Cubic.
Notes:
â€¢ The main goal of this part is to get familiar with the TCP concept of sending
messages between two endpoints.
â€¢ For approaching this part of the assignment, please be sure that you are familiar
with the congestion control algorithms and how to change them using the correct
method in C (see Appendix B for more information).
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). You've
learned that TCP is reliable by design, so you can assume that all the data have been
passed correctly, and thus, no need to recheck.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
Usage:
â€¢ Receiver:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
â€¢ Sender:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port of the Receiver.
â€¢ ğ‘¨ğ‘³ğ‘®ğ‘¶ â€“ The TCP congestion control algorithm that will be used by the party
member (either ğ’“ğ’†ğ’ğ’ for TCP Reno or ğ’„ğ’–ğ’ƒğ’Šğ’„ for TCP Cubic).
 Communication Networks Course
Page | 3
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a TCP socket between the Sender and the
Receiver.
3) Send the file.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a TCP connection between the Receiver and
the Sender.
2) Get a connection from the sender.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./TCP_Receiver -p 1234 -algo reno
Starting Receiver...
Waiting for TCP connection...
Sender connected, beginning to receive file...
File transfer completed.
Waiting for Sender response...
Sender sent exit message.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 4
Part B â€“ Reliable User Datagram Protocol (Reliable UDP or RUDP) â€“ 40 points
Youâ€™ve learned that while TCP is reliable, it lacks speed and has an overhead data of 20 bytes,
compering to UDP that needs only 8 bytes of overhead data.
Reliable UDP or RUDP, is a protocol that uses the UDP protocol for a faster transmission of
data, while adding a reliability layer to it, but without adding too much overhead data like
TCP.
A simple sketch for a RUDP connection would look something like this:
Your task in this part is to implement a Reliable protocol using UDP only. For simplicity, your
implementation should only support a handshake, closing scheme, error checking,
acknowledgment of received packets, and retransmission of lost packets.
Guidance:
â€¢ You can use ğ‘ ğ‘’ğ‘¡ğ‘ ğ‘œğ‘ğ‘˜ğ‘œğ‘ğ‘¡(2) for detecting a timeout.
â€¢ You need to build your own protocol, as Reliable UDP isnâ€™t a standard protocol (see a
draft of RUDP in this link), and no official header is provided. You can use this sketch
for a header, but you can come up with your own protocol, as long as it works.
Where:
o ğ‘³ğ’†ğ’ğ’ˆğ’•ğ’‰ is the length of the data itself, without the RUDP header.
o ğ‘ªğ’‰ğ’†ğ’„ğ’Œğ’”ğ’–ğ’ is a 16bit number that validates the correctness of the data.
o ğ‘­ğ’ğ’‚ğ’ˆğ’” is a special byte where we classify the packet itself (SYN, ACK, etc.).
â€¢ In your PDF, you must explain how your implementation of RUDP works â€“ How does
it detect a timeout to do retransmissions, how does the handshake work, what is the
header overhead, etc.
â€¢ For this part, youâ€™ll write three files: ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¨ğ‘·ğ‘°. ğ’„, ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and
ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
Reliable UDP Header proposed sketch
Byte 0 Byte 1 Byte 2 Byte 3
Length (2 Bytes) Checksum (2 Bytes)
Flags (1 Byte)
Figure 1 - RUDP Protocol Architecture, Geeksforgeeks
 Communication Networks Course
Page | 5
Notes:
â€¢ The Sender will send a random generated file and the Receiver will receive it and
measure the time it took for his program to receive the file. The file size should be at
least 2MB.
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). But, as the
RUDP is based on UDP, itâ€™s not reliable. You must use some form of error checking
(like checksum) to ensure that the packet wasnâ€™t alerted during the transfer.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
â€¢ The RUDP needs support only 1 sender and 1 receiver, for simplicity purposes.
Usage:
â€¢ Receiver:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
â€¢ Sender:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port that both the Sender and the Receiver will use.
The ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„ file will contain all the implementations of the RUDP API functions (That is, to
prevent reusing the same chuck of code both in the Sender and the Receiver.).
The API should support at the bare minimum the following functions (you decide what
parameters to implement, and what are the names of the functions, as long as the API is
explained in the PDF):
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘œğ‘ğ‘˜ğ‘’ğ‘¡() â€“ Creating a RUDP socket and creating a handshake between two
peers.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘’ğ‘›ğ‘‘() â€“ Sending data to the peer. The function should wait for an
acknowledgment packet, and if it didnâ€™t receive any, retransmits the data.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘Ÿğ‘’ğ‘ğ‘£() â€“ Receive data from a peer.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ğ‘™ğ‘œğ‘ ğ‘’() â€“ Closes a connection between peers.
 Communication Networks Course
Page | 6
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a UDP socket between the Sender and the
Receiver.
3) Send the file via the RUDP protocol.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a UDP connection between the Receiver and
the Sender.
2) Get a connection from the sender, by the custom
RUDP protocol youâ€™ve built.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./RUDP_Receiver -p 1234
Starting Receiver...
Waiting for RUDP connection...
Connection request received, sending ACK.
Sender connected, beginning to receive file...
File transfer completed.
ACK sent.
Waiting for Sender response...
Sender sent exit message.
ACK sent.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 7
Part C â€“ Research â€“ 30 points
In this part, youâ€™ll conduct research about your implementations of part A and part B.
In the research itself, each one of the versions (TCP version and UDP version) will be run at
least 5 times (meaning that the file transfer will occur at least 5 times) by the following
conditions:
â€¢ For TCP, youâ€™ll run it in TCP Reno and TCP Cubic, alternating each time, for each
scenario, meaning that you run 5 times with TCP Reno in both Sender and Receiver,
and 5 times with TCP Cubic in both Sender and Receiver.
Bonus (5 points): Create a very large data set â€“ 5 times with TCP Reno in both Sender
and Receiver, 5 times with TCP Reno in Sender and TCP Cubic in Receiver, 5 times
with TCP Cubic in Sender and TCP Reno in Receiver, and 5 times with TCP Cubic in
both Sender and Receiver. This will give you a data set large enough, which allows
you to work with, compare with and to reach a definite conclusion.
â€¢ For RUDP, you will run it 5 times for each scenario.
â€¢ For both TCP and RUDP, you will run them on those scenarios of packet loss:
o 0% packet loss â€“ Control group, simulating perfect connection.
o 2% packet loss â€“ Simulating unstable connection that commonly occur.
o 5% packet loss â€“ Simulating bad connection.
o 10% packet loss â€“ Simulating extremely poor connection.
For each scenario, you must provide a filtered PCAP file and relevant screenshots that
explain each one of the steps in the process. (10 points)
After youâ€™ve gathered the data set for both TCP and Reliable UDP, answer the following
questions:
1) In TCP, which congestion control algorithm gave better results overall? TCP Reno or
TCP Cubic? Which one gave better results on high packet loss? Explain how you came
to this conclusion based on the data set youâ€™ve gathered. (5 points)
2) How did your implementation of Reliable UDP perform overall compared to regular
TCP? Which one is better for high packet loss? (5 points)
3) According to the data youâ€™ve gathered, in which scenarios and applications would we
prefer to use TCP and in which situations would we prefer to use reliable UDP?
Explain your answer. (5 points)
 Communication Networks Course
Page | 8
×¢× ×• ×¢×œ ×”×©××œ×•×ª ×”×‘××•×ª )5 × ×§×•×“×•×ª(:
â— ×‘"×¨×©×ª ×××™× ×”" ×”×›×•×•× ×” ×”×™× ×œ×¨×©×ª ×©×‘×” ××¢×˜ ×××•×“ ×—×‘×™×œ×•×ª ×”×•×œ×›×•×ª ×œ××™×‘×•×“. ×‘"×§×©×¨ ××¨×•×š" ×”×›×•×•× ×” ×”×™×
×œ×§×©×¨ TCP ×©×™×© ×‘×• ×”×¨×‘×” ×××•×“ ××™×“×¢ ×œ×©×œ×•×—. ××•×¦×¢ ×œ×”×’×“×™×œ ×‘ -TCP ××ª SSThreshold ×‘×ª×—×™×œ×ª ×”×§×©×¨.
×‘××™×–×” ××”××§×¨×™× ×”×‘××™× ×”×©×™× ×•×™ ×”×–×” ×¢×©×•×™ ×œ×”×•×¢×™×œ ×‘××™×“×” ×”××™×¨×‘×™×ª? × ××§.
.1 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
.2 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.3 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.4 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.5 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.6 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.7 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.8 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
â— A ×©×•×œ×— ×œ -B ×—×‘×™×œ×•×ª ××™×“×¢ ×‘×××¦×¢×•×ª ×§×©×¨ TCP. × ×ª×•×Ÿ ×›×™ ×”×§×©×¨ ××ª×—×™×œ ×¢× ×—×œ×•×Ÿ ×‘×’×•×“×œ 1MSS. ×”×§×©×¨
××¡×ª×™×™× ×‘×¤×¢× ×”×¨××©×•× ×” ×©×”×•× ××’×™×¢ ×œ -SSthresh. ×‘××”×œ×š ×”×§×©×¨ ×œ× ××•×‘×“×•×ª ×—×‘×™×œ×•×ª. × ×¡××Ÿ ×‘×§×™×¦×•×¨:
.SSthresh=S*MSS
× ×ª×•×Ÿ ×›×™ ×œ××•×¨×š ×›×œ ×”×§×©×¨ rwnd < MSS*S.
××”×™ ×”×ª×¤×•×§×” ×©×œ ×”×§×©×¨ ×-A ×œ-B( ×‘ -sec / Bytes )×‘×–××Ÿ ×”× "×œ? × ××§×™.
]S*MSS / [lg (S) * RTT*2 ×‘×¢×¨×š .1
]S*MSS / [S^0.5 * RTT*2 ×‘×¢×¨×š .2
S*MSS / RTT ×‘×¢×¨×š .3
S^2)*MSS / RTT( ×‘×¢×¨×š .4
â— ×©×ª×™ ×ª×—× ×•×ª ××ª×§×©×¨×•×ª ×‘××•×¤×Ÿ ××œ×—×•×˜×™ ×‘×©×™×˜×ª N Back Go.
× ×¡××Ÿ ×‘-X ××ª ×¡×¤×¨×ª ×”×‘×™×§×•×¨×ª ×©×œ ×”×ª.×–. ×©×œ×š. ×× ×©× ×™ ×©×•×ª×¤×™× ××’×™×©×™× ××ª ×”×ª×¨×’×™×œ ×™×—×“, X ×”×•× ×¡×¤×¨×ª
×”×‘×™×§×•×¨×ª ×‘×¢×œ×ª ×”×¢×¨×š ×”× ××•×š ×™×•×ª×¨ ××‘×™×Ÿ ×”×©×ª×™×™×.
×§×¦×‘ ×”×ª×§×©×•×¨×ª ×”×•× 8Gbps, ×•×’×•×“×œ ×›×œ ×—×‘×™×œ×” ×”×•× KByte*X. ×’×“×œ×™ ×”-headers ×•×” -Acks ×–× ×™×—×™×.
ï¿½ğ‘’ğ‘ ï¿½/ï¿½ï¿½ 8 , ×•×”××¨×—×§ ×‘×™×Ÿ ×”×ª×—× ×•×ª ×”×•× 1Km. ×§×¦×‘ ×”×”×ª×¤×©×˜×•×ª ×”×•× 10 â‹… 2
×–××Ÿ ×¢×™×‘×•×“ ×”× ×ª×•× ×™× ×‘×ª×—× ×•×ª ×–× ×™×—.
××£ ×—×‘×™×œ×” ×•××£ Ack ×œ× ×”×•×œ×›×™× ×œ××™×‘×•×“.
â— ××”×• X ×©×œ×š?
â— ××” ×¦×¨×™×š ×œ×”×™×•×ª ×’×•×“×œ ×—×œ×•×Ÿ ×”××©×œ×•×— ×›×“×™ ×œ×”×‘×˜×™×— ×ª×¤×•×§×” ××§×¡×™××œ×™×ª?
 Communication Networks Course
Page | 9
Bonus â€“ Improving the Reliable UDP â€“ 15 points
Note: This part isnâ€™t mandatory and is a bonus only!
In this part, youâ€™ll improve your RUDP implementation by adding the concepts of flow
control and congestion control from TCP. Youâ€™re free to choose which algorithms to
implement, as long as you explain in your PDF which algorithms youâ€™ve used. Youâ€™ll probably
need to make changes in the original design of the RUDP. Changes only need to be to the API
itself, ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„.
Points distribution:
â€¢ Flow control improvement â€“ 7 Points
â€¢ Congestion control improvement â€“ 8 points.
Guidance:
â€¢ For flow control, you must use one of the Sliding window techniques: stop-and-wait
ARQ, Go-Back-N or Selective repeat.
â€¢ List of known TCP congestion control algorithms, which you can use any one of them
for this bonus task, or makeup your own:
Figure 2 â€“ List of known TCP congestion control algorithms, Wikipedia
 Communication Networks Course
Page | 10
Appendix A â€“ Linux local packet loss tool
To simulate a packet loss in a local network, we'll use a Linux tool that's called Linux Traffic
Control (ğ‘¡ğ‘). This requires a full Linux installation, so working with WSL won't work.
If the tool isn't installed in your machine, you can install it by using the following commands:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’
If the installation didn't work, you can use the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’2
To create a packet loss scenario, type the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘ğ‘‘ğ‘‘ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
After creating a packet loss scenario, you can change the percentage by typing the following
command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘â„ğ‘ğ‘›ğ‘”ğ‘’ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
To remove the packet loss scenario, write the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘‘ğ‘’ğ‘™ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š
 Communication Networks Course
Page | 11
Appendix B â€“ ğ’ğ’‚ğ’(ğŸ) system calls
This appendixâ€™s purpose is to give you a better understanding of socket handling in C.
A recommended reference is Beejâ€™s Guide to Network Programming, by Brian â€œBeej
Jorgensenâ€ Hall, which gives a lot of information about sockets in C and functions.
Functions and documentation links:
â€¢ ğ’”ğ’ğ’„ğ’Œğ’†ğ’•(ğŸ) â€“ A Factory method system call that creates a socket with the given
parameters.
â€¢ ğ’ƒğ’Šğ’ğ’…(ğŸ) â€“ Whenever we create a new socket, we need to bind it to a specific port in
our machine, â€œto catch a portâ€. The port number is managed and used by the kernel
to link incoming packets to the corresponding application socket. The port numbers
are usually fixed. The ğ‘ğ‘‘ğ‘‘ğ‘Ÿ parameter must match the current socket that is used.
â€¢ ğ’ğ’Šğ’”ğ’•ğ’†ğ’(ğŸ) â€“ The ğ‘™ğ‘–ğ‘ ğ‘¡ğ‘’ğ‘›(2) system call doesn't do anything in the mean of
communication but only memory allocation (malloc) for stream sockets only. If we
won't allocate memory, any incoming connection will fail.
â€¢ ğ’„ğ’ğ’ğ’ğ’†ğ’„ğ’•(ğŸ) â€“ The ğ‘ğ‘œğ‘›ğ‘›ğ‘’ğ‘ğ‘¡(2) system call starts the link between a client and a
specific IP address and port number. The connection would complete when the
other side will call the ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call.
â€¢ ğ’‚ğ’„ğ’„ğ’†ğ’‘ğ’•(ğŸ) â€“ The ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call accepts the incoming stream connection
request from the other side, by the listening socket. This system call completes the
three-way handshake of stream socket (like TCP) and opens a new socket that has a
direct communication channel only with the other party in the handshake.
â€¢ ğ’”ğ’†ğ’ğ’…(ğŸ) and ğ’”ğ’†ğ’ğ’…ğ’•ğ’(ğŸ) â€“ The ğ‘ ğ‘’ğ‘›ğ‘‘(2) and ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system calls are an analogy
for the ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’(2) system call, specifcly for sockets, with flags set to 0. Those system
calls return the number of bytes that were sent through the socket itself, as the
number of bytes can vary. The ğ‘ ğ‘’ğ‘›ğ‘‘(2)system call designed for stream sockets (like
TCP), while the ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system call designed for datagram connection-less
sockets (like UDP). When the ğ‘ ğ‘’ğ‘›ğ‘‘(2) system call returns 0, it means that the other
party closed the connection.
â€¢ ğ’“ğ’†ğ’„ğ’—(ğŸ) and ğ’“ğ’†ğ’„ğ’—ğ’‡ğ’“ğ’ğ’(ğŸ) â€“ The ğ‘Ÿğ‘’ğ‘ğ‘£(2) and ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system calls are an
analogy for the ğ‘Ÿğ‘’ğ‘ğ‘‘(2) system call, specifically for sockets, with flags set to 0.
Those system calls return the number of bytes that were received through the socket
itself, as the number of bytes can vary. The ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call designed for stream
sockets (like TCP), while the ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system call designed for datagram
connection-less sockets (like UDP). When the ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call returns 0, it means
that the other party closed the connection.
â€¢ ğ’„ğ’ğ’ğ’”ğ’†(ğŸ) and ğ’”ğ’‰ğ’–ğ’•ğ’…ğ’ğ’˜ğ’(ğŸ) â€“ The ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) and ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2) system calls close
the socket. While ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) system call closes the whole socket, the ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2)
system call partially closes the socket for read/write.
 Communication Networks Course
Page | 12
Appendix C â€“ Random data generator
The data that you are going to send in this assignment is randomly generated. You can use
your own file with appropriate size or use the following function (or a function of your own)
to generate the data:
/*
* @brief A random data generator function based on srand() and rand().
* @param size The size of the data to generate (up to 2^32 bytes).
* @return A pointer to the buffer.
*/
char *util_generate_random_data(unsigned int size) {
 char *buffer = NULL;
 // Argument check.
 if (size == 0)
 return NULL;
 buffer = (char *)calloc(size, sizeof(char));
 // Error checking.
 if (buffer == NULL)
 return NULL;
 // Randomize the seed of the random number generator.
 srand(time(NULL));
 for (unsigned int i = 0; i < size; i++)
 *(buffer + i) = ((unsigned int)rand() % 256);
 return buffer;
}
 Communication Networks Course
Page | 13
Appendix D â€“ Checksum function
A checksum is a small-sized block of data derived from another block of digital data for the
purpose of detecting errors that may have been introduced during its transmission or
storage. By themselves, checksums are often used to verify data integrity but are not relied
upon to verify data authenticity.
Below is a simple yet efficient implementation of the checksum function, you can use it for
the assignment, but you can implement your own checksum function.
/*
* @brief A checksum function that returns 16 bit checksum for data.
* @param data The data to do the checksum for.
* @param bytes The length of the data in bytes.
* @return The checksum itself as 16 bit unsigned number.
* @note This function is taken from RFC1071, can be found here:
* @note https://tools.ietf.org/html/rfc1071
* @note It is the simplest way to calculate a checksum and is not very strong.
* However, it is good enough for this assignment.
* @note You are free to use any other checksum function as well.
* You can also use this function as such without any change.
*/
unsigned short int calculate_checksum(void *data, unsigned int bytes) {
 unsigned short int *data_pointer = (unsigned short int *)data;
 unsigned int total_sum = 0;
 // Main summing loop
 while (bytes > 1) {
 total_sum += *data_pointer++;
 bytes -= 2;
 }
 // Add left-over byte, if any
 if (bytes > 0)
 total_sum += *((unsigned char *)data_pointer);
 // Fold 32-bit sum to 16 bits
 while (total_sum >> 16)
 total_sum = (total_sum & 0xFFFF) + (total_sum >> 16);
 return (~((unsigned short int)total_sum));
} Communication Networks Course
Page | 1
Assignment 3 â€“ Transport Layer
Assignment Notes and Instructions
This assignment is to be done in pairs only. You must upload all the necessary files in a ZIP
file named after both of the studentâ€™s ID. For example: ğŸğŸğŸ‘ğŸ’ğŸ“ğŸ”ğŸ•ğŸ–ğŸ—_ğŸ—ğŸ–ğŸ•ğŸ”ğŸ“ğŸ’ğŸ‘ğŸğŸ. ğ’›ğ’Šğ’‘.
1) The assignment must be submitted by the date specified in the submission box.
2) All the assignment files (Code, Wireshark pcap files, PDF) must be submitted in a ZIP file. The
PDF must contain all the necessary screenshots with a description for each one of them.
3) The assignment must be done in pairs only. In exceptional cases, you should send an email to
the course coordinator.
4) You can use any reference material available through the course Moodle website or any
material passed during the exercises.
5) You can use any reference from the web, but copying codes from websites is forbidden; this
includes codes from other GitHub repositories. A student who gets caught in the act will
automatically fail this assignment (score 0). Any website youâ€™ve used to solve the
assignment, every website you used to solve the assignment must be noted in the PDF.
6) No delays in submission without special permission. Lateness without approval will result in
failure of the assignment (score 0).
7) All submissions will be submitted via the course's Moodle website. Email submissions will not
be accepted, resulting in a failure in the assignment.
8) The order and design of the code must be carefully considered. Make sure that the program
output is as clear as possible, comments in the code, and meaningful variable names. You
must also submit a makefile that compiles all the programs.
9) The assignment code must be written in C only.
10) The assignment is personal for each pair, and you should not accept help from other people,
whether outside the university or inside it. You can contact the course staff during reception
hours for help or raise a question in the course forum. Do not transfer code sections
between students, upload solutions or parts of solutions to websites on the Internet or in
various communication groups.
11) Students who copy a solution will receive a 0 in all assignments in the course and a report will
be made to the institutional disciplinary committee.
12) All code files of the assignment are required to both compile and run properly on the Ubuntu
22.04 LTS operating system. This is the operating system where the submissions will be
tested. You mustnâ€™t code it in Windows, as it uses different API for sockets. WSL wonâ€™t work,
as the task needs a tool that works only in a fully Linux environment.
Good Luck!
 Communication Networks Course
Page | 2
Part A â€“ Transmission Control Protocol (TCP) â€“ 30 points
In this part, youâ€™ll write two program files: ğ‘»ğ‘ªğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and ğ‘»ğ‘ªğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
The Sender will send a randomly generated file and the Receiver will receive it and measure
the time it took for his program to receive the file. The file size should be at least 2MB.
When running the Sender and Receiver, they both should support two standard congestion
control algorithms: TCP Reno and TCP Cubic.
Notes:
â€¢ The main goal of this part is to get familiar with the TCP concept of sending
messages between two endpoints.
â€¢ For approaching this part of the assignment, please be sure that you are familiar
with the congestion control algorithms and how to change them using the correct
method in C (see Appendix B for more information).
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). You've
learned that TCP is reliable by design, so you can assume that all the data have been
passed correctly, and thus, no need to recheck.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
Usage:
â€¢ Receiver:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
â€¢ Sender:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port of the Receiver.
â€¢ ğ‘¨ğ‘³ğ‘®ğ‘¶ â€“ The TCP congestion control algorithm that will be used by the party
member (either ğ’“ğ’†ğ’ğ’ for TCP Reno or ğ’„ğ’–ğ’ƒğ’Šğ’„ for TCP Cubic).
 Communication Networks Course
Page | 3
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a TCP socket between the Sender and the
Receiver.
3) Send the file.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a TCP connection between the Receiver and
the Sender.
2) Get a connection from the sender.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./TCP_Receiver -p 1234 -algo reno
Starting Receiver...
Waiting for TCP connection...
Sender connected, beginning to receive file...
File transfer completed.
Waiting for Sender response...
Sender sent exit message.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 4
Part B â€“ Reliable User Datagram Protocol (Reliable UDP or RUDP) â€“ 40 points
Youâ€™ve learned that while TCP is reliable, it lacks speed and has an overhead data of 20 bytes,
compering to UDP that needs only 8 bytes of overhead data.
Reliable UDP or RUDP, is a protocol that uses the UDP protocol for a faster transmission of
data, while adding a reliability layer to it, but without adding too much overhead data like
TCP.
A simple sketch for a RUDP connection would look something like this:
Your task in this part is to implement a Reliable protocol using UDP only. For simplicity, your
implementation should only support a handshake, closing scheme, error checking,
acknowledgment of received packets, and retransmission of lost packets.
Guidance:
â€¢ You can use ğ‘ ğ‘’ğ‘¡ğ‘ ğ‘œğ‘ğ‘˜ğ‘œğ‘ğ‘¡(2) for detecting a timeout.
â€¢ You need to build your own protocol, as Reliable UDP isnâ€™t a standard protocol (see a
draft of RUDP in this link), and no official header is provided. You can use this sketch
for a header, but you can come up with your own protocol, as long as it works.
Where:
o ğ‘³ğ’†ğ’ğ’ˆğ’•ğ’‰ is the length of the data itself, without the RUDP header.
o ğ‘ªğ’‰ğ’†ğ’„ğ’Œğ’”ğ’–ğ’ is a 16bit number that validates the correctness of the data.
o ğ‘­ğ’ğ’‚ğ’ˆğ’” is a special byte where we classify the packet itself (SYN, ACK, etc.).
â€¢ In your PDF, you must explain how your implementation of RUDP works â€“ How does
it detect a timeout to do retransmissions, how does the handshake work, what is the
header overhead, etc.
â€¢ For this part, youâ€™ll write three files: ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¨ğ‘·ğ‘°. ğ’„, ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and
ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
Reliable UDP Header proposed sketch
Byte 0 Byte 1 Byte 2 Byte 3
Length (2 Bytes) Checksum (2 Bytes)
Flags (1 Byte)
Figure 1 - RUDP Protocol Architecture, Geeksforgeeks
 Communication Networks Course
Page | 5
Notes:
â€¢ The Sender will send a random generated file and the Receiver will receive it and
measure the time it took for his program to receive the file. The file size should be at
least 2MB.
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). But, as the
RUDP is based on UDP, itâ€™s not reliable. You must use some form of error checking
(like checksum) to ensure that the packet wasnâ€™t alerted during the transfer.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
â€¢ The RUDP needs support only 1 sender and 1 receiver, for simplicity purposes.
Usage:
â€¢ Receiver:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
â€¢ Sender:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port that both the Sender and the Receiver will use.
The ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„ file will contain all the implementations of the RUDP API functions (That is, to
prevent reusing the same chuck of code both in the Sender and the Receiver.).
The API should support at the bare minimum the following functions (you decide what
parameters to implement, and what are the names of the functions, as long as the API is
explained in the PDF):
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘œğ‘ğ‘˜ğ‘’ğ‘¡() â€“ Creating a RUDP socket and creating a handshake between two
peers.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘’ğ‘›ğ‘‘() â€“ Sending data to the peer. The function should wait for an
acknowledgment packet, and if it didnâ€™t receive any, retransmits the data.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘Ÿğ‘’ğ‘ğ‘£() â€“ Receive data from a peer.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ğ‘™ğ‘œğ‘ ğ‘’() â€“ Closes a connection between peers.
 Communication Networks Course
Page | 6
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a UDP socket between the Sender and the
Receiver.
3) Send the file via the RUDP protocol.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a UDP connection between the Receiver and
the Sender.
2) Get a connection from the sender, by the custom
RUDP protocol youâ€™ve built.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./RUDP_Receiver -p 1234
Starting Receiver...
Waiting for RUDP connection...
Connection request received, sending ACK.
Sender connected, beginning to receive file...
File transfer completed.
ACK sent.
Waiting for Sender response...
Sender sent exit message.
ACK sent.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 7
Part C â€“ Research â€“ 30 points
In this part, youâ€™ll conduct research about your implementations of part A and part B.
In the research itself, each one of the versions (TCP version and UDP version) will be run at
least 5 times (meaning that the file transfer will occur at least 5 times) by the following
conditions:
â€¢ For TCP, youâ€™ll run it in TCP Reno and TCP Cubic, alternating each time, for each
scenario, meaning that you run 5 times with TCP Reno in both Sender and Receiver,
and 5 times with TCP Cubic in both Sender and Receiver.
Bonus (5 points): Create a very large data set â€“ 5 times with TCP Reno in both Sender
and Receiver, 5 times with TCP Reno in Sender and TCP Cubic in Receiver, 5 times
with TCP Cubic in Sender and TCP Reno in Receiver, and 5 times with TCP Cubic in
both Sender and Receiver. This will give you a data set large enough, which allows
you to work with, compare with and to reach a definite conclusion.
â€¢ For RUDP, you will run it 5 times for each scenario.
â€¢ For both TCP and RUDP, you will run them on those scenarios of packet loss:
o 0% packet loss â€“ Control group, simulating perfect connection.
o 2% packet loss â€“ Simulating unstable connection that commonly occur.
o 5% packet loss â€“ Simulating bad connection.
o 10% packet loss â€“ Simulating extremely poor connection.
For each scenario, you must provide a filtered PCAP file and relevant screenshots that
explain each one of the steps in the process. (10 points)
After youâ€™ve gathered the data set for both TCP and Reliable UDP, answer the following
questions:
1) In TCP, which congestion control algorithm gave better results overall? TCP Reno or
TCP Cubic? Which one gave better results on high packet loss? Explain how you came
to this conclusion based on the data set youâ€™ve gathered. (5 points)
2) How did your implementation of Reliable UDP perform overall compared to regular
TCP? Which one is better for high packet loss? (5 points)
3) According to the data youâ€™ve gathered, in which scenarios and applications would we
prefer to use TCP and in which situations would we prefer to use reliable UDP?
Explain your answer. (5 points)
 Communication Networks Course
Page | 8
×¢× ×• ×¢×œ ×”×©××œ×•×ª ×”×‘××•×ª )5 × ×§×•×“×•×ª(:
â— ×‘"×¨×©×ª ×××™× ×”" ×”×›×•×•× ×” ×”×™× ×œ×¨×©×ª ×©×‘×” ××¢×˜ ×××•×“ ×—×‘×™×œ×•×ª ×”×•×œ×›×•×ª ×œ××™×‘×•×“. ×‘"×§×©×¨ ××¨×•×š" ×”×›×•×•× ×” ×”×™×
×œ×§×©×¨ TCP ×©×™×© ×‘×• ×”×¨×‘×” ×××•×“ ××™×“×¢ ×œ×©×œ×•×—. ××•×¦×¢ ×œ×”×’×“×™×œ ×‘ -TCP ××ª SSThreshold ×‘×ª×—×™×œ×ª ×”×§×©×¨.
×‘××™×–×” ××”××§×¨×™× ×”×‘××™× ×”×©×™× ×•×™ ×”×–×” ×¢×©×•×™ ×œ×”×•×¢×™×œ ×‘××™×“×” ×”××™×¨×‘×™×ª? × ××§.
.1 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
.2 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.3 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.4 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.5 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.6 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.7 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.8 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
â— A ×©×•×œ×— ×œ -B ×—×‘×™×œ×•×ª ××™×“×¢ ×‘×××¦×¢×•×ª ×§×©×¨ TCP. × ×ª×•×Ÿ ×›×™ ×”×§×©×¨ ××ª×—×™×œ ×¢× ×—×œ×•×Ÿ ×‘×’×•×“×œ 1MSS. ×”×§×©×¨
××¡×ª×™×™× ×‘×¤×¢× ×”×¨××©×•× ×” ×©×”×•× ××’×™×¢ ×œ -SSthresh. ×‘××”×œ×š ×”×§×©×¨ ×œ× ××•×‘×“×•×ª ×—×‘×™×œ×•×ª. × ×¡××Ÿ ×‘×§×™×¦×•×¨:
.SSthresh=S*MSS
× ×ª×•×Ÿ ×›×™ ×œ××•×¨×š ×›×œ ×”×§×©×¨ rwnd < MSS*S.
××”×™ ×”×ª×¤×•×§×” ×©×œ ×”×§×©×¨ ×-A ×œ-B( ×‘ -sec / Bytes )×‘×–××Ÿ ×”× "×œ? × ××§×™.
]S*MSS / [lg (S) * RTT*2 ×‘×¢×¨×š .1
]S*MSS / [S^0.5 * RTT*2 ×‘×¢×¨×š .2
S*MSS / RTT ×‘×¢×¨×š .3
S^2)*MSS / RTT( ×‘×¢×¨×š .4
â— ×©×ª×™ ×ª×—× ×•×ª ××ª×§×©×¨×•×ª ×‘××•×¤×Ÿ ××œ×—×•×˜×™ ×‘×©×™×˜×ª N Back Go.
× ×¡××Ÿ ×‘-X ××ª ×¡×¤×¨×ª ×”×‘×™×§×•×¨×ª ×©×œ ×”×ª.×–. ×©×œ×š. ×× ×©× ×™ ×©×•×ª×¤×™× ××’×™×©×™× ××ª ×”×ª×¨×’×™×œ ×™×—×“, X ×”×•× ×¡×¤×¨×ª
×”×‘×™×§×•×¨×ª ×‘×¢×œ×ª ×”×¢×¨×š ×”× ××•×š ×™×•×ª×¨ ××‘×™×Ÿ ×”×©×ª×™×™×.
×§×¦×‘ ×”×ª×§×©×•×¨×ª ×”×•× 8Gbps, ×•×’×•×“×œ ×›×œ ×—×‘×™×œ×” ×”×•× KByte*X. ×’×“×œ×™ ×”-headers ×•×” -Acks ×–× ×™×—×™×.
ï¿½ğ‘’ğ‘ ï¿½/ï¿½ï¿½ 8 , ×•×”××¨×—×§ ×‘×™×Ÿ ×”×ª×—× ×•×ª ×”×•× 1Km. ×§×¦×‘ ×”×”×ª×¤×©×˜×•×ª ×”×•× 10 â‹… 2
×–××Ÿ ×¢×™×‘×•×“ ×”× ×ª×•× ×™× ×‘×ª×—× ×•×ª ×–× ×™×—.
××£ ×—×‘×™×œ×” ×•××£ Ack ×œ× ×”×•×œ×›×™× ×œ××™×‘×•×“.
â— ××”×• X ×©×œ×š?
â— ××” ×¦×¨×™×š ×œ×”×™×•×ª ×’×•×“×œ ×—×œ×•×Ÿ ×”××©×œ×•×— ×›×“×™ ×œ×”×‘×˜×™×— ×ª×¤×•×§×” ××§×¡×™××œ×™×ª?
 Communication Networks Course
Page | 9
Bonus â€“ Improving the Reliable UDP â€“ 15 points
Note: This part isnâ€™t mandatory and is a bonus only!
In this part, youâ€™ll improve your RUDP implementation by adding the concepts of flow
control and congestion control from TCP. Youâ€™re free to choose which algorithms to
implement, as long as you explain in your PDF which algorithms youâ€™ve used. Youâ€™ll probably
need to make changes in the original design of the RUDP. Changes only need to be to the API
itself, ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„.
Points distribution:
â€¢ Flow control improvement â€“ 7 Points
â€¢ Congestion control improvement â€“ 8 points.
Guidance:
â€¢ For flow control, you must use one of the Sliding window techniques: stop-and-wait
ARQ, Go-Back-N or Selective repeat.
â€¢ List of known TCP congestion control algorithms, which you can use any one of them
for this bonus task, or makeup your own:
Figure 2 â€“ List of known TCP congestion control algorithms, Wikipedia
 Communication Networks Course
Page | 10
Appendix A â€“ Linux local packet loss tool
To simulate a packet loss in a local network, we'll use a Linux tool that's called Linux Traffic
Control (ğ‘¡ğ‘). This requires a full Linux installation, so working with WSL won't work.
If the tool isn't installed in your machine, you can install it by using the following commands:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’
If the installation didn't work, you can use the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’2
To create a packet loss scenario, type the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘ğ‘‘ğ‘‘ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
After creating a packet loss scenario, you can change the percentage by typing the following
command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘â„ğ‘ğ‘›ğ‘”ğ‘’ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
To remove the packet loss scenario, write the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘‘ğ‘’ğ‘™ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š
 Communication Networks Course
Page | 11
Appendix B â€“ ğ’ğ’‚ğ’(ğŸ) system calls
This appendixâ€™s purpose is to give you a better understanding of socket handling in C.
A recommended reference is Beejâ€™s Guide to Network Programming, by Brian â€œBeej
Jorgensenâ€ Hall, which gives a lot of information about sockets in C and functions.
Functions and documentation links:
â€¢ ğ’”ğ’ğ’„ğ’Œğ’†ğ’•(ğŸ) â€“ A Factory method system call that creates a socket with the given
parameters.
â€¢ ğ’ƒğ’Šğ’ğ’…(ğŸ) â€“ Whenever we create a new socket, we need to bind it to a specific port in
our machine, â€œto catch a portâ€. The port number is managed and used by the kernel
to link incoming packets to the corresponding application socket. The port numbers
are usually fixed. The ğ‘ğ‘‘ğ‘‘ğ‘Ÿ parameter must match the current socket that is used.
â€¢ ğ’ğ’Šğ’”ğ’•ğ’†ğ’(ğŸ) â€“ The ğ‘™ğ‘–ğ‘ ğ‘¡ğ‘’ğ‘›(2) system call doesn't do anything in the mean of
communication but only memory allocation (malloc) for stream sockets only. If we
won't allocate memory, any incoming connection will fail.
â€¢ ğ’„ğ’ğ’ğ’ğ’†ğ’„ğ’•(ğŸ) â€“ The ğ‘ğ‘œğ‘›ğ‘›ğ‘’ğ‘ğ‘¡(2) system call starts the link between a client and a
specific IP address and port number. The connection would complete when the
other side will call the ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call.
â€¢ ğ’‚ğ’„ğ’„ğ’†ğ’‘ğ’•(ğŸ) â€“ The ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call accepts the incoming stream connection
request from the other side, by the listening socket. This system call completes the
three-way handshake of stream socket (like TCP) and opens a new socket that has a
direct communication channel only with the other party in the handshake.
â€¢ ğ’”ğ’†ğ’ğ’…(ğŸ) and ğ’”ğ’†ğ’ğ’…ğ’•ğ’(ğŸ) â€“ The ğ‘ ğ‘’ğ‘›ğ‘‘(2) and ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system calls are an analogy
for the ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’(2) system call, specifcly for sockets, with flags set to 0. Those system
calls return the number of bytes that were sent through the socket itself, as the
number of bytes can vary. The ğ‘ ğ‘’ğ‘›ğ‘‘(2)system call designed for stream sockets (like
TCP), while the ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system call designed for datagram connection-less
sockets (like UDP). When the ğ‘ ğ‘’ğ‘›ğ‘‘(2) system call returns 0, it means that the other
party closed the connection.
â€¢ ğ’“ğ’†ğ’„ğ’—(ğŸ) and ğ’“ğ’†ğ’„ğ’—ğ’‡ğ’“ğ’ğ’(ğŸ) â€“ The ğ‘Ÿğ‘’ğ‘ğ‘£(2) and ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system calls are an
analogy for the ğ‘Ÿğ‘’ğ‘ğ‘‘(2) system call, specifically for sockets, with flags set to 0.
Those system calls return the number of bytes that were received through the socket
itself, as the number of bytes can vary. The ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call designed for stream
sockets (like TCP), while the ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system call designed for datagram
connection-less sockets (like UDP). When the ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call returns 0, it means
that the other party closed the connection.
â€¢ ğ’„ğ’ğ’ğ’”ğ’†(ğŸ) and ğ’”ğ’‰ğ’–ğ’•ğ’…ğ’ğ’˜ğ’(ğŸ) â€“ The ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) and ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2) system calls close
the socket. While ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) system call closes the whole socket, the ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2)
system call partially closes the socket for read/write.
 Communication Networks Course
Page | 12
Appendix C â€“ Random data generator
The data that you are going to send in this assignment is randomly generated. You can use
your own file with appropriate size or use the following function (or a function of your own)
to generate the data:
/*
* @brief A random data generator function based on srand() and rand().
* @param size The size of the data to generate (up to 2^32 bytes).
* @return A pointer to the buffer.
*/
char *util_generate_random_data(unsigned int size) {
 char *buffer = NULL;
 // Argument check.
 if (size == 0)
 return NULL;
 buffer = (char *)calloc(size, sizeof(char));
 // Error checking.
 if (buffer == NULL)
 return NULL;
 // Randomize the seed of the random number generator.
 srand(time(NULL));
 for (unsigned int i = 0; i < size; i++)
 *(buffer + i) = ((unsigned int)rand() % 256);
 return buffer;
}
 Communication Networks Course
Page | 13
Appendix D â€“ Checksum function
A checksum is a small-sized block of data derived from another block of digital data for the
purpose of detecting errors that may have been introduced during its transmission or
storage. By themselves, checksums are often used to verify data integrity but are not relied
upon to verify data authenticity.
Below is a simple yet efficient implementation of the checksum function, you can use it for
the assignment, but you can implement your own checksum function.
/*
* @brief A checksum function that returns 16 bit checksum for data.
* @param data The data to do the checksum for.
* @param bytes The length of the data in bytes.
* @return The checksum itself as 16 bit unsigned number.
* @note This function is taken from RFC1071, can be found here:
* @note https://tools.ietf.org/html/rfc1071
* @note It is the simplest way to calculate a checksum and is not very strong.
* However, it is good enough for this assignment.
* @note You are free to use any other checksum function as well.
* You can also use this function as such without any change.
*/
unsigned short int calculate_checksum(void *data, unsigned int bytes) {
 unsigned short int *data_pointer = (unsigned short int *)data;
 unsigned int total_sum = 0;
 // Main summing loop
 while (bytes > 1) {
 total_sum += *data_pointer++;
 bytes -= 2;
 }
 // Add left-over byte, if any
 if (bytes > 0)
 total_sum += *((unsigned char *)data_pointer);
 // Fold 32-bit sum to 16 bits
 while (total_sum >> 16)
 total_sum = (total_sum & 0xFFFF) + (total_sum >> 16);
 return (~((unsigned short int)total_sum));
} Communication Networks Course
Page | 1
Assignment 3 â€“ Transport Layer
Assignment Notes and Instructions
This assignment is to be done in pairs only. You must upload all the necessary files in a ZIP
file named after both of the studentâ€™s ID. For example: ğŸğŸğŸ‘ğŸ’ğŸ“ğŸ”ğŸ•ğŸ–ğŸ—_ğŸ—ğŸ–ğŸ•ğŸ”ğŸ“ğŸ’ğŸ‘ğŸğŸ. ğ’›ğ’Šğ’‘.
1) The assignment must be submitted by the date specified in the submission box.
2) All the assignment files (Code, Wireshark pcap files, PDF) must be submitted in a ZIP file. The
PDF must contain all the necessary screenshots with a description for each one of them.
3) The assignment must be done in pairs only. In exceptional cases, you should send an email to
the course coordinator.
4) You can use any reference material available through the course Moodle website or any
material passed during the exercises.
5) You can use any reference from the web, but copying codes from websites is forbidden; this
includes codes from other GitHub repositories. A student who gets caught in the act will
automatically fail this assignment (score 0). Any website youâ€™ve used to solve the
assignment, every website you used to solve the assignment must be noted in the PDF.
6) No delays in submission without special permission. Lateness without approval will result in
failure of the assignment (score 0).
7) All submissions will be submitted via the course's Moodle website. Email submissions will not
be accepted, resulting in a failure in the assignment.
8) The order and design of the code must be carefully considered. Make sure that the program
output is as clear as possible, comments in the code, and meaningful variable names. You
must also submit a makefile that compiles all the programs.
9) The assignment code must be written in C only.
10) The assignment is personal for each pair, and you should not accept help from other people,
whether outside the university or inside it. You can contact the course staff during reception
hours for help or raise a question in the course forum. Do not transfer code sections
between students, upload solutions or parts of solutions to websites on the Internet or in
various communication groups.
11) Students who copy a solution will receive a 0 in all assignments in the course and a report will
be made to the institutional disciplinary committee.
12) All code files of the assignment are required to both compile and run properly on the Ubuntu
22.04 LTS operating system. This is the operating system where the submissions will be
tested. You mustnâ€™t code it in Windows, as it uses different API for sockets. WSL wonâ€™t work,
as the task needs a tool that works only in a fully Linux environment.
Good Luck!
 Communication Networks Course
Page | 2
Part A â€“ Transmission Control Protocol (TCP) â€“ 30 points
In this part, youâ€™ll write two program files: ğ‘»ğ‘ªğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and ğ‘»ğ‘ªğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
The Sender will send a randomly generated file and the Receiver will receive it and measure
the time it took for his program to receive the file. The file size should be at least 2MB.
When running the Sender and Receiver, they both should support two standard congestion
control algorithms: TCP Reno and TCP Cubic.
Notes:
â€¢ The main goal of this part is to get familiar with the TCP concept of sending
messages between two endpoints.
â€¢ For approaching this part of the assignment, please be sure that you are familiar
with the congestion control algorithms and how to change them using the correct
method in C (see Appendix B for more information).
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). You've
learned that TCP is reliable by design, so you can assume that all the data have been
passed correctly, and thus, no need to recheck.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
Usage:
â€¢ Receiver:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
â€¢ Sender:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port of the Receiver.
â€¢ ğ‘¨ğ‘³ğ‘®ğ‘¶ â€“ The TCP congestion control algorithm that will be used by the party
member (either ğ’“ğ’†ğ’ğ’ for TCP Reno or ğ’„ğ’–ğ’ƒğ’Šğ’„ for TCP Cubic).
 Communication Networks Course
Page | 3
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a TCP socket between the Sender and the
Receiver.
3) Send the file.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a TCP connection between the Receiver and
the Sender.
2) Get a connection from the sender.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./TCP_Receiver -p 1234 -algo reno
Starting Receiver...
Waiting for TCP connection...
Sender connected, beginning to receive file...
File transfer completed.
Waiting for Sender response...
Sender sent exit message.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 4
Part B â€“ Reliable User Datagram Protocol (Reliable UDP or RUDP) â€“ 40 points
Youâ€™ve learned that while TCP is reliable, it lacks speed and has an overhead data of 20 bytes,
compering to UDP that needs only 8 bytes of overhead data.
Reliable UDP or RUDP, is a protocol that uses the UDP protocol for a faster transmission of
data, while adding a reliability layer to it, but without adding too much overhead data like
TCP.
A simple sketch for a RUDP connection would look something like this:
Your task in this part is to implement a Reliable protocol using UDP only. For simplicity, your
implementation should only support a handshake, closing scheme, error checking,
acknowledgment of received packets, and retransmission of lost packets.
Guidance:
â€¢ You can use ğ‘ ğ‘’ğ‘¡ğ‘ ğ‘œğ‘ğ‘˜ğ‘œğ‘ğ‘¡(2) for detecting a timeout.
â€¢ You need to build your own protocol, as Reliable UDP isnâ€™t a standard protocol (see a
draft of RUDP in this link), and no official header is provided. You can use this sketch
for a header, but you can come up with your own protocol, as long as it works.
Where:
o ğ‘³ğ’†ğ’ğ’ˆğ’•ğ’‰ is the length of the data itself, without the RUDP header.
o ğ‘ªğ’‰ğ’†ğ’„ğ’Œğ’”ğ’–ğ’ is a 16bit number that validates the correctness of the data.
o ğ‘­ğ’ğ’‚ğ’ˆğ’” is a special byte where we classify the packet itself (SYN, ACK, etc.).
â€¢ In your PDF, you must explain how your implementation of RUDP works â€“ How does
it detect a timeout to do retransmissions, how does the handshake work, what is the
header overhead, etc.
â€¢ For this part, youâ€™ll write three files: ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¨ğ‘·ğ‘°. ğ’„, ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and
ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
Reliable UDP Header proposed sketch
Byte 0 Byte 1 Byte 2 Byte 3
Length (2 Bytes) Checksum (2 Bytes)
Flags (1 Byte)
Figure 1 - RUDP Protocol Architecture, Geeksforgeeks
 Communication Networks Course
Page | 5
Notes:
â€¢ The Sender will send a random generated file and the Receiver will receive it and
measure the time it took for his program to receive the file. The file size should be at
least 2MB.
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). But, as the
RUDP is based on UDP, itâ€™s not reliable. You must use some form of error checking
(like checksum) to ensure that the packet wasnâ€™t alerted during the transfer.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
â€¢ The RUDP needs support only 1 sender and 1 receiver, for simplicity purposes.
Usage:
â€¢ Receiver:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
â€¢ Sender:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port that both the Sender and the Receiver will use.
The ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„ file will contain all the implementations of the RUDP API functions (That is, to
prevent reusing the same chuck of code both in the Sender and the Receiver.).
The API should support at the bare minimum the following functions (you decide what
parameters to implement, and what are the names of the functions, as long as the API is
explained in the PDF):
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘œğ‘ğ‘˜ğ‘’ğ‘¡() â€“ Creating a RUDP socket and creating a handshake between two
peers.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘’ğ‘›ğ‘‘() â€“ Sending data to the peer. The function should wait for an
acknowledgment packet, and if it didnâ€™t receive any, retransmits the data.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘Ÿğ‘’ğ‘ğ‘£() â€“ Receive data from a peer.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ğ‘™ğ‘œğ‘ ğ‘’() â€“ Closes a connection between peers.
 Communication Networks Course
Page | 6
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a UDP socket between the Sender and the
Receiver.
3) Send the file via the RUDP protocol.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a UDP connection between the Receiver and
the Sender.
2) Get a connection from the sender, by the custom
RUDP protocol youâ€™ve built.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./RUDP_Receiver -p 1234
Starting Receiver...
Waiting for RUDP connection...
Connection request received, sending ACK.
Sender connected, beginning to receive file...
File transfer completed.
ACK sent.
Waiting for Sender response...
Sender sent exit message.
ACK sent.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 7
Part C â€“ Research â€“ 30 points
In this part, youâ€™ll conduct research about your implementations of part A and part B.
In the research itself, each one of the versions (TCP version and UDP version) will be run at
least 5 times (meaning that the file transfer will occur at least 5 times) by the following
conditions:
â€¢ For TCP, youâ€™ll run it in TCP Reno and TCP Cubic, alternating each time, for each
scenario, meaning that you run 5 times with TCP Reno in both Sender and Receiver,
and 5 times with TCP Cubic in both Sender and Receiver.
Bonus (5 points): Create a very large data set â€“ 5 times with TCP Reno in both Sender
and Receiver, 5 times with TCP Reno in Sender and TCP Cubic in Receiver, 5 times
with TCP Cubic in Sender and TCP Reno in Receiver, and 5 times with TCP Cubic in
both Sender and Receiver. This will give you a data set large enough, which allows
you to work with, compare with and to reach a definite conclusion.
â€¢ For RUDP, you will run it 5 times for each scenario.
â€¢ For both TCP and RUDP, you will run them on those scenarios of packet loss:
o 0% packet loss â€“ Control group, simulating perfect connection.
o 2% packet loss â€“ Simulating unstable connection that commonly occur.
o 5% packet loss â€“ Simulating bad connection.
o 10% packet loss â€“ Simulating extremely poor connection.
For each scenario, you must provide a filtered PCAP file and relevant screenshots that
explain each one of the steps in the process. (10 points)
After youâ€™ve gathered the data set for both TCP and Reliable UDP, answer the following
questions:
1) In TCP, which congestion control algorithm gave better results overall? TCP Reno or
TCP Cubic? Which one gave better results on high packet loss? Explain how you came
to this conclusion based on the data set youâ€™ve gathered. (5 points)
2) How did your implementation of Reliable UDP perform overall compared to regular
TCP? Which one is better for high packet loss? (5 points)
3) According to the data youâ€™ve gathered, in which scenarios and applications would we
prefer to use TCP and in which situations would we prefer to use reliable UDP?
Explain your answer. (5 points)
 Communication Networks Course
Page | 8
×¢× ×• ×¢×œ ×”×©××œ×•×ª ×”×‘××•×ª )5 × ×§×•×“×•×ª(:
â— ×‘"×¨×©×ª ×××™× ×”" ×”×›×•×•× ×” ×”×™× ×œ×¨×©×ª ×©×‘×” ××¢×˜ ×××•×“ ×—×‘×™×œ×•×ª ×”×•×œ×›×•×ª ×œ××™×‘×•×“. ×‘"×§×©×¨ ××¨×•×š" ×”×›×•×•× ×” ×”×™×
×œ×§×©×¨ TCP ×©×™×© ×‘×• ×”×¨×‘×” ×××•×“ ××™×“×¢ ×œ×©×œ×•×—. ××•×¦×¢ ×œ×”×’×“×™×œ ×‘ -TCP ××ª SSThreshold ×‘×ª×—×™×œ×ª ×”×§×©×¨.
×‘××™×–×” ××”××§×¨×™× ×”×‘××™× ×”×©×™× ×•×™ ×”×–×” ×¢×©×•×™ ×œ×”×•×¢×™×œ ×‘××™×“×” ×”××™×¨×‘×™×ª? × ××§.
.1 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
.2 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.3 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.4 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.5 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.6 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.7 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.8 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
â— A ×©×•×œ×— ×œ -B ×—×‘×™×œ×•×ª ××™×“×¢ ×‘×××¦×¢×•×ª ×§×©×¨ TCP. × ×ª×•×Ÿ ×›×™ ×”×§×©×¨ ××ª×—×™×œ ×¢× ×—×œ×•×Ÿ ×‘×’×•×“×œ 1MSS. ×”×§×©×¨
××¡×ª×™×™× ×‘×¤×¢× ×”×¨××©×•× ×” ×©×”×•× ××’×™×¢ ×œ -SSthresh. ×‘××”×œ×š ×”×§×©×¨ ×œ× ××•×‘×“×•×ª ×—×‘×™×œ×•×ª. × ×¡××Ÿ ×‘×§×™×¦×•×¨:
.SSthresh=S*MSS
× ×ª×•×Ÿ ×›×™ ×œ××•×¨×š ×›×œ ×”×§×©×¨ rwnd < MSS*S.
××”×™ ×”×ª×¤×•×§×” ×©×œ ×”×§×©×¨ ×-A ×œ-B( ×‘ -sec / Bytes )×‘×–××Ÿ ×”× "×œ? × ××§×™.
]S*MSS / [lg (S) * RTT*2 ×‘×¢×¨×š .1
]S*MSS / [S^0.5 * RTT*2 ×‘×¢×¨×š .2
S*MSS / RTT ×‘×¢×¨×š .3
S^2)*MSS / RTT( ×‘×¢×¨×š .4
â— ×©×ª×™ ×ª×—× ×•×ª ××ª×§×©×¨×•×ª ×‘××•×¤×Ÿ ××œ×—×•×˜×™ ×‘×©×™×˜×ª N Back Go.
× ×¡××Ÿ ×‘-X ××ª ×¡×¤×¨×ª ×”×‘×™×§×•×¨×ª ×©×œ ×”×ª.×–. ×©×œ×š. ×× ×©× ×™ ×©×•×ª×¤×™× ××’×™×©×™× ××ª ×”×ª×¨×’×™×œ ×™×—×“, X ×”×•× ×¡×¤×¨×ª
×”×‘×™×§×•×¨×ª ×‘×¢×œ×ª ×”×¢×¨×š ×”× ××•×š ×™×•×ª×¨ ××‘×™×Ÿ ×”×©×ª×™×™×.
×§×¦×‘ ×”×ª×§×©×•×¨×ª ×”×•× 8Gbps, ×•×’×•×“×œ ×›×œ ×—×‘×™×œ×” ×”×•× KByte*X. ×’×“×œ×™ ×”-headers ×•×” -Acks ×–× ×™×—×™×.
ï¿½ğ‘’ğ‘ ï¿½/ï¿½ï¿½ 8 , ×•×”××¨×—×§ ×‘×™×Ÿ ×”×ª×—× ×•×ª ×”×•× 1Km. ×§×¦×‘ ×”×”×ª×¤×©×˜×•×ª ×”×•× 10 â‹… 2
×–××Ÿ ×¢×™×‘×•×“ ×”× ×ª×•× ×™× ×‘×ª×—× ×•×ª ×–× ×™×—.
××£ ×—×‘×™×œ×” ×•××£ Ack ×œ× ×”×•×œ×›×™× ×œ××™×‘×•×“.
â— ××”×• X ×©×œ×š?
â— ××” ×¦×¨×™×š ×œ×”×™×•×ª ×’×•×“×œ ×—×œ×•×Ÿ ×”××©×œ×•×— ×›×“×™ ×œ×”×‘×˜×™×— ×ª×¤×•×§×” ××§×¡×™××œ×™×ª?
 Communication Networks Course
Page | 9
Bonus â€“ Improving the Reliable UDP â€“ 15 points
Note: This part isnâ€™t mandatory and is a bonus only!
In this part, youâ€™ll improve your RUDP implementation by adding the concepts of flow
control and congestion control from TCP. Youâ€™re free to choose which algorithms to
implement, as long as you explain in your PDF which algorithms youâ€™ve used. Youâ€™ll probably
need to make changes in the original design of the RUDP. Changes only need to be to the API
itself, ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„.
Points distribution:
â€¢ Flow control improvement â€“ 7 Points
â€¢ Congestion control improvement â€“ 8 points.
Guidance:
â€¢ For flow control, you must use one of the Sliding window techniques: stop-and-wait
ARQ, Go-Back-N or Selective repeat.
â€¢ List of known TCP congestion control algorithms, which you can use any one of them
for this bonus task, or makeup your own:
Figure 2 â€“ List of known TCP congestion control algorithms, Wikipedia
 Communication Networks Course
Page | 10
Appendix A â€“ Linux local packet loss tool
To simulate a packet loss in a local network, we'll use a Linux tool that's called Linux Traffic
Control (ğ‘¡ğ‘). This requires a full Linux installation, so working with WSL won't work.
If the tool isn't installed in your machine, you can install it by using the following commands:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’
If the installation didn't work, you can use the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’2
To create a packet loss scenario, type the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘ğ‘‘ğ‘‘ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
After creating a packet loss scenario, you can change the percentage by typing the following
command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘â„ğ‘ğ‘›ğ‘”ğ‘’ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
To remove the packet loss scenario, write the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘‘ğ‘’ğ‘™ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š
 Communication Networks Course
Page | 11
Appendix B â€“ ğ’ğ’‚ğ’(ğŸ) system calls
This appendixâ€™s purpose is to give you a better understanding of socket handling in C.
A recommended reference is Beejâ€™s Guide to Network Programming, by Brian â€œBeej
Jorgensenâ€ Hall, which gives a lot of information about sockets in C and functions.
Functions and documentation links:
â€¢ ğ’”ğ’ğ’„ğ’Œğ’†ğ’•(ğŸ) â€“ A Factory method system call that creates a socket with the given
parameters.
â€¢ ğ’ƒğ’Šğ’ğ’…(ğŸ) â€“ Whenever we create a new socket, we need to bind it to a specific port in
our machine, â€œto catch a portâ€. The port number is managed and used by the kernel
to link incoming packets to the corresponding application socket. The port numbers
are usually fixed. The ğ‘ğ‘‘ğ‘‘ğ‘Ÿ parameter must match the current socket that is used.
â€¢ ğ’ğ’Šğ’”ğ’•ğ’†ğ’(ğŸ) â€“ The ğ‘™ğ‘–ğ‘ ğ‘¡ğ‘’ğ‘›(2) system call doesn't do anything in the mean of
communication but only memory allocation (malloc) for stream sockets only. If we
won't allocate memory, any incoming connection will fail.
â€¢ ğ’„ğ’ğ’ğ’ğ’†ğ’„ğ’•(ğŸ) â€“ The ğ‘ğ‘œğ‘›ğ‘›ğ‘’ğ‘ğ‘¡(2) system call starts the link between a client and a
specific IP address and port number. The connection would complete when the
other side will call the ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call.
â€¢ ğ’‚ğ’„ğ’„ğ’†ğ’‘ğ’•(ğŸ) â€“ The ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call accepts the incoming stream connection
request from the other side, by the listening socket. This system call completes the
three-way handshake of stream socket (like TCP) and opens a new socket that has a
direct communication channel only with the other party in the handshake.
â€¢ ğ’”ğ’†ğ’ğ’…(ğŸ) and ğ’”ğ’†ğ’ğ’…ğ’•ğ’(ğŸ) â€“ The ğ‘ ğ‘’ğ‘›ğ‘‘(2) and ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system calls are an analogy
for the ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’(2) system call, specifcly for sockets, with flags set to 0. Those system
calls return the number of bytes that were sent through the socket itself, as the
number of bytes can vary. The ğ‘ ğ‘’ğ‘›ğ‘‘(2)system call designed for stream sockets (like
TCP), while the ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system call designed for datagram connection-less
sockets (like UDP). When the ğ‘ ğ‘’ğ‘›ğ‘‘(2) system call returns 0, it means that the other
party closed the connection.
â€¢ ğ’“ğ’†ğ’„ğ’—(ğŸ) and ğ’“ğ’†ğ’„ğ’—ğ’‡ğ’“ğ’ğ’(ğŸ) â€“ The ğ‘Ÿğ‘’ğ‘ğ‘£(2) and ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system calls are an
analogy for the ğ‘Ÿğ‘’ğ‘ğ‘‘(2) system call, specifically for sockets, with flags set to 0.
Those system calls return the number of bytes that were received through the socket
itself, as the number of bytes can vary. The ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call designed for stream
sockets (like TCP), while the ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system call designed for datagram
connection-less sockets (like UDP). When the ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call returns 0, it means
that the other party closed the connection.
â€¢ ğ’„ğ’ğ’ğ’”ğ’†(ğŸ) and ğ’”ğ’‰ğ’–ğ’•ğ’…ğ’ğ’˜ğ’(ğŸ) â€“ The ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) and ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2) system calls close
the socket. While ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) system call closes the whole socket, the ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2)
system call partially closes the socket for read/write.
 Communication Networks Course
Page | 12
Appendix C â€“ Random data generator
The data that you are going to send in this assignment is randomly generated. You can use
your own file with appropriate size or use the following function (or a function of your own)
to generate the data:
/*
* @brief A random data generator function based on srand() and rand().
* @param size The size of the data to generate (up to 2^32 bytes).
* @return A pointer to the buffer.
*/
char *util_generate_random_data(unsigned int size) {
 char *buffer = NULL;
 // Argument check.
 if (size == 0)
 return NULL;
 buffer = (char *)calloc(size, sizeof(char));
 // Error checking.
 if (buffer == NULL)
 return NULL;
 // Randomize the seed of the random number generator.
 srand(time(NULL));
 for (unsigned int i = 0; i < size; i++)
 *(buffer + i) = ((unsigned int)rand() % 256);
 return buffer;
}
 Communication Networks Course
Page | 13
Appendix D â€“ Checksum function
A checksum is a small-sized block of data derived from another block of digital data for the
purpose of detecting errors that may have been introduced during its transmission or
storage. By themselves, checksums are often used to verify data integrity but are not relied
upon to verify data authenticity.
Below is a simple yet efficient implementation of the checksum function, you can use it for
the assignment, but you can implement your own checksum function.
/*
* @brief A checksum function that returns 16 bit checksum for data.
* @param data The data to do the checksum for.
* @param bytes The length of the data in bytes.
* @return The checksum itself as 16 bit unsigned number.
* @note This function is taken from RFC1071, can be found here:
* @note https://tools.ietf.org/html/rfc1071
* @note It is the simplest way to calculate a checksum and is not very strong.
* However, it is good enough for this assignment.
* @note You are free to use any other checksum function as well.
* You can also use this function as such without any change.
*/
unsigned short int calculate_checksum(void *data, unsigned int bytes) {
 unsigned short int *data_pointer = (unsigned short int *)data;
 unsigned int total_sum = 0;
 // Main summing loop
 while (bytes > 1) {
 total_sum += *data_pointer++;
 bytes -= 2;
 }
 // Add left-over byte, if any
 if (bytes > 0)
 total_sum += *((unsigned char *)data_pointer);
 // Fold 32-bit sum to 16 bits
 while (total_sum >> 16)
 total_sum = (total_sum & 0xFFFF) + (total_sum >> 16);
 return (~((unsigned short int)total_sum));
} Communication Networks Course
Page | 1
Assignment 3 â€“ Transport Layer
Assignment Notes and Instructions
This assignment is to be done in pairs only. You must upload all the necessary files in a ZIP
file named after both of the studentâ€™s ID. For example: ğŸğŸğŸ‘ğŸ’ğŸ“ğŸ”ğŸ•ğŸ–ğŸ—_ğŸ—ğŸ–ğŸ•ğŸ”ğŸ“ğŸ’ğŸ‘ğŸğŸ. ğ’›ğ’Šğ’‘.
1) The assignment must be submitted by the date specified in the submission box.
2) All the assignment files (Code, Wireshark pcap files, PDF) must be submitted in a ZIP file. The
PDF must contain all the necessary screenshots with a description for each one of them.
3) The assignment must be done in pairs only. In exceptional cases, you should send an email to
the course coordinator.
4) You can use any reference material available through the course Moodle website or any
material passed during the exercises.
5) You can use any reference from the web, but copying codes from websites is forbidden; this
includes codes from other GitHub repositories. A student who gets caught in the act will
automatically fail this assignment (score 0). Any website youâ€™ve used to solve the
assignment, every website you used to solve the assignment must be noted in the PDF.
6) No delays in submission without special permission. Lateness without approval will result in
failure of the assignment (score 0).
7) All submissions will be submitted via the course's Moodle website. Email submissions will not
be accepted, resulting in a failure in the assignment.
8) The order and design of the code must be carefully considered. Make sure that the program
output is as clear as possible, comments in the code, and meaningful variable names. You
must also submit a makefile that compiles all the programs.
9) The assignment code must be written in C only.
10) The assignment is personal for each pair, and you should not accept help from other people,
whether outside the university or inside it. You can contact the course staff during reception
hours for help or raise a question in the course forum. Do not transfer code sections
between students, upload solutions or parts of solutions to websites on the Internet or in
various communication groups.
11) Students who copy a solution will receive a 0 in all assignments in the course and a report will
be made to the institutional disciplinary committee.
12) All code files of the assignment are required to both compile and run properly on the Ubuntu
22.04 LTS operating system. This is the operating system where the submissions will be
tested. You mustnâ€™t code it in Windows, as it uses different API for sockets. WSL wonâ€™t work,
as the task needs a tool that works only in a fully Linux environment.
Good Luck!
 Communication Networks Course
Page | 2
Part A â€“ Transmission Control Protocol (TCP) â€“ 30 points
In this part, youâ€™ll write two program files: ğ‘»ğ‘ªğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and ğ‘»ğ‘ªğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
The Sender will send a randomly generated file and the Receiver will receive it and measure
the time it took for his program to receive the file. The file size should be at least 2MB.
When running the Sender and Receiver, they both should support two standard congestion
control algorithms: TCP Reno and TCP Cubic.
Notes:
â€¢ The main goal of this part is to get familiar with the TCP concept of sending
messages between two endpoints.
â€¢ For approaching this part of the assignment, please be sure that you are familiar
with the congestion control algorithms and how to change them using the correct
method in C (see Appendix B for more information).
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). You've
learned that TCP is reliable by design, so you can assume that all the data have been
passed correctly, and thus, no need to recheck.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
Usage:
â€¢ Receiver:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
â€¢ Sender:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port of the Receiver.
â€¢ ğ‘¨ğ‘³ğ‘®ğ‘¶ â€“ The TCP congestion control algorithm that will be used by the party
member (either ğ’“ğ’†ğ’ğ’ for TCP Reno or ğ’„ğ’–ğ’ƒğ’Šğ’„ for TCP Cubic).
 Communication Networks Course
Page | 3
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a TCP socket between the Sender and the
Receiver.
3) Send the file.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a TCP connection between the Receiver and
the Sender.
2) Get a connection from the sender.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./TCP_Receiver -p 1234 -algo reno
Starting Receiver...
Waiting for TCP connection...
Sender connected, beginning to receive file...
File transfer completed.
Waiting for Sender response...
Sender sent exit message.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 4
Part B â€“ Reliable User Datagram Protocol (Reliable UDP or RUDP) â€“ 40 points
Youâ€™ve learned that while TCP is reliable, it lacks speed and has an overhead data of 20 bytes,
compering to UDP that needs only 8 bytes of overhead data.
Reliable UDP or RUDP, is a protocol that uses the UDP protocol for a faster transmission of
data, while adding a reliability layer to it, but without adding too much overhead data like
TCP.
A simple sketch for a RUDP connection would look something like this:
Your task in this part is to implement a Reliable protocol using UDP only. For simplicity, your
implementation should only support a handshake, closing scheme, error checking,
acknowledgment of received packets, and retransmission of lost packets.
Guidance:
â€¢ You can use ğ‘ ğ‘’ğ‘¡ğ‘ ğ‘œğ‘ğ‘˜ğ‘œğ‘ğ‘¡(2) for detecting a timeout.
â€¢ You need to build your own protocol, as Reliable UDP isnâ€™t a standard protocol (see a
draft of RUDP in this link), and no official header is provided. You can use this sketch
for a header, but you can come up with your own protocol, as long as it works.
Where:
o ğ‘³ğ’†ğ’ğ’ˆğ’•ğ’‰ is the length of the data itself, without the RUDP header.
o ğ‘ªğ’‰ğ’†ğ’„ğ’Œğ’”ğ’–ğ’ is a 16bit number that validates the correctness of the data.
o ğ‘­ğ’ğ’‚ğ’ˆğ’” is a special byte where we classify the packet itself (SYN, ACK, etc.).
â€¢ In your PDF, you must explain how your implementation of RUDP works â€“ How does
it detect a timeout to do retransmissions, how does the handshake work, what is the
header overhead, etc.
â€¢ For this part, youâ€™ll write three files: ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¨ğ‘·ğ‘°. ğ’„, ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and
ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
Reliable UDP Header proposed sketch
Byte 0 Byte 1 Byte 2 Byte 3
Length (2 Bytes) Checksum (2 Bytes)
Flags (1 Byte)
Figure 1 - RUDP Protocol Architecture, Geeksforgeeks
 Communication Networks Course
Page | 5
Notes:
â€¢ The Sender will send a random generated file and the Receiver will receive it and
measure the time it took for his program to receive the file. The file size should be at
least 2MB.
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). But, as the
RUDP is based on UDP, itâ€™s not reliable. You must use some form of error checking
(like checksum) to ensure that the packet wasnâ€™t alerted during the transfer.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
â€¢ The RUDP needs support only 1 sender and 1 receiver, for simplicity purposes.
Usage:
â€¢ Receiver:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
â€¢ Sender:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port that both the Sender and the Receiver will use.
The ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„ file will contain all the implementations of the RUDP API functions (That is, to
prevent reusing the same chuck of code both in the Sender and the Receiver.).
The API should support at the bare minimum the following functions (you decide what
parameters to implement, and what are the names of the functions, as long as the API is
explained in the PDF):
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘œğ‘ğ‘˜ğ‘’ğ‘¡() â€“ Creating a RUDP socket and creating a handshake between two
peers.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘’ğ‘›ğ‘‘() â€“ Sending data to the peer. The function should wait for an
acknowledgment packet, and if it didnâ€™t receive any, retransmits the data.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘Ÿğ‘’ğ‘ğ‘£() â€“ Receive data from a peer.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ğ‘™ğ‘œğ‘ ğ‘’() â€“ Closes a connection between peers.
 Communication Networks Course
Page | 6
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a UDP socket between the Sender and the
Receiver.
3) Send the file via the RUDP protocol.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a UDP connection between the Receiver and
the Sender.
2) Get a connection from the sender, by the custom
RUDP protocol youâ€™ve built.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./RUDP_Receiver -p 1234
Starting Receiver...
Waiting for RUDP connection...
Connection request received, sending ACK.
Sender connected, beginning to receive file...
File transfer completed.
ACK sent.
Waiting for Sender response...
Sender sent exit message.
ACK sent.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 7
Part C â€“ Research â€“ 30 points
In this part, youâ€™ll conduct research about your implementations of part A and part B.
In the research itself, each one of the versions (TCP version and UDP version) will be run at
least 5 times (meaning that the file transfer will occur at least 5 times) by the following
conditions:
â€¢ For TCP, youâ€™ll run it in TCP Reno and TCP Cubic, alternating each time, for each
scenario, meaning that you run 5 times with TCP Reno in both Sender and Receiver,
and 5 times with TCP Cubic in both Sender and Receiver.
Bonus (5 points): Create a very large data set â€“ 5 times with TCP Reno in both Sender
and Receiver, 5 times with TCP Reno in Sender and TCP Cubic in Receiver, 5 times
with TCP Cubic in Sender and TCP Reno in Receiver, and 5 times with TCP Cubic in
both Sender and Receiver. This will give you a data set large enough, which allows
you to work with, compare with and to reach a definite conclusion.
â€¢ For RUDP, you will run it 5 times for each scenario.
â€¢ For both TCP and RUDP, you will run them on those scenarios of packet loss:
o 0% packet loss â€“ Control group, simulating perfect connection.
o 2% packet loss â€“ Simulating unstable connection that commonly occur.
o 5% packet loss â€“ Simulating bad connection.
o 10% packet loss â€“ Simulating extremely poor connection.
For each scenario, you must provide a filtered PCAP file and relevant screenshots that
explain each one of the steps in the process. (10 points)
After youâ€™ve gathered the data set for both TCP and Reliable UDP, answer the following
questions:
1) In TCP, which congestion control algorithm gave better results overall? TCP Reno or
TCP Cubic? Which one gave better results on high packet loss? Explain how you came
to this conclusion based on the data set youâ€™ve gathered. (5 points)
2) How did your implementation of Reliable UDP perform overall compared to regular
TCP? Which one is better for high packet loss? (5 points)
3) According to the data youâ€™ve gathered, in which scenarios and applications would we
prefer to use TCP and in which situations would we prefer to use reliable UDP?
Explain your answer. (5 points)
 Communication Networks Course
Page | 8
×¢× ×• ×¢×œ ×”×©××œ×•×ª ×”×‘××•×ª )5 × ×§×•×“×•×ª(:
â— ×‘"×¨×©×ª ×××™× ×”" ×”×›×•×•× ×” ×”×™× ×œ×¨×©×ª ×©×‘×” ××¢×˜ ×××•×“ ×—×‘×™×œ×•×ª ×”×•×œ×›×•×ª ×œ××™×‘×•×“. ×‘"×§×©×¨ ××¨×•×š" ×”×›×•×•× ×” ×”×™×
×œ×§×©×¨ TCP ×©×™×© ×‘×• ×”×¨×‘×” ×××•×“ ××™×“×¢ ×œ×©×œ×•×—. ××•×¦×¢ ×œ×”×’×“×™×œ ×‘ -TCP ××ª SSThreshold ×‘×ª×—×™×œ×ª ×”×§×©×¨.
×‘××™×–×” ××”××§×¨×™× ×”×‘××™× ×”×©×™× ×•×™ ×”×–×” ×¢×©×•×™ ×œ×”×•×¢×™×œ ×‘××™×“×” ×”××™×¨×‘×™×ª? × ××§.
.1 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
.2 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.3 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.4 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.5 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.6 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.7 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.8 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
â— A ×©×•×œ×— ×œ -B ×—×‘×™×œ×•×ª ××™×“×¢ ×‘×××¦×¢×•×ª ×§×©×¨ TCP. × ×ª×•×Ÿ ×›×™ ×”×§×©×¨ ××ª×—×™×œ ×¢× ×—×œ×•×Ÿ ×‘×’×•×“×œ 1MSS. ×”×§×©×¨
××¡×ª×™×™× ×‘×¤×¢× ×”×¨××©×•× ×” ×©×”×•× ××’×™×¢ ×œ -SSthresh. ×‘××”×œ×š ×”×§×©×¨ ×œ× ××•×‘×“×•×ª ×—×‘×™×œ×•×ª. × ×¡××Ÿ ×‘×§×™×¦×•×¨:
.SSthresh=S*MSS
× ×ª×•×Ÿ ×›×™ ×œ××•×¨×š ×›×œ ×”×§×©×¨ rwnd < MSS*S.
××”×™ ×”×ª×¤×•×§×” ×©×œ ×”×§×©×¨ ×-A ×œ-B( ×‘ -sec / Bytes )×‘×–××Ÿ ×”× "×œ? × ××§×™.
]S*MSS / [lg (S) * RTT*2 ×‘×¢×¨×š .1
]S*MSS / [S^0.5 * RTT*2 ×‘×¢×¨×š .2
S*MSS / RTT ×‘×¢×¨×š .3
S^2)*MSS / RTT( ×‘×¢×¨×š .4
â— ×©×ª×™ ×ª×—× ×•×ª ××ª×§×©×¨×•×ª ×‘××•×¤×Ÿ ××œ×—×•×˜×™ ×‘×©×™×˜×ª N Back Go.
× ×¡××Ÿ ×‘-X ××ª ×¡×¤×¨×ª ×”×‘×™×§×•×¨×ª ×©×œ ×”×ª.×–. ×©×œ×š. ×× ×©× ×™ ×©×•×ª×¤×™× ××’×™×©×™× ××ª ×”×ª×¨×’×™×œ ×™×—×“, X ×”×•× ×¡×¤×¨×ª
×”×‘×™×§×•×¨×ª ×‘×¢×œ×ª ×”×¢×¨×š ×”× ××•×š ×™×•×ª×¨ ××‘×™×Ÿ ×”×©×ª×™×™×.
×§×¦×‘ ×”×ª×§×©×•×¨×ª ×”×•× 8Gbps, ×•×’×•×“×œ ×›×œ ×—×‘×™×œ×” ×”×•× KByte*X. ×’×“×œ×™ ×”-headers ×•×” -Acks ×–× ×™×—×™×.
ï¿½ğ‘’ğ‘ ï¿½/ï¿½ï¿½ 8 , ×•×”××¨×—×§ ×‘×™×Ÿ ×”×ª×—× ×•×ª ×”×•× 1Km. ×§×¦×‘ ×”×”×ª×¤×©×˜×•×ª ×”×•× 10 â‹… 2
×–××Ÿ ×¢×™×‘×•×“ ×”× ×ª×•× ×™× ×‘×ª×—× ×•×ª ×–× ×™×—.
××£ ×—×‘×™×œ×” ×•××£ Ack ×œ× ×”×•×œ×›×™× ×œ××™×‘×•×“.
â— ××”×• X ×©×œ×š?
â— ××” ×¦×¨×™×š ×œ×”×™×•×ª ×’×•×“×œ ×—×œ×•×Ÿ ×”××©×œ×•×— ×›×“×™ ×œ×”×‘×˜×™×— ×ª×¤×•×§×” ××§×¡×™××œ×™×ª?
 Communication Networks Course
Page | 9
Bonus â€“ Improving the Reliable UDP â€“ 15 points
Note: This part isnâ€™t mandatory and is a bonus only!
In this part, youâ€™ll improve your RUDP implementation by adding the concepts of flow
control and congestion control from TCP. Youâ€™re free to choose which algorithms to
implement, as long as you explain in your PDF which algorithms youâ€™ve used. Youâ€™ll probably
need to make changes in the original design of the RUDP. Changes only need to be to the API
itself, ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„.
Points distribution:
â€¢ Flow control improvement â€“ 7 Points
â€¢ Congestion control improvement â€“ 8 points.
Guidance:
â€¢ For flow control, you must use one of the Sliding window techniques: stop-and-wait
ARQ, Go-Back-N or Selective repeat.
â€¢ List of known TCP congestion control algorithms, which you can use any one of them
for this bonus task, or makeup your own:
Figure 2 â€“ List of known TCP congestion control algorithms, Wikipedia
 Communication Networks Course
Page | 10
Appendix A â€“ Linux local packet loss tool
To simulate a packet loss in a local network, we'll use a Linux tool that's called Linux Traffic
Control (ğ‘¡ğ‘). This requires a full Linux installation, so working with WSL won't work.
If the tool isn't installed in your machine, you can install it by using the following commands:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’
If the installation didn't work, you can use the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’2
To create a packet loss scenario, type the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘ğ‘‘ğ‘‘ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
After creating a packet loss scenario, you can change the percentage by typing the following
command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘â„ğ‘ğ‘›ğ‘”ğ‘’ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
To remove the packet loss scenario, write the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘‘ğ‘’ğ‘™ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š
 Communication Networks Course
Page | 11
Appendix B â€“ ğ’ğ’‚ğ’(ğŸ) system calls
This appendixâ€™s purpose is to give you a better understanding of socket handling in C.
A recommended reference is Beejâ€™s Guide to Network Programming, by Brian â€œBeej
Jorgensenâ€ Hall, which gives a lot of information about sockets in C and functions.
Functions and documentation links:
â€¢ ğ’”ğ’ğ’„ğ’Œğ’†ğ’•(ğŸ) â€“ A Factory method system call that creates a socket with the given
parameters.
â€¢ ğ’ƒğ’Šğ’ğ’…(ğŸ) â€“ Whenever we create a new socket, we need to bind it to a specific port in
our machine, â€œto catch a portâ€. The port number is managed and used by the kernel
to link incoming packets to the corresponding application socket. The port numbers
are usually fixed. The ğ‘ğ‘‘ğ‘‘ğ‘Ÿ parameter must match the current socket that is used.
â€¢ ğ’ğ’Šğ’”ğ’•ğ’†ğ’(ğŸ) â€“ The ğ‘™ğ‘–ğ‘ ğ‘¡ğ‘’ğ‘›(2) system call doesn't do anything in the mean of
communication but only memory allocation (malloc) for stream sockets only. If we
won't allocate memory, any incoming connection will fail.
â€¢ ğ’„ğ’ğ’ğ’ğ’†ğ’„ğ’•(ğŸ) â€“ The ğ‘ğ‘œğ‘›ğ‘›ğ‘’ğ‘ğ‘¡(2) system call starts the link between a client and a
specific IP address and port number. The connection would complete when the
other side will call the ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call.
â€¢ ğ’‚ğ’„ğ’„ğ’†ğ’‘ğ’•(ğŸ) â€“ The ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call accepts the incoming stream connection
request from the other side, by the listening socket. This system call completes the
three-way handshake of stream socket (like TCP) and opens a new socket that has a
direct communication channel only with the other party in the handshake.
â€¢ ğ’”ğ’†ğ’ğ’…(ğŸ) and ğ’”ğ’†ğ’ğ’…ğ’•ğ’(ğŸ) â€“ The ğ‘ ğ‘’ğ‘›ğ‘‘(2) and ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system calls are an analogy
for the ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’(2) system call, specifcly for sockets, with flags set to 0. Those system
calls return the number of bytes that were sent through the socket itself, as the
number of bytes can vary. The ğ‘ ğ‘’ğ‘›ğ‘‘(2)system call designed for stream sockets (like
TCP), while the ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system call designed for datagram connection-less
sockets (like UDP). When the ğ‘ ğ‘’ğ‘›ğ‘‘(2) system call returns 0, it means that the other
party closed the connection.
â€¢ ğ’“ğ’†ğ’„ğ’—(ğŸ) and ğ’“ğ’†ğ’„ğ’—ğ’‡ğ’“ğ’ğ’(ğŸ) â€“ The ğ‘Ÿğ‘’ğ‘ğ‘£(2) and ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system calls are an
analogy for the ğ‘Ÿğ‘’ğ‘ğ‘‘(2) system call, specifically for sockets, with flags set to 0.
Those system calls return the number of bytes that were received through the socket
itself, as the number of bytes can vary. The ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call designed for stream
sockets (like TCP), while the ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system call designed for datagram
connection-less sockets (like UDP). When the ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call returns 0, it means
that the other party closed the connection.
â€¢ ğ’„ğ’ğ’ğ’”ğ’†(ğŸ) and ğ’”ğ’‰ğ’–ğ’•ğ’…ğ’ğ’˜ğ’(ğŸ) â€“ The ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) and ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2) system calls close
the socket. While ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) system call closes the whole socket, the ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2)
system call partially closes the socket for read/write.
 Communication Networks Course
Page | 12
Appendix C â€“ Random data generator
The data that you are going to send in this assignment is randomly generated. You can use
your own file with appropriate size or use the following function (or a function of your own)
to generate the data:
/*
* @brief A random data generator function based on srand() and rand().
* @param size The size of the data to generate (up to 2^32 bytes).
* @return A pointer to the buffer.
*/
char *util_generate_random_data(unsigned int size) {
 char *buffer = NULL;
 // Argument check.
 if (size == 0)
 return NULL;
 buffer = (char *)calloc(size, sizeof(char));
 // Error checking.
 if (buffer == NULL)
 return NULL;
 // Randomize the seed of the random number generator.
 srand(time(NULL));
 for (unsigned int i = 0; i < size; i++)
 *(buffer + i) = ((unsigned int)rand() % 256);
 return buffer;
}
 Communication Networks Course
Page | 13
Appendix D â€“ Checksum function
A checksum is a small-sized block of data derived from another block of digital data for the
purpose of detecting errors that may have been introduced during its transmission or
storage. By themselves, checksums are often used to verify data integrity but are not relied
upon to verify data authenticity.
Below is a simple yet efficient implementation of the checksum function, you can use it for
the assignment, but you can implement your own checksum function.
/*
* @brief A checksum function that returns 16 bit checksum for data.
* @param data The data to do the checksum for.
* @param bytes The length of the data in bytes.
* @return The checksum itself as 16 bit unsigned number.
* @note This function is taken from RFC1071, can be found here:
* @note https://tools.ietf.org/html/rfc1071
* @note It is the simplest way to calculate a checksum and is not very strong.
* However, it is good enough for this assignment.
* @note You are free to use any other checksum function as well.
* You can also use this function as such without any change.
*/
unsigned short int calculate_checksum(void *data, unsigned int bytes) {
 unsigned short int *data_pointer = (unsigned short int *)data;
 unsigned int total_sum = 0;
 // Main summing loop
 while (bytes > 1) {
 total_sum += *data_pointer++;
 bytes -= 2;
 }
 // Add left-over byte, if any
 if (bytes > 0)
 total_sum += *((unsigned char *)data_pointer);
 // Fold 32-bit sum to 16 bits
 while (total_sum >> 16)
 total_sum = (total_sum & 0xFFFF) + (total_sum >> 16);
 return (~((unsigned short int)total_sum));
} Communication Networks Course
Page | 1
Assignment 3 â€“ Transport Layer
Assignment Notes and Instructions
This assignment is to be done in pairs only. You must upload all the necessary files in a ZIP
file named after both of the studentâ€™s ID. For example: ğŸğŸğŸ‘ğŸ’ğŸ“ğŸ”ğŸ•ğŸ–ğŸ—_ğŸ—ğŸ–ğŸ•ğŸ”ğŸ“ğŸ’ğŸ‘ğŸğŸ. ğ’›ğ’Šğ’‘.
1) The assignment must be submitted by the date specified in the submission box.
2) All the assignment files (Code, Wireshark pcap files, PDF) must be submitted in a ZIP file. The
PDF must contain all the necessary screenshots with a description for each one of them.
3) The assignment must be done in pairs only. In exceptional cases, you should send an email to
the course coordinator.
4) You can use any reference material available through the course Moodle website or any
material passed during the exercises.
5) You can use any reference from the web, but copying codes from websites is forbidden; this
includes codes from other GitHub repositories. A student who gets caught in the act will
automatically fail this assignment (score 0). Any website youâ€™ve used to solve the
assignment, every website you used to solve the assignment must be noted in the PDF.
6) No delays in submission without special permission. Lateness without approval will result in
failure of the assignment (score 0).
7) All submissions will be submitted via the course's Moodle website. Email submissions will not
be accepted, resulting in a failure in the assignment.
8) The order and design of the code must be carefully considered. Make sure that the program
output is as clear as possible, comments in the code, and meaningful variable names. You
must also submit a makefile that compiles all the programs.
9) The assignment code must be written in C only.
10) The assignment is personal for each pair, and you should not accept help from other people,
whether outside the university or inside it. You can contact the course staff during reception
hours for help or raise a question in the course forum. Do not transfer code sections
between students, upload solutions or parts of solutions to websites on the Internet or in
various communication groups.
11) Students who copy a solution will receive a 0 in all assignments in the course and a report will
be made to the institutional disciplinary committee.
12) All code files of the assignment are required to both compile and run properly on the Ubuntu
22.04 LTS operating system. This is the operating system where the submissions will be
tested. You mustnâ€™t code it in Windows, as it uses different API for sockets. WSL wonâ€™t work,
as the task needs a tool that works only in a fully Linux environment.
Good Luck!
 Communication Networks Course
Page | 2
Part A â€“ Transmission Control Protocol (TCP) â€“ 30 points
In this part, youâ€™ll write two program files: ğ‘»ğ‘ªğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and ğ‘»ğ‘ªğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
The Sender will send a randomly generated file and the Receiver will receive it and measure
the time it took for his program to receive the file. The file size should be at least 2MB.
When running the Sender and Receiver, they both should support two standard congestion
control algorithms: TCP Reno and TCP Cubic.
Notes:
â€¢ The main goal of this part is to get familiar with the TCP concept of sending
messages between two endpoints.
â€¢ For approaching this part of the assignment, please be sure that you are familiar
with the congestion control algorithms and how to change them using the correct
method in C (see Appendix B for more information).
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). You've
learned that TCP is reliable by design, so you can assume that all the data have been
passed correctly, and thus, no need to recheck.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
Usage:
â€¢ Receiver:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
â€¢ Sender:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port of the Receiver.
â€¢ ğ‘¨ğ‘³ğ‘®ğ‘¶ â€“ The TCP congestion control algorithm that will be used by the party
member (either ğ’“ğ’†ğ’ğ’ for TCP Reno or ğ’„ğ’–ğ’ƒğ’Šğ’„ for TCP Cubic).
 Communication Networks Course
Page | 3
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a TCP socket between the Sender and the
Receiver.
3) Send the file.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a TCP connection between the Receiver and
the Sender.
2) Get a connection from the sender.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./TCP_Receiver -p 1234 -algo reno
Starting Receiver...
Waiting for TCP connection...
Sender connected, beginning to receive file...
File transfer completed.
Waiting for Sender response...
Sender sent exit message.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 4
Part B â€“ Reliable User Datagram Protocol (Reliable UDP or RUDP) â€“ 40 points
Youâ€™ve learned that while TCP is reliable, it lacks speed and has an overhead data of 20 bytes,
compering to UDP that needs only 8 bytes of overhead data.
Reliable UDP or RUDP, is a protocol that uses the UDP protocol for a faster transmission of
data, while adding a reliability layer to it, but without adding too much overhead data like
TCP.
A simple sketch for a RUDP connection would look something like this:
Your task in this part is to implement a Reliable protocol using UDP only. For simplicity, your
implementation should only support a handshake, closing scheme, error checking,
acknowledgment of received packets, and retransmission of lost packets.
Guidance:
â€¢ You can use ğ‘ ğ‘’ğ‘¡ğ‘ ğ‘œğ‘ğ‘˜ğ‘œğ‘ğ‘¡(2) for detecting a timeout.
â€¢ You need to build your own protocol, as Reliable UDP isnâ€™t a standard protocol (see a
draft of RUDP in this link), and no official header is provided. You can use this sketch
for a header, but you can come up with your own protocol, as long as it works.
Where:
o ğ‘³ğ’†ğ’ğ’ˆğ’•ğ’‰ is the length of the data itself, without the RUDP header.
o ğ‘ªğ’‰ğ’†ğ’„ğ’Œğ’”ğ’–ğ’ is a 16bit number that validates the correctness of the data.
o ğ‘­ğ’ğ’‚ğ’ˆğ’” is a special byte where we classify the packet itself (SYN, ACK, etc.).
â€¢ In your PDF, you must explain how your implementation of RUDP works â€“ How does
it detect a timeout to do retransmissions, how does the handshake work, what is the
header overhead, etc.
â€¢ For this part, youâ€™ll write three files: ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¨ğ‘·ğ‘°. ğ’„, ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and
ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
Reliable UDP Header proposed sketch
Byte 0 Byte 1 Byte 2 Byte 3
Length (2 Bytes) Checksum (2 Bytes)
Flags (1 Byte)
Figure 1 - RUDP Protocol Architecture, Geeksforgeeks
 Communication Networks Course
Page | 5
Notes:
â€¢ The Sender will send a random generated file and the Receiver will receive it and
measure the time it took for his program to receive the file. The file size should be at
least 2MB.
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). But, as the
RUDP is based on UDP, itâ€™s not reliable. You must use some form of error checking
(like checksum) to ensure that the packet wasnâ€™t alerted during the transfer.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
â€¢ The RUDP needs support only 1 sender and 1 receiver, for simplicity purposes.
Usage:
â€¢ Receiver:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
â€¢ Sender:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port that both the Sender and the Receiver will use.
The ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„ file will contain all the implementations of the RUDP API functions (That is, to
prevent reusing the same chuck of code both in the Sender and the Receiver.).
The API should support at the bare minimum the following functions (you decide what
parameters to implement, and what are the names of the functions, as long as the API is
explained in the PDF):
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘œğ‘ğ‘˜ğ‘’ğ‘¡() â€“ Creating a RUDP socket and creating a handshake between two
peers.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘’ğ‘›ğ‘‘() â€“ Sending data to the peer. The function should wait for an
acknowledgment packet, and if it didnâ€™t receive any, retransmits the data.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘Ÿğ‘’ğ‘ğ‘£() â€“ Receive data from a peer.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ğ‘™ğ‘œğ‘ ğ‘’() â€“ Closes a connection between peers.
 Communication Networks Course
Page | 6
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a UDP socket between the Sender and the
Receiver.
3) Send the file via the RUDP protocol.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a UDP connection between the Receiver and
the Sender.
2) Get a connection from the sender, by the custom
RUDP protocol youâ€™ve built.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./RUDP_Receiver -p 1234
Starting Receiver...
Waiting for RUDP connection...
Connection request received, sending ACK.
Sender connected, beginning to receive file...
File transfer completed.
ACK sent.
Waiting for Sender response...
Sender sent exit message.
ACK sent.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 7
Part C â€“ Research â€“ 30 points
In this part, youâ€™ll conduct research about your implementations of part A and part B.
In the research itself, each one of the versions (TCP version and UDP version) will be run at
least 5 times (meaning that the file transfer will occur at least 5 times) by the following
conditions:
â€¢ For TCP, youâ€™ll run it in TCP Reno and TCP Cubic, alternating each time, for each
scenario, meaning that you run 5 times with TCP Reno in both Sender and Receiver,
and 5 times with TCP Cubic in both Sender and Receiver.
Bonus (5 points): Create a very large data set â€“ 5 times with TCP Reno in both Sender
and Receiver, 5 times with TCP Reno in Sender and TCP Cubic in Receiver, 5 times
with TCP Cubic in Sender and TCP Reno in Receiver, and 5 times with TCP Cubic in
both Sender and Receiver. This will give you a data set large enough, which allows
you to work with, compare with and to reach a definite conclusion.
â€¢ For RUDP, you will run it 5 times for each scenario.
â€¢ For both TCP and RUDP, you will run them on those scenarios of packet loss:
o 0% packet loss â€“ Control group, simulating perfect connection.
o 2% packet loss â€“ Simulating unstable connection that commonly occur.
o 5% packet loss â€“ Simulating bad connection.
o 10% packet loss â€“ Simulating extremely poor connection.
For each scenario, you must provide a filtered PCAP file and relevant screenshots that
explain each one of the steps in the process. (10 points)
After youâ€™ve gathered the data set for both TCP and Reliable UDP, answer the following
questions:
1) In TCP, which congestion control algorithm gave better results overall? TCP Reno or
TCP Cubic? Which one gave better results on high packet loss? Explain how you came
to this conclusion based on the data set youâ€™ve gathered. (5 points)
2) How did your implementation of Reliable UDP perform overall compared to regular
TCP? Which one is better for high packet loss? (5 points)
3) According to the data youâ€™ve gathered, in which scenarios and applications would we
prefer to use TCP and in which situations would we prefer to use reliable UDP?
Explain your answer. (5 points)
 Communication Networks Course
Page | 8
×¢× ×• ×¢×œ ×”×©××œ×•×ª ×”×‘××•×ª )5 × ×§×•×“×•×ª(:
â— ×‘"×¨×©×ª ×××™× ×”" ×”×›×•×•× ×” ×”×™× ×œ×¨×©×ª ×©×‘×” ××¢×˜ ×××•×“ ×—×‘×™×œ×•×ª ×”×•×œ×›×•×ª ×œ××™×‘×•×“. ×‘"×§×©×¨ ××¨×•×š" ×”×›×•×•× ×” ×”×™×
×œ×§×©×¨ TCP ×©×™×© ×‘×• ×”×¨×‘×” ×××•×“ ××™×“×¢ ×œ×©×œ×•×—. ××•×¦×¢ ×œ×”×’×“×™×œ ×‘ -TCP ××ª SSThreshold ×‘×ª×—×™×œ×ª ×”×§×©×¨.
×‘××™×–×” ××”××§×¨×™× ×”×‘××™× ×”×©×™× ×•×™ ×”×–×” ×¢×©×•×™ ×œ×”×•×¢×™×œ ×‘××™×“×” ×”××™×¨×‘×™×ª? × ××§.
.1 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
.2 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.3 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.4 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.5 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.6 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.7 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.8 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
â— A ×©×•×œ×— ×œ -B ×—×‘×™×œ×•×ª ××™×“×¢ ×‘×××¦×¢×•×ª ×§×©×¨ TCP. × ×ª×•×Ÿ ×›×™ ×”×§×©×¨ ××ª×—×™×œ ×¢× ×—×œ×•×Ÿ ×‘×’×•×“×œ 1MSS. ×”×§×©×¨
××¡×ª×™×™× ×‘×¤×¢× ×”×¨××©×•× ×” ×©×”×•× ××’×™×¢ ×œ -SSthresh. ×‘××”×œ×š ×”×§×©×¨ ×œ× ××•×‘×“×•×ª ×—×‘×™×œ×•×ª. × ×¡××Ÿ ×‘×§×™×¦×•×¨:
.SSthresh=S*MSS
× ×ª×•×Ÿ ×›×™ ×œ××•×¨×š ×›×œ ×”×§×©×¨ rwnd < MSS*S.
××”×™ ×”×ª×¤×•×§×” ×©×œ ×”×§×©×¨ ×-A ×œ-B( ×‘ -sec / Bytes )×‘×–××Ÿ ×”× "×œ? × ××§×™.
]S*MSS / [lg (S) * RTT*2 ×‘×¢×¨×š .1
]S*MSS / [S^0.5 * RTT*2 ×‘×¢×¨×š .2
S*MSS / RTT ×‘×¢×¨×š .3
S^2)*MSS / RTT( ×‘×¢×¨×š .4
â— ×©×ª×™ ×ª×—× ×•×ª ××ª×§×©×¨×•×ª ×‘××•×¤×Ÿ ××œ×—×•×˜×™ ×‘×©×™×˜×ª N Back Go.
× ×¡××Ÿ ×‘-X ××ª ×¡×¤×¨×ª ×”×‘×™×§×•×¨×ª ×©×œ ×”×ª.×–. ×©×œ×š. ×× ×©× ×™ ×©×•×ª×¤×™× ××’×™×©×™× ××ª ×”×ª×¨×’×™×œ ×™×—×“, X ×”×•× ×¡×¤×¨×ª
×”×‘×™×§×•×¨×ª ×‘×¢×œ×ª ×”×¢×¨×š ×”× ××•×š ×™×•×ª×¨ ××‘×™×Ÿ ×”×©×ª×™×™×.
×§×¦×‘ ×”×ª×§×©×•×¨×ª ×”×•× 8Gbps, ×•×’×•×“×œ ×›×œ ×—×‘×™×œ×” ×”×•× KByte*X. ×’×“×œ×™ ×”-headers ×•×” -Acks ×–× ×™×—×™×.
ï¿½ğ‘’ğ‘ ï¿½/ï¿½ï¿½ 8 , ×•×”××¨×—×§ ×‘×™×Ÿ ×”×ª×—× ×•×ª ×”×•× 1Km. ×§×¦×‘ ×”×”×ª×¤×©×˜×•×ª ×”×•× 10 â‹… 2
×–××Ÿ ×¢×™×‘×•×“ ×”× ×ª×•× ×™× ×‘×ª×—× ×•×ª ×–× ×™×—.
××£ ×—×‘×™×œ×” ×•××£ Ack ×œ× ×”×•×œ×›×™× ×œ××™×‘×•×“.
â— ××”×• X ×©×œ×š?
â— ××” ×¦×¨×™×š ×œ×”×™×•×ª ×’×•×“×œ ×—×œ×•×Ÿ ×”××©×œ×•×— ×›×“×™ ×œ×”×‘×˜×™×— ×ª×¤×•×§×” ××§×¡×™××œ×™×ª?
 Communication Networks Course
Page | 9
Bonus â€“ Improving the Reliable UDP â€“ 15 points
Note: This part isnâ€™t mandatory and is a bonus only!
In this part, youâ€™ll improve your RUDP implementation by adding the concepts of flow
control and congestion control from TCP. Youâ€™re free to choose which algorithms to
implement, as long as you explain in your PDF which algorithms youâ€™ve used. Youâ€™ll probably
need to make changes in the original design of the RUDP. Changes only need to be to the API
itself, ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„.
Points distribution:
â€¢ Flow control improvement â€“ 7 Points
â€¢ Congestion control improvement â€“ 8 points.
Guidance:
â€¢ For flow control, you must use one of the Sliding window techniques: stop-and-wait
ARQ, Go-Back-N or Selective repeat.
â€¢ List of known TCP congestion control algorithms, which you can use any one of them
for this bonus task, or makeup your own:
Figure 2 â€“ List of known TCP congestion control algorithms, Wikipedia
 Communication Networks Course
Page | 10
Appendix A â€“ Linux local packet loss tool
To simulate a packet loss in a local network, we'll use a Linux tool that's called Linux Traffic
Control (ğ‘¡ğ‘). This requires a full Linux installation, so working with WSL won't work.
If the tool isn't installed in your machine, you can install it by using the following commands:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’
If the installation didn't work, you can use the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’2
To create a packet loss scenario, type the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘ğ‘‘ğ‘‘ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
After creating a packet loss scenario, you can change the percentage by typing the following
command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘â„ğ‘ğ‘›ğ‘”ğ‘’ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
To remove the packet loss scenario, write the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘‘ğ‘’ğ‘™ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š
 Communication Networks Course
Page | 11
Appendix B â€“ ğ’ğ’‚ğ’(ğŸ) system calls
This appendixâ€™s purpose is to give you a better understanding of socket handling in C.
A recommended reference is Beejâ€™s Guide to Network Programming, by Brian â€œBeej
Jorgensenâ€ Hall, which gives a lot of information about sockets in C and functions.
Functions and documentation links:
â€¢ ğ’”ğ’ğ’„ğ’Œğ’†ğ’•(ğŸ) â€“ A Factory method system call that creates a socket with the given
parameters.
â€¢ ğ’ƒğ’Šğ’ğ’…(ğŸ) â€“ Whenever we create a new socket, we need to bind it to a specific port in
our machine, â€œto catch a portâ€. The port number is managed and used by the kernel
to link incoming packets to the corresponding application socket. The port numbers
are usually fixed. The ğ‘ğ‘‘ğ‘‘ğ‘Ÿ parameter must match the current socket that is used.
â€¢ ğ’ğ’Šğ’”ğ’•ğ’†ğ’(ğŸ) â€“ The ğ‘™ğ‘–ğ‘ ğ‘¡ğ‘’ğ‘›(2) system call doesn't do anything in the mean of
communication but only memory allocation (malloc) for stream sockets only. If we
won't allocate memory, any incoming connection will fail.
â€¢ ğ’„ğ’ğ’ğ’ğ’†ğ’„ğ’•(ğŸ) â€“ The ğ‘ğ‘œğ‘›ğ‘›ğ‘’ğ‘ğ‘¡(2) system call starts the link between a client and a
specific IP address and port number. The connection would complete when the
other side will call the ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call.
â€¢ ğ’‚ğ’„ğ’„ğ’†ğ’‘ğ’•(ğŸ) â€“ The ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call accepts the incoming stream connection
request from the other side, by the listening socket. This system call completes the
three-way handshake of stream socket (like TCP) and opens a new socket that has a
direct communication channel only with the other party in the handshake.
â€¢ ğ’”ğ’†ğ’ğ’…(ğŸ) and ğ’”ğ’†ğ’ğ’…ğ’•ğ’(ğŸ) â€“ The ğ‘ ğ‘’ğ‘›ğ‘‘(2) and ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system calls are an analogy
for the ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’(2) system call, specifcly for sockets, with flags set to 0. Those system
calls return the number of bytes that were sent through the socket itself, as the
number of bytes can vary. The ğ‘ ğ‘’ğ‘›ğ‘‘(2)system call designed for stream sockets (like
TCP), while the ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system call designed for datagram connection-less
sockets (like UDP). When the ğ‘ ğ‘’ğ‘›ğ‘‘(2) system call returns 0, it means that the other
party closed the connection.
â€¢ ğ’“ğ’†ğ’„ğ’—(ğŸ) and ğ’“ğ’†ğ’„ğ’—ğ’‡ğ’“ğ’ğ’(ğŸ) â€“ The ğ‘Ÿğ‘’ğ‘ğ‘£(2) and ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system calls are an
analogy for the ğ‘Ÿğ‘’ğ‘ğ‘‘(2) system call, specifically for sockets, with flags set to 0.
Those system calls return the number of bytes that were received through the socket
itself, as the number of bytes can vary. The ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call designed for stream
sockets (like TCP), while the ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system call designed for datagram
connection-less sockets (like UDP). When the ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call returns 0, it means
that the other party closed the connection.
â€¢ ğ’„ğ’ğ’ğ’”ğ’†(ğŸ) and ğ’”ğ’‰ğ’–ğ’•ğ’…ğ’ğ’˜ğ’(ğŸ) â€“ The ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) and ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2) system calls close
the socket. While ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) system call closes the whole socket, the ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2)
system call partially closes the socket for read/write.
 Communication Networks Course
Page | 12
Appendix C â€“ Random data generator
The data that you are going to send in this assignment is randomly generated. You can use
your own file with appropriate size or use the following function (or a function of your own)
to generate the data:
/*
* @brief A random data generator function based on srand() and rand().
* @param size The size of the data to generate (up to 2^32 bytes).
* @return A pointer to the buffer.
*/
char *util_generate_random_data(unsigned int size) {
 char *buffer = NULL;
 // Argument check.
 if (size == 0)
 return NULL;
 buffer = (char *)calloc(size, sizeof(char));
 // Error checking.
 if (buffer == NULL)
 return NULL;
 // Randomize the seed of the random number generator.
 srand(time(NULL));
 for (unsigned int i = 0; i < size; i++)
 *(buffer + i) = ((unsigned int)rand() % 256);
 return buffer;
}
 Communication Networks Course
Page | 13
Appendix D â€“ Checksum function
A checksum is a small-sized block of data derived from another block of digital data for the
purpose of detecting errors that may have been introduced during its transmission or
storage. By themselves, checksums are often used to verify data integrity but are not relied
upon to verify data authenticity.
Below is a simple yet efficient implementation of the checksum function, you can use it for
the assignment, but you can implement your own checksum function.
/*
* @brief A checksum function that returns 16 bit checksum for data.
* @param data The data to do the checksum for.
* @param bytes The length of the data in bytes.
* @return The checksum itself as 16 bit unsigned number.
* @note This function is taken from RFC1071, can be found here:
* @note https://tools.ietf.org/html/rfc1071
* @note It is the simplest way to calculate a checksum and is not very strong.
* However, it is good enough for this assignment.
* @note You are free to use any other checksum function as well.
* You can also use this function as such without any change.
*/
unsigned short int calculate_checksum(void *data, unsigned int bytes) {
 unsigned short int *data_pointer = (unsigned short int *)data;
 unsigned int total_sum = 0;
 // Main summing loop
 while (bytes > 1) {
 total_sum += *data_pointer++;
 bytes -= 2;
 }
 // Add left-over byte, if any
 if (bytes > 0)
 total_sum += *((unsigned char *)data_pointer);
 // Fold 32-bit sum to 16 bits
 while (total_sum >> 16)
 total_sum = (total_sum & 0xFFFF) + (total_sum >> 16);
 return (~((unsigned short int)total_sum));
} Communication Networks Course
Page | 1
Assignment 3 â€“ Transport Layer
Assignment Notes and Instructions
This assignment is to be done in pairs only. You must upload all the necessary files in a ZIP
file named after both of the studentâ€™s ID. For example: ğŸğŸğŸ‘ğŸ’ğŸ“ğŸ”ğŸ•ğŸ–ğŸ—_ğŸ—ğŸ–ğŸ•ğŸ”ğŸ“ğŸ’ğŸ‘ğŸğŸ. ğ’›ğ’Šğ’‘.
1) The assignment must be submitted by the date specified in the submission box.
2) All the assignment files (Code, Wireshark pcap files, PDF) must be submitted in a ZIP file. The
PDF must contain all the necessary screenshots with a description for each one of them.
3) The assignment must be done in pairs only. In exceptional cases, you should send an email to
the course coordinator.
4) You can use any reference material available through the course Moodle website or any
material passed during the exercises.
5) You can use any reference from the web, but copying codes from websites is forbidden; this
includes codes from other GitHub repositories. A student who gets caught in the act will
automatically fail this assignment (score 0). Any website youâ€™ve used to solve the
assignment, every website you used to solve the assignment must be noted in the PDF.
6) No delays in submission without special permission. Lateness without approval will result in
failure of the assignment (score 0).
7) All submissions will be submitted via the course's Moodle website. Email submissions will not
be accepted, resulting in a failure in the assignment.
8) The order and design of the code must be carefully considered. Make sure that the program
output is as clear as possible, comments in the code, and meaningful variable names. You
must also submit a makefile that compiles all the programs.
9) The assignment code must be written in C only.
10) The assignment is personal for each pair, and you should not accept help from other people,
whether outside the university or inside it. You can contact the course staff during reception
hours for help or raise a question in the course forum. Do not transfer code sections
between students, upload solutions or parts of solutions to websites on the Internet or in
various communication groups.
11) Students who copy a solution will receive a 0 in all assignments in the course and a report will
be made to the institutional disciplinary committee.
12) All code files of the assignment are required to both compile and run properly on the Ubuntu
22.04 LTS operating system. This is the operating system where the submissions will be
tested. You mustnâ€™t code it in Windows, as it uses different API for sockets. WSL wonâ€™t work,
as the task needs a tool that works only in a fully Linux environment.
Good Luck!
 Communication Networks Course
Page | 2
Part A â€“ Transmission Control Protocol (TCP) â€“ 30 points
In this part, youâ€™ll write two program files: ğ‘»ğ‘ªğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and ğ‘»ğ‘ªğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
The Sender will send a randomly generated file and the Receiver will receive it and measure
the time it took for his program to receive the file. The file size should be at least 2MB.
When running the Sender and Receiver, they both should support two standard congestion
control algorithms: TCP Reno and TCP Cubic.
Notes:
â€¢ The main goal of this part is to get familiar with the TCP concept of sending
messages between two endpoints.
â€¢ For approaching this part of the assignment, please be sure that you are familiar
with the congestion control algorithms and how to change them using the correct
method in C (see Appendix B for more information).
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). You've
learned that TCP is reliable by design, so you can assume that all the data have been
passed correctly, and thus, no need to recheck.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
Usage:
â€¢ Receiver:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
â€¢ Sender:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port of the Receiver.
â€¢ ğ‘¨ğ‘³ğ‘®ğ‘¶ â€“ The TCP congestion control algorithm that will be used by the party
member (either ğ’“ğ’†ğ’ğ’ for TCP Reno or ğ’„ğ’–ğ’ƒğ’Šğ’„ for TCP Cubic).
 Communication Networks Course
Page | 3
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a TCP socket between the Sender and the
Receiver.
3) Send the file.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a TCP connection between the Receiver and
the Sender.
2) Get a connection from the sender.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./TCP_Receiver -p 1234 -algo reno
Starting Receiver...
Waiting for TCP connection...
Sender connected, beginning to receive file...
File transfer completed.
Waiting for Sender response...
Sender sent exit message.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 4
Part B â€“ Reliable User Datagram Protocol (Reliable UDP or RUDP) â€“ 40 points
Youâ€™ve learned that while TCP is reliable, it lacks speed and has an overhead data of 20 bytes,
compering to UDP that needs only 8 bytes of overhead data.
Reliable UDP or RUDP, is a protocol that uses the UDP protocol for a faster transmission of
data, while adding a reliability layer to it, but without adding too much overhead data like
TCP.
A simple sketch for a RUDP connection would look something like this:
Your task in this part is to implement a Reliable protocol using UDP only. For simplicity, your
implementation should only support a handshake, closing scheme, error checking,
acknowledgment of received packets, and retransmission of lost packets.
Guidance:
â€¢ You can use ğ‘ ğ‘’ğ‘¡ğ‘ ğ‘œğ‘ğ‘˜ğ‘œğ‘ğ‘¡(2) for detecting a timeout.
â€¢ You need to build your own protocol, as Reliable UDP isnâ€™t a standard protocol (see a
draft of RUDP in this link), and no official header is provided. You can use this sketch
for a header, but you can come up with your own protocol, as long as it works.
Where:
o ğ‘³ğ’†ğ’ğ’ˆğ’•ğ’‰ is the length of the data itself, without the RUDP header.
o ğ‘ªğ’‰ğ’†ğ’„ğ’Œğ’”ğ’–ğ’ is a 16bit number that validates the correctness of the data.
o ğ‘­ğ’ğ’‚ğ’ˆğ’” is a special byte where we classify the packet itself (SYN, ACK, etc.).
â€¢ In your PDF, you must explain how your implementation of RUDP works â€“ How does
it detect a timeout to do retransmissions, how does the handshake work, what is the
header overhead, etc.
â€¢ For this part, youâ€™ll write three files: ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¨ğ‘·ğ‘°. ğ’„, ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and
ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
Reliable UDP Header proposed sketch
Byte 0 Byte 1 Byte 2 Byte 3
Length (2 Bytes) Checksum (2 Bytes)
Flags (1 Byte)
Figure 1 - RUDP Protocol Architecture, Geeksforgeeks
 Communication Networks Course
Page | 5
Notes:
â€¢ The Sender will send a random generated file and the Receiver will receive it and
measure the time it took for his program to receive the file. The file size should be at
least 2MB.
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). But, as the
RUDP is based on UDP, itâ€™s not reliable. You must use some form of error checking
(like checksum) to ensure that the packet wasnâ€™t alerted during the transfer.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
â€¢ The RUDP needs support only 1 sender and 1 receiver, for simplicity purposes.
Usage:
â€¢ Receiver:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
â€¢ Sender:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port that both the Sender and the Receiver will use.
The ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„ file will contain all the implementations of the RUDP API functions (That is, to
prevent reusing the same chuck of code both in the Sender and the Receiver.).
The API should support at the bare minimum the following functions (you decide what
parameters to implement, and what are the names of the functions, as long as the API is
explained in the PDF):
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘œğ‘ğ‘˜ğ‘’ğ‘¡() â€“ Creating a RUDP socket and creating a handshake between two
peers.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘’ğ‘›ğ‘‘() â€“ Sending data to the peer. The function should wait for an
acknowledgment packet, and if it didnâ€™t receive any, retransmits the data.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘Ÿğ‘’ğ‘ğ‘£() â€“ Receive data from a peer.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ğ‘™ğ‘œğ‘ ğ‘’() â€“ Closes a connection between peers.
 Communication Networks Course
Page | 6
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a UDP socket between the Sender and the
Receiver.
3) Send the file via the RUDP protocol.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a UDP connection between the Receiver and
the Sender.
2) Get a connection from the sender, by the custom
RUDP protocol youâ€™ve built.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./RUDP_Receiver -p 1234
Starting Receiver...
Waiting for RUDP connection...
Connection request received, sending ACK.
Sender connected, beginning to receive file...
File transfer completed.
ACK sent.
Waiting for Sender response...
Sender sent exit message.
ACK sent.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 7
Part C â€“ Research â€“ 30 points
In this part, youâ€™ll conduct research about your implementations of part A and part B.
In the research itself, each one of the versions (TCP version and UDP version) will be run at
least 5 times (meaning that the file transfer will occur at least 5 times) by the following
conditions:
â€¢ For TCP, youâ€™ll run it in TCP Reno and TCP Cubic, alternating each time, for each
scenario, meaning that you run 5 times with TCP Reno in both Sender and Receiver,
and 5 times with TCP Cubic in both Sender and Receiver.
Bonus (5 points): Create a very large data set â€“ 5 times with TCP Reno in both Sender
and Receiver, 5 times with TCP Reno in Sender and TCP Cubic in Receiver, 5 times
with TCP Cubic in Sender and TCP Reno in Receiver, and 5 times with TCP Cubic in
both Sender and Receiver. This will give you a data set large enough, which allows
you to work with, compare with and to reach a definite conclusion.
â€¢ For RUDP, you will run it 5 times for each scenario.
â€¢ For both TCP and RUDP, you will run them on those scenarios of packet loss:
o 0% packet loss â€“ Control group, simulating perfect connection.
o 2% packet loss â€“ Simulating unstable connection that commonly occur.
o 5% packet loss â€“ Simulating bad connection.
o 10% packet loss â€“ Simulating extremely poor connection.
For each scenario, you must provide a filtered PCAP file and relevant screenshots that
explain each one of the steps in the process. (10 points)
After youâ€™ve gathered the data set for both TCP and Reliable UDP, answer the following
questions:
1) In TCP, which congestion control algorithm gave better results overall? TCP Reno or
TCP Cubic? Which one gave better results on high packet loss? Explain how you came
to this conclusion based on the data set youâ€™ve gathered. (5 points)
2) How did your implementation of Reliable UDP perform overall compared to regular
TCP? Which one is better for high packet loss? (5 points)
3) According to the data youâ€™ve gathered, in which scenarios and applications would we
prefer to use TCP and in which situations would we prefer to use reliable UDP?
Explain your answer. (5 points)
 Communication Networks Course
Page | 8
×¢× ×• ×¢×œ ×”×©××œ×•×ª ×”×‘××•×ª )5 × ×§×•×“×•×ª(:
â— ×‘"×¨×©×ª ×××™× ×”" ×”×›×•×•× ×” ×”×™× ×œ×¨×©×ª ×©×‘×” ××¢×˜ ×××•×“ ×—×‘×™×œ×•×ª ×”×•×œ×›×•×ª ×œ××™×‘×•×“. ×‘"×§×©×¨ ××¨×•×š" ×”×›×•×•× ×” ×”×™×
×œ×§×©×¨ TCP ×©×™×© ×‘×• ×”×¨×‘×” ×××•×“ ××™×“×¢ ×œ×©×œ×•×—. ××•×¦×¢ ×œ×”×’×“×™×œ ×‘ -TCP ××ª SSThreshold ×‘×ª×—×™×œ×ª ×”×§×©×¨.
×‘××™×–×” ××”××§×¨×™× ×”×‘××™× ×”×©×™× ×•×™ ×”×–×” ×¢×©×•×™ ×œ×”×•×¢×™×œ ×‘××™×“×” ×”××™×¨×‘×™×ª? × ××§.
.1 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
.2 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.3 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.4 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.5 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.6 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.7 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.8 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
â— A ×©×•×œ×— ×œ -B ×—×‘×™×œ×•×ª ××™×“×¢ ×‘×××¦×¢×•×ª ×§×©×¨ TCP. × ×ª×•×Ÿ ×›×™ ×”×§×©×¨ ××ª×—×™×œ ×¢× ×—×œ×•×Ÿ ×‘×’×•×“×œ 1MSS. ×”×§×©×¨
××¡×ª×™×™× ×‘×¤×¢× ×”×¨××©×•× ×” ×©×”×•× ××’×™×¢ ×œ -SSthresh. ×‘××”×œ×š ×”×§×©×¨ ×œ× ××•×‘×“×•×ª ×—×‘×™×œ×•×ª. × ×¡××Ÿ ×‘×§×™×¦×•×¨:
.SSthresh=S*MSS
× ×ª×•×Ÿ ×›×™ ×œ××•×¨×š ×›×œ ×”×§×©×¨ rwnd < MSS*S.
××”×™ ×”×ª×¤×•×§×” ×©×œ ×”×§×©×¨ ×-A ×œ-B( ×‘ -sec / Bytes )×‘×–××Ÿ ×”× "×œ? × ××§×™.
]S*MSS / [lg (S) * RTT*2 ×‘×¢×¨×š .1
]S*MSS / [S^0.5 * RTT*2 ×‘×¢×¨×š .2
S*MSS / RTT ×‘×¢×¨×š .3
S^2)*MSS / RTT( ×‘×¢×¨×š .4
â— ×©×ª×™ ×ª×—× ×•×ª ××ª×§×©×¨×•×ª ×‘××•×¤×Ÿ ××œ×—×•×˜×™ ×‘×©×™×˜×ª N Back Go.
× ×¡××Ÿ ×‘-X ××ª ×¡×¤×¨×ª ×”×‘×™×§×•×¨×ª ×©×œ ×”×ª.×–. ×©×œ×š. ×× ×©× ×™ ×©×•×ª×¤×™× ××’×™×©×™× ××ª ×”×ª×¨×’×™×œ ×™×—×“, X ×”×•× ×¡×¤×¨×ª
×”×‘×™×§×•×¨×ª ×‘×¢×œ×ª ×”×¢×¨×š ×”× ××•×š ×™×•×ª×¨ ××‘×™×Ÿ ×”×©×ª×™×™×.
×§×¦×‘ ×”×ª×§×©×•×¨×ª ×”×•× 8Gbps, ×•×’×•×“×œ ×›×œ ×—×‘×™×œ×” ×”×•× KByte*X. ×’×“×œ×™ ×”-headers ×•×” -Acks ×–× ×™×—×™×.
ï¿½ğ‘’ğ‘ ï¿½/ï¿½ï¿½ 8 , ×•×”××¨×—×§ ×‘×™×Ÿ ×”×ª×—× ×•×ª ×”×•× 1Km. ×§×¦×‘ ×”×”×ª×¤×©×˜×•×ª ×”×•× 10 â‹… 2
×–××Ÿ ×¢×™×‘×•×“ ×”× ×ª×•× ×™× ×‘×ª×—× ×•×ª ×–× ×™×—.
××£ ×—×‘×™×œ×” ×•××£ Ack ×œ× ×”×•×œ×›×™× ×œ××™×‘×•×“.
â— ××”×• X ×©×œ×š?
â— ××” ×¦×¨×™×š ×œ×”×™×•×ª ×’×•×“×œ ×—×œ×•×Ÿ ×”××©×œ×•×— ×›×“×™ ×œ×”×‘×˜×™×— ×ª×¤×•×§×” ××§×¡×™××œ×™×ª?
 Communication Networks Course
Page | 9
Bonus â€“ Improving the Reliable UDP â€“ 15 points
Note: This part isnâ€™t mandatory and is a bonus only!
In this part, youâ€™ll improve your RUDP implementation by adding the concepts of flow
control and congestion control from TCP. Youâ€™re free to choose which algorithms to
implement, as long as you explain in your PDF which algorithms youâ€™ve used. Youâ€™ll probably
need to make changes in the original design of the RUDP. Changes only need to be to the API
itself, ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„.
Points distribution:
â€¢ Flow control improvement â€“ 7 Points
â€¢ Congestion control improvement â€“ 8 points.
Guidance:
â€¢ For flow control, you must use one of the Sliding window techniques: stop-and-wait
ARQ, Go-Back-N or Selective repeat.
â€¢ List of known TCP congestion control algorithms, which you can use any one of them
for this bonus task, or makeup your own:
Figure 2 â€“ List of known TCP congestion control algorithms, Wikipedia
 Communication Networks Course
Page | 10
Appendix A â€“ Linux local packet loss tool
To simulate a packet loss in a local network, we'll use a Linux tool that's called Linux Traffic
Control (ğ‘¡ğ‘). This requires a full Linux installation, so working with WSL won't work.
If the tool isn't installed in your machine, you can install it by using the following commands:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’
If the installation didn't work, you can use the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’2
To create a packet loss scenario, type the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘ğ‘‘ğ‘‘ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
After creating a packet loss scenario, you can change the percentage by typing the following
command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘â„ğ‘ğ‘›ğ‘”ğ‘’ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
To remove the packet loss scenario, write the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘‘ğ‘’ğ‘™ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š
 Communication Networks Course
Page | 11
Appendix B â€“ ğ’ğ’‚ğ’(ğŸ) system calls
This appendixâ€™s purpose is to give you a better understanding of socket handling in C.
A recommended reference is Beejâ€™s Guide to Network Programming, by Brian â€œBeej
Jorgensenâ€ Hall, which gives a lot of information about sockets in C and functions.
Functions and documentation links:
â€¢ ğ’”ğ’ğ’„ğ’Œğ’†ğ’•(ğŸ) â€“ A Factory method system call that creates a socket with the given
parameters.
â€¢ ğ’ƒğ’Šğ’ğ’…(ğŸ) â€“ Whenever we create a new socket, we need to bind it to a specific port in
our machine, â€œto catch a portâ€. The port number is managed and used by the kernel
to link incoming packets to the corresponding application socket. The port numbers
are usually fixed. The ğ‘ğ‘‘ğ‘‘ğ‘Ÿ parameter must match the current socket that is used.
â€¢ ğ’ğ’Šğ’”ğ’•ğ’†ğ’(ğŸ) â€“ The ğ‘™ğ‘–ğ‘ ğ‘¡ğ‘’ğ‘›(2) system call doesn't do anything in the mean of
communication but only memory allocation (malloc) for stream sockets only. If we
won't allocate memory, any incoming connection will fail.
â€¢ ğ’„ğ’ğ’ğ’ğ’†ğ’„ğ’•(ğŸ) â€“ The ğ‘ğ‘œğ‘›ğ‘›ğ‘’ğ‘ğ‘¡(2) system call starts the link between a client and a
specific IP address and port number. The connection would complete when the
other side will call the ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call.
â€¢ ğ’‚ğ’„ğ’„ğ’†ğ’‘ğ’•(ğŸ) â€“ The ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call accepts the incoming stream connection
request from the other side, by the listening socket. This system call completes the
three-way handshake of stream socket (like TCP) and opens a new socket that has a
direct communication channel only with the other party in the handshake.
â€¢ ğ’”ğ’†ğ’ğ’…(ğŸ) and ğ’”ğ’†ğ’ğ’…ğ’•ğ’(ğŸ) â€“ The ğ‘ ğ‘’ğ‘›ğ‘‘(2) and ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system calls are an analogy
for the ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’(2) system call, specifcly for sockets, with flags set to 0. Those system
calls return the number of bytes that were sent through the socket itself, as the
number of bytes can vary. The ğ‘ ğ‘’ğ‘›ğ‘‘(2)system call designed for stream sockets (like
TCP), while the ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system call designed for datagram connection-less
sockets (like UDP). When the ğ‘ ğ‘’ğ‘›ğ‘‘(2) system call returns 0, it means that the other
party closed the connection.
â€¢ ğ’“ğ’†ğ’„ğ’—(ğŸ) and ğ’“ğ’†ğ’„ğ’—ğ’‡ğ’“ğ’ğ’(ğŸ) â€“ The ğ‘Ÿğ‘’ğ‘ğ‘£(2) and ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system calls are an
analogy for the ğ‘Ÿğ‘’ğ‘ğ‘‘(2) system call, specifically for sockets, with flags set to 0.
Those system calls return the number of bytes that were received through the socket
itself, as the number of bytes can vary. The ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call designed for stream
sockets (like TCP), while the ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system call designed for datagram
connection-less sockets (like UDP). When the ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call returns 0, it means
that the other party closed the connection.
â€¢ ğ’„ğ’ğ’ğ’”ğ’†(ğŸ) and ğ’”ğ’‰ğ’–ğ’•ğ’…ğ’ğ’˜ğ’(ğŸ) â€“ The ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) and ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2) system calls close
the socket. While ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) system call closes the whole socket, the ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2)
system call partially closes the socket for read/write.
 Communication Networks Course
Page | 12
Appendix C â€“ Random data generator
The data that you are going to send in this assignment is randomly generated. You can use
your own file with appropriate size or use the following function (or a function of your own)
to generate the data:
/*
* @brief A random data generator function based on srand() and rand().
* @param size The size of the data to generate (up to 2^32 bytes).
* @return A pointer to the buffer.
*/
char *util_generate_random_data(unsigned int size) {
 char *buffer = NULL;
 // Argument check.
 if (size == 0)
 return NULL;
 buffer = (char *)calloc(size, sizeof(char));
 // Error checking.
 if (buffer == NULL)
 return NULL;
 // Randomize the seed of the random number generator.
 srand(time(NULL));
 for (unsigned int i = 0; i < size; i++)
 *(buffer + i) = ((unsigned int)rand() % 256);
 return buffer;
}
 Communication Networks Course
Page | 13
Appendix D â€“ Checksum function
A checksum is a small-sized block of data derived from another block of digital data for the
purpose of detecting errors that may have been introduced during its transmission or
storage. By themselves, checksums are often used to verify data integrity but are not relied
upon to verify data authenticity.
Below is a simple yet efficient implementation of the checksum function, you can use it for
the assignment, but you can implement your own checksum function.
/*
* @brief A checksum function that returns 16 bit checksum for data.
* @param data The data to do the checksum for.
* @param bytes The length of the data in bytes.
* @return The checksum itself as 16 bit unsigned number.
* @note This function is taken from RFC1071, can be found here:
* @note https://tools.ietf.org/html/rfc1071
* @note It is the simplest way to calculate a checksum and is not very strong.
* However, it is good enough for this assignment.
* @note You are free to use any other checksum function as well.
* You can also use this function as such without any change.
*/
unsigned short int calculate_checksum(void *data, unsigned int bytes) {
 unsigned short int *data_pointer = (unsigned short int *)data;
 unsigned int total_sum = 0;
 // Main summing loop
 while (bytes > 1) {
 total_sum += *data_pointer++;
 bytes -= 2;
 }
 // Add left-over byte, if any
 if (bytes > 0)
 total_sum += *((unsigned char *)data_pointer);
 // Fold 32-bit sum to 16 bits
 while (total_sum >> 16)
 total_sum = (total_sum & 0xFFFF) + (total_sum >> 16);
 return (~((unsigned short int)total_sum));
} Communication Networks Course
Page | 1
Assignment 3 â€“ Transport Layer
Assignment Notes and Instructions
This assignment is to be done in pairs only. You must upload all the necessary files in a ZIP
file named after both of the studentâ€™s ID. For example: ğŸğŸğŸ‘ğŸ’ğŸ“ğŸ”ğŸ•ğŸ–ğŸ—_ğŸ—ğŸ–ğŸ•ğŸ”ğŸ“ğŸ’ğŸ‘ğŸğŸ. ğ’›ğ’Šğ’‘.
1) The assignment must be submitted by the date specified in the submission box.
2) All the assignment files (Code, Wireshark pcap files, PDF) must be submitted in a ZIP file. The
PDF must contain all the necessary screenshots with a description for each one of them.
3) The assignment must be done in pairs only. In exceptional cases, you should send an email to
the course coordinator.
4) You can use any reference material available through the course Moodle website or any
material passed during the exercises.
5) You can use any reference from the web, but copying codes from websites is forbidden; this
includes codes from other GitHub repositories. A student who gets caught in the act will
automatically fail this assignment (score 0). Any website youâ€™ve used to solve the
assignment, every website you used to solve the assignment must be noted in the PDF.
6) No delays in submission without special permission. Lateness without approval will result in
failure of the assignment (score 0).
7) All submissions will be submitted via the course's Moodle website. Email submissions will not
be accepted, resulting in a failure in the assignment.
8) The order and design of the code must be carefully considered. Make sure that the program
output is as clear as possible, comments in the code, and meaningful variable names. You
must also submit a makefile that compiles all the programs.
9) The assignment code must be written in C only.
10) The assignment is personal for each pair, and you should not accept help from other people,
whether outside the university or inside it. You can contact the course staff during reception
hours for help or raise a question in the course forum. Do not transfer code sections
between students, upload solutions or parts of solutions to websites on the Internet or in
various communication groups.
11) Students who copy a solution will receive a 0 in all assignments in the course and a report will
be made to the institutional disciplinary committee.
12) All code files of the assignment are required to both compile and run properly on the Ubuntu
22.04 LTS operating system. This is the operating system where the submissions will be
tested. You mustnâ€™t code it in Windows, as it uses different API for sockets. WSL wonâ€™t work,
as the task needs a tool that works only in a fully Linux environment.
Good Luck!
 Communication Networks Course
Page | 2
Part A â€“ Transmission Control Protocol (TCP) â€“ 30 points
In this part, youâ€™ll write two program files: ğ‘»ğ‘ªğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and ğ‘»ğ‘ªğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
The Sender will send a randomly generated file and the Receiver will receive it and measure
the time it took for his program to receive the file. The file size should be at least 2MB.
When running the Sender and Receiver, they both should support two standard congestion
control algorithms: TCP Reno and TCP Cubic.
Notes:
â€¢ The main goal of this part is to get familiar with the TCP concept of sending
messages between two endpoints.
â€¢ For approaching this part of the assignment, please be sure that you are familiar
with the congestion control algorithms and how to change them using the correct
method in C (see Appendix B for more information).
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). You've
learned that TCP is reliable by design, so you can assume that all the data have been
passed correctly, and thus, no need to recheck.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
Usage:
â€¢ Receiver:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
â€¢ Sender:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port of the Receiver.
â€¢ ğ‘¨ğ‘³ğ‘®ğ‘¶ â€“ The TCP congestion control algorithm that will be used by the party
member (either ğ’“ğ’†ğ’ğ’ for TCP Reno or ğ’„ğ’–ğ’ƒğ’Šğ’„ for TCP Cubic).
 Communication Networks Course
Page | 3
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a TCP socket between the Sender and the
Receiver.
3) Send the file.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a TCP connection between the Receiver and
the Sender.
2) Get a connection from the sender.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./TCP_Receiver -p 1234 -algo reno
Starting Receiver...
Waiting for TCP connection...
Sender connected, beginning to receive file...
File transfer completed.
Waiting for Sender response...
Sender sent exit message.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 4
Part B â€“ Reliable User Datagram Protocol (Reliable UDP or RUDP) â€“ 40 points
Youâ€™ve learned that while TCP is reliable, it lacks speed and has an overhead data of 20 bytes,
compering to UDP that needs only 8 bytes of overhead data.
Reliable UDP or RUDP, is a protocol that uses the UDP protocol for a faster transmission of
data, while adding a reliability layer to it, but without adding too much overhead data like
TCP.
A simple sketch for a RUDP connection would look something like this:
Your task in this part is to implement a Reliable protocol using UDP only. For simplicity, your
implementation should only support a handshake, closing scheme, error checking,
acknowledgment of received packets, and retransmission of lost packets.
Guidance:
â€¢ You can use ğ‘ ğ‘’ğ‘¡ğ‘ ğ‘œğ‘ğ‘˜ğ‘œğ‘ğ‘¡(2) for detecting a timeout.
â€¢ You need to build your own protocol, as Reliable UDP isnâ€™t a standard protocol (see a
draft of RUDP in this link), and no official header is provided. You can use this sketch
for a header, but you can come up with your own protocol, as long as it works.
Where:
o ğ‘³ğ’†ğ’ğ’ˆğ’•ğ’‰ is the length of the data itself, without the RUDP header.
o ğ‘ªğ’‰ğ’†ğ’„ğ’Œğ’”ğ’–ğ’ is a 16bit number that validates the correctness of the data.
o ğ‘­ğ’ğ’‚ğ’ˆğ’” is a special byte where we classify the packet itself (SYN, ACK, etc.).
â€¢ In your PDF, you must explain how your implementation of RUDP works â€“ How does
it detect a timeout to do retransmissions, how does the handshake work, what is the
header overhead, etc.
â€¢ For this part, youâ€™ll write three files: ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¨ğ‘·ğ‘°. ğ’„, ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and
ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
Reliable UDP Header proposed sketch
Byte 0 Byte 1 Byte 2 Byte 3
Length (2 Bytes) Checksum (2 Bytes)
Flags (1 Byte)
Figure 1 - RUDP Protocol Architecture, Geeksforgeeks
 Communication Networks Course
Page | 5
Notes:
â€¢ The Sender will send a random generated file and the Receiver will receive it and
measure the time it took for his program to receive the file. The file size should be at
least 2MB.
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). But, as the
RUDP is based on UDP, itâ€™s not reliable. You must use some form of error checking
(like checksum) to ensure that the packet wasnâ€™t alerted during the transfer.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
â€¢ The RUDP needs support only 1 sender and 1 receiver, for simplicity purposes.
Usage:
â€¢ Receiver:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
â€¢ Sender:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port that both the Sender and the Receiver will use.
The ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„ file will contain all the implementations of the RUDP API functions (That is, to
prevent reusing the same chuck of code both in the Sender and the Receiver.).
The API should support at the bare minimum the following functions (you decide what
parameters to implement, and what are the names of the functions, as long as the API is
explained in the PDF):
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘œğ‘ğ‘˜ğ‘’ğ‘¡() â€“ Creating a RUDP socket and creating a handshake between two
peers.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘’ğ‘›ğ‘‘() â€“ Sending data to the peer. The function should wait for an
acknowledgment packet, and if it didnâ€™t receive any, retransmits the data.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘Ÿğ‘’ğ‘ğ‘£() â€“ Receive data from a peer.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ğ‘™ğ‘œğ‘ ğ‘’() â€“ Closes a connection between peers.
 Communication Networks Course
Page | 6
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a UDP socket between the Sender and the
Receiver.
3) Send the file via the RUDP protocol.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a UDP connection between the Receiver and
the Sender.
2) Get a connection from the sender, by the custom
RUDP protocol youâ€™ve built.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./RUDP_Receiver -p 1234
Starting Receiver...
Waiting for RUDP connection...
Connection request received, sending ACK.
Sender connected, beginning to receive file...
File transfer completed.
ACK sent.
Waiting for Sender response...
Sender sent exit message.
ACK sent.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 7
Part C â€“ Research â€“ 30 points
In this part, youâ€™ll conduct research about your implementations of part A and part B.
In the research itself, each one of the versions (TCP version and UDP version) will be run at
least 5 times (meaning that the file transfer will occur at least 5 times) by the following
conditions:
â€¢ For TCP, youâ€™ll run it in TCP Reno and TCP Cubic, alternating each time, for each
scenario, meaning that you run 5 times with TCP Reno in both Sender and Receiver,
and 5 times with TCP Cubic in both Sender and Receiver.
Bonus (5 points): Create a very large data set â€“ 5 times with TCP Reno in both Sender
and Receiver, 5 times with TCP Reno in Sender and TCP Cubic in Receiver, 5 times
with TCP Cubic in Sender and TCP Reno in Receiver, and 5 times with TCP Cubic in
both Sender and Receiver. This will give you a data set large enough, which allows
you to work with, compare with and to reach a definite conclusion.
â€¢ For RUDP, you will run it 5 times for each scenario.
â€¢ For both TCP and RUDP, you will run them on those scenarios of packet loss:
o 0% packet loss â€“ Control group, simulating perfect connection.
o 2% packet loss â€“ Simulating unstable connection that commonly occur.
o 5% packet loss â€“ Simulating bad connection.
o 10% packet loss â€“ Simulating extremely poor connection.
For each scenario, you must provide a filtered PCAP file and relevant screenshots that
explain each one of the steps in the process. (10 points)
After youâ€™ve gathered the data set for both TCP and Reliable UDP, answer the following
questions:
1) In TCP, which congestion control algorithm gave better results overall? TCP Reno or
TCP Cubic? Which one gave better results on high packet loss? Explain how you came
to this conclusion based on the data set youâ€™ve gathered. (5 points)
2) How did your implementation of Reliable UDP perform overall compared to regular
TCP? Which one is better for high packet loss? (5 points)
3) According to the data youâ€™ve gathered, in which scenarios and applications would we
prefer to use TCP and in which situations would we prefer to use reliable UDP?
Explain your answer. (5 points)
 Communication Networks Course
Page | 8
×¢× ×• ×¢×œ ×”×©××œ×•×ª ×”×‘××•×ª )5 × ×§×•×“×•×ª(:
â— ×‘"×¨×©×ª ×××™× ×”" ×”×›×•×•× ×” ×”×™× ×œ×¨×©×ª ×©×‘×” ××¢×˜ ×××•×“ ×—×‘×™×œ×•×ª ×”×•×œ×›×•×ª ×œ××™×‘×•×“. ×‘"×§×©×¨ ××¨×•×š" ×”×›×•×•× ×” ×”×™×
×œ×§×©×¨ TCP ×©×™×© ×‘×• ×”×¨×‘×” ×××•×“ ××™×“×¢ ×œ×©×œ×•×—. ××•×¦×¢ ×œ×”×’×“×™×œ ×‘ -TCP ××ª SSThreshold ×‘×ª×—×™×œ×ª ×”×§×©×¨.
×‘××™×–×” ××”××§×¨×™× ×”×‘××™× ×”×©×™× ×•×™ ×”×–×” ×¢×©×•×™ ×œ×”×•×¢×™×œ ×‘××™×“×” ×”××™×¨×‘×™×ª? × ××§.
.1 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
.2 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.3 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.4 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.5 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.6 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.7 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.8 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
â— A ×©×•×œ×— ×œ -B ×—×‘×™×œ×•×ª ××™×“×¢ ×‘×××¦×¢×•×ª ×§×©×¨ TCP. × ×ª×•×Ÿ ×›×™ ×”×§×©×¨ ××ª×—×™×œ ×¢× ×—×œ×•×Ÿ ×‘×’×•×“×œ 1MSS. ×”×§×©×¨
××¡×ª×™×™× ×‘×¤×¢× ×”×¨××©×•× ×” ×©×”×•× ××’×™×¢ ×œ -SSthresh. ×‘××”×œ×š ×”×§×©×¨ ×œ× ××•×‘×“×•×ª ×—×‘×™×œ×•×ª. × ×¡××Ÿ ×‘×§×™×¦×•×¨:
.SSthresh=S*MSS
× ×ª×•×Ÿ ×›×™ ×œ××•×¨×š ×›×œ ×”×§×©×¨ rwnd < MSS*S.
××”×™ ×”×ª×¤×•×§×” ×©×œ ×”×§×©×¨ ×-A ×œ-B( ×‘ -sec / Bytes )×‘×–××Ÿ ×”× "×œ? × ××§×™.
]S*MSS / [lg (S) * RTT*2 ×‘×¢×¨×š .1
]S*MSS / [S^0.5 * RTT*2 ×‘×¢×¨×š .2
S*MSS / RTT ×‘×¢×¨×š .3
S^2)*MSS / RTT( ×‘×¢×¨×š .4
â— ×©×ª×™ ×ª×—× ×•×ª ××ª×§×©×¨×•×ª ×‘××•×¤×Ÿ ××œ×—×•×˜×™ ×‘×©×™×˜×ª N Back Go.
× ×¡××Ÿ ×‘-X ××ª ×¡×¤×¨×ª ×”×‘×™×§×•×¨×ª ×©×œ ×”×ª.×–. ×©×œ×š. ×× ×©× ×™ ×©×•×ª×¤×™× ××’×™×©×™× ××ª ×”×ª×¨×’×™×œ ×™×—×“, X ×”×•× ×¡×¤×¨×ª
×”×‘×™×§×•×¨×ª ×‘×¢×œ×ª ×”×¢×¨×š ×”× ××•×š ×™×•×ª×¨ ××‘×™×Ÿ ×”×©×ª×™×™×.
×§×¦×‘ ×”×ª×§×©×•×¨×ª ×”×•× 8Gbps, ×•×’×•×“×œ ×›×œ ×—×‘×™×œ×” ×”×•× KByte*X. ×’×“×œ×™ ×”-headers ×•×” -Acks ×–× ×™×—×™×.
ï¿½ğ‘’ğ‘ ï¿½/ï¿½ï¿½ 8 , ×•×”××¨×—×§ ×‘×™×Ÿ ×”×ª×—× ×•×ª ×”×•× 1Km. ×§×¦×‘ ×”×”×ª×¤×©×˜×•×ª ×”×•× 10 â‹… 2
×–××Ÿ ×¢×™×‘×•×“ ×”× ×ª×•× ×™× ×‘×ª×—× ×•×ª ×–× ×™×—.
××£ ×—×‘×™×œ×” ×•××£ Ack ×œ× ×”×•×œ×›×™× ×œ××™×‘×•×“.
â— ××”×• X ×©×œ×š?
â— ××” ×¦×¨×™×š ×œ×”×™×•×ª ×’×•×“×œ ×—×œ×•×Ÿ ×”××©×œ×•×— ×›×“×™ ×œ×”×‘×˜×™×— ×ª×¤×•×§×” ××§×¡×™××œ×™×ª?
 Communication Networks Course
Page | 9
Bonus â€“ Improving the Reliable UDP â€“ 15 points
Note: This part isnâ€™t mandatory and is a bonus only!
In this part, youâ€™ll improve your RUDP implementation by adding the concepts of flow
control and congestion control from TCP. Youâ€™re free to choose which algorithms to
implement, as long as you explain in your PDF which algorithms youâ€™ve used. Youâ€™ll probably
need to make changes in the original design of the RUDP. Changes only need to be to the API
itself, ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„.
Points distribution:
â€¢ Flow control improvement â€“ 7 Points
â€¢ Congestion control improvement â€“ 8 points.
Guidance:
â€¢ For flow control, you must use one of the Sliding window techniques: stop-and-wait
ARQ, Go-Back-N or Selective repeat.
â€¢ List of known TCP congestion control algorithms, which you can use any one of them
for this bonus task, or makeup your own:
Figure 2 â€“ List of known TCP congestion control algorithms, Wikipedia
 Communication Networks Course
Page | 10
Appendix A â€“ Linux local packet loss tool
To simulate a packet loss in a local network, we'll use a Linux tool that's called Linux Traffic
Control (ğ‘¡ğ‘). This requires a full Linux installation, so working with WSL won't work.
If the tool isn't installed in your machine, you can install it by using the following commands:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’
If the installation didn't work, you can use the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’2
To create a packet loss scenario, type the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘ğ‘‘ğ‘‘ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
After creating a packet loss scenario, you can change the percentage by typing the following
command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘â„ğ‘ğ‘›ğ‘”ğ‘’ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
To remove the packet loss scenario, write the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘‘ğ‘’ğ‘™ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š
 Communication Networks Course
Page | 11
Appendix B â€“ ğ’ğ’‚ğ’(ğŸ) system calls
This appendixâ€™s purpose is to give you a better understanding of socket handling in C.
A recommended reference is Beejâ€™s Guide to Network Programming, by Brian â€œBeej
Jorgensenâ€ Hall, which gives a lot of information about sockets in C and functions.
Functions and documentation links:
â€¢ ğ’”ğ’ğ’„ğ’Œğ’†ğ’•(ğŸ) â€“ A Factory method system call that creates a socket with the given
parameters.
â€¢ ğ’ƒğ’Šğ’ğ’…(ğŸ) â€“ Whenever we create a new socket, we need to bind it to a specific port in
our machine, â€œto catch a portâ€. The port number is managed and used by the kernel
to link incoming packets to the corresponding application socket. The port numbers
are usually fixed. The ğ‘ğ‘‘ğ‘‘ğ‘Ÿ parameter must match the current socket that is used.
â€¢ ğ’ğ’Šğ’”ğ’•ğ’†ğ’(ğŸ) â€“ The ğ‘™ğ‘–ğ‘ ğ‘¡ğ‘’ğ‘›(2) system call doesn't do anything in the mean of
communication but only memory allocation (malloc) for stream sockets only. If we
won't allocate memory, any incoming connection will fail.
â€¢ ğ’„ğ’ğ’ğ’ğ’†ğ’„ğ’•(ğŸ) â€“ The ğ‘ğ‘œğ‘›ğ‘›ğ‘’ğ‘ğ‘¡(2) system call starts the link between a client and a
specific IP address and port number. The connection would complete when the
other side will call the ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call.
â€¢ ğ’‚ğ’„ğ’„ğ’†ğ’‘ğ’•(ğŸ) â€“ The ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call accepts the incoming stream connection
request from the other side, by the listening socket. This system call completes the
three-way handshake of stream socket (like TCP) and opens a new socket that has a
direct communication channel only with the other party in the handshake.
â€¢ ğ’”ğ’†ğ’ğ’…(ğŸ) and ğ’”ğ’†ğ’ğ’…ğ’•ğ’(ğŸ) â€“ The ğ‘ ğ‘’ğ‘›ğ‘‘(2) and ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system calls are an analogy
for the ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’(2) system call, specifcly for sockets, with flags set to 0. Those system
calls return the number of bytes that were sent through the socket itself, as the
number of bytes can vary. The ğ‘ ğ‘’ğ‘›ğ‘‘(2)system call designed for stream sockets (like
TCP), while the ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system call designed for datagram connection-less
sockets (like UDP). When the ğ‘ ğ‘’ğ‘›ğ‘‘(2) system call returns 0, it means that the other
party closed the connection.
â€¢ ğ’“ğ’†ğ’„ğ’—(ğŸ) and ğ’“ğ’†ğ’„ğ’—ğ’‡ğ’“ğ’ğ’(ğŸ) â€“ The ğ‘Ÿğ‘’ğ‘ğ‘£(2) and ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system calls are an
analogy for the ğ‘Ÿğ‘’ğ‘ğ‘‘(2) system call, specifically for sockets, with flags set to 0.
Those system calls return the number of bytes that were received through the socket
itself, as the number of bytes can vary. The ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call designed for stream
sockets (like TCP), while the ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system call designed for datagram
connection-less sockets (like UDP). When the ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call returns 0, it means
that the other party closed the connection.
â€¢ ğ’„ğ’ğ’ğ’”ğ’†(ğŸ) and ğ’”ğ’‰ğ’–ğ’•ğ’…ğ’ğ’˜ğ’(ğŸ) â€“ The ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) and ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2) system calls close
the socket. While ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) system call closes the whole socket, the ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2)
system call partially closes the socket for read/write.
 Communication Networks Course
Page | 12
Appendix C â€“ Random data generator
The data that you are going to send in this assignment is randomly generated. You can use
your own file with appropriate size or use the following function (or a function of your own)
to generate the data:
/*
* @brief A random data generator function based on srand() and rand().
* @param size The size of the data to generate (up to 2^32 bytes).
* @return A pointer to the buffer.
*/
char *util_generate_random_data(unsigned int size) {
 char *buffer = NULL;
 // Argument check.
 if (size == 0)
 return NULL;
 buffer = (char *)calloc(size, sizeof(char));
 // Error checking.
 if (buffer == NULL)
 return NULL;
 // Randomize the seed of the random number generator.
 srand(time(NULL));
 for (unsigned int i = 0; i < size; i++)
 *(buffer + i) = ((unsigned int)rand() % 256);
 return buffer;
}
 Communication Networks Course
Page | 13
Appendix D â€“ Checksum function
A checksum is a small-sized block of data derived from another block of digital data for the
purpose of detecting errors that may have been introduced during its transmission or
storage. By themselves, checksums are often used to verify data integrity but are not relied
upon to verify data authenticity.
Below is a simple yet efficient implementation of the checksum function, you can use it for
the assignment, but you can implement your own checksum function.
/*
* @brief A checksum function that returns 16 bit checksum for data.
* @param data The data to do the checksum for.
* @param bytes The length of the data in bytes.
* @return The checksum itself as 16 bit unsigned number.
* @note This function is taken from RFC1071, can be found here:
* @note https://tools.ietf.org/html/rfc1071
* @note It is the simplest way to calculate a checksum and is not very strong.
* However, it is good enough for this assignment.
* @note You are free to use any other checksum function as well.
* You can also use this function as such without any change.
*/
unsigned short int calculate_checksum(void *data, unsigned int bytes) {
 unsigned short int *data_pointer = (unsigned short int *)data;
 unsigned int total_sum = 0;
 // Main summing loop
 while (bytes > 1) {
 total_sum += *data_pointer++;
 bytes -= 2;
 }
 // Add left-over byte, if any
 if (bytes > 0)
 total_sum += *((unsigned char *)data_pointer);
 // Fold 32-bit sum to 16 bits
 while (total_sum >> 16)
 total_sum = (total_sum & 0xFFFF) + (total_sum >> 16);
 return (~((unsigned short int)total_sum));
} Communication Networks Course
Page | 1
Assignment 3 â€“ Transport Layer
Assignment Notes and Instructions
This assignment is to be done in pairs only. You must upload all the necessary files in a ZIP
file named after both of the studentâ€™s ID. For example: ğŸğŸğŸ‘ğŸ’ğŸ“ğŸ”ğŸ•ğŸ–ğŸ—_ğŸ—ğŸ–ğŸ•ğŸ”ğŸ“ğŸ’ğŸ‘ğŸğŸ. ğ’›ğ’Šğ’‘.
1) The assignment must be submitted by the date specified in the submission box.
2) All the assignment files (Code, Wireshark pcap files, PDF) must be submitted in a ZIP file. The
PDF must contain all the necessary screenshots with a description for each one of them.
3) The assignment must be done in pairs only. In exceptional cases, you should send an email to
the course coordinator.
4) You can use any reference material available through the course Moodle website or any
material passed during the exercises.
5) You can use any reference from the web, but copying codes from websites is forbidden; this
includes codes from other GitHub repositories. A student who gets caught in the act will
automatically fail this assignment (score 0). Any website youâ€™ve used to solve the
assignment, every website you used to solve the assignment must be noted in the PDF.
6) No delays in submission without special permission. Lateness without approval will result in
failure of the assignment (score 0).
7) All submissions will be submitted via the course's Moodle website. Email submissions will not
be accepted, resulting in a failure in the assignment.
8) The order and design of the code must be carefully considered. Make sure that the program
output is as clear as possible, comments in the code, and meaningful variable names. You
must also submit a makefile that compiles all the programs.
9) The assignment code must be written in C only.
10) The assignment is personal for each pair, and you should not accept help from other people,
whether outside the university or inside it. You can contact the course staff during reception
hours for help or raise a question in the course forum. Do not transfer code sections
between students, upload solutions or parts of solutions to websites on the Internet or in
various communication groups.
11) Students who copy a solution will receive a 0 in all assignments in the course and a report will
be made to the institutional disciplinary committee.
12) All code files of the assignment are required to both compile and run properly on the Ubuntu
22.04 LTS operating system. This is the operating system where the submissions will be
tested. You mustnâ€™t code it in Windows, as it uses different API for sockets. WSL wonâ€™t work,
as the task needs a tool that works only in a fully Linux environment.
Good Luck!
 Communication Networks Course
Page | 2
Part A â€“ Transmission Control Protocol (TCP) â€“ 30 points
In this part, youâ€™ll write two program files: ğ‘»ğ‘ªğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and ğ‘»ğ‘ªğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
The Sender will send a randomly generated file and the Receiver will receive it and measure
the time it took for his program to receive the file. The file size should be at least 2MB.
When running the Sender and Receiver, they both should support two standard congestion
control algorithms: TCP Reno and TCP Cubic.
Notes:
â€¢ The main goal of this part is to get familiar with the TCP concept of sending
messages between two endpoints.
â€¢ For approaching this part of the assignment, please be sure that you are familiar
with the congestion control algorithms and how to change them using the correct
method in C (see Appendix B for more information).
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). You've
learned that TCP is reliable by design, so you can assume that all the data have been
passed correctly, and thus, no need to recheck.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
Usage:
â€¢ Receiver:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
â€¢ Sender:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port of the Receiver.
â€¢ ğ‘¨ğ‘³ğ‘®ğ‘¶ â€“ The TCP congestion control algorithm that will be used by the party
member (either ğ’“ğ’†ğ’ğ’ for TCP Reno or ğ’„ğ’–ğ’ƒğ’Šğ’„ for TCP Cubic).
 Communication Networks Course
Page | 3
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a TCP socket between the Sender and the
Receiver.
3) Send the file.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a TCP connection between the Receiver and
the Sender.
2) Get a connection from the sender.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./TCP_Receiver -p 1234 -algo reno
Starting Receiver...
Waiting for TCP connection...
Sender connected, beginning to receive file...
File transfer completed.
Waiting for Sender response...
Sender sent exit message.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 4
Part B â€“ Reliable User Datagram Protocol (Reliable UDP or RUDP) â€“ 40 points
Youâ€™ve learned that while TCP is reliable, it lacks speed and has an overhead data of 20 bytes,
compering to UDP that needs only 8 bytes of overhead data.
Reliable UDP or RUDP, is a protocol that uses the UDP protocol for a faster transmission of
data, while adding a reliability layer to it, but without adding too much overhead data like
TCP.
A simple sketch for a RUDP connection would look something like this:
Your task in this part is to implement a Reliable protocol using UDP only. For simplicity, your
implementation should only support a handshake, closing scheme, error checking,
acknowledgment of received packets, and retransmission of lost packets.
Guidance:
â€¢ You can use ğ‘ ğ‘’ğ‘¡ğ‘ ğ‘œğ‘ğ‘˜ğ‘œğ‘ğ‘¡(2) for detecting a timeout.
â€¢ You need to build your own protocol, as Reliable UDP isnâ€™t a standard protocol (see a
draft of RUDP in this link), and no official header is provided. You can use this sketch
for a header, but you can come up with your own protocol, as long as it works.
Where:
o ğ‘³ğ’†ğ’ğ’ˆğ’•ğ’‰ is the length of the data itself, without the RUDP header.
o ğ‘ªğ’‰ğ’†ğ’„ğ’Œğ’”ğ’–ğ’ is a 16bit number that validates the correctness of the data.
o ğ‘­ğ’ğ’‚ğ’ˆğ’” is a special byte where we classify the packet itself (SYN, ACK, etc.).
â€¢ In your PDF, you must explain how your implementation of RUDP works â€“ How does
it detect a timeout to do retransmissions, how does the handshake work, what is the
header overhead, etc.
â€¢ For this part, youâ€™ll write three files: ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¨ğ‘·ğ‘°. ğ’„, ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and
ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
Reliable UDP Header proposed sketch
Byte 0 Byte 1 Byte 2 Byte 3
Length (2 Bytes) Checksum (2 Bytes)
Flags (1 Byte)
Figure 1 - RUDP Protocol Architecture, Geeksforgeeks
 Communication Networks Course
Page | 5
Notes:
â€¢ The Sender will send a random generated file and the Receiver will receive it and
measure the time it took for his program to receive the file. The file size should be at
least 2MB.
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). But, as the
RUDP is based on UDP, itâ€™s not reliable. You must use some form of error checking
(like checksum) to ensure that the packet wasnâ€™t alerted during the transfer.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
â€¢ The RUDP needs support only 1 sender and 1 receiver, for simplicity purposes.
Usage:
â€¢ Receiver:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
â€¢ Sender:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port that both the Sender and the Receiver will use.
The ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„ file will contain all the implementations of the RUDP API functions (That is, to
prevent reusing the same chuck of code both in the Sender and the Receiver.).
The API should support at the bare minimum the following functions (you decide what
parameters to implement, and what are the names of the functions, as long as the API is
explained in the PDF):
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘œğ‘ğ‘˜ğ‘’ğ‘¡() â€“ Creating a RUDP socket and creating a handshake between two
peers.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘’ğ‘›ğ‘‘() â€“ Sending data to the peer. The function should wait for an
acknowledgment packet, and if it didnâ€™t receive any, retransmits the data.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘Ÿğ‘’ğ‘ğ‘£() â€“ Receive data from a peer.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ğ‘™ğ‘œğ‘ ğ‘’() â€“ Closes a connection between peers.
 Communication Networks Course
Page | 6
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a UDP socket between the Sender and the
Receiver.
3) Send the file via the RUDP protocol.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a UDP connection between the Receiver and
the Sender.
2) Get a connection from the sender, by the custom
RUDP protocol youâ€™ve built.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./RUDP_Receiver -p 1234
Starting Receiver...
Waiting for RUDP connection...
Connection request received, sending ACK.
Sender connected, beginning to receive file...
File transfer completed.
ACK sent.
Waiting for Sender response...
Sender sent exit message.
ACK sent.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 7
Part C â€“ Research â€“ 30 points
In this part, youâ€™ll conduct research about your implementations of part A and part B.
In the research itself, each one of the versions (TCP version and UDP version) will be run at
least 5 times (meaning that the file transfer will occur at least 5 times) by the following
conditions:
â€¢ For TCP, youâ€™ll run it in TCP Reno and TCP Cubic, alternating each time, for each
scenario, meaning that you run 5 times with TCP Reno in both Sender and Receiver,
and 5 times with TCP Cubic in both Sender and Receiver.
Bonus (5 points): Create a very large data set â€“ 5 times with TCP Reno in both Sender
and Receiver, 5 times with TCP Reno in Sender and TCP Cubic in Receiver, 5 times
with TCP Cubic in Sender and TCP Reno in Receiver, and 5 times with TCP Cubic in
both Sender and Receiver. This will give you a data set large enough, which allows
you to work with, compare with and to reach a definite conclusion.
â€¢ For RUDP, you will run it 5 times for each scenario.
â€¢ For both TCP and RUDP, you will run them on those scenarios of packet loss:
o 0% packet loss â€“ Control group, simulating perfect connection.
o 2% packet loss â€“ Simulating unstable connection that commonly occur.
o 5% packet loss â€“ Simulating bad connection.
o 10% packet loss â€“ Simulating extremely poor connection.
For each scenario, you must provide a filtered PCAP file and relevant screenshots that
explain each one of the steps in the process. (10 points)
After youâ€™ve gathered the data set for both TCP and Reliable UDP, answer the following
questions:
1) In TCP, which congestion control algorithm gave better results overall? TCP Reno or
TCP Cubic? Which one gave better results on high packet loss? Explain how you came
to this conclusion based on the data set youâ€™ve gathered. (5 points)
2) How did your implementation of Reliable UDP perform overall compared to regular
TCP? Which one is better for high packet loss? (5 points)
3) According to the data youâ€™ve gathered, in which scenarios and applications would we
prefer to use TCP and in which situations would we prefer to use reliable UDP?
Explain your answer. (5 points)
 Communication Networks Course
Page | 8
×¢× ×• ×¢×œ ×”×©××œ×•×ª ×”×‘××•×ª )5 × ×§×•×“×•×ª(:
â— ×‘"×¨×©×ª ×××™× ×”" ×”×›×•×•× ×” ×”×™× ×œ×¨×©×ª ×©×‘×” ××¢×˜ ×××•×“ ×—×‘×™×œ×•×ª ×”×•×œ×›×•×ª ×œ××™×‘×•×“. ×‘"×§×©×¨ ××¨×•×š" ×”×›×•×•× ×” ×”×™×
×œ×§×©×¨ TCP ×©×™×© ×‘×• ×”×¨×‘×” ×××•×“ ××™×“×¢ ×œ×©×œ×•×—. ××•×¦×¢ ×œ×”×’×“×™×œ ×‘ -TCP ××ª SSThreshold ×‘×ª×—×™×œ×ª ×”×§×©×¨.
×‘××™×–×” ××”××§×¨×™× ×”×‘××™× ×”×©×™× ×•×™ ×”×–×” ×¢×©×•×™ ×œ×”×•×¢×™×œ ×‘××™×“×” ×”××™×¨×‘×™×ª? × ××§.
.1 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
.2 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.3 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.4 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.5 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.6 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.7 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.8 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
â— A ×©×•×œ×— ×œ -B ×—×‘×™×œ×•×ª ××™×“×¢ ×‘×××¦×¢×•×ª ×§×©×¨ TCP. × ×ª×•×Ÿ ×›×™ ×”×§×©×¨ ××ª×—×™×œ ×¢× ×—×œ×•×Ÿ ×‘×’×•×“×œ 1MSS. ×”×§×©×¨
××¡×ª×™×™× ×‘×¤×¢× ×”×¨××©×•× ×” ×©×”×•× ××’×™×¢ ×œ -SSthresh. ×‘××”×œ×š ×”×§×©×¨ ×œ× ××•×‘×“×•×ª ×—×‘×™×œ×•×ª. × ×¡××Ÿ ×‘×§×™×¦×•×¨:
.SSthresh=S*MSS
× ×ª×•×Ÿ ×›×™ ×œ××•×¨×š ×›×œ ×”×§×©×¨ rwnd < MSS*S.
××”×™ ×”×ª×¤×•×§×” ×©×œ ×”×§×©×¨ ×-A ×œ-B( ×‘ -sec / Bytes )×‘×–××Ÿ ×”× "×œ? × ××§×™.
]S*MSS / [lg (S) * RTT*2 ×‘×¢×¨×š .1
]S*MSS / [S^0.5 * RTT*2 ×‘×¢×¨×š .2
S*MSS / RTT ×‘×¢×¨×š .3
S^2)*MSS / RTT( ×‘×¢×¨×š .4
â— ×©×ª×™ ×ª×—× ×•×ª ××ª×§×©×¨×•×ª ×‘××•×¤×Ÿ ××œ×—×•×˜×™ ×‘×©×™×˜×ª N Back Go.
× ×¡××Ÿ ×‘-X ××ª ×¡×¤×¨×ª ×”×‘×™×§×•×¨×ª ×©×œ ×”×ª.×–. ×©×œ×š. ×× ×©× ×™ ×©×•×ª×¤×™× ××’×™×©×™× ××ª ×”×ª×¨×’×™×œ ×™×—×“, X ×”×•× ×¡×¤×¨×ª
×”×‘×™×§×•×¨×ª ×‘×¢×œ×ª ×”×¢×¨×š ×”× ××•×š ×™×•×ª×¨ ××‘×™×Ÿ ×”×©×ª×™×™×.
×§×¦×‘ ×”×ª×§×©×•×¨×ª ×”×•× 8Gbps, ×•×’×•×“×œ ×›×œ ×—×‘×™×œ×” ×”×•× KByte*X. ×’×“×œ×™ ×”-headers ×•×” -Acks ×–× ×™×—×™×.
ï¿½ğ‘’ğ‘ ï¿½/ï¿½ï¿½ 8 , ×•×”××¨×—×§ ×‘×™×Ÿ ×”×ª×—× ×•×ª ×”×•× 1Km. ×§×¦×‘ ×”×”×ª×¤×©×˜×•×ª ×”×•× 10 â‹… 2
×–××Ÿ ×¢×™×‘×•×“ ×”× ×ª×•× ×™× ×‘×ª×—× ×•×ª ×–× ×™×—.
××£ ×—×‘×™×œ×” ×•××£ Ack ×œ× ×”×•×œ×›×™× ×œ××™×‘×•×“.
â— ××”×• X ×©×œ×š?
â— ××” ×¦×¨×™×š ×œ×”×™×•×ª ×’×•×“×œ ×—×œ×•×Ÿ ×”××©×œ×•×— ×›×“×™ ×œ×”×‘×˜×™×— ×ª×¤×•×§×” ××§×¡×™××œ×™×ª?
 Communication Networks Course
Page | 9
Bonus â€“ Improving the Reliable UDP â€“ 15 points
Note: This part isnâ€™t mandatory and is a bonus only!
In this part, youâ€™ll improve your RUDP implementation by adding the concepts of flow
control and congestion control from TCP. Youâ€™re free to choose which algorithms to
implement, as long as you explain in your PDF which algorithms youâ€™ve used. Youâ€™ll probably
need to make changes in the original design of the RUDP. Changes only need to be to the API
itself, ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„.
Points distribution:
â€¢ Flow control improvement â€“ 7 Points
â€¢ Congestion control improvement â€“ 8 points.
Guidance:
â€¢ For flow control, you must use one of the Sliding window techniques: stop-and-wait
ARQ, Go-Back-N or Selective repeat.
â€¢ List of known TCP congestion control algorithms, which you can use any one of them
for this bonus task, or makeup your own:
Figure 2 â€“ List of known TCP congestion control algorithms, Wikipedia
 Communication Networks Course
Page | 10
Appendix A â€“ Linux local packet loss tool
To simulate a packet loss in a local network, we'll use a Linux tool that's called Linux Traffic
Control (ğ‘¡ğ‘). This requires a full Linux installation, so working with WSL won't work.
If the tool isn't installed in your machine, you can install it by using the following commands:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’
If the installation didn't work, you can use the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’2
To create a packet loss scenario, type the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘ğ‘‘ğ‘‘ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
After creating a packet loss scenario, you can change the percentage by typing the following
command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘â„ğ‘ğ‘›ğ‘”ğ‘’ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
To remove the packet loss scenario, write the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘‘ğ‘’ğ‘™ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š
 Communication Networks Course
Page | 11
Appendix B â€“ ğ’ğ’‚ğ’(ğŸ) system calls
This appendixâ€™s purpose is to give you a better understanding of socket handling in C.
A recommended reference is Beejâ€™s Guide to Network Programming, by Brian â€œBeej
Jorgensenâ€ Hall, which gives a lot of information about sockets in C and functions.
Functions and documentation links:
â€¢ ğ’”ğ’ğ’„ğ’Œğ’†ğ’•(ğŸ) â€“ A Factory method system call that creates a socket with the given
parameters.
â€¢ ğ’ƒğ’Šğ’ğ’…(ğŸ) â€“ Whenever we create a new socket, we need to bind it to a specific port in
our machine, â€œto catch a portâ€. The port number is managed and used by the kernel
to link incoming packets to the corresponding application socket. The port numbers
are usually fixed. The ğ‘ğ‘‘ğ‘‘ğ‘Ÿ parameter must match the current socket that is used.
â€¢ ğ’ğ’Šğ’”ğ’•ğ’†ğ’(ğŸ) â€“ The ğ‘™ğ‘–ğ‘ ğ‘¡ğ‘’ğ‘›(2) system call doesn't do anything in the mean of
communication but only memory allocation (malloc) for stream sockets only. If we
won't allocate memory, any incoming connection will fail.
â€¢ ğ’„ğ’ğ’ğ’ğ’†ğ’„ğ’•(ğŸ) â€“ The ğ‘ğ‘œğ‘›ğ‘›ğ‘’ğ‘ğ‘¡(2) system call starts the link between a client and a
specific IP address and port number. The connection would complete when the
other side will call the ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call.
â€¢ ğ’‚ğ’„ğ’„ğ’†ğ’‘ğ’•(ğŸ) â€“ The ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call accepts the incoming stream connection
request from the other side, by the listening socket. This system call completes the
three-way handshake of stream socket (like TCP) and opens a new socket that has a
direct communication channel only with the other party in the handshake.
â€¢ ğ’”ğ’†ğ’ğ’…(ğŸ) and ğ’”ğ’†ğ’ğ’…ğ’•ğ’(ğŸ) â€“ The ğ‘ ğ‘’ğ‘›ğ‘‘(2) and ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system calls are an analogy
for the ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’(2) system call, specifcly for sockets, with flags set to 0. Those system
calls return the number of bytes that were sent through the socket itself, as the
number of bytes can vary. The ğ‘ ğ‘’ğ‘›ğ‘‘(2)system call designed for stream sockets (like
TCP), while the ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system call designed for datagram connection-less
sockets (like UDP). When the ğ‘ ğ‘’ğ‘›ğ‘‘(2) system call returns 0, it means that the other
party closed the connection.
â€¢ ğ’“ğ’†ğ’„ğ’—(ğŸ) and ğ’“ğ’†ğ’„ğ’—ğ’‡ğ’“ğ’ğ’(ğŸ) â€“ The ğ‘Ÿğ‘’ğ‘ğ‘£(2) and ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system calls are an
analogy for the ğ‘Ÿğ‘’ğ‘ğ‘‘(2) system call, specifically for sockets, with flags set to 0.
Those system calls return the number of bytes that were received through the socket
itself, as the number of bytes can vary. The ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call designed for stream
sockets (like TCP), while the ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system call designed for datagram
connection-less sockets (like UDP). When the ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call returns 0, it means
that the other party closed the connection.
â€¢ ğ’„ğ’ğ’ğ’”ğ’†(ğŸ) and ğ’”ğ’‰ğ’–ğ’•ğ’…ğ’ğ’˜ğ’(ğŸ) â€“ The ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) and ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2) system calls close
the socket. While ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) system call closes the whole socket, the ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2)
system call partially closes the socket for read/write.
 Communication Networks Course
Page | 12
Appendix C â€“ Random data generator
The data that you are going to send in this assignment is randomly generated. You can use
your own file with appropriate size or use the following function (or a function of your own)
to generate the data:
/*
* @brief A random data generator function based on srand() and rand().
* @param size The size of the data to generate (up to 2^32 bytes).
* @return A pointer to the buffer.
*/
char *util_generate_random_data(unsigned int size) {
 char *buffer = NULL;
 // Argument check.
 if (size == 0)
 return NULL;
 buffer = (char *)calloc(size, sizeof(char));
 // Error checking.
 if (buffer == NULL)
 return NULL;
 // Randomize the seed of the random number generator.
 srand(time(NULL));
 for (unsigned int i = 0; i < size; i++)
 *(buffer + i) = ((unsigned int)rand() % 256);
 return buffer;
}
 Communication Networks Course
Page | 13
Appendix D â€“ Checksum function
A checksum is a small-sized block of data derived from another block of digital data for the
purpose of detecting errors that may have been introduced during its transmission or
storage. By themselves, checksums are often used to verify data integrity but are not relied
upon to verify data authenticity.
Below is a simple yet efficient implementation of the checksum function, you can use it for
the assignment, but you can implement your own checksum function.
/*
* @brief A checksum function that returns 16 bit checksum for data.
* @param data The data to do the checksum for.
* @param bytes The length of the data in bytes.
* @return The checksum itself as 16 bit unsigned number.
* @note This function is taken from RFC1071, can be found here:
* @note https://tools.ietf.org/html/rfc1071
* @note It is the simplest way to calculate a checksum and is not very strong.
* However, it is good enough for this assignment.
* @note You are free to use any other checksum function as well.
* You can also use this function as such without any change.
*/
unsigned short int calculate_checksum(void *data, unsigned int bytes) {
 unsigned short int *data_pointer = (unsigned short int *)data;
 unsigned int total_sum = 0;
 // Main summing loop
 while (bytes > 1) {
 total_sum += *data_pointer++;
 bytes -= 2;
 }
 // Add left-over byte, if any
 if (bytes > 0)
 total_sum += *((unsigned char *)data_pointer);
 // Fold 32-bit sum to 16 bits
 while (total_sum >> 16)
 total_sum = (total_sum & 0xFFFF) + (total_sum >> 16);
 return (~((unsigned short int)total_sum));
} Communication Networks Course
Page | 1
Assignment 3 â€“ Transport Layer
Assignment Notes and Instructions
This assignment is to be done in pairs only. You must upload all the necessary files in a ZIP
file named after both of the studentâ€™s ID. For example: ğŸğŸğŸ‘ğŸ’ğŸ“ğŸ”ğŸ•ğŸ–ğŸ—_ğŸ—ğŸ–ğŸ•ğŸ”ğŸ“ğŸ’ğŸ‘ğŸğŸ. ğ’›ğ’Šğ’‘.
1) The assignment must be submitted by the date specified in the submission box.
2) All the assignment files (Code, Wireshark pcap files, PDF) must be submitted in a ZIP file. The
PDF must contain all the necessary screenshots with a description for each one of them.
3) The assignment must be done in pairs only. In exceptional cases, you should send an email to
the course coordinator.
4) You can use any reference material available through the course Moodle website or any
material passed during the exercises.
5) You can use any reference from the web, but copying codes from websites is forbidden; this
includes codes from other GitHub repositories. A student who gets caught in the act will
automatically fail this assignment (score 0). Any website youâ€™ve used to solve the
assignment, every website you used to solve the assignment must be noted in the PDF.
6) No delays in submission without special permission. Lateness without approval will result in
failure of the assignment (score 0).
7) All submissions will be submitted via the course's Moodle website. Email submissions will not
be accepted, resulting in a failure in the assignment.
8) The order and design of the code must be carefully considered. Make sure that the program
output is as clear as possible, comments in the code, and meaningful variable names. You
must also submit a makefile that compiles all the programs.
9) The assignment code must be written in C only.
10) The assignment is personal for each pair, and you should not accept help from other people,
whether outside the university or inside it. You can contact the course staff during reception
hours for help or raise a question in the course forum. Do not transfer code sections
between students, upload solutions or parts of solutions to websites on the Internet or in
various communication groups.
11) Students who copy a solution will receive a 0 in all assignments in the course and a report will
be made to the institutional disciplinary committee.
12) All code files of the assignment are required to both compile and run properly on the Ubuntu
22.04 LTS operating system. This is the operating system where the submissions will be
tested. You mustnâ€™t code it in Windows, as it uses different API for sockets. WSL wonâ€™t work,
as the task needs a tool that works only in a fully Linux environment.
Good Luck!
 Communication Networks Course
Page | 2
Part A â€“ Transmission Control Protocol (TCP) â€“ 30 points
In this part, youâ€™ll write two program files: ğ‘»ğ‘ªğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and ğ‘»ğ‘ªğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
The Sender will send a randomly generated file and the Receiver will receive it and measure
the time it took for his program to receive the file. The file size should be at least 2MB.
When running the Sender and Receiver, they both should support two standard congestion
control algorithms: TCP Reno and TCP Cubic.
Notes:
â€¢ The main goal of this part is to get familiar with the TCP concept of sending
messages between two endpoints.
â€¢ For approaching this part of the assignment, please be sure that you are familiar
with the congestion control algorithms and how to change them using the correct
method in C (see Appendix B for more information).
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). You've
learned that TCP is reliable by design, so you can assume that all the data have been
passed correctly, and thus, no need to recheck.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
Usage:
â€¢ Receiver:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
â€¢ Sender:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port of the Receiver.
â€¢ ğ‘¨ğ‘³ğ‘®ğ‘¶ â€“ The TCP congestion control algorithm that will be used by the party
member (either ğ’“ğ’†ğ’ğ’ for TCP Reno or ğ’„ğ’–ğ’ƒğ’Šğ’„ for TCP Cubic).
 Communication Networks Course
Page | 3
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a TCP socket between the Sender and the
Receiver.
3) Send the file.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a TCP connection between the Receiver and
the Sender.
2) Get a connection from the sender.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./TCP_Receiver -p 1234 -algo reno
Starting Receiver...
Waiting for TCP connection...
Sender connected, beginning to receive file...
File transfer completed.
Waiting for Sender response...
Sender sent exit message.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 4
Part B â€“ Reliable User Datagram Protocol (Reliable UDP or RUDP) â€“ 40 points
Youâ€™ve learned that while TCP is reliable, it lacks speed and has an overhead data of 20 bytes,
compering to UDP that needs only 8 bytes of overhead data.
Reliable UDP or RUDP, is a protocol that uses the UDP protocol for a faster transmission of
data, while adding a reliability layer to it, but without adding too much overhead data like
TCP.
A simple sketch for a RUDP connection would look something like this:
Your task in this part is to implement a Reliable protocol using UDP only. For simplicity, your
implementation should only support a handshake, closing scheme, error checking,
acknowledgment of received packets, and retransmission of lost packets.
Guidance:
â€¢ You can use ğ‘ ğ‘’ğ‘¡ğ‘ ğ‘œğ‘ğ‘˜ğ‘œğ‘ğ‘¡(2) for detecting a timeout.
â€¢ You need to build your own protocol, as Reliable UDP isnâ€™t a standard protocol (see a
draft of RUDP in this link), and no official header is provided. You can use this sketch
for a header, but you can come up with your own protocol, as long as it works.
Where:
o ğ‘³ğ’†ğ’ğ’ˆğ’•ğ’‰ is the length of the data itself, without the RUDP header.
o ğ‘ªğ’‰ğ’†ğ’„ğ’Œğ’”ğ’–ğ’ is a 16bit number that validates the correctness of the data.
o ğ‘­ğ’ğ’‚ğ’ˆğ’” is a special byte where we classify the packet itself (SYN, ACK, etc.).
â€¢ In your PDF, you must explain how your implementation of RUDP works â€“ How does
it detect a timeout to do retransmissions, how does the handshake work, what is the
header overhead, etc.
â€¢ For this part, youâ€™ll write three files: ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¨ğ‘·ğ‘°. ğ’„, ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and
ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
Reliable UDP Header proposed sketch
Byte 0 Byte 1 Byte 2 Byte 3
Length (2 Bytes) Checksum (2 Bytes)
Flags (1 Byte)
Figure 1 - RUDP Protocol Architecture, Geeksforgeeks
 Communication Networks Course
Page | 5
Notes:
â€¢ The Sender will send a random generated file and the Receiver will receive it and
measure the time it took for his program to receive the file. The file size should be at
least 2MB.
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). But, as the
RUDP is based on UDP, itâ€™s not reliable. You must use some form of error checking
(like checksum) to ensure that the packet wasnâ€™t alerted during the transfer.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
â€¢ The RUDP needs support only 1 sender and 1 receiver, for simplicity purposes.
Usage:
â€¢ Receiver:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
â€¢ Sender:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port that both the Sender and the Receiver will use.
The ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„ file will contain all the implementations of the RUDP API functions (That is, to
prevent reusing the same chuck of code both in the Sender and the Receiver.).
The API should support at the bare minimum the following functions (you decide what
parameters to implement, and what are the names of the functions, as long as the API is
explained in the PDF):
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘œğ‘ğ‘˜ğ‘’ğ‘¡() â€“ Creating a RUDP socket and creating a handshake between two
peers.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘’ğ‘›ğ‘‘() â€“ Sending data to the peer. The function should wait for an
acknowledgment packet, and if it didnâ€™t receive any, retransmits the data.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘Ÿğ‘’ğ‘ğ‘£() â€“ Receive data from a peer.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ğ‘™ğ‘œğ‘ ğ‘’() â€“ Closes a connection between peers.
 Communication Networks Course
Page | 6
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a UDP socket between the Sender and the
Receiver.
3) Send the file via the RUDP protocol.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a UDP connection between the Receiver and
the Sender.
2) Get a connection from the sender, by the custom
RUDP protocol youâ€™ve built.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./RUDP_Receiver -p 1234
Starting Receiver...
Waiting for RUDP connection...
Connection request received, sending ACK.
Sender connected, beginning to receive file...
File transfer completed.
ACK sent.
Waiting for Sender response...
Sender sent exit message.
ACK sent.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 7
Part C â€“ Research â€“ 30 points
In this part, youâ€™ll conduct research about your implementations of part A and part B.
In the research itself, each one of the versions (TCP version and UDP version) will be run at
least 5 times (meaning that the file transfer will occur at least 5 times) by the following
conditions:
â€¢ For TCP, youâ€™ll run it in TCP Reno and TCP Cubic, alternating each time, for each
scenario, meaning that you run 5 times with TCP Reno in both Sender and Receiver,
and 5 times with TCP Cubic in both Sender and Receiver.
Bonus (5 points): Create a very large data set â€“ 5 times with TCP Reno in both Sender
and Receiver, 5 times with TCP Reno in Sender and TCP Cubic in Receiver, 5 times
with TCP Cubic in Sender and TCP Reno in Receiver, and 5 times with TCP Cubic in
both Sender and Receiver. This will give you a data set large enough, which allows
you to work with, compare with and to reach a definite conclusion.
â€¢ For RUDP, you will run it 5 times for each scenario.
â€¢ For both TCP and RUDP, you will run them on those scenarios of packet loss:
o 0% packet loss â€“ Control group, simulating perfect connection.
o 2% packet loss â€“ Simulating unstable connection that commonly occur.
o 5% packet loss â€“ Simulating bad connection.
o 10% packet loss â€“ Simulating extremely poor connection.
For each scenario, you must provide a filtered PCAP file and relevant screenshots that
explain each one of the steps in the process. (10 points)
After youâ€™ve gathered the data set for both TCP and Reliable UDP, answer the following
questions:
1) In TCP, which congestion control algorithm gave better results overall? TCP Reno or
TCP Cubic? Which one gave better results on high packet loss? Explain how you came
to this conclusion based on the data set youâ€™ve gathered. (5 points)
2) How did your implementation of Reliable UDP perform overall compared to regular
TCP? Which one is better for high packet loss? (5 points)
3) According to the data youâ€™ve gathered, in which scenarios and applications would we
prefer to use TCP and in which situations would we prefer to use reliable UDP?
Explain your answer. (5 points)
 Communication Networks Course
Page | 8
×¢× ×• ×¢×œ ×”×©××œ×•×ª ×”×‘××•×ª )5 × ×§×•×“×•×ª(:
â— ×‘"×¨×©×ª ×××™× ×”" ×”×›×•×•× ×” ×”×™× ×œ×¨×©×ª ×©×‘×” ××¢×˜ ×××•×“ ×—×‘×™×œ×•×ª ×”×•×œ×›×•×ª ×œ××™×‘×•×“. ×‘"×§×©×¨ ××¨×•×š" ×”×›×•×•× ×” ×”×™×
×œ×§×©×¨ TCP ×©×™×© ×‘×• ×”×¨×‘×” ×××•×“ ××™×“×¢ ×œ×©×œ×•×—. ××•×¦×¢ ×œ×”×’×“×™×œ ×‘ -TCP ××ª SSThreshold ×‘×ª×—×™×œ×ª ×”×§×©×¨.
×‘××™×–×” ××”××§×¨×™× ×”×‘××™× ×”×©×™× ×•×™ ×”×–×” ×¢×©×•×™ ×œ×”×•×¢×™×œ ×‘××™×“×” ×”××™×¨×‘×™×ª? × ××§.
.1 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
.2 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.3 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.4 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.5 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.6 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.7 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.8 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
â— A ×©×•×œ×— ×œ -B ×—×‘×™×œ×•×ª ××™×“×¢ ×‘×××¦×¢×•×ª ×§×©×¨ TCP. × ×ª×•×Ÿ ×›×™ ×”×§×©×¨ ××ª×—×™×œ ×¢× ×—×œ×•×Ÿ ×‘×’×•×“×œ 1MSS. ×”×§×©×¨
××¡×ª×™×™× ×‘×¤×¢× ×”×¨××©×•× ×” ×©×”×•× ××’×™×¢ ×œ -SSthresh. ×‘××”×œ×š ×”×§×©×¨ ×œ× ××•×‘×“×•×ª ×—×‘×™×œ×•×ª. × ×¡××Ÿ ×‘×§×™×¦×•×¨:
.SSthresh=S*MSS
× ×ª×•×Ÿ ×›×™ ×œ××•×¨×š ×›×œ ×”×§×©×¨ rwnd < MSS*S.
××”×™ ×”×ª×¤×•×§×” ×©×œ ×”×§×©×¨ ×-A ×œ-B( ×‘ -sec / Bytes )×‘×–××Ÿ ×”× "×œ? × ××§×™.
]S*MSS / [lg (S) * RTT*2 ×‘×¢×¨×š .1
]S*MSS / [S^0.5 * RTT*2 ×‘×¢×¨×š .2
S*MSS / RTT ×‘×¢×¨×š .3
S^2)*MSS / RTT( ×‘×¢×¨×š .4
â— ×©×ª×™ ×ª×—× ×•×ª ××ª×§×©×¨×•×ª ×‘××•×¤×Ÿ ××œ×—×•×˜×™ ×‘×©×™×˜×ª N Back Go.
× ×¡××Ÿ ×‘-X ××ª ×¡×¤×¨×ª ×”×‘×™×§×•×¨×ª ×©×œ ×”×ª.×–. ×©×œ×š. ×× ×©× ×™ ×©×•×ª×¤×™× ××’×™×©×™× ××ª ×”×ª×¨×’×™×œ ×™×—×“, X ×”×•× ×¡×¤×¨×ª
×”×‘×™×§×•×¨×ª ×‘×¢×œ×ª ×”×¢×¨×š ×”× ××•×š ×™×•×ª×¨ ××‘×™×Ÿ ×”×©×ª×™×™×.
×§×¦×‘ ×”×ª×§×©×•×¨×ª ×”×•× 8Gbps, ×•×’×•×“×œ ×›×œ ×—×‘×™×œ×” ×”×•× KByte*X. ×’×“×œ×™ ×”-headers ×•×” -Acks ×–× ×™×—×™×.
ï¿½ğ‘’ğ‘ ï¿½/ï¿½ï¿½ 8 , ×•×”××¨×—×§ ×‘×™×Ÿ ×”×ª×—× ×•×ª ×”×•× 1Km. ×§×¦×‘ ×”×”×ª×¤×©×˜×•×ª ×”×•× 10 â‹… 2
×–××Ÿ ×¢×™×‘×•×“ ×”× ×ª×•× ×™× ×‘×ª×—× ×•×ª ×–× ×™×—.
××£ ×—×‘×™×œ×” ×•××£ Ack ×œ× ×”×•×œ×›×™× ×œ××™×‘×•×“.
â— ××”×• X ×©×œ×š?
â— ××” ×¦×¨×™×š ×œ×”×™×•×ª ×’×•×“×œ ×—×œ×•×Ÿ ×”××©×œ×•×— ×›×“×™ ×œ×”×‘×˜×™×— ×ª×¤×•×§×” ××§×¡×™××œ×™×ª?
 Communication Networks Course
Page | 9
Bonus â€“ Improving the Reliable UDP â€“ 15 points
Note: This part isnâ€™t mandatory and is a bonus only!
In this part, youâ€™ll improve your RUDP implementation by adding the concepts of flow
control and congestion control from TCP. Youâ€™re free to choose which algorithms to
implement, as long as you explain in your PDF which algorithms youâ€™ve used. Youâ€™ll probably
need to make changes in the original design of the RUDP. Changes only need to be to the API
itself, ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„.
Points distribution:
â€¢ Flow control improvement â€“ 7 Points
â€¢ Congestion control improvement â€“ 8 points.
Guidance:
â€¢ For flow control, you must use one of the Sliding window techniques: stop-and-wait
ARQ, Go-Back-N or Selective repeat.
â€¢ List of known TCP congestion control algorithms, which you can use any one of them
for this bonus task, or makeup your own:
Figure 2 â€“ List of known TCP congestion control algorithms, Wikipedia
 Communication Networks Course
Page | 10
Appendix A â€“ Linux local packet loss tool
To simulate a packet loss in a local network, we'll use a Linux tool that's called Linux Traffic
Control (ğ‘¡ğ‘). This requires a full Linux installation, so working with WSL won't work.
If the tool isn't installed in your machine, you can install it by using the following commands:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’
If the installation didn't work, you can use the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’2
To create a packet loss scenario, type the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘ğ‘‘ğ‘‘ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
After creating a packet loss scenario, you can change the percentage by typing the following
command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘â„ğ‘ğ‘›ğ‘”ğ‘’ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
To remove the packet loss scenario, write the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘‘ğ‘’ğ‘™ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š
 Communication Networks Course
Page | 11
Appendix B â€“ ğ’ğ’‚ğ’(ğŸ) system calls
This appendixâ€™s purpose is to give you a better understanding of socket handling in C.
A recommended reference is Beejâ€™s Guide to Network Programming, by Brian â€œBeej
Jorgensenâ€ Hall, which gives a lot of information about sockets in C and functions.
Functions and documentation links:
â€¢ ğ’”ğ’ğ’„ğ’Œğ’†ğ’•(ğŸ) â€“ A Factory method system call that creates a socket with the given
parameters.
â€¢ ğ’ƒğ’Šğ’ğ’…(ğŸ) â€“ Whenever we create a new socket, we need to bind it to a specific port in
our machine, â€œto catch a portâ€. The port number is managed and used by the kernel
to link incoming packets to the corresponding application socket. The port numbers
are usually fixed. The ğ‘ğ‘‘ğ‘‘ğ‘Ÿ parameter must match the current socket that is used.
â€¢ ğ’ğ’Šğ’”ğ’•ğ’†ğ’(ğŸ) â€“ The ğ‘™ğ‘–ğ‘ ğ‘¡ğ‘’ğ‘›(2) system call doesn't do anything in the mean of
communication but only memory allocation (malloc) for stream sockets only. If we
won't allocate memory, any incoming connection will fail.
â€¢ ğ’„ğ’ğ’ğ’ğ’†ğ’„ğ’•(ğŸ) â€“ The ğ‘ğ‘œğ‘›ğ‘›ğ‘’ğ‘ğ‘¡(2) system call starts the link between a client and a
specific IP address and port number. The connection would complete when the
other side will call the ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call.
â€¢ ğ’‚ğ’„ğ’„ğ’†ğ’‘ğ’•(ğŸ) â€“ The ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call accepts the incoming stream connection
request from the other side, by the listening socket. This system call completes the
three-way handshake of stream socket (like TCP) and opens a new socket that has a
direct communication channel only with the other party in the handshake.
â€¢ ğ’”ğ’†ğ’ğ’…(ğŸ) and ğ’”ğ’†ğ’ğ’…ğ’•ğ’(ğŸ) â€“ The ğ‘ ğ‘’ğ‘›ğ‘‘(2) and ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system calls are an analogy
for the ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’(2) system call, specifcly for sockets, with flags set to 0. Those system
calls return the number of bytes that were sent through the socket itself, as the
number of bytes can vary. The ğ‘ ğ‘’ğ‘›ğ‘‘(2)system call designed for stream sockets (like
TCP), while the ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system call designed for datagram connection-less
sockets (like UDP). When the ğ‘ ğ‘’ğ‘›ğ‘‘(2) system call returns 0, it means that the other
party closed the connection.
â€¢ ğ’“ğ’†ğ’„ğ’—(ğŸ) and ğ’“ğ’†ğ’„ğ’—ğ’‡ğ’“ğ’ğ’(ğŸ) â€“ The ğ‘Ÿğ‘’ğ‘ğ‘£(2) and ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system calls are an
analogy for the ğ‘Ÿğ‘’ğ‘ğ‘‘(2) system call, specifically for sockets, with flags set to 0.
Those system calls return the number of bytes that were received through the socket
itself, as the number of bytes can vary. The ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call designed for stream
sockets (like TCP), while the ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system call designed for datagram
connection-less sockets (like UDP). When the ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call returns 0, it means
that the other party closed the connection.
â€¢ ğ’„ğ’ğ’ğ’”ğ’†(ğŸ) and ğ’”ğ’‰ğ’–ğ’•ğ’…ğ’ğ’˜ğ’(ğŸ) â€“ The ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) and ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2) system calls close
the socket. While ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) system call closes the whole socket, the ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2)
system call partially closes the socket for read/write.
 Communication Networks Course
Page | 12
Appendix C â€“ Random data generator
The data that you are going to send in this assignment is randomly generated. You can use
your own file with appropriate size or use the following function (or a function of your own)
to generate the data:
/*
* @brief A random data generator function based on srand() and rand().
* @param size The size of the data to generate (up to 2^32 bytes).
* @return A pointer to the buffer.
*/
char *util_generate_random_data(unsigned int size) {
 char *buffer = NULL;
 // Argument check.
 if (size == 0)
 return NULL;
 buffer = (char *)calloc(size, sizeof(char));
 // Error checking.
 if (buffer == NULL)
 return NULL;
 // Randomize the seed of the random number generator.
 srand(time(NULL));
 for (unsigned int i = 0; i < size; i++)
 *(buffer + i) = ((unsigned int)rand() % 256);
 return buffer;
}
 Communication Networks Course
Page | 13
Appendix D â€“ Checksum function
A checksum is a small-sized block of data derived from another block of digital data for the
purpose of detecting errors that may have been introduced during its transmission or
storage. By themselves, checksums are often used to verify data integrity but are not relied
upon to verify data authenticity.
Below is a simple yet efficient implementation of the checksum function, you can use it for
the assignment, but you can implement your own checksum function.
/*
* @brief A checksum function that returns 16 bit checksum for data.
* @param data The data to do the checksum for.
* @param bytes The length of the data in bytes.
* @return The checksum itself as 16 bit unsigned number.
* @note This function is taken from RFC1071, can be found here:
* @note https://tools.ietf.org/html/rfc1071
* @note It is the simplest way to calculate a checksum and is not very strong.
* However, it is good enough for this assignment.
* @note You are free to use any other checksum function as well.
* You can also use this function as such without any change.
*/
unsigned short int calculate_checksum(void *data, unsigned int bytes) {
 unsigned short int *data_pointer = (unsigned short int *)data;
 unsigned int total_sum = 0;
 // Main summing loop
 while (bytes > 1) {
 total_sum += *data_pointer++;
 bytes -= 2;
 }
 // Add left-over byte, if any
 if (bytes > 0)
 total_sum += *((unsigned char *)data_pointer);
 // Fold 32-bit sum to 16 bits
 while (total_sum >> 16)
 total_sum = (total_sum & 0xFFFF) + (total_sum >> 16);
 return (~((unsigned short int)total_sum));
} Communication Networks Course
Page | 1
Assignment 3 â€“ Transport Layer
Assignment Notes and Instructions
This assignment is to be done in pairs only. You must upload all the necessary files in a ZIP
file named after both of the studentâ€™s ID. For example: ğŸğŸğŸ‘ğŸ’ğŸ“ğŸ”ğŸ•ğŸ–ğŸ—_ğŸ—ğŸ–ğŸ•ğŸ”ğŸ“ğŸ’ğŸ‘ğŸğŸ. ğ’›ğ’Šğ’‘.
1) The assignment must be submitted by the date specified in the submission box.
2) All the assignment files (Code, Wireshark pcap files, PDF) must be submitted in a ZIP file. The
PDF must contain all the necessary screenshots with a description for each one of them.
3) The assignment must be done in pairs only. In exceptional cases, you should send an email to
the course coordinator.
4) You can use any reference material available through the course Moodle website or any
material passed during the exercises.
5) You can use any reference from the web, but copying codes from websites is forbidden; this
includes codes from other GitHub repositories. A student who gets caught in the act will
automatically fail this assignment (score 0). Any website youâ€™ve used to solve the
assignment, every website you used to solve the assignment must be noted in the PDF.
6) No delays in submission without special permission. Lateness without approval will result in
failure of the assignment (score 0).
7) All submissions will be submitted via the course's Moodle website. Email submissions will not
be accepted, resulting in a failure in the assignment.
8) The order and design of the code must be carefully considered. Make sure that the program
output is as clear as possible, comments in the code, and meaningful variable names. You
must also submit a makefile that compiles all the programs.
9) The assignment code must be written in C only.
10) The assignment is personal for each pair, and you should not accept help from other people,
whether outside the university or inside it. You can contact the course staff during reception
hours for help or raise a question in the course forum. Do not transfer code sections
between students, upload solutions or parts of solutions to websites on the Internet or in
various communication groups.
11) Students who copy a solution will receive a 0 in all assignments in the course and a report will
be made to the institutional disciplinary committee.
12) All code files of the assignment are required to both compile and run properly on the Ubuntu
22.04 LTS operating system. This is the operating system where the submissions will be
tested. You mustnâ€™t code it in Windows, as it uses different API for sockets. WSL wonâ€™t work,
as the task needs a tool that works only in a fully Linux environment.
Good Luck!
 Communication Networks Course
Page | 2
Part A â€“ Transmission Control Protocol (TCP) â€“ 30 points
In this part, youâ€™ll write two program files: ğ‘»ğ‘ªğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and ğ‘»ğ‘ªğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
The Sender will send a randomly generated file and the Receiver will receive it and measure
the time it took for his program to receive the file. The file size should be at least 2MB.
When running the Sender and Receiver, they both should support two standard congestion
control algorithms: TCP Reno and TCP Cubic.
Notes:
â€¢ The main goal of this part is to get familiar with the TCP concept of sending
messages between two endpoints.
â€¢ For approaching this part of the assignment, please be sure that you are familiar
with the congestion control algorithms and how to change them using the correct
method in C (see Appendix B for more information).
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). You've
learned that TCP is reliable by design, so you can assume that all the data have been
passed correctly, and thus, no need to recheck.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
Usage:
â€¢ Receiver:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
â€¢ Sender:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port of the Receiver.
â€¢ ğ‘¨ğ‘³ğ‘®ğ‘¶ â€“ The TCP congestion control algorithm that will be used by the party
member (either ğ’“ğ’†ğ’ğ’ for TCP Reno or ğ’„ğ’–ğ’ƒğ’Šğ’„ for TCP Cubic).
 Communication Networks Course
Page | 3
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a TCP socket between the Sender and the
Receiver.
3) Send the file.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a TCP connection between the Receiver and
the Sender.
2) Get a connection from the sender.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./TCP_Receiver -p 1234 -algo reno
Starting Receiver...
Waiting for TCP connection...
Sender connected, beginning to receive file...
File transfer completed.
Waiting for Sender response...
Sender sent exit message.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 4
Part B â€“ Reliable User Datagram Protocol (Reliable UDP or RUDP) â€“ 40 points
Youâ€™ve learned that while TCP is reliable, it lacks speed and has an overhead data of 20 bytes,
compering to UDP that needs only 8 bytes of overhead data.
Reliable UDP or RUDP, is a protocol that uses the UDP protocol for a faster transmission of
data, while adding a reliability layer to it, but without adding too much overhead data like
TCP.
A simple sketch for a RUDP connection would look something like this:
Your task in this part is to implement a Reliable protocol using UDP only. For simplicity, your
implementation should only support a handshake, closing scheme, error checking,
acknowledgment of received packets, and retransmission of lost packets.
Guidance:
â€¢ You can use ğ‘ ğ‘’ğ‘¡ğ‘ ğ‘œğ‘ğ‘˜ğ‘œğ‘ğ‘¡(2) for detecting a timeout.
â€¢ You need to build your own protocol, as Reliable UDP isnâ€™t a standard protocol (see a
draft of RUDP in this link), and no official header is provided. You can use this sketch
for a header, but you can come up with your own protocol, as long as it works.
Where:
o ğ‘³ğ’†ğ’ğ’ˆğ’•ğ’‰ is the length of the data itself, without the RUDP header.
o ğ‘ªğ’‰ğ’†ğ’„ğ’Œğ’”ğ’–ğ’ is a 16bit number that validates the correctness of the data.
o ğ‘­ğ’ğ’‚ğ’ˆğ’” is a special byte where we classify the packet itself (SYN, ACK, etc.).
â€¢ In your PDF, you must explain how your implementation of RUDP works â€“ How does
it detect a timeout to do retransmissions, how does the handshake work, what is the
header overhead, etc.
â€¢ For this part, youâ€™ll write three files: ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¨ğ‘·ğ‘°. ğ’„, ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and
ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
Reliable UDP Header proposed sketch
Byte 0 Byte 1 Byte 2 Byte 3
Length (2 Bytes) Checksum (2 Bytes)
Flags (1 Byte)
Figure 1 - RUDP Protocol Architecture, Geeksforgeeks
 Communication Networks Course
Page | 5
Notes:
â€¢ The Sender will send a random generated file and the Receiver will receive it and
measure the time it took for his program to receive the file. The file size should be at
least 2MB.
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). But, as the
RUDP is based on UDP, itâ€™s not reliable. You must use some form of error checking
(like checksum) to ensure that the packet wasnâ€™t alerted during the transfer.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
â€¢ The RUDP needs support only 1 sender and 1 receiver, for simplicity purposes.
Usage:
â€¢ Receiver:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
â€¢ Sender:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port that both the Sender and the Receiver will use.
The ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„ file will contain all the implementations of the RUDP API functions (That is, to
prevent reusing the same chuck of code both in the Sender and the Receiver.).
The API should support at the bare minimum the following functions (you decide what
parameters to implement, and what are the names of the functions, as long as the API is
explained in the PDF):
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘œğ‘ğ‘˜ğ‘’ğ‘¡() â€“ Creating a RUDP socket and creating a handshake between two
peers.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘’ğ‘›ğ‘‘() â€“ Sending data to the peer. The function should wait for an
acknowledgment packet, and if it didnâ€™t receive any, retransmits the data.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘Ÿğ‘’ğ‘ğ‘£() â€“ Receive data from a peer.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ğ‘™ğ‘œğ‘ ğ‘’() â€“ Closes a connection between peers.
 Communication Networks Course
Page | 6
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a UDP socket between the Sender and the
Receiver.
3) Send the file via the RUDP protocol.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a UDP connection between the Receiver and
the Sender.
2) Get a connection from the sender, by the custom
RUDP protocol youâ€™ve built.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./RUDP_Receiver -p 1234
Starting Receiver...
Waiting for RUDP connection...
Connection request received, sending ACK.
Sender connected, beginning to receive file...
File transfer completed.
ACK sent.
Waiting for Sender response...
Sender sent exit message.
ACK sent.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 7
Part C â€“ Research â€“ 30 points
In this part, youâ€™ll conduct research about your implementations of part A and part B.
In the research itself, each one of the versions (TCP version and UDP version) will be run at
least 5 times (meaning that the file transfer will occur at least 5 times) by the following
conditions:
â€¢ For TCP, youâ€™ll run it in TCP Reno and TCP Cubic, alternating each time, for each
scenario, meaning that you run 5 times with TCP Reno in both Sender and Receiver,
and 5 times with TCP Cubic in both Sender and Receiver.
Bonus (5 points): Create a very large data set â€“ 5 times with TCP Reno in both Sender
and Receiver, 5 times with TCP Reno in Sender and TCP Cubic in Receiver, 5 times
with TCP Cubic in Sender and TCP Reno in Receiver, and 5 times with TCP Cubic in
both Sender and Receiver. This will give you a data set large enough, which allows
you to work with, compare with and to reach a definite conclusion.
â€¢ For RUDP, you will run it 5 times for each scenario.
â€¢ For both TCP and RUDP, you will run them on those scenarios of packet loss:
o 0% packet loss â€“ Control group, simulating perfect connection.
o 2% packet loss â€“ Simulating unstable connection that commonly occur.
o 5% packet loss â€“ Simulating bad connection.
o 10% packet loss â€“ Simulating extremely poor connection.
For each scenario, you must provide a filtered PCAP file and relevant screenshots that
explain each one of the steps in the process. (10 points)
After youâ€™ve gathered the data set for both TCP and Reliable UDP, answer the following
questions:
1) In TCP, which congestion control algorithm gave better results overall? TCP Reno or
TCP Cubic? Which one gave better results on high packet loss? Explain how you came
to this conclusion based on the data set youâ€™ve gathered. (5 points)
2) How did your implementation of Reliable UDP perform overall compared to regular
TCP? Which one is better for high packet loss? (5 points)
3) According to the data youâ€™ve gathered, in which scenarios and applications would we
prefer to use TCP and in which situations would we prefer to use reliable UDP?
Explain your answer. (5 points)
 Communication Networks Course
Page | 8
×¢× ×• ×¢×œ ×”×©××œ×•×ª ×”×‘××•×ª )5 × ×§×•×“×•×ª(:
â— ×‘"×¨×©×ª ×××™× ×”" ×”×›×•×•× ×” ×”×™× ×œ×¨×©×ª ×©×‘×” ××¢×˜ ×××•×“ ×—×‘×™×œ×•×ª ×”×•×œ×›×•×ª ×œ××™×‘×•×“. ×‘"×§×©×¨ ××¨×•×š" ×”×›×•×•× ×” ×”×™×
×œ×§×©×¨ TCP ×©×™×© ×‘×• ×”×¨×‘×” ×××•×“ ××™×“×¢ ×œ×©×œ×•×—. ××•×¦×¢ ×œ×”×’×“×™×œ ×‘ -TCP ××ª SSThreshold ×‘×ª×—×™×œ×ª ×”×§×©×¨.
×‘××™×–×” ××”××§×¨×™× ×”×‘××™× ×”×©×™× ×•×™ ×”×–×” ×¢×©×•×™ ×œ×”×•×¢×™×œ ×‘××™×“×” ×”××™×¨×‘×™×ª? × ××§.
.1 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
.2 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.3 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.4 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.5 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.6 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.7 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.8 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
â— A ×©×•×œ×— ×œ -B ×—×‘×™×œ×•×ª ××™×“×¢ ×‘×××¦×¢×•×ª ×§×©×¨ TCP. × ×ª×•×Ÿ ×›×™ ×”×§×©×¨ ××ª×—×™×œ ×¢× ×—×œ×•×Ÿ ×‘×’×•×“×œ 1MSS. ×”×§×©×¨
××¡×ª×™×™× ×‘×¤×¢× ×”×¨××©×•× ×” ×©×”×•× ××’×™×¢ ×œ -SSthresh. ×‘××”×œ×š ×”×§×©×¨ ×œ× ××•×‘×“×•×ª ×—×‘×™×œ×•×ª. × ×¡××Ÿ ×‘×§×™×¦×•×¨:
.SSthresh=S*MSS
× ×ª×•×Ÿ ×›×™ ×œ××•×¨×š ×›×œ ×”×§×©×¨ rwnd < MSS*S.
××”×™ ×”×ª×¤×•×§×” ×©×œ ×”×§×©×¨ ×-A ×œ-B( ×‘ -sec / Bytes )×‘×–××Ÿ ×”× "×œ? × ××§×™.
]S*MSS / [lg (S) * RTT*2 ×‘×¢×¨×š .1
]S*MSS / [S^0.5 * RTT*2 ×‘×¢×¨×š .2
S*MSS / RTT ×‘×¢×¨×š .3
S^2)*MSS / RTT( ×‘×¢×¨×š .4
â— ×©×ª×™ ×ª×—× ×•×ª ××ª×§×©×¨×•×ª ×‘××•×¤×Ÿ ××œ×—×•×˜×™ ×‘×©×™×˜×ª N Back Go.
× ×¡××Ÿ ×‘-X ××ª ×¡×¤×¨×ª ×”×‘×™×§×•×¨×ª ×©×œ ×”×ª.×–. ×©×œ×š. ×× ×©× ×™ ×©×•×ª×¤×™× ××’×™×©×™× ××ª ×”×ª×¨×’×™×œ ×™×—×“, X ×”×•× ×¡×¤×¨×ª
×”×‘×™×§×•×¨×ª ×‘×¢×œ×ª ×”×¢×¨×š ×”× ××•×š ×™×•×ª×¨ ××‘×™×Ÿ ×”×©×ª×™×™×.
×§×¦×‘ ×”×ª×§×©×•×¨×ª ×”×•× 8Gbps, ×•×’×•×“×œ ×›×œ ×—×‘×™×œ×” ×”×•× KByte*X. ×’×“×œ×™ ×”-headers ×•×” -Acks ×–× ×™×—×™×.
ï¿½ğ‘’ğ‘ ï¿½/ï¿½ï¿½ 8 , ×•×”××¨×—×§ ×‘×™×Ÿ ×”×ª×—× ×•×ª ×”×•× 1Km. ×§×¦×‘ ×”×”×ª×¤×©×˜×•×ª ×”×•× 10 â‹… 2
×–××Ÿ ×¢×™×‘×•×“ ×”× ×ª×•× ×™× ×‘×ª×—× ×•×ª ×–× ×™×—.
××£ ×—×‘×™×œ×” ×•××£ Ack ×œ× ×”×•×œ×›×™× ×œ××™×‘×•×“.
â— ××”×• X ×©×œ×š?
â— ××” ×¦×¨×™×š ×œ×”×™×•×ª ×’×•×“×œ ×—×œ×•×Ÿ ×”××©×œ×•×— ×›×“×™ ×œ×”×‘×˜×™×— ×ª×¤×•×§×” ××§×¡×™××œ×™×ª?
 Communication Networks Course
Page | 9
Bonus â€“ Improving the Reliable UDP â€“ 15 points
Note: This part isnâ€™t mandatory and is a bonus only!
In this part, youâ€™ll improve your RUDP implementation by adding the concepts of flow
control and congestion control from TCP. Youâ€™re free to choose which algorithms to
implement, as long as you explain in your PDF which algorithms youâ€™ve used. Youâ€™ll probably
need to make changes in the original design of the RUDP. Changes only need to be to the API
itself, ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„.
Points distribution:
â€¢ Flow control improvement â€“ 7 Points
â€¢ Congestion control improvement â€“ 8 points.
Guidance:
â€¢ For flow control, you must use one of the Sliding window techniques: stop-and-wait
ARQ, Go-Back-N or Selective repeat.
â€¢ List of known TCP congestion control algorithms, which you can use any one of them
for this bonus task, or makeup your own:
Figure 2 â€“ List of known TCP congestion control algorithms, Wikipedia
 Communication Networks Course
Page | 10
Appendix A â€“ Linux local packet loss tool
To simulate a packet loss in a local network, we'll use a Linux tool that's called Linux Traffic
Control (ğ‘¡ğ‘). This requires a full Linux installation, so working with WSL won't work.
If the tool isn't installed in your machine, you can install it by using the following commands:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’
If the installation didn't work, you can use the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’2
To create a packet loss scenario, type the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘ğ‘‘ğ‘‘ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
After creating a packet loss scenario, you can change the percentage by typing the following
command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘â„ğ‘ğ‘›ğ‘”ğ‘’ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
To remove the packet loss scenario, write the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘‘ğ‘’ğ‘™ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š
 Communication Networks Course
Page | 11
Appendix B â€“ ğ’ğ’‚ğ’(ğŸ) system calls
This appendixâ€™s purpose is to give you a better understanding of socket handling in C.
A recommended reference is Beejâ€™s Guide to Network Programming, by Brian â€œBeej
Jorgensenâ€ Hall, which gives a lot of information about sockets in C and functions.
Functions and documentation links:
â€¢ ğ’”ğ’ğ’„ğ’Œğ’†ğ’•(ğŸ) â€“ A Factory method system call that creates a socket with the given
parameters.
â€¢ ğ’ƒğ’Šğ’ğ’…(ğŸ) â€“ Whenever we create a new socket, we need to bind it to a specific port in
our machine, â€œto catch a portâ€. The port number is managed and used by the kernel
to link incoming packets to the corresponding application socket. The port numbers
are usually fixed. The ğ‘ğ‘‘ğ‘‘ğ‘Ÿ parameter must match the current socket that is used.
â€¢ ğ’ğ’Šğ’”ğ’•ğ’†ğ’(ğŸ) â€“ The ğ‘™ğ‘–ğ‘ ğ‘¡ğ‘’ğ‘›(2) system call doesn't do anything in the mean of
communication but only memory allocation (malloc) for stream sockets only. If we
won't allocate memory, any incoming connection will fail.
â€¢ ğ’„ğ’ğ’ğ’ğ’†ğ’„ğ’•(ğŸ) â€“ The ğ‘ğ‘œğ‘›ğ‘›ğ‘’ğ‘ğ‘¡(2) system call starts the link between a client and a
specific IP address and port number. The connection would complete when the
other side will call the ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call.
â€¢ ğ’‚ğ’„ğ’„ğ’†ğ’‘ğ’•(ğŸ) â€“ The ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call accepts the incoming stream connection
request from the other side, by the listening socket. This system call completes the
three-way handshake of stream socket (like TCP) and opens a new socket that has a
direct communication channel only with the other party in the handshake.
â€¢ ğ’”ğ’†ğ’ğ’…(ğŸ) and ğ’”ğ’†ğ’ğ’…ğ’•ğ’(ğŸ) â€“ The ğ‘ ğ‘’ğ‘›ğ‘‘(2) and ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system calls are an analogy
for the ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’(2) system call, specifcly for sockets, with flags set to 0. Those system
calls return the number of bytes that were sent through the socket itself, as the
number of bytes can vary. The ğ‘ ğ‘’ğ‘›ğ‘‘(2)system call designed for stream sockets (like
TCP), while the ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system call designed for datagram connection-less
sockets (like UDP). When the ğ‘ ğ‘’ğ‘›ğ‘‘(2) system call returns 0, it means that the other
party closed the connection.
â€¢ ğ’“ğ’†ğ’„ğ’—(ğŸ) and ğ’“ğ’†ğ’„ğ’—ğ’‡ğ’“ğ’ğ’(ğŸ) â€“ The ğ‘Ÿğ‘’ğ‘ğ‘£(2) and ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system calls are an
analogy for the ğ‘Ÿğ‘’ğ‘ğ‘‘(2) system call, specifically for sockets, with flags set to 0.
Those system calls return the number of bytes that were received through the socket
itself, as the number of bytes can vary. The ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call designed for stream
sockets (like TCP), while the ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system call designed for datagram
connection-less sockets (like UDP). When the ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call returns 0, it means
that the other party closed the connection.
â€¢ ğ’„ğ’ğ’ğ’”ğ’†(ğŸ) and ğ’”ğ’‰ğ’–ğ’•ğ’…ğ’ğ’˜ğ’(ğŸ) â€“ The ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) and ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2) system calls close
the socket. While ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) system call closes the whole socket, the ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2)
system call partially closes the socket for read/write.
 Communication Networks Course
Page | 12
Appendix C â€“ Random data generator
The data that you are going to send in this assignment is randomly generated. You can use
your own file with appropriate size or use the following function (or a function of your own)
to generate the data:
/*
* @brief A random data generator function based on srand() and rand().
* @param size The size of the data to generate (up to 2^32 bytes).
* @return A pointer to the buffer.
*/
char *util_generate_random_data(unsigned int size) {
 char *buffer = NULL;
 // Argument check.
 if (size == 0)
 return NULL;
 buffer = (char *)calloc(size, sizeof(char));
 // Error checking.
 if (buffer == NULL)
 return NULL;
 // Randomize the seed of the random number generator.
 srand(time(NULL));
 for (unsigned int i = 0; i < size; i++)
 *(buffer + i) = ((unsigned int)rand() % 256);
 return buffer;
}
 Communication Networks Course
Page | 13
Appendix D â€“ Checksum function
A checksum is a small-sized block of data derived from another block of digital data for the
purpose of detecting errors that may have been introduced during its transmission or
storage. By themselves, checksums are often used to verify data integrity but are not relied
upon to verify data authenticity.
Below is a simple yet efficient implementation of the checksum function, you can use it for
the assignment, but you can implement your own checksum function.
/*
* @brief A checksum function that returns 16 bit checksum for data.
* @param data The data to do the checksum for.
* @param bytes The length of the data in bytes.
* @return The checksum itself as 16 bit unsigned number.
* @note This function is taken from RFC1071, can be found here:
* @note https://tools.ietf.org/html/rfc1071
* @note It is the simplest way to calculate a checksum and is not very strong.
* However, it is good enough for this assignment.
* @note You are free to use any other checksum function as well.
* You can also use this function as such without any change.
*/
unsigned short int calculate_checksum(void *data, unsigned int bytes) {
 unsigned short int *data_pointer = (unsigned short int *)data;
 unsigned int total_sum = 0;
 // Main summing loop
 while (bytes > 1) {
 total_sum += *data_pointer++;
 bytes -= 2;
 }
 // Add left-over byte, if any
 if (bytes > 0)
 total_sum += *((unsigned char *)data_pointer);
 // Fold 32-bit sum to 16 bits
 while (total_sum >> 16)
 total_sum = (total_sum & 0xFFFF) + (total_sum >> 16);
 return (~((unsigned short int)total_sum));
} Communication Networks Course
Page | 1
Assignment 3 â€“ Transport Layer
Assignment Notes and Instructions
This assignment is to be done in pairs only. You must upload all the necessary files in a ZIP
file named after both of the studentâ€™s ID. For example: ğŸğŸğŸ‘ğŸ’ğŸ“ğŸ”ğŸ•ğŸ–ğŸ—_ğŸ—ğŸ–ğŸ•ğŸ”ğŸ“ğŸ’ğŸ‘ğŸğŸ. ğ’›ğ’Šğ’‘.
1) The assignment must be submitted by the date specified in the submission box.
2) All the assignment files (Code, Wireshark pcap files, PDF) must be submitted in a ZIP file. The
PDF must contain all the necessary screenshots with a description for each one of them.
3) The assignment must be done in pairs only. In exceptional cases, you should send an email to
the course coordinator.
4) You can use any reference material available through the course Moodle website or any
material passed during the exercises.
5) You can use any reference from the web, but copying codes from websites is forbidden; this
includes codes from other GitHub repositories. A student who gets caught in the act will
automatically fail this assignment (score 0). Any website youâ€™ve used to solve the
assignment, every website you used to solve the assignment must be noted in the PDF.
6) No delays in submission without special permission. Lateness without approval will result in
failure of the assignment (score 0).
7) All submissions will be submitted via the course's Moodle website. Email submissions will not
be accepted, resulting in a failure in the assignment.
8) The order and design of the code must be carefully considered. Make sure that the program
output is as clear as possible, comments in the code, and meaningful variable names. You
must also submit a makefile that compiles all the programs.
9) The assignment code must be written in C only.
10) The assignment is personal for each pair, and you should not accept help from other people,
whether outside the university or inside it. You can contact the course staff during reception
hours for help or raise a question in the course forum. Do not transfer code sections
between students, upload solutions or parts of solutions to websites on the Internet or in
various communication groups.
11) Students who copy a solution will receive a 0 in all assignments in the course and a report will
be made to the institutional disciplinary committee.
12) All code files of the assignment are required to both compile and run properly on the Ubuntu
22.04 LTS operating system. This is the operating system where the submissions will be
tested. You mustnâ€™t code it in Windows, as it uses different API for sockets. WSL wonâ€™t work,
as the task needs a tool that works only in a fully Linux environment.
Good Luck!
 Communication Networks Course
Page | 2
Part A â€“ Transmission Control Protocol (TCP) â€“ 30 points
In this part, youâ€™ll write two program files: ğ‘»ğ‘ªğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and ğ‘»ğ‘ªğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
The Sender will send a randomly generated file and the Receiver will receive it and measure
the time it took for his program to receive the file. The file size should be at least 2MB.
When running the Sender and Receiver, they both should support two standard congestion
control algorithms: TCP Reno and TCP Cubic.
Notes:
â€¢ The main goal of this part is to get familiar with the TCP concept of sending
messages between two endpoints.
â€¢ For approaching this part of the assignment, please be sure that you are familiar
with the congestion control algorithms and how to change them using the correct
method in C (see Appendix B for more information).
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). You've
learned that TCP is reliable by design, so you can assume that all the data have been
passed correctly, and thus, no need to recheck.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
Usage:
â€¢ Receiver:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
â€¢ Sender:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port of the Receiver.
â€¢ ğ‘¨ğ‘³ğ‘®ğ‘¶ â€“ The TCP congestion control algorithm that will be used by the party
member (either ğ’“ğ’†ğ’ğ’ for TCP Reno or ğ’„ğ’–ğ’ƒğ’Šğ’„ for TCP Cubic).
 Communication Networks Course
Page | 3
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a TCP socket between the Sender and the
Receiver.
3) Send the file.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a TCP connection between the Receiver and
the Sender.
2) Get a connection from the sender.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./TCP_Receiver -p 1234 -algo reno
Starting Receiver...
Waiting for TCP connection...
Sender connected, beginning to receive file...
File transfer completed.
Waiting for Sender response...
Sender sent exit message.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 4
Part B â€“ Reliable User Datagram Protocol (Reliable UDP or RUDP) â€“ 40 points
Youâ€™ve learned that while TCP is reliable, it lacks speed and has an overhead data of 20 bytes,
compering to UDP that needs only 8 bytes of overhead data.
Reliable UDP or RUDP, is a protocol that uses the UDP protocol for a faster transmission of
data, while adding a reliability layer to it, but without adding too much overhead data like
TCP.
A simple sketch for a RUDP connection would look something like this:
Your task in this part is to implement a Reliable protocol using UDP only. For simplicity, your
implementation should only support a handshake, closing scheme, error checking,
acknowledgment of received packets, and retransmission of lost packets.
Guidance:
â€¢ You can use ğ‘ ğ‘’ğ‘¡ğ‘ ğ‘œğ‘ğ‘˜ğ‘œğ‘ğ‘¡(2) for detecting a timeout.
â€¢ You need to build your own protocol, as Reliable UDP isnâ€™t a standard protocol (see a
draft of RUDP in this link), and no official header is provided. You can use this sketch
for a header, but you can come up with your own protocol, as long as it works.
Where:
o ğ‘³ğ’†ğ’ğ’ˆğ’•ğ’‰ is the length of the data itself, without the RUDP header.
o ğ‘ªğ’‰ğ’†ğ’„ğ’Œğ’”ğ’–ğ’ is a 16bit number that validates the correctness of the data.
o ğ‘­ğ’ğ’‚ğ’ˆğ’” is a special byte where we classify the packet itself (SYN, ACK, etc.).
â€¢ In your PDF, you must explain how your implementation of RUDP works â€“ How does
it detect a timeout to do retransmissions, how does the handshake work, what is the
header overhead, etc.
â€¢ For this part, youâ€™ll write three files: ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¨ğ‘·ğ‘°. ğ’„, ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and
ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
Reliable UDP Header proposed sketch
Byte 0 Byte 1 Byte 2 Byte 3
Length (2 Bytes) Checksum (2 Bytes)
Flags (1 Byte)
Figure 1 - RUDP Protocol Architecture, Geeksforgeeks
 Communication Networks Course
Page | 5
Notes:
â€¢ The Sender will send a random generated file and the Receiver will receive it and
measure the time it took for his program to receive the file. The file size should be at
least 2MB.
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). But, as the
RUDP is based on UDP, itâ€™s not reliable. You must use some form of error checking
(like checksum) to ensure that the packet wasnâ€™t alerted during the transfer.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
â€¢ The RUDP needs support only 1 sender and 1 receiver, for simplicity purposes.
Usage:
â€¢ Receiver:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
â€¢ Sender:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port that both the Sender and the Receiver will use.
The ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„ file will contain all the implementations of the RUDP API functions (That is, to
prevent reusing the same chuck of code both in the Sender and the Receiver.).
The API should support at the bare minimum the following functions (you decide what
parameters to implement, and what are the names of the functions, as long as the API is
explained in the PDF):
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘œğ‘ğ‘˜ğ‘’ğ‘¡() â€“ Creating a RUDP socket and creating a handshake between two
peers.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘’ğ‘›ğ‘‘() â€“ Sending data to the peer. The function should wait for an
acknowledgment packet, and if it didnâ€™t receive any, retransmits the data.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘Ÿğ‘’ğ‘ğ‘£() â€“ Receive data from a peer.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ğ‘™ğ‘œğ‘ ğ‘’() â€“ Closes a connection between peers.
 Communication Networks Course
Page | 6
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a UDP socket between the Sender and the
Receiver.
3) Send the file via the RUDP protocol.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a UDP connection between the Receiver and
the Sender.
2) Get a connection from the sender, by the custom
RUDP protocol youâ€™ve built.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./RUDP_Receiver -p 1234
Starting Receiver...
Waiting for RUDP connection...
Connection request received, sending ACK.
Sender connected, beginning to receive file...
File transfer completed.
ACK sent.
Waiting for Sender response...
Sender sent exit message.
ACK sent.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 7
Part C â€“ Research â€“ 30 points
In this part, youâ€™ll conduct research about your implementations of part A and part B.
In the research itself, each one of the versions (TCP version and UDP version) will be run at
least 5 times (meaning that the file transfer will occur at least 5 times) by the following
conditions:
â€¢ For TCP, youâ€™ll run it in TCP Reno and TCP Cubic, alternating each time, for each
scenario, meaning that you run 5 times with TCP Reno in both Sender and Receiver,
and 5 times with TCP Cubic in both Sender and Receiver.
Bonus (5 points): Create a very large data set â€“ 5 times with TCP Reno in both Sender
and Receiver, 5 times with TCP Reno in Sender and TCP Cubic in Receiver, 5 times
with TCP Cubic in Sender and TCP Reno in Receiver, and 5 times with TCP Cubic in
both Sender and Receiver. This will give you a data set large enough, which allows
you to work with, compare with and to reach a definite conclusion.
â€¢ For RUDP, you will run it 5 times for each scenario.
â€¢ For both TCP and RUDP, you will run them on those scenarios of packet loss:
o 0% packet loss â€“ Control group, simulating perfect connection.
o 2% packet loss â€“ Simulating unstable connection that commonly occur.
o 5% packet loss â€“ Simulating bad connection.
o 10% packet loss â€“ Simulating extremely poor connection.
For each scenario, you must provide a filtered PCAP file and relevant screenshots that
explain each one of the steps in the process. (10 points)
After youâ€™ve gathered the data set for both TCP and Reliable UDP, answer the following
questions:
1) In TCP, which congestion control algorithm gave better results overall? TCP Reno or
TCP Cubic? Which one gave better results on high packet loss? Explain how you came
to this conclusion based on the data set youâ€™ve gathered. (5 points)
2) How did your implementation of Reliable UDP perform overall compared to regular
TCP? Which one is better for high packet loss? (5 points)
3) According to the data youâ€™ve gathered, in which scenarios and applications would we
prefer to use TCP and in which situations would we prefer to use reliable UDP?
Explain your answer. (5 points)
 Communication Networks Course
Page | 8
×¢× ×• ×¢×œ ×”×©××œ×•×ª ×”×‘××•×ª )5 × ×§×•×“×•×ª(:
â— ×‘"×¨×©×ª ×××™× ×”" ×”×›×•×•× ×” ×”×™× ×œ×¨×©×ª ×©×‘×” ××¢×˜ ×××•×“ ×—×‘×™×œ×•×ª ×”×•×œ×›×•×ª ×œ××™×‘×•×“. ×‘"×§×©×¨ ××¨×•×š" ×”×›×•×•× ×” ×”×™×
×œ×§×©×¨ TCP ×©×™×© ×‘×• ×”×¨×‘×” ×××•×“ ××™×“×¢ ×œ×©×œ×•×—. ××•×¦×¢ ×œ×”×’×“×™×œ ×‘ -TCP ××ª SSThreshold ×‘×ª×—×™×œ×ª ×”×§×©×¨.
×‘××™×–×” ××”××§×¨×™× ×”×‘××™× ×”×©×™× ×•×™ ×”×–×” ×¢×©×•×™ ×œ×”×•×¢×™×œ ×‘××™×“×” ×”××™×¨×‘×™×ª? × ××§.
.1 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
.2 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.3 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.4 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.5 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.6 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.7 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.8 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
â— A ×©×•×œ×— ×œ -B ×—×‘×™×œ×•×ª ××™×“×¢ ×‘×××¦×¢×•×ª ×§×©×¨ TCP. × ×ª×•×Ÿ ×›×™ ×”×§×©×¨ ××ª×—×™×œ ×¢× ×—×œ×•×Ÿ ×‘×’×•×“×œ 1MSS. ×”×§×©×¨
××¡×ª×™×™× ×‘×¤×¢× ×”×¨××©×•× ×” ×©×”×•× ××’×™×¢ ×œ -SSthresh. ×‘××”×œ×š ×”×§×©×¨ ×œ× ××•×‘×“×•×ª ×—×‘×™×œ×•×ª. × ×¡××Ÿ ×‘×§×™×¦×•×¨:
.SSthresh=S*MSS
× ×ª×•×Ÿ ×›×™ ×œ××•×¨×š ×›×œ ×”×§×©×¨ rwnd < MSS*S.
××”×™ ×”×ª×¤×•×§×” ×©×œ ×”×§×©×¨ ×-A ×œ-B( ×‘ -sec / Bytes )×‘×–××Ÿ ×”× "×œ? × ××§×™.
]S*MSS / [lg (S) * RTT*2 ×‘×¢×¨×š .1
]S*MSS / [S^0.5 * RTT*2 ×‘×¢×¨×š .2
S*MSS / RTT ×‘×¢×¨×š .3
S^2)*MSS / RTT( ×‘×¢×¨×š .4
â— ×©×ª×™ ×ª×—× ×•×ª ××ª×§×©×¨×•×ª ×‘××•×¤×Ÿ ××œ×—×•×˜×™ ×‘×©×™×˜×ª N Back Go.
× ×¡××Ÿ ×‘-X ××ª ×¡×¤×¨×ª ×”×‘×™×§×•×¨×ª ×©×œ ×”×ª.×–. ×©×œ×š. ×× ×©× ×™ ×©×•×ª×¤×™× ××’×™×©×™× ××ª ×”×ª×¨×’×™×œ ×™×—×“, X ×”×•× ×¡×¤×¨×ª
×”×‘×™×§×•×¨×ª ×‘×¢×œ×ª ×”×¢×¨×š ×”× ××•×š ×™×•×ª×¨ ××‘×™×Ÿ ×”×©×ª×™×™×.
×§×¦×‘ ×”×ª×§×©×•×¨×ª ×”×•× 8Gbps, ×•×’×•×“×œ ×›×œ ×—×‘×™×œ×” ×”×•× KByte*X. ×’×“×œ×™ ×”-headers ×•×” -Acks ×–× ×™×—×™×.
ï¿½ğ‘’ğ‘ ï¿½/ï¿½ï¿½ 8 , ×•×”××¨×—×§ ×‘×™×Ÿ ×”×ª×—× ×•×ª ×”×•× 1Km. ×§×¦×‘ ×”×”×ª×¤×©×˜×•×ª ×”×•× 10 â‹… 2
×–××Ÿ ×¢×™×‘×•×“ ×”× ×ª×•× ×™× ×‘×ª×—× ×•×ª ×–× ×™×—.
××£ ×—×‘×™×œ×” ×•××£ Ack ×œ× ×”×•×œ×›×™× ×œ××™×‘×•×“.
â— ××”×• X ×©×œ×š?
â— ××” ×¦×¨×™×š ×œ×”×™×•×ª ×’×•×“×œ ×—×œ×•×Ÿ ×”××©×œ×•×— ×›×“×™ ×œ×”×‘×˜×™×— ×ª×¤×•×§×” ××§×¡×™××œ×™×ª?
 Communication Networks Course
Page | 9
Bonus â€“ Improving the Reliable UDP â€“ 15 points
Note: This part isnâ€™t mandatory and is a bonus only!
In this part, youâ€™ll improve your RUDP implementation by adding the concepts of flow
control and congestion control from TCP. Youâ€™re free to choose which algorithms to
implement, as long as you explain in your PDF which algorithms youâ€™ve used. Youâ€™ll probably
need to make changes in the original design of the RUDP. Changes only need to be to the API
itself, ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„.
Points distribution:
â€¢ Flow control improvement â€“ 7 Points
â€¢ Congestion control improvement â€“ 8 points.
Guidance:
â€¢ For flow control, you must use one of the Sliding window techniques: stop-and-wait
ARQ, Go-Back-N or Selective repeat.
â€¢ List of known TCP congestion control algorithms, which you can use any one of them
for this bonus task, or makeup your own:
Figure 2 â€“ List of known TCP congestion control algorithms, Wikipedia
 Communication Networks Course
Page | 10
Appendix A â€“ Linux local packet loss tool
To simulate a packet loss in a local network, we'll use a Linux tool that's called Linux Traffic
Control (ğ‘¡ğ‘). This requires a full Linux installation, so working with WSL won't work.
If the tool isn't installed in your machine, you can install it by using the following commands:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’
If the installation didn't work, you can use the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’2
To create a packet loss scenario, type the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘ğ‘‘ğ‘‘ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
After creating a packet loss scenario, you can change the percentage by typing the following
command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘â„ğ‘ğ‘›ğ‘”ğ‘’ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
To remove the packet loss scenario, write the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘‘ğ‘’ğ‘™ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š
 Communication Networks Course
Page | 11
Appendix B â€“ ğ’ğ’‚ğ’(ğŸ) system calls
This appendixâ€™s purpose is to give you a better understanding of socket handling in C.
A recommended reference is Beejâ€™s Guide to Network Programming, by Brian â€œBeej
Jorgensenâ€ Hall, which gives a lot of information about sockets in C and functions.
Functions and documentation links:
â€¢ ğ’”ğ’ğ’„ğ’Œğ’†ğ’•(ğŸ) â€“ A Factory method system call that creates a socket with the given
parameters.
â€¢ ğ’ƒğ’Šğ’ğ’…(ğŸ) â€“ Whenever we create a new socket, we need to bind it to a specific port in
our machine, â€œto catch a portâ€. The port number is managed and used by the kernel
to link incoming packets to the corresponding application socket. The port numbers
are usually fixed. The ğ‘ğ‘‘ğ‘‘ğ‘Ÿ parameter must match the current socket that is used.
â€¢ ğ’ğ’Šğ’”ğ’•ğ’†ğ’(ğŸ) â€“ The ğ‘™ğ‘–ğ‘ ğ‘¡ğ‘’ğ‘›(2) system call doesn't do anything in the mean of
communication but only memory allocation (malloc) for stream sockets only. If we
won't allocate memory, any incoming connection will fail.
â€¢ ğ’„ğ’ğ’ğ’ğ’†ğ’„ğ’•(ğŸ) â€“ The ğ‘ğ‘œğ‘›ğ‘›ğ‘’ğ‘ğ‘¡(2) system call starts the link between a client and a
specific IP address and port number. The connection would complete when the
other side will call the ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call.
â€¢ ğ’‚ğ’„ğ’„ğ’†ğ’‘ğ’•(ğŸ) â€“ The ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call accepts the incoming stream connection
request from the other side, by the listening socket. This system call completes the
three-way handshake of stream socket (like TCP) and opens a new socket that has a
direct communication channel only with the other party in the handshake.
â€¢ ğ’”ğ’†ğ’ğ’…(ğŸ) and ğ’”ğ’†ğ’ğ’…ğ’•ğ’(ğŸ) â€“ The ğ‘ ğ‘’ğ‘›ğ‘‘(2) and ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system calls are an analogy
for the ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’(2) system call, specifcly for sockets, with flags set to 0. Those system
calls return the number of bytes that were sent through the socket itself, as the
number of bytes can vary. The ğ‘ ğ‘’ğ‘›ğ‘‘(2)system call designed for stream sockets (like
TCP), while the ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system call designed for datagram connection-less
sockets (like UDP). When the ğ‘ ğ‘’ğ‘›ğ‘‘(2) system call returns 0, it means that the other
party closed the connection.
â€¢ ğ’“ğ’†ğ’„ğ’—(ğŸ) and ğ’“ğ’†ğ’„ğ’—ğ’‡ğ’“ğ’ğ’(ğŸ) â€“ The ğ‘Ÿğ‘’ğ‘ğ‘£(2) and ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system calls are an
analogy for the ğ‘Ÿğ‘’ğ‘ğ‘‘(2) system call, specifically for sockets, with flags set to 0.
Those system calls return the number of bytes that were received through the socket
itself, as the number of bytes can vary. The ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call designed for stream
sockets (like TCP), while the ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system call designed for datagram
connection-less sockets (like UDP). When the ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call returns 0, it means
that the other party closed the connection.
â€¢ ğ’„ğ’ğ’ğ’”ğ’†(ğŸ) and ğ’”ğ’‰ğ’–ğ’•ğ’…ğ’ğ’˜ğ’(ğŸ) â€“ The ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) and ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2) system calls close
the socket. While ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) system call closes the whole socket, the ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2)
system call partially closes the socket for read/write.
 Communication Networks Course
Page | 12
Appendix C â€“ Random data generator
The data that you are going to send in this assignment is randomly generated. You can use
your own file with appropriate size or use the following function (or a function of your own)
to generate the data:
/*
* @brief A random data generator function based on srand() and rand().
* @param size The size of the data to generate (up to 2^32 bytes).
* @return A pointer to the buffer.
*/
char *util_generate_random_data(unsigned int size) {
 char *buffer = NULL;
 // Argument check.
 if (size == 0)
 return NULL;
 buffer = (char *)calloc(size, sizeof(char));
 // Error checking.
 if (buffer == NULL)
 return NULL;
 // Randomize the seed of the random number generator.
 srand(time(NULL));
 for (unsigned int i = 0; i < size; i++)
 *(buffer + i) = ((unsigned int)rand() % 256);
 return buffer;
}
 Communication Networks Course
Page | 13
Appendix D â€“ Checksum function
A checksum is a small-sized block of data derived from another block of digital data for the
purpose of detecting errors that may have been introduced during its transmission or
storage. By themselves, checksums are often used to verify data integrity but are not relied
upon to verify data authenticity.
Below is a simple yet efficient implementation of the checksum function, you can use it for
the assignment, but you can implement your own checksum function.
/*
* @brief A checksum function that returns 16 bit checksum for data.
* @param data The data to do the checksum for.
* @param bytes The length of the data in bytes.
* @return The checksum itself as 16 bit unsigned number.
* @note This function is taken from RFC1071, can be found here:
* @note https://tools.ietf.org/html/rfc1071
* @note It is the simplest way to calculate a checksum and is not very strong.
* However, it is good enough for this assignment.
* @note You are free to use any other checksum function as well.
* You can also use this function as such without any change.
*/
unsigned short int calculate_checksum(void *data, unsigned int bytes) {
 unsigned short int *data_pointer = (unsigned short int *)data;
 unsigned int total_sum = 0;
 // Main summing loop
 while (bytes > 1) {
 total_sum += *data_pointer++;
 bytes -= 2;
 }
 // Add left-over byte, if any
 if (bytes > 0)
 total_sum += *((unsigned char *)data_pointer);
 // Fold 32-bit sum to 16 bits
 while (total_sum >> 16)
 total_sum = (total_sum & 0xFFFF) + (total_sum >> 16);
 return (~((unsigned short int)total_sum));
} Communication Networks Course
Page | 1
Assignment 3 â€“ Transport Layer
Assignment Notes and Instructions
This assignment is to be done in pairs only. You must upload all the necessary files in a ZIP
file named after both of the studentâ€™s ID. For example: ğŸğŸğŸ‘ğŸ’ğŸ“ğŸ”ğŸ•ğŸ–ğŸ—_ğŸ—ğŸ–ğŸ•ğŸ”ğŸ“ğŸ’ğŸ‘ğŸğŸ. ğ’›ğ’Šğ’‘.
1) The assignment must be submitted by the date specified in the submission box.
2) All the assignment files (Code, Wireshark pcap files, PDF) must be submitted in a ZIP file. The
PDF must contain all the necessary screenshots with a description for each one of them.
3) The assignment must be done in pairs only. In exceptional cases, you should send an email to
the course coordinator.
4) You can use any reference material available through the course Moodle website or any
material passed during the exercises.
5) You can use any reference from the web, but copying codes from websites is forbidden; this
includes codes from other GitHub repositories. A student who gets caught in the act will
automatically fail this assignment (score 0). Any website youâ€™ve used to solve the
assignment, every website you used to solve the assignment must be noted in the PDF.
6) No delays in submission without special permission. Lateness without approval will result in
failure of the assignment (score 0).
7) All submissions will be submitted via the course's Moodle website. Email submissions will not
be accepted, resulting in a failure in the assignment.
8) The order and design of the code must be carefully considered. Make sure that the program
output is as clear as possible, comments in the code, and meaningful variable names. You
must also submit a makefile that compiles all the programs.
9) The assignment code must be written in C only.
10) The assignment is personal for each pair, and you should not accept help from other people,
whether outside the university or inside it. You can contact the course staff during reception
hours for help or raise a question in the course forum. Do not transfer code sections
between students, upload solutions or parts of solutions to websites on the Internet or in
various communication groups.
11) Students who copy a solution will receive a 0 in all assignments in the course and a report will
be made to the institutional disciplinary committee.
12) All code files of the assignment are required to both compile and run properly on the Ubuntu
22.04 LTS operating system. This is the operating system where the submissions will be
tested. You mustnâ€™t code it in Windows, as it uses different API for sockets. WSL wonâ€™t work,
as the task needs a tool that works only in a fully Linux environment.
Good Luck!
 Communication Networks Course
Page | 2
Part A â€“ Transmission Control Protocol (TCP) â€“ 30 points
In this part, youâ€™ll write two program files: ğ‘»ğ‘ªğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and ğ‘»ğ‘ªğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
The Sender will send a randomly generated file and the Receiver will receive it and measure
the time it took for his program to receive the file. The file size should be at least 2MB.
When running the Sender and Receiver, they both should support two standard congestion
control algorithms: TCP Reno and TCP Cubic.
Notes:
â€¢ The main goal of this part is to get familiar with the TCP concept of sending
messages between two endpoints.
â€¢ For approaching this part of the assignment, please be sure that you are familiar
with the congestion control algorithms and how to change them using the correct
method in C (see Appendix B for more information).
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). You've
learned that TCP is reliable by design, so you can assume that all the data have been
passed correctly, and thus, no need to recheck.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
Usage:
â€¢ Receiver:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
â€¢ Sender:
./ğ‘‡ğ¶ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡ âˆ’ ğ‘ğ‘™ğ‘”ğ‘œ ğ´ğ¿ğºğ‘‚
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port of the Receiver.
â€¢ ğ‘¨ğ‘³ğ‘®ğ‘¶ â€“ The TCP congestion control algorithm that will be used by the party
member (either ğ’“ğ’†ğ’ğ’ for TCP Reno or ğ’„ğ’–ğ’ƒğ’Šğ’„ for TCP Cubic).
 Communication Networks Course
Page | 3
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a TCP socket between the Sender and the
Receiver.
3) Send the file.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a TCP connection between the Receiver and
the Sender.
2) Get a connection from the sender.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./TCP_Receiver -p 1234 -algo reno
Starting Receiver...
Waiting for TCP connection...
Sender connected, beginning to receive file...
File transfer completed.
Waiting for Sender response...
Sender sent exit message.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 4
Part B â€“ Reliable User Datagram Protocol (Reliable UDP or RUDP) â€“ 40 points
Youâ€™ve learned that while TCP is reliable, it lacks speed and has an overhead data of 20 bytes,
compering to UDP that needs only 8 bytes of overhead data.
Reliable UDP or RUDP, is a protocol that uses the UDP protocol for a faster transmission of
data, while adding a reliability layer to it, but without adding too much overhead data like
TCP.
A simple sketch for a RUDP connection would look something like this:
Your task in this part is to implement a Reliable protocol using UDP only. For simplicity, your
implementation should only support a handshake, closing scheme, error checking,
acknowledgment of received packets, and retransmission of lost packets.
Guidance:
â€¢ You can use ğ‘ ğ‘’ğ‘¡ğ‘ ğ‘œğ‘ğ‘˜ğ‘œğ‘ğ‘¡(2) for detecting a timeout.
â€¢ You need to build your own protocol, as Reliable UDP isnâ€™t a standard protocol (see a
draft of RUDP in this link), and no official header is provided. You can use this sketch
for a header, but you can come up with your own protocol, as long as it works.
Where:
o ğ‘³ğ’†ğ’ğ’ˆğ’•ğ’‰ is the length of the data itself, without the RUDP header.
o ğ‘ªğ’‰ğ’†ğ’„ğ’Œğ’”ğ’–ğ’ is a 16bit number that validates the correctness of the data.
o ğ‘­ğ’ğ’‚ğ’ˆğ’” is a special byte where we classify the packet itself (SYN, ACK, etc.).
â€¢ In your PDF, you must explain how your implementation of RUDP works â€“ How does
it detect a timeout to do retransmissions, how does the handshake work, what is the
header overhead, etc.
â€¢ For this part, youâ€™ll write three files: ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¨ğ‘·ğ‘°. ğ’„, ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘ºğ’†ğ’ğ’…ğ’†ğ’“. ğ’„ and
ğ‘¹ğ‘¼ğ‘«ğ‘·_ğ‘¹ğ’†ğ’„ğ’†ğ’Šğ’—ğ’†ğ’“. ğ’„.
Reliable UDP Header proposed sketch
Byte 0 Byte 1 Byte 2 Byte 3
Length (2 Bytes) Checksum (2 Bytes)
Flags (1 Byte)
Figure 1 - RUDP Protocol Architecture, Geeksforgeeks
 Communication Networks Course
Page | 5
Notes:
â€¢ The Sender will send a random generated file and the Receiver will receive it and
measure the time it took for his program to receive the file. The file size should be at
least 2MB.
â€¢ The receiver doesnâ€™t really care about saving the file itself (or its content). But, as the
RUDP is based on UDP, itâ€™s not reliable. You must use some form of error checking
(like checksum) to ensure that the packet wasnâ€™t alerted during the transfer.
â€¢ You can support either IPv4 or IPv6, but you must note in your PDF in which IP
version your assignment uses.
â€¢ The RUDP needs support only 1 sender and 1 receiver, for simplicity purposes.
Usage:
â€¢ Receiver:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘…ğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘Ÿ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
â€¢ Sender:
./ğ‘…ğ‘ˆğ·ğ‘ƒ_ğ‘†ğ‘’ğ‘›ğ‘‘ğ‘’ğ‘Ÿ âˆ’ ğ‘–ğ‘ ğ¼ğ‘ƒ âˆ’ ğ‘ ğ‘ƒğ‘‚ğ‘…ğ‘‡
Where:
â€¢ ğ‘°ğ‘· â€“ The IP address of the receiver.
â€¢ ğ‘·ğ‘¶ğ‘¹ğ‘» â€“ The TCP port that both the Sender and the Receiver will use.
The ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„ file will contain all the implementations of the RUDP API functions (That is, to
prevent reusing the same chuck of code both in the Sender and the Receiver.).
The API should support at the bare minimum the following functions (you decide what
parameters to implement, and what are the names of the functions, as long as the API is
explained in the PDF):
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘œğ‘ğ‘˜ğ‘’ğ‘¡() â€“ Creating a RUDP socket and creating a handshake between two
peers.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ ğ‘’ğ‘›ğ‘‘() â€“ Sending data to the peer. The function should wait for an
acknowledgment packet, and if it didnâ€™t receive any, retransmits the data.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘Ÿğ‘’ğ‘ğ‘£() â€“ Receive data from a peer.
â€¢ ğ‘Ÿğ‘¢ğ‘‘ğ‘_ğ‘ğ‘™ğ‘œğ‘ ğ‘’() â€“ Closes a connection between peers.
 Communication Networks Course
Page | 6
The programs will do the following:
Sender Receiver
1) Read the created file.
2) Create a UDP socket between the Sender and the
Receiver.
3) Send the file via the RUDP protocol.
4) User decision: Send the file again?
a. If yes, go back to step 3.
b. If no, continue to step 5.
5) Send an exit message to the receiver.
6) Close the TCP connection.
7) Exit.
1) Create a UDP connection between the Receiver and
the Sender.
2) Get a connection from the sender, by the custom
RUDP protocol youâ€™ve built.
3) Receive the file, measure the time it took and save it.
4) Wait for Sender response:
a. If Sender resends the file, go back to step 3.
b. If Sender sends exit message, go to step 5.
5) Print out the times (in milliseconds), and the average
bandwidth for each time the file was received.
6) Calculate the average time and the total average
bandwidth.
7) Exit.
Example output of the Receiver (this is just an example, your output can look different, as
long as itâ€™s readable and understandable):
foo@bar:~$ ./RUDP_Receiver -p 1234
Starting Receiver...
Waiting for RUDP connection...
Connection request received, sending ACK.
Sender connected, beginning to receive file...
File transfer completed.
ACK sent.
Waiting for Sender response...
Sender sent exit message.
ACK sent.
----------------------------------
- * Statistics * -
- Run #1 Data: Time=0.2ms; Speed=1024.00MB/s
-
- Average time: 0.2ms
- Average bandwidth: 1024.00MB/s
----------------------------------
Receiver end.
 Communication Networks Course
Page | 7
Part C â€“ Research â€“ 30 points
In this part, youâ€™ll conduct research about your implementations of part A and part B.
In the research itself, each one of the versions (TCP version and UDP version) will be run at
least 5 times (meaning that the file transfer will occur at least 5 times) by the following
conditions:
â€¢ For TCP, youâ€™ll run it in TCP Reno and TCP Cubic, alternating each time, for each
scenario, meaning that you run 5 times with TCP Reno in both Sender and Receiver,
and 5 times with TCP Cubic in both Sender and Receiver.
Bonus (5 points): Create a very large data set â€“ 5 times with TCP Reno in both Sender
and Receiver, 5 times with TCP Reno in Sender and TCP Cubic in Receiver, 5 times
with TCP Cubic in Sender and TCP Reno in Receiver, and 5 times with TCP Cubic in
both Sender and Receiver. This will give you a data set large enough, which allows
you to work with, compare with and to reach a definite conclusion.
â€¢ For RUDP, you will run it 5 times for each scenario.
â€¢ For both TCP and RUDP, you will run them on those scenarios of packet loss:
o 0% packet loss â€“ Control group, simulating perfect connection.
o 2% packet loss â€“ Simulating unstable connection that commonly occur.
o 5% packet loss â€“ Simulating bad connection.
o 10% packet loss â€“ Simulating extremely poor connection.
For each scenario, you must provide a filtered PCAP file and relevant screenshots that
explain each one of the steps in the process. (10 points)
After youâ€™ve gathered the data set for both TCP and Reliable UDP, answer the following
questions:
1) In TCP, which congestion control algorithm gave better results overall? TCP Reno or
TCP Cubic? Which one gave better results on high packet loss? Explain how you came
to this conclusion based on the data set youâ€™ve gathered. (5 points)
2) How did your implementation of Reliable UDP perform overall compared to regular
TCP? Which one is better for high packet loss? (5 points)
3) According to the data youâ€™ve gathered, in which scenarios and applications would we
prefer to use TCP and in which situations would we prefer to use reliable UDP?
Explain your answer. (5 points)
 Communication Networks Course
Page | 8
×¢× ×• ×¢×œ ×”×©××œ×•×ª ×”×‘××•×ª )5 × ×§×•×“×•×ª(:
â— ×‘"×¨×©×ª ×××™× ×”" ×”×›×•×•× ×” ×”×™× ×œ×¨×©×ª ×©×‘×” ××¢×˜ ×××•×“ ×—×‘×™×œ×•×ª ×”×•×œ×›×•×ª ×œ××™×‘×•×“. ×‘"×§×©×¨ ××¨×•×š" ×”×›×•×•× ×” ×”×™×
×œ×§×©×¨ TCP ×©×™×© ×‘×• ×”×¨×‘×” ×××•×“ ××™×“×¢ ×œ×©×œ×•×—. ××•×¦×¢ ×œ×”×’×“×™×œ ×‘ -TCP ××ª SSThreshold ×‘×ª×—×™×œ×ª ×”×§×©×¨.
×‘××™×–×” ××”××§×¨×™× ×”×‘××™× ×”×©×™× ×•×™ ×”×–×” ×¢×©×•×™ ×œ×”×•×¢×™×œ ×‘××™×“×” ×”××™×¨×‘×™×ª? × ××§.
.1 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
.2 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.3 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×’×“×•×œ.
.4 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.5 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.6 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.7 ×‘×§×©×¨ ××¨×•×š ×¢×œ ×’×‘×™ ×¨×©×ª ×œ× ×××™× ×” ×¢× RTT ×§×˜×Ÿ.
.8 ×‘×§×©×¨ ×§×¦×¨ ×¢×œ ×’×‘×™ ×¨×©×ª ×××™× ×” ×¢× RTT ×’×“×•×œ.
â— A ×©×•×œ×— ×œ -B ×—×‘×™×œ×•×ª ××™×“×¢ ×‘×××¦×¢×•×ª ×§×©×¨ TCP. × ×ª×•×Ÿ ×›×™ ×”×§×©×¨ ××ª×—×™×œ ×¢× ×—×œ×•×Ÿ ×‘×’×•×“×œ 1MSS. ×”×§×©×¨
××¡×ª×™×™× ×‘×¤×¢× ×”×¨××©×•× ×” ×©×”×•× ××’×™×¢ ×œ -SSthresh. ×‘××”×œ×š ×”×§×©×¨ ×œ× ××•×‘×“×•×ª ×—×‘×™×œ×•×ª. × ×¡××Ÿ ×‘×§×™×¦×•×¨:
.SSthresh=S*MSS
× ×ª×•×Ÿ ×›×™ ×œ××•×¨×š ×›×œ ×”×§×©×¨ rwnd < MSS*S.
××”×™ ×”×ª×¤×•×§×” ×©×œ ×”×§×©×¨ ×-A ×œ-B( ×‘ -sec / Bytes )×‘×–××Ÿ ×”× "×œ? × ××§×™.
]S*MSS / [lg (S) * RTT*2 ×‘×¢×¨×š .1
]S*MSS / [S^0.5 * RTT*2 ×‘×¢×¨×š .2
S*MSS / RTT ×‘×¢×¨×š .3
S^2)*MSS / RTT( ×‘×¢×¨×š .4
â— ×©×ª×™ ×ª×—× ×•×ª ××ª×§×©×¨×•×ª ×‘××•×¤×Ÿ ××œ×—×•×˜×™ ×‘×©×™×˜×ª N Back Go.
× ×¡××Ÿ ×‘-X ××ª ×¡×¤×¨×ª ×”×‘×™×§×•×¨×ª ×©×œ ×”×ª.×–. ×©×œ×š. ×× ×©× ×™ ×©×•×ª×¤×™× ××’×™×©×™× ××ª ×”×ª×¨×’×™×œ ×™×—×“, X ×”×•× ×¡×¤×¨×ª
×”×‘×™×§×•×¨×ª ×‘×¢×œ×ª ×”×¢×¨×š ×”× ××•×š ×™×•×ª×¨ ××‘×™×Ÿ ×”×©×ª×™×™×.
×§×¦×‘ ×”×ª×§×©×•×¨×ª ×”×•× 8Gbps, ×•×’×•×“×œ ×›×œ ×—×‘×™×œ×” ×”×•× KByte*X. ×’×“×œ×™ ×”-headers ×•×” -Acks ×–× ×™×—×™×.
ï¿½ğ‘’ğ‘ ï¿½/ï¿½ï¿½ 8 , ×•×”××¨×—×§ ×‘×™×Ÿ ×”×ª×—× ×•×ª ×”×•× 1Km. ×§×¦×‘ ×”×”×ª×¤×©×˜×•×ª ×”×•× 10 â‹… 2
×–××Ÿ ×¢×™×‘×•×“ ×”× ×ª×•× ×™× ×‘×ª×—× ×•×ª ×–× ×™×—.
××£ ×—×‘×™×œ×” ×•××£ Ack ×œ× ×”×•×œ×›×™× ×œ××™×‘×•×“.
â— ××”×• X ×©×œ×š?
â— ××” ×¦×¨×™×š ×œ×”×™×•×ª ×’×•×“×œ ×—×œ×•×Ÿ ×”××©×œ×•×— ×›×“×™ ×œ×”×‘×˜×™×— ×ª×¤×•×§×” ××§×¡×™××œ×™×ª?
 Communication Networks Course
Page | 9
Bonus â€“ Improving the Reliable UDP â€“ 15 points
Note: This part isnâ€™t mandatory and is a bonus only!
In this part, youâ€™ll improve your RUDP implementation by adding the concepts of flow
control and congestion control from TCP. Youâ€™re free to choose which algorithms to
implement, as long as you explain in your PDF which algorithms youâ€™ve used. Youâ€™ll probably
need to make changes in the original design of the RUDP. Changes only need to be to the API
itself, ğ‘¹ğ‘¼ğ‘«ğ‘·. ğ’„.
Points distribution:
â€¢ Flow control improvement â€“ 7 Points
â€¢ Congestion control improvement â€“ 8 points.
Guidance:
â€¢ For flow control, you must use one of the Sliding window techniques: stop-and-wait
ARQ, Go-Back-N or Selective repeat.
â€¢ List of known TCP congestion control algorithms, which you can use any one of them
for this bonus task, or makeup your own:
Figure 2 â€“ List of known TCP congestion control algorithms, Wikipedia
 Communication Networks Course
Page | 10
Appendix A â€“ Linux local packet loss tool
To simulate a packet loss in a local network, we'll use a Linux tool that's called Linux Traffic
Control (ğ‘¡ğ‘). This requires a full Linux installation, so working with WSL won't work.
If the tool isn't installed in your machine, you can install it by using the following commands:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’
If the installation didn't work, you can use the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘ğ‘ğ‘¡ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘ğ‘™ğ‘™ ğ‘–ğ‘ğ‘Ÿğ‘œğ‘¢ğ‘¡ğ‘’2
To create a packet loss scenario, type the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘ğ‘‘ğ‘‘ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
After creating a packet loss scenario, you can change the percentage by typing the following
command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘â„ğ‘ğ‘›ğ‘”ğ‘’ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š ğ‘™ğ‘œğ‘ ğ‘  ğ‘‹ğ‘‹%
Where XX represents the wanted packet loss percentage.
To remove the packet loss scenario, write the following command:
ğ‘ ğ‘¢ğ‘‘ğ‘œ ğ‘¡ğ‘ ğ‘ğ‘‘ğ‘–ğ‘ ğ‘ ğ‘‘ğ‘’ğ‘™ ğ‘‘ğ‘’ğ‘£ ğ‘™ğ‘œ ğ‘Ÿğ‘œğ‘œğ‘¡ ğ‘›ğ‘’ğ‘¡ğ‘’ğ‘š
 Communication Networks Course
Page | 11
Appendix B â€“ ğ’ğ’‚ğ’(ğŸ) system calls
This appendixâ€™s purpose is to give you a better understanding of socket handling in C.
A recommended reference is Beejâ€™s Guide to Network Programming, by Brian â€œBeej
Jorgensenâ€ Hall, which gives a lot of information about sockets in C and functions.
Functions and documentation links:
â€¢ ğ’”ğ’ğ’„ğ’Œğ’†ğ’•(ğŸ) â€“ A Factory method system call that creates a socket with the given
parameters.
â€¢ ğ’ƒğ’Šğ’ğ’…(ğŸ) â€“ Whenever we create a new socket, we need to bind it to a specific port in
our machine, â€œto catch a portâ€. The port number is managed and used by the kernel
to link incoming packets to the corresponding application socket. The port numbers
are usually fixed. The ğ‘ğ‘‘ğ‘‘ğ‘Ÿ parameter must match the current socket that is used.
â€¢ ğ’ğ’Šğ’”ğ’•ğ’†ğ’(ğŸ) â€“ The ğ‘™ğ‘–ğ‘ ğ‘¡ğ‘’ğ‘›(2) system call doesn't do anything in the mean of
communication but only memory allocation (malloc) for stream sockets only. If we
won't allocate memory, any incoming connection will fail.
â€¢ ğ’„ğ’ğ’ğ’ğ’†ğ’„ğ’•(ğŸ) â€“ The ğ‘ğ‘œğ‘›ğ‘›ğ‘’ğ‘ğ‘¡(2) system call starts the link between a client and a
specific IP address and port number. The connection would complete when the
other side will call the ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call.
â€¢ ğ’‚ğ’„ğ’„ğ’†ğ’‘ğ’•(ğŸ) â€“ The ğ‘ğ‘ğ‘ğ‘’ğ‘ğ‘¡(2) system call accepts the incoming stream connection
request from the other side, by the listening socket. This system call completes the
three-way handshake of stream socket (like TCP) and opens a new socket that has a
direct communication channel only with the other party in the handshake.
â€¢ ğ’”ğ’†ğ’ğ’…(ğŸ) and ğ’”ğ’†ğ’ğ’…ğ’•ğ’(ğŸ) â€“ The ğ‘ ğ‘’ğ‘›ğ‘‘(2) and ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system calls are an analogy
for the ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’(2) system call, specifcly for sockets, with flags set to 0. Those system
calls return the number of bytes that were sent through the socket itself, as the
number of bytes can vary. The ğ‘ ğ‘’ğ‘›ğ‘‘(2)system call designed for stream sockets (like
TCP), while the ğ‘ ğ‘’ğ‘›ğ‘‘ğ‘¡ğ‘œ(2) system call designed for datagram connection-less
sockets (like UDP). When the ğ‘ ğ‘’ğ‘›ğ‘‘(2) system call returns 0, it means that the other
party closed the connection.
â€¢ ğ’“ğ’†ğ’„ğ’—(ğŸ) and ğ’“ğ’†ğ’„ğ’—ğ’‡ğ’“ğ’ğ’(ğŸ) â€“ The ğ‘Ÿğ‘’ğ‘ğ‘£(2) and ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system calls are an
analogy for the ğ‘Ÿğ‘’ğ‘ğ‘‘(2) system call, specifically for sockets, with flags set to 0.
Those system calls return the number of bytes that were received through the socket
itself, as the number of bytes can vary. The ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call designed for stream
sockets (like TCP), while the ğ‘Ÿğ‘’ğ‘ğ‘£ğ‘“ğ‘Ÿğ‘œğ‘š(2) system call designed for datagram
connection-less sockets (like UDP). When the ğ‘Ÿğ‘’ğ‘ğ‘£(2) system call returns 0, it means
that the other party closed the connection.
â€¢ ğ’„ğ’ğ’ğ’”ğ’†(ğŸ) and ğ’”ğ’‰ğ’–ğ’•ğ’…ğ’ğ’˜ğ’(ğŸ) â€“ The ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) and ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2) system calls close
the socket. While ğ‘ğ‘™ğ‘œğ‘ ğ‘’(2) system call closes the whole socket, the ğ‘ â„ğ‘¢ğ‘¡ğ‘‘ğ‘œğ‘¤ğ‘›(2)
system call partially closes the socket for read/write.
 Communication Networks Course
Page | 12
Appendix C â€“ Random data generator
The data that you are going to send in this assignment is randomly generated. You can use
your own file with appropriate size or use the following function (or a function of your own)
to generate the data:
/*
* @brief A random data generator function based on srand() and rand().
* @param size The size of the data to generate (up to 2^32 bytes).
* @return A pointer to the buffer.
*/
char *util_generate_random_data(unsigned int size) {
 char *buffer = NULL;
 // Argument check.
 if (size == 0)
 return NULL;
 buffer = (char *)calloc(size, sizeof(char));
 // Error checking.
 if (buffer == NULL)
 return NULL;
 // Randomize the seed of the random number generator.
 srand(time(NULL));
 for (unsigned int i = 0; i < size; i++)
 *(buffer + i) = ((unsigned int)rand() % 256);
 return buffer;
}
 Communication Networks Course
Page | 13
Appendix D â€“ Checksum function
A checksum is a small-sized block of data derived from another block of digital data for the
purpose of detecting errors that may have been introduced during its transmission or
storage. By themselves, checksums are often used to verify data integrity but are not relied
upon to verify data authenticity.
Below is a simple yet efficient implementation of the checksum function, you can use it for
the assignment, but you can implement your own checksum function.
/*
* @brief A checksum function that returns 16 bit checksum for data.
* @param data The data to do the checksum for.
* @param bytes The length of the data in bytes.
* @return The checksum itself as 16 bit unsigned number.
* @note This function is taken from RFC1071, can be found here:
* @note https://tools.ietf.org/html/rfc1071
* @note It is the simplest way to calculate a checksum and is not very strong.
* However, it is good enough for this assignment.
* @note You are free to use any other checksum function as well.
* You can also use this function as such without any change.
*/
unsigned short int calculate_checksum(void *data, unsigned int bytes) {
 unsigned short int *data_pointer = (unsigned short int *)data;
 unsigned int total_sum = 0;
 // Main summing loop
 while (bytes > 1) {
 total_sum += *data_pointer++;
 bytes -= 2;
 }
 // Add left-over byte, if any
 if (bytes > 0)
 total_sum += *((unsigned char *)data_pointer);
 // Fold 32-bit sum to 16 bits
 while (total_sum >> 16)
 total_sum = (total_sum & 0xFFFF) + (total_sum >> 16);
 return (~((unsigned short int)total_sum));
}